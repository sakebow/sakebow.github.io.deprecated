<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>这是我的hexo博客</title>
    <url>/2020/01/27/README/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>2020年6月2日，在找工作的绝望之中接到了研究生的待录取通知，现在终于闲下来了。所以将所有乱七八糟的笔记重新整理一遍，梳理知识点的同时也加强记忆。</strong></p>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>废话我就不多说了，Hexo到现在已经发展到无人不知的地步了，所以这里就单纯说一些想说的话。</p>
<h2 id="博客内容"><a href="#博客内容" class="headerlink" title="博客内容"></a>博客内容</h2><p>这个博客我就准备作为<strong>技术笔记</strong>和<strong>日记</strong>来使用了。</p>
<p>由于之前所有的笔记非常凌乱，不全、空白的占多数，而且没有好好归类。现在就重新整理一下。之前发表的文章也不算多数，所以工作量也不是很大。这次弄完了就准备一直用这样的格式了。这样的风格可能不是最绚丽的，<strong>但一定是我用心做的</strong>；技术文档一定是认真考证之后才发出来，其中的文字描述和图片描述一定尽可能简单完善。</p>
<p>当然，我一个人不可能研究所有的技术，所以会有一些博客会有引用别人文章的地方。我会一一标明出处，表示对原作者劳动成果的尊敬。也希望各位读者在传递知识的时候也传承这份尊敬。</p>
<p>但是对于日记呢，我会设置密码。因为毕竟是自己的日记，多少还是有非常强烈的个人情感，公开的话有可能对某些人造成伤害。</p>
<p>最后，也会开设一个<strong>个人信息</strong>的栏目，作为求职的在线简历。我也明白对面的HR绝对不想看，也明白他们没时间看，所以就放一个在线的，至少点进去就能有所反馈，而不是点开邮箱再下载。</p>
<h2 id="进度安排"><a href="#进度安排" class="headerlink" title="进度安排"></a>进度安排</h2><p>之前学习的时候一直不注意笔记的整理，单纯的看视频，往往有很多的弊端。看到后面忘记了前面，只能把前面的重新看一遍。所以这些将会好好地记录视频里面的重要笔记。技术博客的话我还是非常希望我能够3天一更，并且能够坚持一直更新下去。我也会尽可能的逼自己，我自己的三分钟热度我还是非常清楚的；而日记就是随性而写了，并无固定的更新周期。</p>
<p>再就是现在明显感觉到了自己的语文水平实在太尴尬，之后还是会开一个读书笔记的栏目，不仅是提高自己的语文水平，以后有了孩子也还是要多在他面前读书，做好榜样。当然读书笔记我希望3天一更，和技术博客保持一样的进度。但是什么时候开始就不清楚了，可能有了孩子以后？总之我还是希望能够尽快。</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>大概就是这些了，如果还有什么想说的我会继续更新的。</p>
]]></content>
      <categories>
        <category>简介</category>
      </categories>
      <tags>
        <tag>想说的话</tag>
      </tags>
  </entry>
  <entry>
    <title>VScode侧边栏字体调整</title>
    <url>/2020/12/04/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/VScode%E4%BE%A7%E8%BE%B9%E6%A0%8F%E5%AD%97%E4%BD%93%E8%B0%83%E6%95%B4/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>现在全网都只有关于<code>Windows</code>系统中修改<code>VScode</code>侧边栏字体大小的方法，在这里介绍<code>Ubuntu</code>系统的修改方法。<code>VScode</code>虽然好用，但是</strong>默认字体实在是太小了<strong>，侧边栏默认$13$号字体，编辑器默认$14$号字体，对于我来说完全<code>hold</code>不住。所以，我去改一改。</strong></p>
<h2 id="寻找侧边栏配置文件"><a href="#寻找侧边栏配置文件" class="headerlink" title="寻找侧边栏配置文件"></a>寻找侧边栏配置文件</h2><h3 id="和Windows不太一样的安装目录和存储文件"><a href="#和Windows不太一样的安装目录和存储文件" class="headerlink" title="和Windows不太一样的安装目录和存储文件"></a>和<code>Windows</code>不太一样的安装目录和存储文件</h3><p>首先就是<strong>用户自己可以设置的</strong>配置文件，也就是<code>settings.json</code>。但是，发现<code>sideBar</code>只有左边还是右边的设置。</p>
<p><img src="https://sakebow.gitee.io/images/经验分享/sidebar-setting.png" alt="只有左右设置"></p>
<p><strong>这显然不是我们想要的结果</strong>。</p>
<h3 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h3><p>于是，在<a href="http://www.zxmseed.com/blog/208537" target="_blank" rel="noopener"><code>Zxmseed</code>写的Visual Studio Code 左侧资源管理器字体设置</a>中找到了配置所在，也就是<code>${installation-location}\Microsoft VS Code\resources\app\out\vs\workbench\</code>里面的<code>workbench.main.css</code>文件中。<strong>但是很不幸</strong>，在<code>Ubuntu</code>系统和<code>Windows</code>系统还是很有些<strong>不一样</strong>的。</p>
<h3 id="使用Linux特有的手段查找文件"><a href="#使用Linux特有的手段查找文件" class="headerlink" title="使用Linux特有的手段查找文件"></a>使用<code>Linux</code>特有的手段查找文件</h3><p>所以，我们使用<code>Linux</code>的<code>find</code>命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> find <span class="variable">$&#123;folder name&#125;</span> -name <span class="variable">$&#123;part of target folder or file name&#125;</span></span></span><br><span class="line">find /usr -name 'code'</span><br></pre></td></tr></table></figure>
<p>这行命令的意思是：<strong>在<code>/usr</code>文件夹下寻找包含<code>code</code>这个单词的子文件夹或者文件</strong>。</p>
<p>当然，你也可以使用第三方包，比如<code>mlocate</code>，需要使用安装命令进行安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install mlocate</span><br></pre></td></tr></table></figure>
<p>然后使用<code>mlocate</code>包中的<code>locate</code>命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">locate code</span><br></pre></td></tr></table></figure>
<p>这种方法<strong>不需要指定查找位置</strong>，直接输入名称就给你匹配出来。</p>
<h3 id="找到了！"><a href="#找到了！" class="headerlink" title="找到了！"></a>找到了！</h3><p>不管用什么方法，最终也很幸运，我们找到了：</p>
<p><img src="https://sakebow.gitee.io/images/经验分享/folder-finding.png" alt="寻找VScode"></p>
<p>于是我们一个个试，发现<code>/usr/share/code</code>就是我们要找的文件夹，也就是<code>Microsoft VScode</code>的安装目录。</p>
<p>接着对照<code>Zxmseed</code>的博客中所指的位置，<strong>锁定了<code>/usr/share/code/resources/app/out/vs/workbench</code></strong>，里面有个文件是<code>workbench.desktop.main.css</code>。</p>
<p><img src="https://sakebow.gitee.io/images/经验分享/lock-folder.png" alt="锁定文件夹"></p>
<p>是不是和<code>Windows</code><strong>有些不同</strong>？也可能是版本更新之后才有所不同的吧。</p>
<h2 id="修改侧边栏配置文件"><a href="#修改侧边栏配置文件" class="headerlink" title="修改侧边栏配置文件"></a>修改侧边栏配置文件</h2><h3 id="没什么做不到的Vim编辑器"><a href="#没什么做不到的Vim编辑器" class="headerlink" title="没什么做不到的Vim编辑器"></a>没什么做不到的<code>Vim</code>编辑器</h3><p>一般<code>Linux</code>系统（<em>不包含<code>Deepin</code>等国产魔改系统</em>）都会内置<code>vi</code>命令来修改文件，<strong>但是非常难用</strong>。所以这里我们改用<code>Vim</code>，需要使用命令安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install vim</span><br></pre></td></tr></table></figure>
<p>安装完就<strong>已经没什么好怕的了</strong>。</p>
<p>找到目标之后，我们<strong>使用<code>Vim</code>打开</strong>这个文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /usr/share/code/resources/app/out/vs/workbench/workbench.desktop.main.css</span><br></pre></td></tr></table></figure>
<p>你会发现很大一批文字。<strong>千万不要妄图使用<code>gedit</code>命令打开超级大的文本文件</strong>，<strong>会卡得不行</strong>。</p>
<p>进入之后，我们使用<code>Vim</code>的<strong>字符串匹配功能</strong>一个个找下去，也就是在界面直接输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> /是匹配命令，后面是匹配字符串</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 直接输入不必回车，就只设置这么多字符串就能找到了</span></span><br><span class="line">/.content&#123;font</span><br></pre></td></tr></table></figure>
<p><img src="https://sakebow.gitee.io/images/经验分享/font-setting.png" alt="找到位置"></p>
<p>立马就锁定了这个位置。按下回车，光标就会停在<code>.content</code>这儿。默认字体大小是$13$号，我们稍微增大一些，改为$15$号，就按下<code>i</code>键，进入编辑模式，左下角会出现“<strong>—插入—</strong>”的字样，就能修改了。修改完按下<code>Esc</code>键退出编辑模式，再输入<code>:x</code>保存修改并退出。</p>
<h2 id="重启VScode应用，成功修改侧边栏字体"><a href="#重启VScode应用，成功修改侧边栏字体" class="headerlink" title="重启VScode应用，成功修改侧边栏字体"></a>重启<code>VScode</code>应用，成功修改侧边栏字体</h2><p>最后，就修改成功了。将<code>VScode</code>全部关掉，然后重新打开，我们就能看到左边的字体稍微有些大了。</p>
<h2 id="编辑器字体修改"><a href="#编辑器字体修改" class="headerlink" title="编辑器字体修改"></a>编辑器字体修改</h2><p>相对的，编辑器的修改就方便很多。直接在上方的<code>File</code>菜单栏里找到<code>Preferences</code>的<code>settings</code>。当然，你也可以使用快捷键：<code>Ctrl</code>+<code>，</code>，在里面搜索<code>font</code>，就能够修改编辑器的字体大小。</p>
<p><img src="https://img-blog.csdnimg.cn/20201204143634557.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29yZGluYXJ5X2Jyb255,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>是不是有点能理解了呢？</p>
]]></content>
      <categories>
        <category>经验分享</category>
      </categories>
      <tags>
        <tag>VScode魔改</tag>
      </tags>
  </entry>
  <entry>
    <title>参天树：决策树的操作</title>
    <url>/2020/12/03/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E5%86%B3%E7%AD%96%E6%A0%91%E7%AE%97%E6%B3%95/%E5%8F%82%E5%A4%A9%E6%A0%91%EF%BC%9A%E5%86%B3%E7%AD%96%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>既然已经了解了决策树的定义和原理，那么现在就更进一步，对树进行描述和修剪，就像是园艺师一样。</strong></p>
<a id="more"></a>
<h2 id="知识点复习：哈夫曼树"><a href="#知识点复习：哈夫曼树" class="headerlink" title="知识点复习：哈夫曼树"></a>知识点复习：哈夫曼树</h2><p>如果说大学稍微努了一点力，那么应该会了解一点哈夫曼树。</p>
<p>在哈夫曼树创建的时候，我们会优先计算所有元素的频率，然后将频率最高的几个元素放在最前面。但是，为什么要这样做？实际上，</p>
<h2 id="决策树创建的基本步骤"><a href="#决策树创建的基本步骤" class="headerlink" title="决策树创建的基本步骤"></a>决策树创建的基本步骤</h2><p>既然我们明白了决策树是在树的基础上进行划分。至于改进在哪？那自然是作为<strong>权重</strong>出现在决策树中间的<strong>信息增益</strong>。</p>
<p>还是搬出<a href="https://blog.csdn.net/ordinary_brony/article/details/110498273" target="_blank" rel="noopener">上一篇文章</a>中出现的一张大图：</p>
<p><img src="https://sakebow.gitee.io/images/决策树/决策流程图.png" alt="决策流程图"></p>
]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>算法模型</tag>
      </tags>
  </entry>
  <entry>
    <title>大树荫：决策树的算法原理</title>
    <url>/2020/12/01/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E5%86%B3%E7%AD%96%E6%A0%91%E7%AE%97%E6%B3%95/%E5%A4%A7%E6%A0%91%E8%8D%AB%EF%BC%9A%E5%86%B3%E7%AD%96%E6%A0%91%E7%9A%84%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>我们理解了决策树的定义与目的之后，我们便可以开始了解决策树背后的意义了。</strong></p>
<a id="more"></a>
<h2 id="信息熵和信息量化"><a href="#信息熵和信息量化" class="headerlink" title="信息熵和信息量化"></a>信息熵和信息量化</h2><p><strong>“等下，信息量有点大……”</strong></p>
<p>当我们面对有点难以接受和一时间反应不过来的信息时，我们经常说这句话。</p>
<p>你家的猫娘听到了特朗普败选的消息，一定是一脸不明所以地盯着眼前这个又跳又叫的奇怪生物；而如果是你和你的室友，那么就会相视一笑。为什么会有这样的差别？因为你的室友和你的猫娘<strong>所接收的信息量是不相同的</strong>。</p>
<p>信息量<strong>越是不足</strong>，那么这件事情就<strong>越不确定</strong>，要<strong>把这件事情搞清楚所需要的信息就越多</strong>；反之，信息量<strong>越足</strong>，各种局势也<strong>愈发明朗</strong>，要<strong>把这件事情搞清楚所需要的信息就越少</strong>。</p>
<p>那么，信息量怎么衡量？单纯的通过人的接受能力和反应时间实在是太主观了，也太武断了。更何况，如果不是使用数学方法衡量的话，现在也很难直接使用机器学习的方法帮助我们<strong>充分挖掘信息中的潜在价值</strong>。</p>
<blockquote>
<p>1948年，像农在他著名的《通信的数学原理》中提出了<strong>信息熵</strong>的概念，从而解决了信息量化的问题。</p>
<p>——摘自《scikit-learn机器学习常用算法原理与编程实战》 [著]黄永昌</p>
</blockquote>
<p>如果你的脑海里还残存了一点点高中化学的知识，你应该知道，<strong>熵是一种不稳定状态的度量方式</strong>。<strong>熵越大</strong>，<strong>空间内越混乱</strong>。那么信息熵也应当类似。如果说对这件事<strong>完全弄明白了</strong>，那么就是一种<strong>稳定状态</strong>；而<strong>半懂不懂</strong>则是一种<strong>不稳定的状态</strong>。信息熵描述的就是对这个信息来说从不稳定（<em>也就是没有完全理解</em>）到稳定（<em>也就是彻底理解</em>）之间的差距。</p>
<p>信息熵的量化公式就是：</p>
<script type="math/tex; mode=display">H(X) = -\sum_{x\in X}P(x)log_2P(x)</script><p>其中，$X$指所研究的事件集合，$x$指事件集合中所出现的其中一个事件，$P(x)$则是事件$x$所出现的概率。</p>
<p>如果在我面前有一个宝箱，出货率如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>物品</th>
<th>概率</th>
</tr>
</thead>
<tbody>
<tr>
<td>一次性湿纸巾一包</td>
<td>$25\%$</td>
</tr>
<tr>
<td>一次性纸手帕一包</td>
<td>$25\%$</td>
</tr>
<tr>
<td>一次性塑料碗一个</td>
<td>$25\%$</td>
</tr>
<tr>
<td>一次性木筷子一双</td>
<td>$25\%$</td>
</tr>
</tbody>
</table>
</div>
<p>既然每一种一次性用品抽中的概率都是$25\%$，那么任意抽一次，也就只有这些结果：</p>
<ul>
<li>一次性湿纸巾一包</li>
<li>一次性纸手帕一包</li>
<li>一次性塑料碗一个</li>
<li>一次性木筷子一双</li>
</ul>
<p>所以，信息熵也就是：</p>
<script type="math/tex; mode=display">H(抽奖结果)=-(\frac{1}{4}\log_2\frac{1}{4})*4=2(bit)</script><p>没错，结果的单位实际上是<strong>比特</strong>。要确认我这次抽到的是4种一次性用具的哪一种，只需要<strong>两个比特</strong>就能解决，也就是一个字节的$\frac{1}{4}$就可以了，大概就是<code>00000000</code>到<code>00000011</code>，或者是<code>0x00</code>到<code>0x03</code>。</p>
<p>很神奇不是么？</p>
<h2 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h2><p>什么是信息增益？<strong>就是信息量的差值</strong>。<strong>信息增益只是一个值</strong>，<strong>没有正负的矢量意义</strong>。还记得之前提到的权重么？<strong>这个权重就是信息增益</strong>。如果增益非常大，那么权重就会非常大。在决策树彻底长成古老的巨树之后，信息增益就会帮我们从根出发，一直上升到对应的叶子。</p>
<p>好的，到了这一步，我们换个场景：</p>
<p>现在你刚拿到你的小蛋糕店，也装修完了，现在剩下一地的箱子，共$100$只。$8$个装了垃圾，$16$个是日用品，$16$个是对蛋糕店来说有用的，$4$个是极其重要的，还有$8$个被你的猫娘们占用了，剩下$48$个是空箱子。现在不再是抽奖了，而是你要逐一分类。当然，这个时候你完全可以看看里面是什么。</p>
<p>渐渐地，在分类的过程中，你也找到了诀窍：</p>
<ul>
<li>空箱子非常轻，踢一脚就会滚两圈；</li>
<li>装了垃圾的箱子会看起来脏一点，蒙着一层灰；</li>
<li>装了日用品的箱子中，有的会伸出来衣架，有的会散发出沐浴露的香味等等；</li>
<li>装了蛋糕店相关的箱子和极其重要的箱子会有很明显的警告标志；</li>
<li>被猫娘们霸占的箱子则会伸出来一只猫尾巴或者猫爪爪</li>
</ul>
<p>看起来很有规律了嘛。那么就开始分类吧：</p>
<p>首先，我们先分析一下，对于这$100$个箱子里面，随便选一个打开看的话，就会有这些事件：</p>
<script type="math/tex; mode=display">X=\{空箱子(x_1),垃圾箱(x_2),日用品箱(x_3),蛋糕箱(x_4),重要箱子(x_5),猫娘箱(x_6)\}</script><p>概率分布就是这样：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>$X$</th>
<th>$x_1$</th>
<th>$x_2$</th>
<th>$x_3$</th>
<th>$x_4$</th>
<th>$x_5$</th>
<th>$x_6$</th>
</tr>
</thead>
<tbody>
<tr>
<td>$P(x)$</td>
<td>$0.48$</td>
<td>$0.08$</td>
<td>$0.16$</td>
<td>$0.16$</td>
<td>$0.04$</td>
<td>$0.08$</td>
</tr>
</tbody>
</table>
</div>
<p>好的，接下来就是信息熵了。</p>
<h3 id="根"><a href="#根" class="headerlink" title="根"></a>根</h3><p>一开始就是一片混沌的6种箱子混在一起，$H(X)=-\sum_{x\in X}P(x)*\log_xP(x)=2.1231$。</p>
<h3 id="猫枝叶、部分日用品枝叶"><a href="#猫枝叶、部分日用品枝叶" class="headerlink" title="猫枝叶、部分日用品枝叶"></a>猫枝叶、部分日用品枝叶</h3><p>为了先照顾你心目中最重要的几只小猫娘，你决定<strong>先看看有没有猫</strong>。于是，你看看箱子里伸出来了啥，然后发现了4个伸出来猫爪爪的箱子和4个伸出来猫尾巴的箱子，还发现了8个伸出来衣架的日用品箱子。于是，$H(x_6)=-P(x_6)<em>\log_2P(x_6)=3.64</em>0.08=0.2912$，这就是找到猫娘所需要的信息增益。对于突然发现的日用品箱$(x_7)$我们也计算一下，$H(x_7)=-P(x_7)*\log_2P(x_7)=0.2915$</p>
<h3 id="分枝"><a href="#分枝" class="headerlink" title="分枝"></a>分枝</h3><p>那么，然后<strong>剩下来空箱子</strong>、<strong>垃圾箱</strong>、<strong>蛋糕箱和剩下的日用品箱</strong>，记为$Y$，$H(Y)=-\sum_{x\in Y}P(x)*\log_2P(x)=1.5143$</p>
<p>然后看看<strong>有没有警告标记</strong>。找到警告标记之后，会找到蛋糕箱和对自己非常重要的箱子，记为$Z$，$H(Z)=-\sum_{x\in Z}P(x)*\log_2P(x)=0.6088$。</p>
<p>而剩下一些空箱子、垃圾箱和剩下的日用品箱，记为$A$，$H(x)=-\sum_{x\in A}P(x)*\log_2P(x)=1.0913$</p>
<h3 id="重要箱子枝叶"><a href="#重要箱子枝叶" class="headerlink" title="重要箱子枝叶"></a>重要箱子枝叶</h3><p>找出了蛋糕箱和重要箱子之后，我们再<strong>打开看看</strong>箱子里是个啥。打开之后如果发现了相册和笔记本，那就是重要箱子，$H(x_5)=-P(x_5)*\log_2P(x_5)=0.1858$。</p>
<h3 id="蛋糕箱枝叶"><a href="#蛋糕箱枝叶" class="headerlink" title="蛋糕箱枝叶"></a>蛋糕箱枝叶</h3><p>同时，我们也找到了蛋糕箱，$H(x_4)=-P(x_4)*\log_2P(x_4)=0.423$。</p>
<h3 id="空箱子枝叶"><a href="#空箱子枝叶" class="headerlink" title="空箱子枝叶"></a>空箱子枝叶</h3><p>我们刚刚通过有没有警示标志找出了空箱子、垃圾箱和剩下的日用品箱，我们接下来就<strong>随便踢一脚试试</strong>，如果瞬间就飞出去翻滚两圈，那就是空箱子。于是，$H(x_1)=-P(x_1)*\log_2P(x_1)=0.5803$</p>
<h3 id="分枝-1"><a href="#分枝-1" class="headerlink" title="分枝"></a>分枝</h3><p>那么，踢不动的就是垃圾箱和日用品箱了，记为$B$，$H(B)=-\sum_{x\in B}P(x)*\log_2P(x)=0.583$</p>
<h3 id="垃圾箱枝叶、剩余日用品箱枝叶"><a href="#垃圾箱枝叶、剩余日用品箱枝叶" class="headerlink" title="垃圾箱枝叶、剩余日用品箱枝叶"></a>垃圾箱枝叶、剩余日用品箱枝叶</h3><p>最后，我们在最后剩下的<strong>箱子里间闻一闻</strong>，就能够通过有没有沐浴露的清香来分辨最后的两种箱子。没有香味那就应该是充满了灰尘味道的垃圾箱了。于是，$H(x_2)=-P(x_2)<em>\log_xP(x_2)=2.915$。最后就是剩下的$8$个日用品箱了，也就是$H(x_3)=-P(x_3)</em>\log_2P(x_3)=2.915$。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这下整颗树就明了了呢。画张图总结一下吧：</p>
<p><img src="https://sakebow.gitee.io/images/决策树/决策流程图.png" alt="决策流程图"></p>
<p>看起来非常不错啊！</p>
<h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><p><strong>在这里插句嘴</strong>，我们一直在计算熵值，也就是这个函数$H(x)=-P(x)*\log_2P(x)$。如果我们吧这个函数画出来：</p>
<p><img src="https://sakebow.gitee.io/images/决策树/函数图像.png" alt="决策流程图"></p>
<p>这也正好说明了：<strong>若是对于这件事发生的概率越大</strong>、<strong>对这件事越确定</strong>，<strong>熵值越低</strong>，<strong>也就越稳定</strong>、<strong>越可靠</strong>。</p>
<p>当然，<strong>还有一个小小的问题</strong>。在化学里面，只要一个独立的系统放在这里，熵值只会变大，只是时间快慢的问题了。也就是说，要是就把这一堆箱子放在这里，箱子只会越来越乱。当然，对于用电脑比较多的办公人士、码农等等，一段时间只往电脑里塞文件而不分类，电脑里面的文件也只会越来越乱。<strong>为什么要分类</strong>？一方面让自己更好地找到自己想要的东西，另一方面，学术一点的表达就是：<strong>让熵值减少</strong>，<strong>从而该事件更稳定</strong>。如果是表述得更哲学一点，那就是像书中说的一样：</p>
<blockquote>
<p>如果没有外力的作用，这个世界将会是越来越无序的。人活着，再与尽量让熵变低，即让世界变得更有序，降低不确定性。</p>
<p>希望笔者在暮年之时，回首往事，能自信地说，我给这个世界带来的信息增益是正数，且已经尽力做到最大了。</p>
<p>——摘自《scikit-learn机器学习常用算法原理及编程实战》 [著]黄永昌</p>
</blockquote>
<p>是不是有点能理解了呢？</p>
]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>算法模型</tag>
      </tags>
  </entry>
  <entry>
    <title>开工：数据集的特征理解</title>
    <url>/2020/11/22/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87%EF%BC%9ADataFrame%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>由于特征分析中包含了很多有关<code>Python</code>中数据分析的方法，这里单独创建一篇文章进行说明。本篇文章会持续更新，收集各种各样非常多不同的、方便的库。</strong></p>
<a id="more"></a>
<h2 id="最常用库"><a href="#最常用库" class="headerlink" title="最常用库"></a>最常用库</h2><h3 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a><code>DataFrame</code></h3><p>如果是图表形式，<code>DataFrame</code>将会是最理想的库。包含了多维度合并分析、多维度降维分析、图像等非常方便的库。</p>
<h3 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a><code>Numpy</code></h3><p>而如果有什么<code>DataFrame</code>做不到的一些事情，就和<code>numpy</code>一起使用，通过矩阵来计算高维度的分析和计算。</p>
<h3 id="Pandas"><a href="#Pandas" class="headerlink" title="Pandas"></a><code>Pandas</code></h3><p>接着就是读取文件的<code>pandas</code>库。确实，现在有着非常多的代码库，也有非常多的形式读取不同形式的文件。但是<code>pandas</code>库能够将任何形式的文件转变为<code>DataFrame</code>格式，对接起来非常方便。</p>
<h3 id="matplotlib"><a href="#matplotlib" class="headerlink" title="matplotlib"></a><code>matplotlib</code></h3><p>如果你觉得数据还是太抽象，你可以使用<code>matplotlib</code>库进行图像的绘制，这样能够让数据更为直观，能够协助看清什么数据有着什么样的趋势，哪些数据占比更多而哪些数据占比更少等等。这些直观的表达更能够为我们下一步的决策和分析提供更细致的参考。</p>
<h2 id="获得数据"><a href="#获得数据" class="headerlink" title="获得数据"></a>获得数据</h2><p>对于数学分析，其实<strong>更推荐文件的形式</strong>，而<strong>不是数据库</strong>。因为数据库的<strong>读取速度非常有限</strong>，在分析大量的数据时需要花费一些时间等待网络请求和数据传输的时间。虽然<code>MongoDB</code>数据库相比<code>Oracle</code>、<code>MySQL</code>、<code>SQL Server</code>等数据库有着非关系型的特点，以<code>JSON</code>的形式保存所有的数据，却还是不能够<strong>在很短的时间内获得大量对象中的同一个属性的属性值进行分析</strong>。所以这里推荐的形式有<code>csv</code>、<code>xls</code>、<code>json</code>和<code>xml</code>等的<strong>本地文件</strong>。</p>
<ul>
<li>如果是<code>csv</code>文件，<code>pandas</code>库提供了<code>read_csv(&lt;str&gt; csv_path)</code>方法；</li>
<li>如果是<code>excel</code>文件，<code>pandas</code>库提供了<code>read_excel(&lt;str&gt; excel_path)</code>方法；</li>
<li>如果是<code>json</code>文件，<code>pandas</code>库提供了<code>read_json(&lt;str&gt; json_path)</code>方法；</li>
<li>如果是剪贴板，<code>pandas</code>库提供了<code>read_clipboard()</code>方法；</li>
<li>……</li>
</ul>
<p>基本上涵盖了目前所有的主流格式。</p>
<h2 id="图表绘制"><a href="#图表绘制" class="headerlink" title="图表绘制"></a>图表绘制</h2><p><code>matplotlib</code>库提供了非常丰富的绘图库，横纵坐标都能够使用<code>numpy</code>的数组。</p>
]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>特征工程</tag>
      </tags>
  </entry>
  <entry>
    <title>开工：数据集的特征理解</title>
    <url>/2020/11/22/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/%E5%BC%80%E5%B7%A5%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%9B%86%E7%9A%84%E7%89%B9%E5%BE%81%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>本篇将详细解释数据集的处理方式。我相信肯定是有小伙伴读过《特征工程入门与实践》，所以这里就拿一些不一样的数据集说明特征理解的过程。</strong></p>
<a id="more"></a>
<h2 id="数据集的准备"><a href="#数据集的准备" class="headerlink" title="数据集的准备"></a>数据集的准备</h2><p>在这里我们使用的是德国的能源消耗信息，是一个结构化的报表。由于数据在外网，所以这里下载下来给大家：<a href="https://sakebow.gitee.io/images/数据集/germany_energy.csv">点击查看并全文复制保存在本地</a>。</p>
<p>如果你使用<code>Chrome</code>浏览器打开，那么你打开的时候应该是这样：</p>
<p><img src="https://sakebow.gitee.io/images/特征工程/德国能源数据集.png" alt="数据集"></p>
<p>我们可以看到，这个数据中包含了从$2006/1/1$开始的所有耗电数据、风力发电数据、太阳能发电数据和风力太阳能混合发电。在准备理解特征之前，我们还是把之前的流程图放在下面供参考：</p>
<p><img src="https://sakebow.gitee.io/images/特征工程/特征理解流程.png" alt="特征工程流程"></p>
<p>好的，开搞！</p>
<h2 id="数据读取"><a href="#数据读取" class="headerlink" title="数据读取"></a>数据读取</h2><p>在这里，我们使用<code>pandas</code>库进行数据的读取。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取数据集文件</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_data</span><span class="params">(path)</span>:</span></span><br><span class="line">  datas = pd.read_csv(path)</span><br><span class="line">  <span class="comment"># 选取耗电作为研究对象</span></span><br><span class="line">  data = datas[[<span class="string">'Date'</span>, <span class="string">'Consumption'</span>]]</span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>封装了这个方法之后，我们调用就是这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 我的文件保存在了/home/sakebow/python/data/germany_energy.csv</span></span><br><span class="line">data = get_data(<span class="string">'/home/sakebow/python/data/germany_energy.csv'</span>)</span><br></pre></td></tr></table></figure>
<p>由于数据本身是用<code>csv</code>存储的，所以具有一定的结构性。<strong>第一步</strong>：<strong>结构化直接完成</strong>$\sqrt{}$</p>
<p>紧接着，我们来看看每一列的情况：</p>
<ul>
<li>日期是定序等级，虽然数值有实际的意义，本质上还是类别；</li>
<li>能耗是定量数据，在研究的时候还是会觉得数值非常大，所以将所有的能耗数据和$2006/01/01$的相减，得到定距等级；</li>
<li>风力发电和混合发电也是使用定距等级进行分析。</li>
</ul>
<p><strong>第二步</strong>：<strong>每一列的类别分析</strong>，<strong>完成</strong>$\sqrt{}$</p>
<p>然后我们就对照<a href="/2020/11/21/人工智能/特征工程/准备：特征理解/">准备：特征理解</a>中提供的参照表进行图表的绘制。</p>
<p>那么对着表一个个看，发现应当这么操作：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>对象</th>
<th>使用图表</th>
</tr>
</thead>
<tbody>
<tr>
<td>日期</td>
<td>直方图</td>
</tr>
<tr>
<td>能耗</td>
<td>折线图、散点图、直方图</td>
</tr>
<tr>
<td>风力</td>
<td>折线图、散点图、直方图</td>
</tr>
<tr>
<td>太阳能</td>
<td>折线图、散点图、直方图</td>
</tr>
<tr>
<td>混合</td>
<td>折线图、散点图、直方图</td>
</tr>
</tbody>
</table>
</div>
<p>看起来还不错。不过我们还是想研究<strong>能耗</strong>、<strong>风力</strong>、<strong>太阳能</strong>和<strong>混合发电量</strong>随着时间的推移而变化的趋势，所以，重新规划一下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>对象</th>
<th>变量类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>日期</td>
<td>自变量（作为$x$轴）</td>
</tr>
<tr>
<td>能耗</td>
<td>因变量（作为$y$轴之一）</td>
</tr>
<tr>
<td>风力</td>
<td>因变量（作为$y$轴之一）</td>
</tr>
<tr>
<td>太阳能</td>
<td>因变量（作为$y$轴之一）</td>
</tr>
<tr>
<td>混合</td>
<td>因变量（作为$y$轴之一）</td>
</tr>
</tbody>
</table>
</div>
<p>好了，图表确认了，我们直接开始吧。</p>
<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>首先，我们先拉出数据集里面的日期和耗电量。刚刚我们拿到了一共四列数据的<code>DataFrame</code>对象<code>data</code>现在我们需要提取其中的几列作为研究对象。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用两个中括号能够同时提取多列作为研究对象</span></span><br><span class="line">consumptions = data[[<span class="string">'Date'</span>, <span class="string">'Consumption'</span>]]</span><br><span class="line"><span class="comment"># 使用DataFrame封装的plot方法能够非常方便的画出图像</span></span><br><span class="line">consumptions.plot()</span><br></pre></td></tr></table></figure>
<p><strong>执行</strong>！</p>
<p>好嘛，啥都没发生。纠其原因，就是没有显示图像。画归画，显示又是另一回事。所以我们引入<code>matplotlib</code>作为绘图包。接下来就是完整的代码：</p>
<p><strong>严重警告</strong>：这部分代码虽然<strong>没问题</strong>，但是得出来的<strong>结果很奇葩</strong>。<strong>复制请慎重</strong>！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> pyplot</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_data</span><span class="params">(path, x, y)</span>:</span></span><br><span class="line">  datas = pd.read_csv(path)</span><br><span class="line">  data = datas[[x, y]]</span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  data = get_data(<span class="string">'/home/sakebow/python/data/germany_energy.csv'</span>, <span class="string">'Date'</span>, <span class="string">'Consumption'</span>)</span><br><span class="line">  data.plot()</span><br><span class="line">  pyplot.xlabel(<span class="string">'date'</span>)</span><br><span class="line">  pyplot.ylabel(<span class="string">'consumption'</span>)</span><br><span class="line">  pyplot.show()</span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p><strong>看起来非常完美</strong>！<strong>运行</strong>！</p>
<p><img src="https://sakebow.gitee.io/images/特征工程/德国能源数据可视化图表_1.png" alt="德国能源数据"></p>
<p>嗯……虽然线条没什么问题，但是这个横坐标也太奇葩了吧？直接将<code>DataFrame</code>的索引变成了横坐标。这显然不是什么好图表。</p>
<p>所以，我们稍加修改：</p>
<p><strong>注意</strong>：下面这个方法是<strong>正确的</strong>，<strong>请放心复制</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> pyplot</span><br><span class="line"><span class="comment"># 封装读取数据的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_data</span><span class="params">(path, x, y)</span>:</span></span><br><span class="line">  datas = pd.read_csv(path)</span><br><span class="line">  data = datas[[x, y]]</span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  <span class="comment"># 获取数据</span></span><br><span class="line">  data = get_data(<span class="string">'/home/sakebow/python/data/germany_energy.csv'</span>, <span class="string">'Date'</span>, <span class="string">'Consumption'</span>)</span><br><span class="line">  <span class="comment"># 确认索引，并且替换掉原先的索引</span></span><br><span class="line">  data.set_index(<span class="string">'Date'</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">  <span class="comment"># 内置函数绘图</span></span><br><span class="line">  data.plot()</span><br><span class="line">  <span class="comment"># 横坐标备注</span></span><br><span class="line">  pyplot.xlabel(<span class="string">'date'</span>)</span><br><span class="line">  <span class="comment"># 纵坐标备注</span></span><br><span class="line">  pyplot.ylabel(<span class="string">'consumption'</span>)</span><br><span class="line">  <span class="comment"># 显示图表</span></span><br><span class="line">  pyplot.show()</span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p><img src="https://sakebow.gitee.io/images/特征工程/德国能源数据可视化图表_2.png" alt="德国能源数据"></p>
<p><strong>这就好多了</strong>。</p>
<p>能够很明显地看出来，没有什么非常明显的规律，甚至还有一定的周期性。</p>
<p>这也就是特征理解一直在做的事情。通过图表分析数据地走向。如果数据量非常多，我们也可以使用这样的方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> pyplot</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  <span class="comment"># 获取数据</span></span><br><span class="line">  datas = pd.read_csv(<span class="string">'/home/sakebow/python/data/germany_energy.csv'</span>)</span><br><span class="line">  <span class="comment"># 确认索引，并且替换掉原先的索引</span></span><br><span class="line">  datas.set_index(<span class="string">'Date'</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">  <span class="comment"># 内置函数绘图</span></span><br><span class="line">  data.plot()</span><br><span class="line">  <span class="comment"># 横坐标备注</span></span><br><span class="line">  pyplot.xlabel(<span class="string">'date'</span>)</span><br><span class="line">  <span class="comment"># 显示图表</span></span><br><span class="line">  pyplot.show()</span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p><img src="https://sakebow.gitee.io/images/特征工程/德国能源数据可视化图表_3.png" alt="德国能源数据"></p>
<p>像这样就非常明显地表明：<strong>从2006年开始德国的耗电有着周期性的</strong>、<strong>稳定的变化</strong>；<strong>风力发电和太阳能发电一直都在增长</strong>。<strong>但是混合发电量依然远远达不到耗电量</strong>。</p>
<p>这就是特征理解了。在这个阶段，我们所做的就是<strong>使用图表来理解什么数据是什么趋势</strong>、<strong>通过肉眼大致预测什么数据和什么有关</strong>。接下来就是剩下的步骤了。</p>
]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>特征工程</tag>
      </tags>
  </entry>
  <entry>
    <title>准备：特征理解</title>
    <url>/2020/11/21/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/%E5%87%86%E5%A4%87%EF%BC%9A%E7%89%B9%E5%BE%81%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>虽然我们介绍了数据的无量纲化，但是在实际编码之前我们还是需要多做一些准备工作。</strong></p>
<a id="more"></a>
<p>在20多年的考试生涯中，老师都不断的提醒我们<strong>多读题</strong>。而在机器学习中，多读题也就变成了<strong>多了解数据的特点</strong>。也就是接下来要介绍的几个特点。</p>
<h2 id="数据是否具有统一的格式"><a href="#数据是否具有统一的格式" class="headerlink" title="数据是否具有统一的格式"></a>数据是否具有统一的格式</h2><p>现在数据飞速膨胀，单一的数字已经没办法满足现在的高标准严要求了。所以，这里使用一些高维度的数据进行说明。</p>
<p>还是收集了20万猫娘数据的你，还是分析各种疾病。但是呢，病情记录却不全是报表形式的数据，而是一大堆毫不相关的症状堆叠在一起。这种数据被称为<strong>非结构化数据</strong>，或者是<strong>无组织数据</strong>。就像是：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>账号</th>
<th>情况</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>12301231823</td>
<td>眼球血丝较多，眼睛经常痒，咽喉处疼痛，鼻涕多</td>
</tr>
<tr>
<td>2</td>
<td>31287936661</td>
<td>呼吸不畅，喷嚏非常多，四肢无力</td>
</tr>
<tr>
<td>3</td>
<td>54174139414</td>
<td>胃胀痛，干呕，恶心</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
</div>
<p>当我们分析情况的时候，就会人和机器一起一头雾水，不知道从哪开始。</p>
<p>另外，分析疾病并不能一杆子打死，而是各有不同，需要每只猫娘的个人信息。这个时候，由于医院系统的数字化管理，猫娘的信息都是以非常标准的报表形式给出，非常方便。这些数据就是<strong>结构化数据</strong>，或者是<strong>有组织数据</strong>。就像是：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>编号</th>
<th>姓名</th>
<th>年龄</th>
<th>性别</th>
<th>种族</th>
<th>持有铃铛</th>
<th>铃铛登记时间</th>
</tr>
</thead>
<tbody>
<tr>
<td>123831643</td>
<td>香子兰</td>
<td>14</td>
<td>女</td>
<td>猫</td>
<td>是</td>
<td>2018-12-25</td>
</tr>
<tr>
<td>123862173</td>
<td>巧克力</td>
<td>14</td>
<td>女</td>
<td>猫</td>
<td>是</td>
<td>2019/5/30</td>
</tr>
<tr>
<td>412371383</td>
<td>铃仙</td>
<td>16</td>
<td>女</td>
<td>兔</td>
<td>否</td>
<td>$\times$</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody>
</table>
</div>
<p>收集这些信息的时候，由于非常严格的格式和非常好理解的表格形式，所以读取非常方便。</p>
<h2 id="数值是指代类别还是具体数值"><a href="#数值是指代类别还是具体数值" class="headerlink" title="数值是指代类别还是具体数值"></a>数值是指代类别还是具体数值</h2><p>还是刚刚的个人信息的例子。</p>
<p>香子兰是女猫娘，这就是<strong>指代类别</strong>的数据。而年龄是14，这又是<strong>具体数值</strong>。虽然都是每一位用户的属性，却相当明确地给出了完全不一样的参考。</p>
<p>类别用于给用户分类，比如女性猫娘更适合比较精细的工作，而男性牛头人更适合力量型的工作等等；数值则用于定量表示用户的各种参数信息。比如握力、跳远距离等等。</p>
<h2 id="数据的四个等级"><a href="#数据的四个等级" class="headerlink" title="数据的四个等级"></a>数据的四个等级</h2><p>刚刚我们把数据分为定性和定量两种，接下来我们继续分类：</p>
<ul>
<li>定类等级</li>
<li>定序等级</li>
<li>定距等级</li>
<li>定比等级</li>
</ul>
<p>刚刚提到的<strong>指代类别</strong>就是<strong>定类等级</strong>数据，这个比较好理解，就不再赘述。</p>
<p>而<strong>定序等级</strong>，则是<strong>在同一种前提下对所有的类别进行排序</strong>所得到的类别集合。打个比方，我们需要在地下城寻找更适合当裁缝的种族，所以收集大量的数据，并按照所有种族的平均表现进行排序。最后我们发现，蚕和毛毛虫这两个种族不相上下，并列第一，其次是蜘蛛，然后是人类。于是，我们就得到了一个有序的集合，这个集合就是含有<strong>定序等级</strong>的数据。虽然说这组数据中包含一些使用数据精确说明的定量数据，但是本身代表的实际上是一个类，哪怕这个数字是一个像$25\%$之类的确切数值数。</p>
<p><strong>定距等级</strong>，顾名思义，就是设置参照并使用差值进行绘图。还是<a href="/2020/11/15/人工智能/特征工程/知识储备：数据的无量纲化/">知识储备：数据的无量纲化</a>中跳远数据的例子。比起全部使用$1.537$上下不等的共20万琐碎数据，还是将$1.537$作为新的参照重新计算这些数据反而效果会更好。其中，这个由差值组成的新的数据集就是包含<strong>定距等级</strong>的数据集。当然，毕竟是20万条数据，画图将会是密密麻麻的一片，毫无参考价值。所以，这里可以以年龄为$x$轴，每个年龄段都计算均值，这样就能得出<strong>年龄-跳远距离</strong>曲线。这个年龄又是<strong>定序等级</strong>。就变成了<strong>不同类别下的定量分析</strong>。全都联系起来了，不是么？</p>
<p><strong>定比等级</strong>同样也是定量的描述，只不过和<strong>定距等级</strong>不一样的是，<strong>定距等级使用的是差值</strong>，而<strong>定比等级使用的是比值</strong>。同样需要参照物，研究的时候也是研究比值而不是源数据。<code>CPU</code>、<code>GPU</code>等电子产品的性能分析就是最好的例子。往往在新款<code>CPU</code>、<code>GPU</code>等电子产品推出的时候，都会和一个参照物进行比较。比如，<code>intel</code>新款<code>CPU</code>会和历代<code>CPU</code>产品进行比较，频率提升了多少比率、各种测试环境下的表现提升了多少比率等等；小米会和华为比较，打开应用的速度提升了百分之多少，游戏延迟降低了百分之多少等等。这些都是<strong>定比等级</strong>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后就用《特征工程入门与实践》中的表格作总结吧。</p>
<p>下面这个表格总结了本篇的核心内容，也就是<strong>四大数据特点的比较</strong>。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>等级</th>
<th>属性</th>
<th>例子</th>
<th>描述性统计</th>
<th>图表</th>
</tr>
</thead>
<tbody>
<tr>
<td>定类</td>
<td>离散、无序</td>
<td>颜色、真或假</td>
<td>频率/占比、众数</td>
<td>条形图、饼状图</td>
</tr>
<tr>
<td>定序</td>
<td>有序</td>
<td>考试等级、年龄分段</td>
<td>频率、众数、中位数、百分数</td>
<td>条形图、饼图、茎叶图</td>
</tr>
<tr>
<td>定距</td>
<td>数据差有真实意义</td>
<td>温度、跳远</td>
<td>频率、众数、中位数、均值、标准差</td>
<td>条形图、饼图、茎叶图、箱线图、直方图</td>
</tr>
<tr>
<td>定比</td>
<td>连续、存在有真实意义的绝对零点，可以做除法</td>
<td>性能指标、金钱、重量</td>
<td>均值、标准差</td>
<td>直方图、箱线图</td>
</tr>
</tbody>
</table>
</div>
<p>如果你不知道<strong>什么等级应该用什么样的统计量表示</strong>，那就对照下面这张表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>统计量</th>
<th>定类</th>
<th>定序</th>
<th>定距</th>
<th>定比</th>
</tr>
</thead>
<tbody>
<tr>
<td>众数</td>
<td>$\sqrt{}$</td>
<td>$\sqrt{}$</td>
<td>$\sqrt{}$</td>
<td>有时可行</td>
</tr>
<tr>
<td>中位数</td>
<td>$\times$</td>
<td>$\sqrt{}$</td>
<td>$\sqrt{}$</td>
<td>$\sqrt{}$</td>
</tr>
<tr>
<td>差值、最小最大值</td>
<td>$\times$</td>
<td>$\sqrt{}$</td>
<td>$\sqrt{}$</td>
<td>$\sqrt{}$</td>
</tr>
<tr>
<td>均值</td>
<td>$\times$</td>
<td>$\times$</td>
<td>$\sqrt{}$</td>
<td>$\sqrt{}$</td>
</tr>
<tr>
<td>标准差</td>
<td>$\times$</td>
<td>$\times$</td>
<td>$\sqrt{}$</td>
<td>$\sqrt{}$</td>
</tr>
</tbody>
</table>
</div>
<p>现在，相信你对一大堆不知所云甚至毫无关联的数据的时候，不会像以前那么害怕了，不是么？最后还是提醒一下，特征工程的特征理解，最最核心的操作步骤，就是下面这张图所示的：</p>
<p><img src="https://sakebow.gitee.io/images/特征工程/特征理解流程.png" alt="特征工程流程"></p>
<p>是不是有点能理解了？</p>
]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>特征工程</tag>
      </tags>
  </entry>
  <entry>
    <title>方向：特征工程的定义与目的</title>
    <url>/2020/11/19/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/%E6%96%B9%E5%90%91%EF%BC%9A%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E7%9B%AE%E7%9A%84/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>本文主要是<a href="https://www.bilibili.com/video/BV1rp4y197fo" target="_blank" rel="noopener">B站视频：【机器学习】特征工程</a>的学习笔记，里面包含了视频内容和自己的理解。</strong></p>
<a id="more"></a>
<h2 id="特征工程的定义"><a href="#特征工程的定义" class="headerlink" title="特征工程的定义"></a>特征工程的定义</h2><blockquote>
<p>特征工程是将<strong>原始数据转化为更好地代表预测模型的潜在问题的特征</strong>的过程，从而<strong>提高了对未知数据的预测准确性</strong>。</p>
<p>——摘自视频中展示的PPT</p>
</blockquote>
<p>也就是说，特征工程不过就是从大量的原始中选出确确实实对需要研究的数据产生了影响的个别数据。听起来和我之前描述的机器学习过程没有什么区别？确实没有什么区别，换了个专业的名词而已。</p>
<h2 id="特征工程的目标"><a href="#特征工程的目标" class="headerlink" title="特征工程的目标"></a>特征工程的目标</h2><p>在大学毕业以前，题目都会明确指定自变量和因变量，然后使用固定的模式来匹配这些自变量和因变量，最终得出结论。</p>
<p>在研究生生活开始以后，就再也没有固定的套路了。一大堆数据里面，确定一个研究对象并设置为因变量，将其他的变量全部设定为自变量，最后分析哪些变量对因变量的变化产生了决定性的作用，哪些变量对因变量产生了重要作用，而哪些变量是与因变量完全无关的。</p>
<p>所以，特征工程的目标则是针对因变量的变化，<strong>通过排除并没有什么作用的变量而降低问题的复杂度</strong>，<strong>让所研究的问题更加清晰</strong>。</p>
<p>这也是机器学习中最需要做的事情。拿到数据之后，选定其中一个数据作为我们需要研究的对象；剩下的便是使用各种各样的机器学习算法对剩余的数据进行降维、降噪和建模分析。</p>
<p>所以，特征工程就是为了机器学习的进一步分析服务的。是不是有点能理解了呢？</p>
]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>特征工程</tag>
      </tags>
  </entry>
  <entry>
    <title>知识储备：数据的无量纲化</title>
    <url>/2020/11/15/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%9A%84%E6%97%A0%E9%87%8F%E7%BA%B2%E5%8C%96/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>你现在拿到了许多数据，顺序是完全随机的。这已经不是单凭肉眼和逻辑推导就能分析出来的规律，只能通过机器学习来计算。那么，应该从哪一步开始？</strong></p>
<a id="more"></a>
<h2 id="数据无量纲化"><a href="#数据无量纲化" class="headerlink" title="数据无量纲化"></a>数据无量纲化</h2><p>放心，无论是谁只要是第一次听到这个名词都会蒙圈一会。其的定义就是：“<strong>将不同规格的数据转换到同一规格</strong>，<strong>或者不同分布的数据转换为同一分布</strong>”。听起来不是很好理解？</p>
<p>还是那个时候收集了20万猫娘数据的你。这个时候你甚至收集到了猫娘们跳远、跳高的数据。可是这些数据都集中在$1.537$米左右，想要分析的话实在是<strong>计算量非常大</strong>。所以，你修改了一下计算参照，不再是将所有的数据和$0$米相比，而是和平均值$1.537$米相比。于是大量的数据都集中在$0$到$0.262$，少部分分布在$0.262$到$0.501$。这个计算量就好多了，不是么？</p>
<p>这就是<strong>数据规格化</strong>。</p>
<blockquote>
<p>数据规格化指对数据的规范化处理。有些情况下，为了能正确地真正反映实际情况，必须对原始数据进行加工处理，使之规范化。数据经过规格化后其计算结果与未经规格化的计算结果差别较大。这是由于相似系数取决于坐标原点的位置。在规格化后，坐标原点移动了，使样品之间的夹角改变很大。</p>
<p>——摘自<a href="https://baike.baidu.com/item/数据规格化/610954" target="_blank" rel="noopener">百度百科【数据规格化】</a></p>
</blockquote>
<p>听到这里，你的<code>DNA</code>应该有反应了。没错，就是</p>
<script type="math/tex; mode=display">若X\sim N(\mu,\sigma^2),那么Y=\frac{X-\mu}{\sigma}\sim N(0,1)</script><p>之前我们在做题的时候都是二话不说先化为标准正态分布，实际上这么做就是为了<strong>数据规格化</strong>。</p>
<p>而对于不同分布的数据我们则是尽可能地转化为统一的分布，这个分布多半选择<strong>正态分布</strong>，因为正态分布有非常多便于统计运算的性质。</p>
<p>正因为数据的无量纲化之后能够将数据变为更为规范的、标准的数据集，所以往往在进行机器学习的时候为了能够更快地收敛、在更短的时间内给出更精确的结果，无量纲化也是重要的一步。当然，也可以跳过，这都看原数据的质量了。</p>
<h2 id="无量纲化的意义"><a href="#无量纲化的意义" class="headerlink" title="无量纲化的意义"></a>无量纲化的意义</h2><blockquote>
<p>机器学习和数据挖掘中所使用的数据，永远不可能是完美的。很多特征，对于分析和建模来说意义非凡，但对于实际收集数据的人却不是如此，因此数据挖掘之中，常常会有重要的字段缺失值很多，但又不能舍弃字段的情况。因此，数据预处理中非常重要的一项就是处理缺失值。</p>
<p>——摘自<a href="https://blog.csdn.net/weixin_36325602/article/details/104134462" target="_blank" rel="noopener">CSDN用户AI_Engine：数据无量纲化</a></p>
</blockquote>
<p>听起来像极了对账的时候各种奇葩漏账、错别字的样子，不是么？机器面对这样一大批乱七八糟的东西也是一样的。“这TM是啥？”“那TM又是啥？”然后稀里糊涂给了个让你情不自禁说出“这TM什么鬼”的结果。</p>
<p>听起来还是有点不太明白？举个例子。</p>
<p>你想给你的小猫娘科普中国四大名著。但是很可惜，在使用电脑准备文案的时候，你把<strong>水浒传</strong>打成了<strong>水许传</strong>。最绝望的是，你的小猫娘学会了。可以想象，你的小猫娘蹦蹦跳跳的跑到别人面前大声喊出“水许传”的时候，你会有多尴尬。</p>
<p>机器学习也是一样的，要是有个错误的数据，完全不会自己思考的机器就会把这个当作正确答案进行进一步的运算，然后得出一个错误的结果。像极了<strong>计算出老奶奶的速度是60km/h</strong>的小学生。</p>
<p><img src="https://sakebow.gitee.io/images/emoji/60码的老奶奶.jpg" alt="计算错误就只好以60码的速度行走的老奶奶" height="350"></p>
<p>当然，除了纠错补全，无量纲化还能够使用正态分布的许多种特性进行新的分析。例如：</p>
<script type="math/tex; mode=display">若X\sim N(0,1),则
\left\{
\begin{matrix}
  EX&=&0\\
  DX&=&1\\
\end{matrix}
\right.</script><p>不仅如此，我们还能够通过查表的方式确定当前服从正态分布的变量对应了多少概率，就像我们高中非常熟悉的$P(-\sigma+\mu&lt;X&lt;+\sigma+\mu)=0.6826$等等。更进一步，我们还能够使用正态分布所引出的其他分布来进行更多的数学分析，就像是考研过程中被折磨了无数遍的$F(m,n)=\frac{n\sum^m_{i=1}x^2}{m\sum^n_{i=1}y^2}$等。</p>
<p>是不是有点能理解了？</p>
]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>特征工程</tag>
      </tags>
  </entry>
  <entry>
    <title>滑动窗口在机器学习中的运用</title>
    <url>/2020/11/13/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E8%BF%90%E7%94%A8/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>如果接触过计算机网络中的<code>TCP/IP</code>协议的话，你可能会对滑动窗口比较熟悉。那么滑动窗口到底是什么原理？在机器学习中又是如何运用？</strong></p>
<a id="more"></a>
<h2 id="计算机网络的滑动窗口复习"><a href="#计算机网络的滑动窗口复习" class="headerlink" title="计算机网络的滑动窗口复习"></a>计算机网络的滑动窗口复习</h2><p>在计算机网络中，滑动窗口的主要目的是<strong>流量控制</strong>，也就是为了处理网络拥塞的情况。对于拥塞，有三种不同策略的滑动窗口，分别是：<strong>停止等待</strong>、<strong>后退N帧</strong>、<strong>选择重传</strong>。这些就不一一展开了，因为我们主要介绍的不是这个，详情请回忆本科时候学习的计算机网络。</p>
<h2 id="滑动窗口的原理"><a href="#滑动窗口的原理" class="headerlink" title="滑动窗口的原理"></a>滑动窗口的原理</h2><p>滑动窗口就像是一张解密卡，中间的可以透光的部分可以让我们看到卡片的后面。</p>
<p><img src="https://sakebow.gitee.io/images/机器学习/解密卡.jpeg" alt="解密卡"></p>
<p><del>嗯……是不是暴露年龄了？</del></p>
<p>如果你恰好有很大一堆需要解密的数据，你就会用这张解密卡从左到右移动，逐渐解开所有的谜题。</p>
<p>这就是滑动窗口的原理。因为是每走一步分析一次，所以滑动窗口对时序数据的分析有着非常大的作用。如果只是单纯的分段分析，有可能会刚刚好忽略了转折点，最终就没能得到较好的结果。</p>
<h2 id="滑动窗口的应用"><a href="#滑动窗口的应用" class="headerlink" title="滑动窗口的应用"></a>滑动窗口的应用</h2><p>正因为滑动窗口对于时序数据的优势，所以滑动窗口将来会更多的应用在涉及时序数据的分析中，比如股票随着时间的变化、脑网络中随时间变化的活动情况、电网中各类传感器数据随时间变化的情况等等。</p>
<p>到了现在这个“充分挖掘数据价值”的时代中，单一时间片的数据已经远远不够价值地体现了，需要大量的、多个时间维度的分析与评价，最终联系多个时间段的实际情况对实验结果的影响最终得出可能的结论。</p>
<p>听不懂没关系，还是一如既往的小例子。</p>
<p>你的小猫娘<strong>并不是一成不变的</strong>。她再怎么说也是有懵懂期、好动期、叛逆期<del>和发情期</del>等等，每个阶段都有不同的心理和生理活动，所以想要理解你的小猫娘的话，要是一直将你的小猫娘固定在让你最快乐的那个时段中，最终对小猫娘的理解<strong>一定是片面的</strong>。而若是动态地分析，不停地按照一定的步长分析每个时段的小猫娘，在保证考虑新时段和旧时段的联系的同时，还要使用相对较长的步长来避免你对过去的小猫娘的不舍。这样最终对小猫娘的理解也会<strong>相对来说更为全面</strong>。</p>
<p>这也就是滑动窗口想要解决的问题。一次只看一小部分，但是每个部分都有相关联的地方，不至于完全隔断，也不至于过度分析。</p>
<h2 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h2><p>滑动窗口虽然是能够让我们看到相对来说更为连续的数据，但是窗口毕竟是窗口，<strong>并不能帮助分析</strong>。窗口的实质只不过是使用狭窄的边框<strong>屏蔽掉</strong>整个数据的其他部分，从而让我们更<strong>好地专注</strong>于整个数据中的一小部分连续的数据。真正的分析还是得使用能够分析数据的机器学习算法，比如<strong>降维</strong>的<code>TSNE</code>、<strong>分类</strong>的随机森林、<strong>预测</strong>的回归分析等等。</p>
]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>算法模型</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows下使用Docker搭建GitLab服务器</title>
    <url>/2020/11/10/%E8%BF%90%E7%BB%B4/docker/Windows%E4%B8%8B%E4%BD%BF%E7%94%A8Docker%E6%90%AD%E5%BB%BAGitLab%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>也不是所有的公司都崇尚<code>Linux</code>哲学，也有非常多的公司热衷于使用<code>Windows</code>当作服务器。所以这里介绍一下在如何在<code>Windows</code>下使用<code>Docker</code>搭建<code>GitLab</code>。</strong></p>
<a id="more"></a>
<h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装<code>Docker</code></h2><p>安装包：<a href="https://pan.baidu.com/s/1Ek_Z4LOAV80Pf2V4FKFs2Q" target="_blank" rel="noopener">提取码：ary4</a></p>
<p>在<code>Windows</code>下安装<code>Docker</code>就非常难受了，需要解决非常多的约束。</p>
<h3 id="系统更新"><a href="#系统更新" class="headerlink" title="系统更新"></a>系统更新</h3><p>有些人非常讨厌更新所以使用一些脚本把更新关掉了。但是人家<code>Docker</code>必须要更新才能安装，你气不气嘛。</p>
<p>如果你是<code>Windows10</code>，在“更新和安全”$\rightarrow$“<code>Windows</code>更新”，在里面找到“检查更新”按钮，点击即可。到最后，会提示你重启以应用更新。当然，你可以选择现在重启，但是我们推荐把下面的步骤做完之后再更新。</p>
<h3 id="添加“适用于Linux的Windows子系统”"><a href="#添加“适用于Linux的Windows子系统”" class="headerlink" title="添加“适用于Linux的Windows子系统”"></a>添加“适用于<code>Linux</code>的<code>Windows</code>子系统”</h3><p>在编辑这篇博客的时候，<code>Docker</code>已经出道了2.5.0，所以需要这样的设置。</p>
<p>打开“控制面板”$\rightarrow$“程序”$\rightarrow$“程序和功能”$\rightarrow$“启用或关闭<code>Windows</code>功能”$\rightarrow$“适用于<code>Linux</code>的<code>Windows</code>子系统”（最下方倒数第三个），勾选，然后点击“确定”。</p>
<p><img src="https://sakebow.gitee.io/images/SpringCloud/安装WSL.png" alt="操作截图"></p>
<p>接着<code>Windows</code>就能够帮你下载这些东西。等待完成之后，系统会提示需要重启，重启之后就应用了更改。这个时候重启吧，但是别忘了，在开机之前还有一点点事情要做。</p>
<h3 id="VT开启"><a href="#VT开启" class="headerlink" title="VT开启"></a><code>VT</code>开启</h3><p>你的<code>Windows</code>需要开启<code>virtual technology</code>，也就是<strong>虚拟化</strong>，打游戏的时候经常要开启的那个。有些主板可能比较难找，但一定会有，实在找不到去问问度娘吧，主办版本太多了也没办法一一说明。</p>
<h3 id="结束？"><a href="#结束？" class="headerlink" title="结束？"></a>结束？</h3><p><strong>试着打开<code>Docker Desktop</code>的安装包吧！</strong></p>
<p>看到这里是不是以为马上就要结束了？<strong>当然没有</strong>。只不过往后的步骤有提示而已，别担心啦。</p>
<p>打开安装包之后，他会提示：需要安装<code>Linux</code>内核以支持<code>Docker</code>的运行。这里她也非常贴心的给出了链接，点进去下载就好了。</p>
<p>这里我也给出我自己已经下载好的吧：<a href="https://pan.baidu.com/s/1TALJ76QmVgm0VrumzDkUQw" target="_blank" rel="noopener">提取码：14m1</a></p>
<p>下载好了之后安装，这个过程是不会让你选择路径的。因为安装包不大，所以也没什么影响，放心安装。</p>
<p>等全部安装完之后，就可以真正意义上打开<code>Docker Desktop</code>的安装包了。</p>
<p>之后便是等待安装结束。<code>Docker</code>安装文件给的提示是注销用户再重新登录即可，可能使用<code>Linux</code>的人比较习惯这种操作。不过呢，既然是傻瓜式的<code>Windows</code>，直接重启计算机就好了。（<em>仅限开机较快的同学</em>）</p>
<p>到这里，就能够打开<code>Docker Desktop</code>正常使用了。</p>
<h2 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h2><p>在<code>Linux</code>系统中，直接修改<code>/etc/docker/daemon.json</code>就够了。但是<code>Windows</code>系统中可没有这个。所以直接打开任务栏中的<code>Docker</code>，按照下图步骤进行设置</p>
<p><img src="https://sakebow.gitee.io/images/SpringCloud/Windows的docker换源.png" alt="Docker界面"></p>
<p>其中国内源可以选择：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Docker国内镜像源</span></span><br><span class="line">https://registry.docker-cn.com</span><br><span class="line"><span class="meta">#</span><span class="bash"> 网易Docker源</span></span><br><span class="line">http://hub-mirror.c.163.com</span><br></pre></td></tr></table></figure>
<p>当然你还可以选择阿里云的私人镜像站，都是非常不错的。这里就不一一介绍了。</p>
<p>最后，安装一下<code>Git</code>客户端吧。在<code>Windows</code>上如果不进行任何配置的话，只能使用<code>Git Bash</code>。但是考虑到<code>GitLab</code>一定要用到<code>Git</code>客户端，所以也就安装了算了吧。</p>
<p>国内的话更推荐使用<a href="http://npm.taobao.org/mirrors/git-for-windows/v2.29.2.windows.2/" target="_blank" rel="noopener">淘宝的Git-2.29.2.2镜像</a>。</p>
<p>就是这样啦。接下来我们开始搭建<code>GitLab</code>。</p>
<p>打开命令行（实际上是<code>Git</code>客户端），输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull twang2218/gitlab-ce-zh # 拉取镜像</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">下载时间很长，我们趁下载的时间准备`docker-compose.yml`：</span><br><span class="line"></span><br><span class="line">```yml</span><br><span class="line">version: '3' # 版本号</span><br><span class="line">services: # 开启服务</span><br><span class="line">  gitlab: # 服务名称</span><br><span class="line">    image: 'twang2218/gitlab-ce-zh:latest' # 使用镜像</span><br><span class="line">    restart: always</span><br><span class="line">    hostname: 'GitLab' # 主机名称（自定义）</span><br><span class="line">    environment: # 环境配置</span><br><span class="line">      TZ: 'Asia/Shanghai'</span><br><span class="line">      GITLAB_OMNIBUS_CONFIG: |</span><br><span class="line">        external_url 'http://192.168.1.112:8080'</span><br><span class="line">        gitlab_rails['gitlab_shell_ssh_port'] = 4022</span><br><span class="line">        unicorn['port'] = 8888</span><br><span class="line">        nginx['listen_port'] = 8080</span><br><span class="line">    ports: # 端口映射，格式为“本机IP：Docker镜像内部IP”</span><br><span class="line">      - '1080:8080'</span><br><span class="line">      - '1043:8443'</span><br><span class="line">      - '1022:22'</span><br><span class="line">    volumes: # 挂载卷</span><br><span class="line">      # 前面是Windows的地址所以斜杠向右；后面是Linux的地址所以向左</span><br><span class="line">      - D:\codes\docker\gitlab\config:/etc/gitlab</span><br><span class="line">      - D:\codes\docker\gitlab\data:/var/opt/gitlab</span><br><span class="line">      - D:\codes\docker\gitlab\logs:/var/log/gitlab</span><br></pre></td></tr></table></figure>
<p>粘贴后记得保存哦。</p>
<p>等拉取完毕后，运行命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose up -d # 以后台进程的方式运行容器</span><br></pre></td></tr></table></figure>
<p>于是，<code>GitLab</code>就能够跑起来了。短暂地等待之后，使用“本机IP：端口号”的形式访问网站就好了。比如说我设置之后就可以使用：<code>http://10.33.76.59:1080</code>进入<code>GitLab</code>网站。</p>
<p>如果你有看过我之前写的<a href="/2020/07/08/Java/SpringCloud/版本控制的另一种打开方式/">版本控制的另一种打开方式</a>，那么你对上述的过程应该很熟悉。但是在<code>Windows</code>下有所不同的是，在进入容器内的时候并不能使用<code>/bin/bash</code>，因为<code>Windows</code>系统压根就没有这个地址。</p>
<p>所以只能使用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it $&#123;docker-container-id&#125; bash</span><br></pre></td></tr></table></figure>
<p>也就是将<code>/bin/bash</code>更换为<code>bash</code>。</p>
<p>这下就能进去了。剩下的改密码、创建什么的都和之前<a href="/2020/07/08/Java/SpringCloud/版本控制的另一种打开方式/">版本控制的另一种打开方式</a>一模一样了。</p>
<p>是不是有点懂了呢？</p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>从面向对象来看静态绑定和动态绑定</title>
    <url>/2020/11/02/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E4%BB%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%9D%A5%E7%9C%8B%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E5%92%8C%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>这个部分是相当底层的知识，不涉及实际编程，可能会有些枯燥。</strong></p>
<a id="more"></a>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>所谓<strong>绑定</strong>，就是<strong>将方法与其所在的对象或者类关联起</strong>来。</p>
<p><strong>静态绑定</strong>，或者有人比较喜欢称为<strong>前期绑定</strong>，意思是<strong>在执行之前就已经明确了什么方法属于什么类或者对象</strong>。</p>
<p><strong>动态绑定</strong>，或者有人比较喜欢称为<strong>后期绑定</strong>，意思是<strong>在执行的时候根据具体的实例化对象绑定对应的方法</strong>。</p>
<p>听起来很绕？来看看这些个例子。</p>
<h2 id="类比说明静态绑定和动态绑定"><a href="#类比说明静态绑定和动态绑定" class="headerlink" title="类比说明静态绑定和动态绑定"></a>类比说明静态绑定和动态绑定</h2><p>有一天，你家里多了一只猫娘。先不管你是怎么得到的吧，总之就在你家了。于是，在这个时候，这只猫娘就和你<strong>绑定</strong>了。</p>
<p>由于家里人就你天天陪着她，她也就每天粘着你。不久之后，你就和这只猫娘<strong>静态绑定</strong>了。有人来看看你和你的猫娘的时候，一看到那只怯生生的猫娘躲在你背后，就知道：啊，这只小猫娘粘上你了呐。</p>
<p>但是呢，眼看着小猫娘一天天长大，总不能一直都在家里吧？。你的猫娘也凭自己的努力得到了一个小铃铛（<del><em>串戏了啊喂</em></del>），你就带着她出去转转了。路上碰到了一个警察，警察看到你的猫娘上有一只铃铛，就把猫娘和你一起<strong>动态绑定</strong>了。只有在你出门之后，警察才会将你和你的小猫娘通过一只铃铛进行绑定。</p>
<h2 id="从面向对象来看静态绑定和动态绑定"><a href="#从面向对象来看静态绑定和动态绑定" class="headerlink" title="从面向对象来看静态绑定和动态绑定"></a>从面向对象来看静态绑定和动态绑定</h2><p>辣么，在面向对象编程中，动态绑定和静态绑定又是什么呢？拿<code>Java</code>来说吧。</p>
<p>我们在创建<code>utils</code>包的时候会封装一些静态类作为项目必须的工具类。其中必定会使用<code>private</code>、<code>final</code>、<code>static</code>等来修饰字段或者方法。这些就是<strong>静态绑定</strong>，在一开始就直接知道了这些个方法和字段就是这个工具类的一部分。</p>
<p>另外，在声明<code>entity</code>包中的各种映射实体类的时候，我们会使用<code>public</code>来修饰，其中的各种方法也是<code>public</code>方法。这种在运行之中<code>JVM</code>也并不清楚这到底是谁的方法，而是在产生各种中间件的时候发现这些个方法是属于这个类的。这就是<strong>动态绑定</strong>。</p>
<p><strong>动态绑定</strong>实际上是将<strong>可执行的方法</strong>和<strong>生成的对象</strong>进行绑定，所以仅发生在程序执行过程中；<strong>静态绑定</strong>则是将<strong>不可被继承</strong>或者<strong>不可被覆盖</strong>的方法和原类进行版绑定。</p>
<h2 id="给实际编程所带来的影响"><a href="#给实际编程所带来的影响" class="headerlink" title="给实际编程所带来的影响"></a>给实际编程所带来的影响</h2><p>可以肯定的是，无论是什么语言，动态绑定永远都比静态绑定耗时较长。拿<code>Java</code>来看，<code>JVM</code>需要消耗一点时间将创建过后的对象和方法对应起来实现动态绑定，而静态绑定则是已经确认了谁和谁本来就应该在一起。所以，如果是使用非常频繁的工具类，我们可以考虑使用静态方法，这样就能够进行静态绑定，这样运行起来会稍微快一点点。（<del><em>虽然一直做<code>CRUD</code>的<code>API</code>调用工程师也接触不到这些内容啦</em></del>）</p>
<p>是不是有点能理解了呢？</p>
]]></content>
      <categories>
        <category>软件开发建模</category>
      </categories>
      <tags>
        <tag>软件项目管理</tag>
      </tags>
  </entry>
  <entry>
    <title>用例图：不是面向对象的面向对象设计概念图</title>
    <url>/2020/11/02/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E7%94%A8%E4%BE%8B%E5%9B%BE%EF%BC%9A%E4%B8%8D%E6%98%AF%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E6%A6%82%E5%BF%B5%E5%9B%BE/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>相信经历软考的人都应当对最后的几个大题的图傻傻分不清楚。别害怕，还有更猛的，把你锤在地上爬都爬不起来。</strong></p>
<a id="more"></a>
<h2 id="用例图简介"><a href="#用例图简介" class="headerlink" title="用例图简介"></a>用例图简介</h2><p>用例图是什么？这个只能通过死记硬背来对应起来。这玩意怎么记呢？既然是用例图，那肯定就是在说<strong>什么对象在使用什么操作</strong>。听起来很有面向对象的那味儿了，不是么？</p>
<blockquote>
<p><img src="https://sakebow.gitee.io/images/软件工程/用例图.png" alt="这是一个用例图的例子"></p>
<p>——摘自<a href="https://baike.baidu.com/item/用例图/9531932" target="_blank" rel="noopener">百度百科【用例图】</a></p>
</blockquote>
<p>来看看上面这张图，这种就是用例图（<del>虽然并不标准</del>）。</p>
<p>可以看到，教师拥有“录入成绩”、“修改成绩”、“查询成绩”、“删除成绩”、“登录”五大功能，同时附赠一个“找回密码”的小功能，而且“录入成绩”、“修改成绩”这两个大功能共用一个“保存成绩”的小功能；学生就只有“查询成绩”、“登录”和附赠的“找回密码”。</p>
<p>可以看到，这张用例图清晰地表示了<strong>哪个角色能够使用哪些功能</strong>，而<strong>哪些功能中包含或者拓展哪些小功能</strong>。</p>
<p>是不是觉得这个系统应该怎么规划都想得很清楚了？是不是觉得现在开始编码随便写写就能出来了？没错，用例图就是这么简单直接所以才能够普及。</p>
<p>顺便说明一下，用例图时需要明确标明系统边界的，所以标准的画法应当是在所有功能外画一个大边框，表示这是系统的边界；与此同时还需要在边框旁边标明这个是什么系统。</p>
<h2 id="面向对象？很可惜不是"><a href="#面向对象？很可惜不是" class="headerlink" title="面向对象？很可惜不是"></a>面向对象？很可惜不是</h2><p>什么是<strong>面向对象</strong>？<strong>每一个类所实例化的对象都有与之对应的属性来描述对象的特征，并且还有成员函数来描述对象的行为</strong>。<strong>类</strong>又是什么？是<strong>属性和操作的封装体</strong>；<strong>对象</strong>是什么？是<strong>类的实例</strong>。</p>
<p>可是用例图有吗？<strong>当然没有</strong>。</p>
<p>回看我们刚刚的例子，用例图<strong>只包含若干个执行者和执行者所对应的操作</strong>。这算哪门子面向对象嘛。</p>
<p>但是也正因为用例图屏蔽了面向对象中很多的细节，删去了属性、不必要的成员函数乃至对象之间的关系，所以反而<strong>传达了更精确的面向对象概念</strong>。</p>
<p>挺可笑的不是嘛。</p>
]]></content>
      <categories>
        <category>软件开发建模</category>
      </categories>
      <tags>
        <tag>软件项目管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Python的最火框架：Django</title>
    <url>/2020/11/01/python/Django/Python%E7%9A%84%E6%9C%80%E7%81%AB%E6%A1%86%E6%9E%B6%EF%BC%9ADjango/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>你可能是一个<code>Java</code>工程师，你还可能想和<code>SpringBoot</code>比划比划。但是呢，<code>Django</code>在<code>SSM</code>时代确实是配置少、功能强。</strong></p>
<a id="more"></a>
<h2 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h2><p>虽然说有人觉得<code>Python</code>比<code>Java</code>更强，但现在<code>SpringBoot</code>框架发展起来了之后，<code>Django</code>的少配置就不怎么少了；<code>SpringCloud</code>框架发展起来之后，<code>Java</code>现在的生态就已经超过<code>Python</code>了。期待<code>Python</code>的后期发力吧。如果你希望在<code>Web</code>开发上有所建树，现在的企业级开发框架基本上已经统一为<code>SpringCloud</code>了。如果你的研究方向就是<code>PythonWeb</code>，那么这篇文章应该会对你有一点点小小的帮助。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>当还在<code>SSM</code>时代，<code>JavaWeb</code>编程依然是一大堆的<code>xml</code>配置文件和很多的<code>properties</code>配置的时候，<code>Django</code>作为一种配置少，而且是<strong>传说中</strong>的“垃圾回收机制比<code>Java</code>强几倍”而且“运行速度快几倍”的<code>Python</code>语言构造的<code>Web</code>框架，并且生态和集成度都比<code>Flask</code>好，所以广受好评。</p>
<p>广受好评了之后，就必然是社区的大力支持。现在<code>Django</code>的社区提供的各种方便的、易集成的库已经远超<code>Flask</code>了。而且，<strong>据说</strong>，<code>SpringBoot</code>往往在编写的时候一不小心就会从小型练手项目升级为中小型企业及解决方案，因为包括权限管理、安全认证和防火墙等等生态已经非常完善了，而且集成还非常容易；而<code>Django</code>并不会，练手就是练手，不会突然升级为中小型企业级解决方案。</p>
<p>不过呢，既然是<code>Web</code>开发，所以很多内容实际上和<code>Java</code>是相通的。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><code>Python</code>安装库和<code>NodeJS</code>类似，直接使用命令安装：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用Python3自带的Pip3工具安装工具库</span></span><br><span class="line">pip3 install django <span class="comment"># 使用pip安装django</span></span><br><span class="line">python3 -m django --version <span class="comment"># 查看django版本</span></span><br><span class="line"><span class="comment"># 显示版本就是安装成功</span></span><br><span class="line"><span class="comment"># 在写这篇博客的时候最新的版本是3.1.3，所以理应在执行后显示“3.1.3”</span></span><br></pre></td></tr></table></figure>
<p>方便吧？</p>
<p>辣么，我们直接开始吧。</p>
]]></content>
      <categories>
        <category>PythonWeb</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>证据理论：真相永远只有一个</title>
    <url>/2020/11/01/%E7%94%B5%E7%BD%91%E7%A0%94%E7%A9%B6/%E8%AF%81%E6%8D%AE%E7%90%86%E8%AE%BA%EF%BC%9A%E7%9C%9F%E7%9B%B8%E6%B0%B8%E8%BF%9C%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>本教程主要参考来自<a href="https://www.bilibili.com/video/BV1hV41117ca/" target="_blank" rel="noopener">B站的【人工智能教程】5.4 - 证据理论</a>视频，在这之上还加入了其他的博客、论文以及针对个人研究方向的见解。</strong></p>
<a id="more"></a>
<h2 id="侦探剧？不，是统计学！"><a href="#侦探剧？不，是统计学！" class="headerlink" title="侦探剧？不，是统计学！"></a>侦探剧？不，是统计学！</h2><p>证据理论，英文全拼其实不重要，反正也很少人说。但是他还有个别称，叫做“<strong><code>DS</code>理论</strong>”。这个名称在各种论文中出现的频率非常的高，因为是新单词，所以被当作高端词汇滥用了（<em>捂脸</em>）</p>
<p>那么，为什么说这个是<strong>统计学</strong>？</p>
<p>我们先来假设这样一个场景：</p>
<p>有一天，你带着你的小猫娘上街去玩。本来走着好好的，突然小猫娘在一家冰淇淋车面前停下来了。你看着她那期待的眼神和流口水的小嘴巴，实在不忍心拉着她快速离开，于是你顺着她的眼神瞟过去，发现了很大一张菜单，不仅有不知所云的名字，还有非常诱人的效果图。菜单上有三样：仰望星空、蓝海默默和冰の爱恋。</p>
<p>好嘛，买嘛。那么她看中的是哪一个呢？名字完全不知所云，估计直接问也不会有结果。那就猜吧！于是，你的脑海中有这么些个结果：（<em>结果以集合形式呈现</em>）</p>
<ul>
<li>{仰望星空}</li>
<li>{蓝海默默}</li>
<li>{冰の爱恋}</li>
<li>{仰望星空，蓝海默默}</li>
<li>{仰望星空，冰の爱恋}</li>
<li>{蓝海默默，冰の爱恋}</li>
<li>{仰望星空，蓝海默默，冰の爱恋}</li>
<li>{不想吃，被五颜六色的图片吸引了}</li>
</ul>
<p>嗯……接下来就是该选什么了。我作为她的主人，多少还是了解她的喜好的。于是我又开始对每个选项赋予一定的概率：</p>
<ul>
<li>{仰望星空} - 25%</li>
<li>{蓝海默默} - 20%</li>
<li>{冰の爱恋} - 15%</li>
<li>{仰望星空，蓝海默默} - 18%</li>
<li>{仰望星空，冰の爱恋} - 13%</li>
<li>{蓝海默默，冰の爱恋} - 8%</li>
<li>{仰望星空，蓝海默默，冰の爱恋} - 1%</li>
<li>{不想吃，被五颜六色的图片吸引了} - 0%</li>
</ul>
<p>你知道，小猫娘对很神秘的名字是没有任何抵抗力的。所以你觉得“仰望星空”应该是分数最高的；另外，小猫娘还吃不完两个冰淇淋，所以不太可能买两个。难道是今天突然懂事了想给你也买一个？三个那就更离谱了，不想吃是绝对不可能的……呜哇，口水都滴到地上了啊……</p>
<p>怎么办，好像“仰望星空”这一款是最有希望的。算了，点了。你的小猫看起来很开心。</p>
<h2 id="背后的统计学原理"><a href="#背后的统计学原理" class="headerlink" title="背后的统计学原理"></a>背后的统计学原理</h2><p>那么我们来分析一下，我们这么选的真正原因。</p>
<p>小猫娘看到了三个冰淇淋，那就是三个选项。对于这三个选项，我们能够生成一共$2^3=8$种子集，分别是空集$1$个、单元素集合$3$个、双元素集合$3$个、三元素集合$1个$。</p>
<p>为了方便说明，我们记这$8$个选项为$\Omega$，每一个选项都有一个概率值，我们可以将这个选项和概率之间的关系称作一种“映射”，也就是将它视为函数：$p_i = f(x_i)\in(0, 1), x_i\in\Omega$。这个可以说是根据周边什么信息推理出来的或主观或客观的评价概率。在冰淇淋这个情境中，你心中的$8$个选项对应的概率值就是你的<strong>主观</strong>考虑，如果说是像娃娃机一样设定好的概率那就是<strong>客观</strong>的了。当然，这个概率不是说我们想怎么定义就怎么定义的，而是遵循这些条件：</p>
<script type="math/tex; mode=display">\left\{\begin{matrix}
  f(\phi) &= &0 &\cdots &❶\\
  \sum_{x_i\in\Omega}f(x_i) &= &1 &\cdots &❷
\end{matrix}\right.</script><p>其实总接下来就是两项：</p>
<ul>
<li>空集无概率</li>
<li>其余和为$1$</li>
</ul>
<p>如果同时满足这两个条件，$f(x)$才能够被称作<strong>概率分配函数</strong>，因为恰好完全分配了。</p>
<p>当然，我们这里的$x$实际上表示一个对象，也就是说，$x$包含了这个对象所有的条件集。有时候我们也写为矩阵形式$\sum_{A\subseteq\Omega}f(A)=1$。而其中的$f(A)$也就是当前环境下对假设集$A$的信任程度。也就是你认为$A$中的条件是不是真的能够成立，成立的概率应该是多少。</p>
<h2 id="证据成立概率的上限和下限"><a href="#证据成立概率的上限和下限" class="headerlink" title="证据成立概率的上限和下限"></a>证据成立概率的上限和下限</h2><p>到这里，相信大家应该对<code>DS</code>理论有一定的了解了。那么接下来就是纯数学了。</p>
<p>我们刚刚提到$x\in\Omega$，其中如果还加上一个条件：$x$的取值相互独立，那么$\Omega$的所有子集就可以称作幂集，记为$2^\Omega$。也就是像给小猫娘麦冰淇淋一样，只能是$8$种相互独立的可能；而如果说是两只双胞胎猫娘，姐姐选了之后妹妹选同样的冰淇淋概率非常高，这就是对另一种可能产生了影响，也就不相互独立。</p>
<p>如果说，$A$代表单元素集合，那么$f(A)$就是对于假设条件$A$的精确信任度；如果$A$代表多元素集合，$f(A)$则仅代表整体信任度，每个假设条件的信任度并不精确，若$A=\Omega$也是同样的。对于这一点，我们用数学语言表示就是：</p>
<script type="math/tex; mode=display">对于任意的A\subseteq\Omega，记B\subseteq{A}，有Bel(A)=\sum_{B\subseteq A}f(B)</script><p>听起来绕口？无所谓啦。总之这句话的意思就是：当$A$为多元素集合的时候，记$Bel(A)$为$A$中<strong>所有子集</strong>的精确信任度之和。这个$Bel(A)$也可以称作<strong>下限函数</strong>。</p>
<p>除了这些，还有<strong>似然函数</strong>，同样是在集合$A$是幂集的前提下，具体表示为：</p>
<script type="math/tex; mode=display">对于\forall A\subseteq\Omega，s.t.\rightarrow Pl(A)=1-Bel(\bar{A})，其中\bar{A}=\Omega-A</script><p>可以看到，这里多了一个<strong>取反</strong>的操作，所以这里讨论的也就不是集合$A$的精确信任度，而是$A$的<strong>非假信任度</strong>。同样的，相对于被称为<strong>下限函数</strong>的$Bel(A)$，$Pl(A)$也就被称为<strong>上限函数</strong>或者<strong>不可驳斥函数</strong>。听起来很让人摸不着头脑不是么？明明都有了真实的精确信任度，偏偏还要弄个非假的信任度，这不是折腾？</p>
<p>只能说，这是另一种求法，可以用在完全没有办法或者说靠人计算实在太麻烦的情况下。比如，你想带着你家里的所有猫娘出去逛街，但是每只猫娘的性格都不太一样，所以需要确定一个地点<strong>至少有一只猫娘愿意去</strong>。估计算到一半你就觉得太难了。所以改变思路：<strong>没有猫娘愿意去</strong>。听起来很不错？但是，还是有一个小小的弊端。因为我们用这个方法求出来的是<strong>非假信任度</strong>，也就是肯定为真的部分加上只能保证不假的部分的和。虽然绝对可以保证不是假的，但是有多少能确定是真的呢？如果精确部分很难算的话，这就真的一点都不知道了，完全决定不了该带猫娘们去哪。</p>
<p>那么<strong>上下限和现实感觉有什么联系</strong>？只能这么说：当上限$Pl(A)=1$，下限$Bel(A)=0$的时候，我们就会在现实生活中觉得：<strong>我们对这件事一无所知</strong>，因为<strong>任何事</strong>发生的概率都是$[0,1]$。</p>
<p>那么上限和下限有什么关系吗？从<strong>数学</strong>上来说，有的。信任函数和似然函数有以下几点性质：</p>
<script type="math/tex; mode=display">\left\{\begin{matrix}
  Bel(\phi) &= &Pl(\phi) &= &0 \\
  Bel(\Omega) &= &Pl(\Omega) &= &1\\
\end{matrix}\right.</script><script type="math/tex; mode=display">若有A\subseteq B，则有\left\{\begin{matrix}
  Bel(A) &\leq &Bel(B)\\
  Pl(A) &\leq &Pl(B)
\end{matrix}\right.</script><script type="math/tex; mode=display">对于\forall A\subseteq\Omega，s.t.：\left\{\begin{matrix}
  Pl(A) &\ge &Bel(A)\\
  Pl(A)+Pl(\bar{A}) &\ge &1\\
  Bel(A)+Bel(\bar{A}) &\le &1
\end{matrix}\right.</script><h2 id="证据组合"><a href="#证据组合" class="headerlink" title="证据组合"></a>证据组合</h2><p>单个证据基本上就是这些了。接下来难度升级：多个证据组合。</p>
<p>对于两个不同的概率分配函数$f(x)$和$g(x)$，正交和$h(x)=f(x)\bigoplus g(x)$满足：</p>
<script type="math/tex; mode=display">\left\{\begin{matrix}
  h(\phi) &= &0\\
  h(A) &= &\frac{\sum_{x\cap y=A}f(x)\times g(y)}{1-\sum_{x\cap y=\phi}f(x)\times g(y)} &= &\frac{\sum_{x\cap y=A}f(x)\times g(y)}{\sum_{x\cap y\neq\phi}f(x)\times g(x)}
\end{matrix}\right.</script><p>看起来头大？只能死记硬背了。我们唯一能做的就是把$h(A)$的分母提取出来：</p>
<script type="math/tex; mode=display">K=1-\sum_{x\cap y=\phi}f(x)\times g(y)=\sum_{x\cap y\neq\phi}f(x)\times g(x)</script><p>对于这个$K$，我们还有一个小小的判定：</p>
<script type="math/tex; mode=display">\left\{\begin{matrix}
  if &K &\neq &0，then：&正交和h(x)也是概率分布函数\\
  if &K &= &0，then：&h(x)不存在，f(x)与g(x)矛盾
\end{matrix}\right.</script><p>这个在多个条件下的混合判定更有用。</p>
<p>拿视频中的例子说明吧。你现在正流鼻涕，眼睛还有点点红。于是你问了你的医生朋友，说道：</p>
<ul>
<li>如果流鼻涕，九成会是感冒但不是过敏性鼻炎；</li>
<li>如果眼睛红了，八成会是过敏性鼻炎而不是感冒。</li>
</ul>
<p>这就是<strong>规则</strong>。那么你的情况就是这样的，也就是<strong>样本空间</strong>：</p>
<ul>
<li>{没病} - 也就是我们所说的空集$\phi$</li>
<li>{感冒}</li>
<li>{过敏性鼻炎}</li>
<li>{又是感冒又是过敏性鼻炎}</li>
</ul>
<p>于是，你将每一块都拉出来分析，最终发现你<strong>就是感冒</strong>，<strong>不是过敏性鼻炎</strong>。</p>
<h2 id="证据理论在电网中的应用"><a href="#证据理论在电网中的应用" class="headerlink" title="证据理论在电网中的应用"></a>证据理论在电网中的应用</h2><p>说了这么多，就该说说实际中的应用了吧。</p>
<p>说白了，证据理论依然是使用非常多的机器学习算法对海量的用户数据进行分析，并作出分类与预测这两个动作，本质上依然是一种机器学习。</p>
<p>实际中，我们可以使用证据理论预判哪条路在什么时候容易堵车、哪些设备在经过怎么样的使用之后会在什么时候损毁，甚至还能够进行心理预测、军事战场动向、信息安全主动防御等等。如果你曾经看过我的<a href="/2020/10/28/电网研究/态势感知：我预判了你的预判！">态势感知</a>，你会发现这些应用方向和态势感知的内容<strong>重复率相当高</strong>。实际上态势感知只是一个方向，而<code>DS</code>理论则是一个<strong>相对比较实际的方法</strong>来感知事物的态势。</p>
<p>那么在电网中呢？我们可以使用证据理论来预判在什么季节哪个小区的用电非常高、哪个片区的故障概率非常高。<strong>在发生停电之前</strong>，我们就能够使用这些预测信息来给用户发送预警，防止用户在洗热水澡、写文档、电压力锅煲羊肉汤的时候突然断电。当然，在信息推送的时候还是要保证<strong>概率下限都足够高</strong>的时候才推送，否则很多误报就会像狼来了一样，让用户丧失信心。</p>
<p>是不是有点能理解了呢？</p>
]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>论文研究</tag>
      </tags>
  </entry>
  <entry>
    <title>态势感知：我预判了你的预判！</title>
    <url>/2020/10/28/%E7%94%B5%E7%BD%91%E7%A0%94%E7%A9%B6/%E6%80%81%E5%8A%BF%E6%84%9F%E7%9F%A5%EF%BC%9A%E6%88%91%E9%A2%84%E5%88%A4%E4%BA%86%E4%BD%A0%E7%9A%84%E9%A2%84%E5%88%A4%EF%BC%81/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>态势感知的英文是<code>Situation Awareness</code>，所以有些情况下也会被简写为<code>SA</code></strong></p>
<a id="more"></a>
<h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>“态势感知”，单单分析这个名词，大概就是“使用某种方法感知态势”。</p>
<blockquote>
<p>态势，即事物发展的形势及状态。</p>
<p>——<a href="https://baike.baidu.com/item/态势/11045952" target="_blank" rel="noopener">百度百科【态势】</a></p>
<p>态势感知是感知大量的时间和空间中的环境要素，理解他们的意义，并预测他们在不久将来的状态</p>
<p>——<a href="https://blog.csdn.net/wyqwilliam/article/details/82596594" target="_blank" rel="noopener">对网络安全态势感知的理解和认识</a></p>
<p>一种不可预测的、多方面情况的不断更新的、有意义的知识，操作人员在参与实时多任务时可以用该知识来指导选择和行动。</p>
<p>——摘自：石乐义,刘佳,朱红强,段鹏飞.网络安全态势感知研究综述[J].计算机工程与应用.2019,55(24):1-9.</p>
</blockquote>
<p>那么也就是说，我们需要<strong>运用某种方法感知事物的发展形势以及状态，而其目的就是预测，并为最终的决策提供参考</strong>。</p>
<p>当然，凭借常人的理解，如果是“<strong>感知</strong>”，那么目的绝对就是<strong>预测</strong>了，也就必然在最后做决定的时候提供参考。但是呢，既然是高端的学术，我们不能这么简单地概括为“<strong>预测</strong>”，我们还应当把周边的其它东西也介绍一下。因为这个<strong>感知</strong>同样是一个小型生态，包括了提取信息、理解信息和预测未来三个方向。接下来我们就开始详细展开这个“<strong>感知</strong>”了。</p>
<blockquote>
<p><img src="https://sakebow.gitee.io/images/电网/JSGG201924002_02800.jpg" alt="态势感知"></p>
<p>——摘自：石乐义,刘佳,朱红强,段鹏飞.网络安全态势感知研究综述[J].计算机工程与应用.2019,55(24):1-9.</p>
</blockquote>
<h2 id="态势感知的子类展开"><a href="#态势感知的子类展开" class="headerlink" title="态势感知的子类展开"></a>态势感知的子类展开</h2><p>态势要素提取，实际上就是收集电网中海量的传感器数据，并使用特定的机器学习算法处理这些数据。在这个部分主要是收集数据，使用报表、日志、第三方数据存储系统等各种各样的方法保存真实数据。这个时候你拿到的无非就是一大堆杂七杂八的文件，还有各式各样的报表，以及乱七八糟的日志。是不是觉得还没开始就头大了？万事开头难嘛（虽然后面也不简单）</p>
<p>态势理解，听起来像是只有人脑才可以做到的数据理解，就像是军事里面的态势理解一样让人琢磨不透。实际上，所谓理解不过是解读数据背后的含义，实际上就是使用机器学习算法对特定的业务数据分析。刚刚我们在要素提取的时候拿到了非常多杂七杂八的数据不是嘛，我们的任务就是在杂七杂八的数据中筛选出和当前研究方向契合度最高的几个变量，然后筛除一些偏差值很大的数据，最终开始使用机器学习算法针对我们研究的方向进行拟合。这个估计就是整个环节中最繁琐的地方了，相当于秘书一样，要把开完会拿到的所有文件整理分类上报。</p>
<p>态势预测，这个词在理解上就相对较容易。顾名思义，态势预测就是预测事物的发展形势。那么，我们在经过了态势要素提取（或者说整体数据的分类）、态势理解（或者说专项数据的进一步分析）之后，我们应该做到了降维、降噪、建模三件事。然后则是套用模型来预测特定条件下的特殊结果，并对以后的决策提供参考。这一步也有人愿意称作“对未来状态的映射”。</p>
<h2 id="举例说明态势感知"><a href="#举例说明态势感知" class="headerlink" title="举例说明态势感知"></a>举例说明态势感知</h2><p>举个简单的例子来说明这整个态势感知的过程吧。</p>
<p>首先，还是你的收集的20万猫娘的数据，给你家的那只小猫娘提供一点点参考。</p>
<p>你凭借着你的热爱，成功找出了20万只猫娘的健康状态和身体情况。在这里，你发现了一些特点，比如健康状况良好的猫娘会有各种各样的表现，无一例外的表现出粘人的特点和对主人的浓厚兴趣；而还有感冒等小病的猫娘则有各种各样的反映，并没有统一的共性。一整套流程下来，我们就得出了一份份文件记录这些猫娘的很多信息。这个过程就是态势要素提取。</p>
<p>当然，你并不满足。于是你针对各种各样的病症开始了各种各样的分析，比方说眼睛红、有气无力、呼吸声音很重等等。虽然这可不是人能够完成的事情，但你还是凭着你的热情，一半人力一半计算机辅助地筛除了一只活到现在都没有得过病的猫娘数据，并得出了关于猫娘生病的一些普适性的公式，也就是症状与病症的映射。这个过程就是态势理解。</p>
<p>最后，你在和你家的小猫娘生活的时候，你发现了小猫娘出现了很类似你之前收集过的某种特征，于是你立马把对照表拿了出来，一一比对。最后，你发现你的小猫娘很可能是患了感冒，于是喂她吃了些对症的药，好好地陪了她一整天。这个过程就是态势预测。</p>
<p>第二天她又生龙活虎的了，粘着你不放。</p>
<h2 id="态势感知的应用"><a href="#态势感知的应用" class="headerlink" title="态势感知的应用"></a>态势感知的应用</h2><p>由于态势感知是从提取，到理解，最后是预测的系统级应用，从过程上来看似乎是“<strong>自上而下</strong>”、“<strong>自顶向下</strong>”的架构。所以，这种技术现阶段往往是规模非常庞大的系统或者是不计成本的系统中才会使用的数据中台，比如大型企业数据中台或者政府平台以及军事平台。</p>
<p>既然是最终目的为预测和决策的中台，那么可以很肯定的说，这个玩意就是为了将来的<strong>战场动向预测</strong>而作准备，其次便是为<strong>异常状况预警</strong>、可以预测的<strong>数据的预报</strong>等等辅助预测而作的准备，再进一步准备就是<strong>自动化生态的建设</strong>，最后就是像是<strong>股市的预测</strong>一样辅助决策。</p>
<p>最开始态势感知是用于军事领域的，然后逐渐在网络安全上铺开，因为是预测攻击对象和攻击手段然后进行预警和自动防御。之后便在多种多样的小细节上加以细化，也就变成了现在的一些自动化系统，也就是现在的电网系统，通过海量的数据来预测未发生故障、定位已发生故障等等方面。</p>
<h2 id="态势感知研究现状"><a href="#态势感知研究现状" class="headerlink" title="态势感知研究现状"></a>态势感知研究现状</h2><p>根据中国知网的数据，有关态势感知的论文在<strong>2019</strong>年一共<strong>886</strong>篇，而自然语言处理相关论文在2019年已经达到了<strong>1522篇</strong>的，是态势感知的<strong>2</strong>倍。其中主要是有关网络安全的态势感知的论文共<strong>286</strong>篇，其次是有关电网的态势感知的论文共67篇，再就是有关军事的战场动向的论文<strong>49</strong>篇。可以看出，态势感知相对来说现在正在研究的人并不是非常多，有关电网的研究更是少之又少。</p>
<p>国外对于态势感知则是从<strong>1999</strong>年首次提出，到现在已经有了20年的发展，相对来说非常成熟。而国内则是从<strong>2009</strong>年首次提出，发展少10年而且发展方向非常受限，直到现在态势感知的主力军也只是局限于网络安全方面的研究。</p>
<p>是不是有点能理解了呢？</p>
]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>论文研究</tag>
      </tags>
  </entry>
  <entry>
    <title>智能微电网</title>
    <url>/2020/10/11/%E7%94%B5%E7%BD%91%E7%A0%94%E7%A9%B6/%E6%99%BA%E8%83%BD%E5%BE%AE%E7%94%B5%E7%BD%91/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>微电网，听起来就像是微服务一样，总觉得和<code>SpringCloud</code>、模块化、可插拔的灵活架构有关。</strong></p>
<a id="more"></a>
<h2 id="微电网"><a href="#微电网" class="headerlink" title="微电网"></a>微电网</h2><p><strong>微电网</strong>和<strong>电网</strong>有一定的区别。</p>
<blockquote>
<p>电力系统中各种电压的变电所及输配电线路组成的整体，称为<strong>电力网</strong>。它包含<strong>变电</strong>、<strong>输电</strong>、<strong>配电</strong>三个单元。电力网的任务是输送与分配电能，改变电压。</p>
<p>——百度百科【<a href="https://baike.baidu.com/item/电网/1250763" target="_blank" rel="noopener">电网</a>】</p>
</blockquote>
<p>也就是说，电网只是单纯的一张<strong>网</strong>，电厂、工厂、公司、家庭等等就像是网中的一个<strong>节点</strong>，节点之间依靠各种电线、变电器、配电器等等<strong>相互连接</strong>。这就是日常生活最普遍的基本电力网络，<strong>单纯供电用网络</strong>。但也正是这个电力网络，是中国现今<strong>特高压坚强电网</strong>的基石，也是“基建狂魔”背后的重要支撑。</p>
<p>那么<strong>微电网</strong>又是什么呢？</p>
<blockquote>
<p>微电网（Micro-Grid）也译为微网，是指由<strong>分布式电源</strong>、<strong>储能装置</strong>、<strong>能量转换装置</strong>、<strong>负荷</strong>、<strong>监控</strong>和<strong>保护装置</strong>等组成的<strong>小型发配电系统</strong>。</p>
<p>——百度百科【<a href="https://baike.baidu.com/item/微电网/568036" target="_blank" rel="noopener">微电网</a>】</p>
</blockquote>
<p>看起来这个说明相较于电网更高端？但是我们来提取关键字：“<strong>小型发配电系统</strong>”，也就是说微电网只是单纯的体量小一些，<strong>本质还是电网</strong>。</p>
<h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><p>如果你以前是Java工程师，那么你应该对<strong>微服务</strong>有所了解。</p>
<p>由于一台机器的负载能力和处理能力是非常有限的，所以将一整个项目拆分成多个模块，每个模块使用一台机器发布服务，这样整个项目的处理能力和负载能力就明显提高了。而<strong>微服务</strong>的核心，就是<strong>分布式</strong>。</p>
<p>打个比方，你一直照顾你们家好多只猫娘的一日三餐。但是你的钱再怎么也不够花一年，所以除了一日三餐你还得工作。虽然非常累的时候有猫娘能治愈你的内心，但这也不是办法。</p>
<p>于是你决定让一些听话懂事的猫娘帮你做饭。比如，大姐帮你剁肉、二姐帮你择菜、最有活力的几个出去购物等等。每只猫娘都在整个做饭过程中都帮了一小部分忙，这样你每天也轻松多了。</p>
<p>这就是微服务，分解、解耦、各司其职，<strong>分布式</strong>就是最核心的部分。</p>
<h2 id="微电网和微服务"><a href="#微电网和微服务" class="headerlink" title="微电网和微服务"></a>微电网和微服务</h2><p>同样的，<strong>微电网</strong>也适用于这样的解释。</p>
<p>微电网由各种分布式的装置，将各个<strong>小规模</strong>的储能装置联合起来形成<strong>大容量</strong>的储能厂；同时保护装置、负荷装置、能量转换装置以及监控保护装置都能够使用<strong>较小型</strong>的设备，减小了开支；同时分布式的架构也能够轻松实现模块的新增和删除，即分布式设备的<strong>即插即用</strong>；不仅如此，分布式的电源能够使得<strong>多种完全不同的发电装置</strong>有了合并的可能，比如风能、太阳能、潮汐能等新兴的新能源发电技术；再加上，地形复杂的西部地区，发电装置难以互联、用电之处远在东南，分布式更适合这种<strong>复杂的地理环境</strong>，更不用说像南海诸岛这样甚至无法架设地面缆线的<strong>极端地形</strong>……可以说是具有相当多的便利了。</p>
<p>当然，有方便之处当然也就有麻烦之处。</p>
<blockquote>
<p>在高并发分布式的场景下，故障经常是突然间就<strong>雪崩式爆发</strong>。所以必须建立完善的监控体系，尽可能发现故障的征兆。</p>
<p>——知乎<strong>老刘</strong>对<a href="https://www.zhihu.com/question/65502802" target="_blank" rel="noopener"><strong>什么是微服务架构</strong></a>的回答（一楼）</p>
</blockquote>
<p>由于<strong>微服务</strong>是由各个模块相互之间交流构成的，所以往往出现错误之后虽然能够补救，却难定位。错误在开发过程中很难预测，往往在开发中就只是用一个统一错误处理草率解决；不仅如此，一旦微服务架构中某个模块出错甚至可能导致整个系统雪崩。所以定位错误有些困难，处理和解决错误也难。<strong>微电网也不例外</strong>。分布式的微电网在故障检测的时候往往要消耗更大的代价。大量的传输线、变压器、配电器，使得监测代价提升了不止一倍；更何况，雪崩之后不知道会发生什么事故，甚至会有工作人员伤亡的可能。</p>
<p>万事万物都是矛盾的，微电网也是。但是，考虑到将来带来的方便，这些缺点无论如何都是要硬着头皮克服了。</p>
<h2 id="现存的微电网标准"><a href="#现存的微电网标准" class="headerlink" title="现存的微电网标准"></a>现存的微电网标准</h2><h3 id="美国"><a href="#美国" class="headerlink" title="美国"></a>美国</h3><p>对于美国地广人稀的特点，部分远郊地区供电成本过大，分布式电网确实比较适合；而华盛顿、曼哈顿等大城市却又是用电量超越想象，分布式电网也拥有较大的负载和能量储存系统，也是不错的选择。</p>
<blockquote>
<p>而美国CERTS定义的微电网要设计成当主电网发生故障时微电网与主电网无缝解列或成孤岛运行，一旦故障去除后便可与主电网重新连接。这种微电网的优点是它在与之相连的配电系统中被视为一个自控型实体，保证重要用户电力供应的不间断，提高供电的可靠性，减少馈线损耗，对当地电压起支持和校正作用。</p>
<p>——百度百科【<a href="https://baike.baidu.com/item/微电网/568036" target="_blank" rel="noopener">微电网</a>】</p>
</blockquote>
<p>可以看到美国对于微电网的要求是具有高灵活度的“热插拔”，也就是分布式模块中的某一个模块坏掉了之后能够立马像火箭一样脱离整体，保证其他地区用电的同时将故障区域隔离开，方便之后的检修。这也是体现了美国使用科技解放人力的主旨。</p>
<h3 id="欧盟"><a href="#欧盟" class="headerlink" title="欧盟"></a>欧盟</h3><p>而欧洲因为起步较早，已经有了相应的气候，整个电网生态的诸多理论已有苗头。另外，相应的，欧盟国家的多个地区为了更好的发展，也一直在互相帮助，高度工业化的欧洲国家也就在互相帮助中有了完全不同的技术与规范。</p>
<blockquote>
<p>欧洲提出要充分利用分布式能源、智能技术、先进电力电子技术等实现集中供电与分布式发电的高效紧密结合，并积极鼓励社会各界广泛参与电力市场，共同推进电网发展。微电网以其智能性、能量利用多元化等特点也成为欧洲未来电网的重要组成。欧洲已初步形成了微电网的运行、控制、保护、安全及通信等理论，并在实验室微电网平台上对这些理论进行了验证。其后续任务将集中于研究更加先进的控制策略、制定相应的标准、建立示范工程等。即，为分布式电源与可再生能源的大规模接入以及传统电网向智能电网的初步过渡做积极准备。</p>
<p>——百度百科【<a href="https://baike.baidu.com/item/微电网/568036" target="_blank" rel="noopener">微电网</a>】</p>
</blockquote>
<p>可以看出，欧洲对于电网的主旨便是像以前的苏联一样，各司其职、物尽其用。另外，已经高度工业化、甚至开始去工业化的欧洲地区，对于电网的另一个考虑就是可再生的清洁能源。</p>
<h3 id="日本"><a href="#日本" class="headerlink" title="日本"></a>日本</h3><p>了解世界地图的人应该都知道，日本这个弹丸之地资源非常有限，需求却始终随着时代的发展不停上涨。所以日本的主题更偏向能源多样化。</p>
<blockquote>
<p>微电网是指在一定区域内利用可控的分布式电源，根据用户需求提供电能的小型系统。</p>
<p>东京大学给出的定义：微电网是一种由分布式电源组成的独立系统，一般通过联络线与大系统相连，由于供电与需求的不平衡关系，微电网可选择与主网之间互供或者独立运行。</p>
<p>三菱公司给出的定义：微电网是一种包含电源和热能设备以及负荷的小型可控系统，对外表现为一整体单元并可以接入主网运行；并且将以传统电源供电的独立电力系统也归入为微电网研究范畴，大大扩展了美国CERTS对微电网的定义范围。</p>
<p>——百度百科【<a href="https://baike.baidu.com/item/微电网/568036" target="_blank" rel="noopener">微电网</a>】</p>
<p>日本微电网的架构允许燃气轮机等旋转发电设备直接接入到微电网同步运行，目前，日本的微电网研究集中在负荷跟踪能力、电能质量监控、电力供需平衡、经济调度以及孤岛稳定运行等方面。</p>
<p>——中国储能网【<a href="http://www.escn.com.cn/news/show-187504.html" target="_blank" rel="noopener">日本微电网项目介绍</a>】</p>
<p>在Hachinohe的微电网展示项目中，目标主要集中在研究间歇的可再生能源发电对微电网控制的影响，分布式电源包括：PV、小型风力机和生物质能发电。</p>
<p>——中国储能网【<a href="http://www.escn.com.cn/news/show-187504.html" target="_blank" rel="noopener">日本微电网项目介绍</a>】</p>
</blockquote>
<p>可以看到，因为资源非常有限，能源来源非常多样，分布式储能系统正好应对了多种能源来源；同时，多样的能源转化、灵活的配电系统，能够让日本针对各种各样的场景进行灵活的升降配。但是，日本却<strong>没有</strong>将设备的<strong>即插即用</strong>考虑进电网之中，具体原因无可考证。但是分布式电源的多样化却做的非常认真，也算是在具有日本特色的发展时代中有所偏重。</p>
<h2 id="我国的微电网现状"><a href="#我国的微电网现状" class="headerlink" title="我国的微电网现状"></a>我国的微电网现状</h2><p>一些发达国家已经先走一步了，现在已经有了略高于我们的成就。但是，毕竟我们有着大量的测试用户（<em>14亿人</em>）、大量的复杂地形（<em>从高原到盆地一应俱全</em>）和大量的刁钻使用方式（<em>从日常使用到工业控制，甚至从军事用电到黑市挖矿</em>），我们若是一一攻克，说不定还有再重大技术上超越发达国家的可能，就比如现如今的音媒体和电子支付已经是远远超过任何一个国家了。当然这也只是我单纯的猜想和内心的希望。</p>
<p>说点实际的吧。</p>
<blockquote>
<p>从2017年开始，国家标准和能源局的文件里已经开始正式把这个定义明确，上升到国家标准层面或者是上升到国家政策层面，在标准里面规定微电网是指由分布式发电、用电负荷、监控、保护和自动化装置等组成的，是一个能够基本实现内部电力电量平衡的小型供电系统，微电网分为并网型微电网和独立型微电网。在2017年能源局发的文件里面，对这个定义也做了进一步的明确，基本上也是比较类似的表述。</p>
<p>——搜狐网：<strong>国电阳光</strong>【<a href="https://www.sohu.com/a/236529823_100005941" target="_blank" rel="noopener">微电网技术当前现状及未来发展趋势</a>】</p>
</blockquote>
<p>可以看到，2017年国家开始重视微电网，并制定了国家层面的标准与规范。事实上，中国在最近5年间已经几近完成了“坚强电网”，所以对于普通民众来说普通电网和微电网并没有什么特别大的差别。但是在石油无法自给自足、甚至还被其他国家左右命运的时代中，可再生的新能源迫在眉睫；同时为了弥补新能源供能尚且不足以超过石油的缺点，多个发电厂联合功能、统一管理也是为了整个电网的安全和稳定不得不作出的考虑。</p>
<p>当然，高层还做出了更远的考虑。</p>
<blockquote>
<p>两大电网公司在今年初都相继提出要向综合能源供应上转变，怎么将电力、燃气、水务、热力等多种资源捆绑成一种资源，实现彼此耦合，解决有关能源的有效利用和调峰的问题，这是微网要解决的问题，当然这也是我们电网公司发展的一个重要的机遇。</p>
<p>——搜狐网：<strong>国电阳光</strong>【<a href="https://www.sohu.com/a/236529823_100005941" target="_blank" rel="noopener">微电网技术当前现状及未来发展趋势</a>】</p>
</blockquote>
<p>可以想象，未来肯定是将会统一管理的。若是发展到了足够优秀的地步，也是能够一切按照各种仪器设备和各类管理系统进行统一的管理，“一条龙服务”的方便未来似乎近在眼前了，不再因为石油危机担忧的未来也不远了，甚至就连一带一路沿线的所有经营点、合作国都将用上这样方便的微电网，逐步走向合作共赢、实现人类命运共同体。</p>
]]></content>
      <categories>
        <category>电网</category>
      </categories>
      <tags>
        <tag>论文研究</tag>
      </tags>
  </entry>
  <entry>
    <title>数据中台是什么</title>
    <url>/2020/10/11/%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0/%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>现在，“数据中台”这个概念越来越火，但是数据中台到底是什么，服务对象是谁，目标又是什么？</strong></p>
<a id="more"></a>
<h2 id="数据中台的概念"><a href="#数据中台的概念" class="headerlink" title="数据中台的概念"></a>数据中台的概念</h2><blockquote>
<p>数据中台被誉为大数据的下一站，由阿里兴起，核心思想是数据共享，并在 2018 年因为“腾讯数据中台论”再度成为了人们谈论的焦点。</p>
<p>——CSDN：<strong>VIP_CQCRE</strong>：【<a href="https://blog.csdn.net/cqcre/article/details/96935800" target="_blank" rel="noopener">到底什么是数据中台？</a>】</p>
<p>数据中台是对既有/新建信息化系统业务与数据的沉淀，是实现数据赋能新业务、新应用的中间、支撑性平台。</p>
<p>——百度百科【<a href="https://baike.baidu.com/item/数据中台/53067001" target="_blank" rel="noopener">数据中台</a>】</p>
</blockquote>
<p>确实，数据中台只是近些年火起来的名词。而且“数据中台”这个词语，听起来就像是和“<strong>数据</strong>”和“<strong>中</strong>”有很大的关系，似乎就是<strong>中间件</strong>+<strong>大数据</strong>。虽然目前还没有一个定义来确定这个词语到底是指代什么，但是很明显的是，这个词语就是为了<strong>数据</strong>和<strong>中间处理</strong>而存在的。</p>
<p>既然这个技术涉及数据，那么这个技术将不可能外包给其他的什么公司或者个人。虽然非常无奈，但是物理隔绝确实能保证秘密不会被传播。所以，比起<code>SpringCloud</code>、<code>Odoo</code>、<code>GoodERP</code>等这些个框架，还是不能够随意售卖、转让或者开源。</p>
<p>那么数据中台到底是什么？</p>
<blockquote>
<p><strong>数据中台是一套可持续“让企业的数据用起来”的机制，一种战略选择和组织形式，是依据企业特有的业务模式和组织架构，通过有形的产品和实施方法论支撑，构建一套持续不断把数据变成资产并服务于业务的机制。</strong></p>
<p>——知乎：<strong>Alan</strong>：【<a href="https://zhuanlan.zhihu.com/p/99591075" target="_blank" rel="noopener">数据中台（一）什么是数据中台</a>】</p>
<p><strong>数据中台是在政企数字化转型过程中，对各业务单元业务与数据的沉淀，构建包括数据技术、数据治理、数据运营等数据建设、管理、使用体系，实现数据赋能。数据中台，是新型信息化应用框架体系中的核心。</strong></p>
<p>——百度百科【<a href="https://baike.baidu.com/item/数据中台/53067001" target="_blank" rel="noopener">数据中台</a>】</p>
<p>中台是一种经营理念；中台是一种组织形式；中台是“平台思维”的自然演进</p>
<p>——节选自<a href="https://bilibili.com/BV1F741177R9" target="_blank" rel="noopener">第十届全球软件开发大会：菜鸟数据中台的演讲</a></p>
</blockquote>
<p>看起来还是有点深奥。而且越来越多的专业词汇让你感觉到更摸不着头脑了！</p>
<p>让我们来看看知乎：<strong>Alan</strong>：【<a href="https://zhuanlan.zhihu.com/p/99591075" target="_blank" rel="noopener">数据中台（一）什么是数据中台</a>】中附上的图片：</p>
<p><img src="https://pic4.zhimg.com/80/v2-62e4ca86b5cc1ca51e99bd115d460e6f_720w.jpg" alt="数据中台的架构图"></p>
<p>到这里，基本上就对数据中台有一个概念了：</p>
<p><strong>数据中台实际上是企业在对用户行为进行分析时，为了将用户数据最大化利用的平台。</strong></p>
<p>那么，什么是最大化利用？（<em>注：因为科技能力限制，所以每个时代都有每个特定的最大化限制</em>）</p>
<p>举个例子，在很早之前，甚至电商还没有起步的时候，你的小蛋糕店（<del><em>La Soleil</em></del>）都是<strong>通过你自己的大脑记住常客的偏好</strong>来选取顾客最喜欢的口味。</p>
<p>但是，你的猫娘女仆们实在太可爱了，为你吸了大量的粉，生意很快做起来了，不光是为了蛋糕，还有为了猫娘慕名前来的顾客，甚至还有预定的顾客，你越来越忙不过来了。所以，你用你超强的代码能力，做了个<strong>推荐系统</strong>出来。用户注册之后，系统便会记录每一次下单的偏好特点，并<strong>制作适当的模型进行预测</strong>。用户再次下单时，就能看到自己的偏好摆在首页上，非常方便。</p>
<p>这时，你的妹妹（<del><em>这即视感太强烈了啊喂</em></del>）当起了你的蛋糕店的公关，开始推广、联动，甚至积极出周边，很快做出了蛋糕店以上的很多服务。你的小蛋糕店规模现在已经不得了了，甚至歪果仁都慕名而来，推荐系统的日活甚至超过了10万。于是，<strong>你决定将小作坊升级为大企业</strong>。这个转变并不容易，所以你想到了数据中台。你希望数据中台为你完成这些任务：</p>
<ul>
<li>你一个人再也没有那么多精力制作那么多的蛋糕了，所以你雇用了很多特级厨师，不仅要做蛋糕，还要做出法式、意式、英式、中式、日式等等特色；别忘了雇佣采购员和外送员，你们家的猫娘忙着照顾客人，才没有时间出去跑腿呢。数据中台就帮助你完成企业中各角色的上下班打卡、每日食品产出、请假、评级等等的人员管理。<strong>这是企业员工管理</strong>；</li>
<li>你的蛋糕店的各种原材料库存得严格把关了。糖每天都有多少、奶油每天还有多少、各种水果罐头每天还有多少……低于某一个阈值的时候发短信、发邮箱进行预警。这是企业库存管理；</li>
<li>你的蛋糕店的各种用户数据都应当记录，并且针对客户的各种订单进行偏好预测；同时，还要能够接收客户对于各种地方的吐槽，并且积极回复、处理、反馈。<strong>这是企业客户管理</strong>；</li>
<li>为了高效制作蛋糕，机器肯定不能少。搅拌机、烘烤机等等全部都要有一个管理，比如哪个设备正在运作、经过了多长时间的连续运转、下次损坏是多久之后等等；不仅如此，部分简单劳动可以使用机器集群完成，一旦集群中某一个坏掉了便需要紧急绕开损毁机器并选择其他运行方案。<strong>这是企业设备管理</strong>；</li>
<li>在完成基本的用餐之后，你的妹妹还需要处理各种联动企划、手办设计和各大平台的推广，于是需要记录各种各样的合作安排与合作绩效，并从中选出最有前景的几家进行长期合作。<strong>这是企业合作管理</strong>；</li>
<li>……</li>
</ul>
<p>听起来这完全就像是一个很普通的<code>ERP</code>系统？不不不，<strong>远没有这么简单</strong>。细心的你应该能注意到这些事情：</p>
<ul>
<li>在<strong>人员管理</strong>中，你可以使用<strong>大数据</strong>对现在的员工进行分析，他们是有什么样的特殊属性才能够成为企业中最优秀的几个员工，下次招聘的时候就按照这个标准进行招聘，从而让自己的员工逐年精进；</li>
<li>在<strong>库存管理</strong>中，你可以使用<strong>大数据</strong>分析前些日子中的售卖数据，然后发现每年的特定时间段有着特定的销售规律，库存也会按照这个规律逐渐耗尽，有时速度非常快，有时速度非常慢。针对不一样的处境，系统会选择不同的时机提出警告，让采购尽快购回；</li>
<li>在<strong>客户管理</strong>中，你可以使用<strong>大数据</strong>分析客户行为数据，将一个个用户逐渐<strong>标签化</strong>，使用权重最大的一个或者很多个标签对用户的偏好进行分析和定义，以便能够更好地推销新旧产品；</li>
<li>在<strong>设备管理</strong>中，你可以使用<strong>大数据</strong>分析机器在什么样的工作环境下工作能够坚持多久，并预测在什么样的环境下这个设备将会被损毁，从而尽快维护翻新更换；同时在机器集群损毁其中一台的时候，你的整个系统能够寻找不影响其他机器运转的其他线路，进行<strong>智能调度</strong>；</li>
<li>在<strong>合作管理</strong>中，你可以使用<strong>大数据</strong>分析在什么样的平台做推广能够得到最大回报，也可以分析手办穿着什么服装、摆出什么动作能够得到买家最大的呼声，并使用<strong>数据可视化</strong>做出日活、周活等折线图、柱状图、饼状图等进一步辅助分析；</li>
<li>……</li>
</ul>
<p>通过<code>ERP</code>和大数据的结合，也就是具有灵魂的业务加上能力超强的工具，就成了。听起来这个普通得不能再普通的<code>ERP</code>系统瞬间就变成了<strong>一整个生态</strong>，包括了企业员工、企业设备、企业自己、合作企业、蛋糕客户、手办客户等等在内所有的数据整合在一起，通过数据挖掘、数据分析、标签化、智能调度、可视化、监控告警等等技术，完成企业方方面面的管理和经营；作为总经理的你面对每一个问题时都能够从数据中台中找出对应的源数据和经过分析后的数据来进行决策。<strong>这听起来就像是世界500强的作风啊</strong>！</p>
<h2 id="数据中台的目的"><a href="#数据中台的目的" class="headerlink" title="数据中台的目的"></a>数据中台的目的</h2><p>看了以上很长一段对于数据中台运行生态和运行机制，我们接下来再讨论数据中台的能力和目的。</p>
<p>数据中台应当具备三个能力：</p>
<blockquote>
<p>1、在中台能力及资源充足的情况下（包括业务知识、技术能力、人才积累），提供数据产品、数据服务。</p>
<p>2、在中台业务能力及人力资源不充分、但体系相对成熟的情况下（包括数据体系、技术体系），提供平台级别的能力，包括数据平台能力、技术平台能力、建模平台能力等，甚至是数据本身。</p>
<p>3、在中台人力资源和对业务领域知识理解不充分，平台级别能力也无法满足要求的情况下，作为算力基础平台提供服务。</p>
<p>——知乎：<strong>帆软</strong>：【<a href="https://zhuanlan.zhihu.com/p/121047371" target="_blank" rel="noopener">一文详解数据中台，别再跟数据平台搞混了！</a>】</p>
</blockquote>
<p>说白了，这三个目的旨在应对三个不同的场景：</p>
<ul>
<li>在企业<strong>已经做到足够大</strong>的情况下，能够为自己的企业、其他的企业提供服务。比如，现在的高德地图提供地图接口、阿里巴巴提供快递查询接口和阿里云服务；</li>
<li>在企业<strong>沿用已有的制度和技术</strong>的情况下，能够给别人提供服务。比如，现在的<code>GoodERP</code>对<code>Odoo</code>进行二次封装之后卖其他的中小型企业，并根据需求进行二次开发和部署；</li>
<li>在企业<strong>完全没有形成气候</strong>的情况下，给其他企业做最简单的事情。比如，现在的各大高校实验室中，技术力较为低下、硬件水平明显不足、工作时间明显较少，但还是在接很多的横向项目，通过外包和承包等等手段介入并为他们根据原型进行代码实现、根据需求进行数据清洗等等。</li>
</ul>
<p>简直就像游戏的难度分级一样：从简单到困难，再就是噩梦难度；从不需要太苦思冥想的简单重复劳动，到需要动点脑子针对特殊的业务进行特殊的编码实现，最后到时时刻刻都需要认真思考，针对每一个细节进行最大的优化。如果真的要做到这一步，我们将会更详细地要求：</p>
<blockquote>
<p><strong>决策支持类</strong>：主题报表（月度/季度/年度/专题）的大屏数据可视化展示</p>
<p><strong>数据分析类</strong>：<code>BI</code>、商业智能、<code>OLAP</code>分析、数据挖掘、数据驱动的机器学习</p>
<p><strong>数据检索类</strong>：全文检索、日志分析、数据血缘分析、数据地图</p>
<p><strong>数据共享开放类</strong>：实时数据订阅、离线数据接触、数据<code>API</code>接出</p>
<p>——知乎：<strong>帆软</strong>：【<a href="https://zhuanlan.zhihu.com/p/121047371" target="_blank" rel="noopener">一文详解数据中台，别再跟数据平台搞混了！</a>】</p>
</blockquote>
<p>这些就都是只有具有超强算力的大型公司才能够完成的任务了。</p>
<p>不难发现，数据中台甚至都包含一定的<strong>业务能力</strong>，如果我们放入鸡蛋、面粉和糖（<em>代指<strong>源数据</strong></em>），出来的可就是蛋糕（<em>代指<strong>最终成果</strong></em>）了；而普通的大数据平台只不过是<strong>分析数据的工具</strong>而已，如果单纯的放入鸡蛋、面粉和糖，可能就只有一团白色的浆糊（<em>代指<strong>半成品</strong>、<strong>中间变量</strong></em>），剩下的烘焙、成型、涂奶油还得我们另外寻找其他办法；再深挖一些，大数据平台中使用的Hadoop集群，就更是完全没有任何其他功能的数学分析工具而已，放入鸡蛋、面粉和糖，它甚至只能在你混在一起之后巧妙地重新分为三类（<em>Hadoop真的是物理意义上毫无感情的机器</em>）。</p>
<p>是不是有点能理解了？</p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>数据中台</tag>
      </tags>
  </entry>
  <entry>
    <title>电网现状和未来</title>
    <url>/2020/10/05/%E7%94%B5%E7%BD%91%E7%A0%94%E7%A9%B6/%E7%94%B5%E7%BD%91%E7%8E%B0%E7%8A%B6%E5%92%8C%E6%9C%AA%E6%9D%A5/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>由于用电问题困扰了中国这个人口大国很久，于是也开始筹备智慧电网了。</strong></p>
<a id="more"></a>
<h2 id="什么是电网？"><a href="#什么是电网？" class="headerlink" title="什么是电网？"></a>什么是电网？</h2><p>现如今，我们的日常生活、游戏娱乐、工作生产等等非常依赖电力，甚至无法想象没有电会给人们带来怎样的空虚与恐慌。而在中国这样一个人口大国，14亿人的用电问题将是一个很严峻的挑战。取电已经到了一定的瓶颈，所以如何<strong>减少浪费</strong>将是另一个很重要的课题。</p>
<p><img src="https://sakebow.gitee.io/images/emoji/nopower.jpg" alt="没电了"></p>
<p><strong>电网</strong>正是处理这样一个问题的解决方案。电网将所有的用户<strong>织成了一张大网</strong>，每个人都在这张网上享有一定的电力。用这个电力，你可以维持你这个节点的正常运作。这正是传统电网的所有功能（<del><em>其实就一个功能</em></del>）。但是，随着需求越来越复杂、实际情况越来越多样，传统电网逐渐暴露出了越来越多的缺点。每当出现意外停电之后，我们除了一脸蒙圈地看着黑黑的屋子发呆，就只能对着电力热线乱发脾气，然后就只能空等着不知道什么时候才能回来的电力。如果你现在正在用电脑写文档，没有保存的你只能在停电之后思考人生。</p>
<p><img src="https://sakebow.gitee.io/images/emoji/down.jpg" alt="难受" width=350 /></p>
<p>所以，为了迎合变化多端的电力需求，就推出了智能电网。用户可以像购买云服务器一样按需升降配，也能够随时启动随时关闭。其中除了完成传统电网的所有功能外，还要加上对用户电力的动态管理、分析用户用电习惯并智能调节、快速定位故障位置并告知检修员和用户等等。</p>
<p><strong>举个简单的例子：</strong></p>
<p>你和几只猫娘住在一个<strong>有些年代</strong>的小区了，<strong>传统电网</strong>将每一家每一户都关联了起来。这里电路、网路都能满足需求。但是，这几年夏天明显热了好几个度，整个小区空调用电<strong>急剧升高</strong>。不是夏天的时候还凑合，结果一到夏天是不是就因为<strong>电路过载就大范围停电了</strong>。你、你的猫娘们和你的邻居们都热得没有办法。</p>
<p><img src = "https://sakebow.gitee.io/images/emoji/annoy.jpg" width=350 alt="生气" /></p>
<p>有一天，你攒够钱了，去了一个高档小区，架设了<strong>智能电网</strong>。虽然有些偏，但是非常宜居。你们经常开着四人座电驱动小汽车出门、开浴霸洗澡、电吹风、电饭煲、电压力锅……<strong>因为人多</strong>，所以你们的电压也明显比原来屋子里的<strong>电压大</strong>，而且电压非常稳定。即使是空调大开的夏天，猫娘和你们的房间也都能稳定制冷，你们每晚睡得都很安稳。</p>
<p><img src="https://sakebow.gitee.io/images/emoji/sigoi.jpg" alt="厉害了" width=350 /></p>
<p>由于你运气非常不错，营收额多了一倍，于是你带着猫娘出去大玩特玩了一周。在这一周内，你们家<strong>所有的用电都停了</strong>，于是你们被分配的<strong>电压也降低了</strong>，多余的电压就<strong>分配给其他的住户了</strong>。可能是你的邻居，也可能是城市另一端的某个陌生人。管他呢，总之你们家的电压因为长时间不用而被减少了。</p>
<p><img src="https://sakebow.gitee.io/images/emoji/np.jpg" alt="牛批的很"></p>
<p>这就是<strong>传统电网</strong>和<strong>智能电网</strong>之间的区别。</p>
<h2 id="电网的生态"><a href="#电网的生态" class="headerlink" title="电网的生态"></a>电网的生态</h2><p>别忘了，电网可是相当底层的技术，所以在这个项目之上理应有<strong>许多小项目</strong>来构成整个生态。就像你<strong>不能光有猫娘</strong>，这样不足以让她生活；还的有对应的猫粮、梳毛器、小鱼干、毛绒玩具、猫爬架等等，才是一个美好的生活环境。</p>
<p>所以，现在就衍生出了多个子项目：客户报障系统（<em>TCT</em>）、地理信息系统（<em>GIS</em>）、营销系统（<em>CMS</em>）、计量系统（<em>AMI</em>）、生产管理系统（<em>PMS</em>）、设计规划（<em>DCS</em>）等等，每个子项目都代表了一个服务，每个服务提供不同的功能。</p>
<p><img src="https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=1976883394,2771927944&amp;fm=173&amp;app=25&amp;f=JPEG?w=640&amp;h=425&amp;s=510366B852C072E7DE94C9480300F0E3" alt="智能电网"></p>
<p>这个图来自<strong>我爱阳光明媚</strong>的<a href="https://baijiahao.baidu.com/s?id=1613397434596286148&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">什么是智能电网？智能电网有哪些特征？</a>，其中智能电网的每一个小模块都代表一个小服务，对应了一个小方向。由上而下的多级管理制度更方便了用电的调度和调节，具体的管理细节就是<strong>工程管理</strong>的知识了。每个调节的地方需要实时监测保障安全和正常使用，这就是仪器仪表的<strong>知识</strong>；调度时考虑每个节点的安全和线路的消耗和规划，这又是电气的知识了；发电能源再从核能发电、火力发电逐渐过渡到风力、水力、地热等等清洁能源，这也是化工的知识；因为是生态，所以在原理上有非常多的内容是相互交叉的，所以在子项目之间如何解耦却又高聚合又是一大问题。这又开始了<strong>软件工程</strong>的知识……</p>
<p>就这么简简单单地一列举，是不是觉得这个电网项目简直就是一项体量超级大的项目？</p>
<h2 id="全球的电网现状"><a href="#全球的电网现状" class="headerlink" title="全球的电网现状"></a>全球的电网现状</h2><p>现在中国的<strong>大部分</strong>城市依然还是使用传统电网，智能电网<strong>起步非常晚</strong>，政策少、标准少。但是面对<strong>14亿人的超大量用电</strong>问题，智能电网的升降配等操作都有很大的困难等待我们的挑战。另外，之前的传统电网都是单纯的电路连接，并不具备智能。如果全部修改成智能，需要大量的传感器、收发器、探测器等等，改造难度不亚于全部拆掉重新建。</p>
<p>国外起步较早，但因为各国发展现状和发展理念不一样，各有侧重。</p>
<p>欧洲电力行业更倾向于清洁能源和环保，毕竟是全球首先发达的几个地区之一，正在慢慢去工业化并更侧重环保；日本由于国土面积小、资源有限，能源可再生、节能降耗则是日本电网的基调；英国国家电网将整个国家分成11个区，每个区设置3到7个变电站和一个经理，每个变电站都有一名工程师和一队操作队。由于系统较中国成熟，所以已经实现了无人值班，并且工程师定期维修检查的制度。在美国，虽然全国被分为完全独立的几个州，电网不能够完全全球联网统一调度，但是美国依然完成了输电线路监测和和输电统通信网，还有配电系统、智能电表和用户侧系统，其中用户侧还包含家庭显示器、可编程恒温器、动态电价计量器等等。</p>
<p>当然，正因为电网是一整个生态，所以这些国家在建设的时候花费了不小的代价。首先是每家每户的传统电表改造成智能电表，并且政府、煤气电力市场等多方面提供了巨额科研经费以供智慧电网的架设和铺开。</p>
<h2 id="我国电网所面临的挑战"><a href="#我国电网所面临的挑战" class="headerlink" title="我国电网所面临的挑战"></a>我国电网所面临的挑战</h2><p>虽然电网建设了一整个包括营销、计量等的完整生态，但建设智能电网的最终目的还是回到了能源。以前的传统电网使用了煤炭、核能等不可再生而且污染严重的能源，而现如今的电网已经大量投入使用清洁能源，比如西南的太阳能、西北的风能等等。</p>
<p>但是正如刚刚所说，太阳能、风能等等分布并不是非常紧凑，反而非常分散；同时绝大部分的用电却又在我国东南部，造成了供电和用电的地理位置上的割裂。所以对于大容量储能还是有所不足，能源出现和能源使用的地方随机性太大。</p>
<p>不过也不用太担心，在电网中我们可以建立虚拟电厂，也就是VPP，全称<em>Virtual Power Plant</em>。虚拟电厂能够将一个片区的电力集中在一起，然后使用智能调控系统进行统一的管理。简单地概括，就是国家有电，你也要电，所以虚拟电厂就充当中介的作用，收集电、发配电。</p>
<p><img src="https://sakebow.gitee.io/images/电网/VPP.png" alt="VPP架构图"></p>
<p>理论上，不管片区多大都是可以集中的，但是考虑到成本问题，一般不会这么无谋。至于智能调控系统，就是刚刚提到的整个生态的系统了。传统电网的面向群体是一个小团体，可能是一个小区，也可能是一个别墅群，也可能是一栋筒子楼，剩下进入家家户户的还是得自行预估、设计、测算、牵线等等，麻烦但是无奈。而智能电网面向的群体则是个体用户，用得多得的多，用的少得的少。</p>
<p>听起来非常不错？但是挑战依然还有很多。如果是面向群体，那么一整个群体就能够共享、调节，最终达到一个稳定的用电标准。既然已经决定面向个体，那么就没有调节的余地了，这也就意味着电网将要面对无数完全不同的复杂需求进行严苛的调整。一户人家只有他一个大龄单身<del>死肥</del>宅，所以用电除了大量的空调就是全天候的电脑用电；你们家有很多只猫娘，从微波炉、电饭煲，到浴霸、热水器，再有空调、地暖，以及电脑和电视甚至电动小汽车等等应有尽有的电器用电，所以需要更多、更稳定、更复杂的管理；还有一家只有一只小小的猫娘，用电水平较低，所以分配较为轻松，但是也不能因为较为轻松所以完全放弃了这一家的正常用电；最后一家是一个到处寻找商机的商人，常年不在家，所以还需要给这位商人一个随时关停家庭用电的远程开关……</p>
<h2 id="我国电网未来的展望"><a href="#我国电网未来的展望" class="headerlink" title="我国电网未来的展望"></a>我国电网未来的展望</h2><p>在智能电网中，最大的方便之处估计就是自愈系统了。传统电力中，你只能等电网公司慢慢报故障、检查工人慢慢找故障、修理工人慢慢慢慢修故障；而在智能电网中，通过类似<code>SpringCloud</code>分布式集群中的熔断机制，能够暂时缓解小范围的断路故障，也能通过对各种各样的探测器传回总部的各种数值的大数据分析得出故障最可能发生的地点，然后让检修工人第一时间赶往现场，并通过<code>GIS</code>系统实时报告故障地址和检修工人的地址与进度。</p>
<p>是不是听起来就很方便？当然，到这里还不算结束。</p>
<p>中国高层已经安排了计划，要求建设运营好“两网”，分别是“<strong>坚强智能电网</strong>”和“<strong>泛在电力物联网</strong>”。</p>
<p>听起来就是两个新鲜的高端词汇？然而“坚强智能电网”即将完成了，就是：</p>
<blockquote>
<p><strong>以特高压为主干网架</strong>，核心使用<strong>传感技术</strong>，利用传感器对<strong>温度在线监测装置</strong>、<strong>断路器在先监测装置</strong>、<strong>避雷器在先监测装置</strong>、<strong>容性设备在线监测装置</strong>等关键设备进行实时监控，通过网络系统整合所有传感数据，通过<strong>数据分析</strong>和<strong>数据挖掘</strong>，协助电力系统的<strong>优化管理</strong>。</p>
<p>——摘自百度百科【<a href="https://baike.baidu.com/item/坚强智能电网" target="_blank" rel="noopener">坚强电网</a>】</p>
</blockquote>
<p>什么？你让我说人话？就是说从电厂出发的电是最强的，然后在运输线沿线各个地方放些传感器，然后让专门的人看看这些传感器的数据又没有问题、要不要修；同时，普通用户也能够看到一些他们自己非常关心的数据，譬如账户余额、家庭用电量什么的，来满足日常生活和突发事故排查以及报障。</p>
<p>这就是“坚强智能电网”，首先是“<strong>坚强</strong>”，然后是“<strong>智能</strong>”。优先保障电力的稳定，然后在这个的基础上保持一定的智能。</p>
<p>那么“泛在电力物联网”又是什么？先从字面上理解，“泛在”一词，顾名思义，意为“<strong>广泛存在的</strong>”，就像是我们现在人手一部手机一样，见怪不怪了。“电力物联网”应当放在一起，因为是<strong>由电力作为媒介传递信息的万物互联而构成的网</strong>。只要是用电的，无论是工厂、办公室还是小商店，都能够实时监控；每个人都像一个行走的结构体，各个字段信息像血肉一样丰富了信息时代的你。</p>
<p>接下来我们看看官方怎么解释：</p>
<blockquote>
<p>国网公司做出两个阶段的战略安排：</p>
<p>到2021年初步建成泛在电力物联网，基本实现业务协同和数据贯通，初步实现统一物联管理，各级智慧能源综合服务平台具备基本功能，支撑电网业务与新兴业务发展。<br>到2024年建成泛在电力物联网，全面实现业务协同、数据贯通和统一物联管理，公司级智慧能源综合服务平台具备强大功能，全面形成共建共治共享的能源互联网生态圈。</p>
<p>——摘自百度百科【<a href="https://baike.baidu.com/item/泛在电力物联网" target="_blank" rel="noopener">泛在电力物联网</a>】</p>
</blockquote>
<p>百度百科的这一条可以说是基本上阐述了泛在电力物联网的目的，挖掘核心价值，就是“万物互联”、“能源服务”和“生态建设”。</p>
<p>万物互联是一个很庞大的图景。有多庞大？就像是单凭一个人画出清明上河图那么庞大。不是完不成，而是需要面对很多挑战。图景里有些什么呢？大到港口运了几千万吨货物，小到今天生产了多少罐猫粮；重要到今天印了多少钞票，普通到你今天看了多少<del>R18</del>图片……是不是不由得默默咽了一口唾沫？</p>
<blockquote>
<p>2018年，国往信通工作会议上就提出了“打造全业务泛在电力物联网，建设指挥企业，引领具有卓越竞争力的世界一流能源互联网企业建设”的工作目标，并提出了建设“国网-电力物联网”，简称<code>SG-eIoT</code>，即<code>electric Internet of Things</code>。</p>
<p>——摘自搜狐新闻【<a href="https://sohu.com/a/299805908_99947185" target="_blank" rel="noopener">什么是“泛在电力物联网”？要建立一个什么样的泛在电力物联网？</a>】</p>
</blockquote>
<p>大力发展智能电网的目的，主要就是为了能够打通终端、网络、平台、运维和安全五大体系，构建一个非常完整的生态，同时打通输电、变电、配电、用电、卖电五大场景，统一管理、统一协调，并实现各类终端设备的热插拔。到了那个时候，不管你是工厂添置设备，还是数据中心追加服务器集群，还是街边添加自助售货机，都是插上电立马给你一条龙服务。</p>
<p>当然，有大项目就得用大技术。预计这次会用到“大云物移智”，即大数据、云计算、物联网、移动互联网和人工智能。不过，感觉像是留了一手一样的，国家电网一点口号都没有喊，甚至都没有大肆宣传任何一点小成就，突然“坚强智能电网”就要建好了，突然就声明2024年需要建好智能电网，突然就声明2030年能够接入<code>SG-IoT</code>网络的设备达到20亿台。可以看到国家电网已经有相当的实力了。</p>
<p>未来肯定是美好的，我也相信学术界和商业圈都已经做好准备了。</p>
]]></content>
      <categories>
        <category>电网</category>
      </categories>
      <tags>
        <tag>论文研究</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义module的导入</title>
    <url>/2020/09/27/JavaScript/Vue/%E8%87%AA%E5%AE%9A%E4%B9%89module%E7%9A%84%E5%AF%BC%E5%85%A5/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>对于前端小白来说，ES5、ES6两套完全不一样的标准放在一起是很头疼的事。导入的时候同时使用两套不同的标准将会在<code>ESLint</code>存在的时候报错。</strong></p>
<a id="more"></a>
<h2 id="ES5的写法"><a href="#ES5的写法" class="headerlink" title="ES5的写法"></a>ES5的写法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义neko.js并作为模块导出</span></span><br><span class="line"><span class="keyword">var</span> Neko = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Neko</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">  Neko.prototype.grow = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age += <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Neko</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  neko: Neko</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Neko模块</span></span><br><span class="line"><span class="keyword">import</span> Neko <span class="keyword">from</span> <span class="string">'./neko'</span></span><br></pre></td></tr></table></figure>
<p>可以看到，在定义这个<code>Neko</code>类的时候非常冗赘，而且多种多样的闭包让人眼花撩乱、不知所措。</p>
<h2 id="ES6的写法"><a href="#ES6的写法" class="headerlink" title="ES6的写法"></a>ES6的写法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义neko.js并作为模块导出</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Neko</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (name, age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">  grow () &#123;</span><br><span class="line">    <span class="keyword">this</span>.age += <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Neko</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Neko.js模块</span></span><br><span class="line"><span class="keyword">const</span> Neko = <span class="built_in">require</span>(<span class="string">'./neko.js'</span>)</span><br></pre></td></tr></table></figure>
<p>在导入和导出的时候都出现了明显的不同。但是在不同之处又有些相同，这就在初学的时候容易弄混。</p>
<p>如果你使用了<code>ESLint</code>，你的语言将非常严格，于是在编辑的时候你只允许使用<code>ES5</code>、<code>ES6</code>的其中一种。</p>
<p>当你混用的时候：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> $ = <span class="built_in">require</span>(<span class="string">'jquery'</span>)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Neko</span><br></pre></td></tr></table></figure>
<p>这个时候你的程序就会报错。你的程序在其他位置一点问题都没有，大量复杂的继承、闭包只会让你更加心烦意乱。所以，我们还是尽可能统一风格、统一标准。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>读论文的方法论</title>
    <url>/2020/09/25/%E7%94%B5%E7%BD%91%E7%A0%94%E7%A9%B6/%E8%AF%BB%E8%AE%BA%E6%96%87%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>研究生生活开始了，学术上可不能有所怠慢，尤其是作为学硕的我。</strong></p>
<a id="more"></a>
<p><strong>一般的，我们会把一篇论文阅读很多次。</strong></p>
<h2 id="第一遍"><a href="#第一遍" class="headerlink" title="第一遍"></a>第一遍</h2><p>首先，我们会关注论文的<strong>摘要</strong>、<strong>引文</strong>。因为这会让我们对开题的各种说明有些了解。</p>
<p>同时，正因为我们正处于寻找课题的阶段，所以我们现在需要做的就是理解研究思路、掌握分析方法。当然也别忘了语言的雕琢，<strong>审稿人最喜欢那些听起来非常拗口的东西了</strong>。</p>
<h2 id="第二遍"><a href="#第二遍" class="headerlink" title="第二遍"></a>第二遍</h2><p>第二遍大概会<strong>在我们稍有基础之后</strong>，这时我们会对一定的数据格式有一定的敏感性。也正是这个时候，我们会仔细了解论文的<strong>图表信息</strong>，包括图表中所包含的<strong>数字</strong>、<strong>文字说明</strong>和<strong>得出结论</strong>。在这时，需要从作者所提供的数据，在作者所站在的角度上通过什么样的标准才能够的出论文中所阐述的结论。如果你觉得恰当，是为什么？如果你觉得欠妥，又是为什么？</p>
<p><em>在这里插播一句话：你能检索的论文都不会有所误解，只会有所欠缺，因为能够在这上面发表的论文起码在因果关系上是没有问题的，数据造假问题不再考虑范围内。</em></p>
<p>当然，这时正因为你有了一些基础，所以你可以<strong>略读摘要和引言</strong>，<strong>直接找图表进行深入讨论</strong>，其他的细枝末节干脆屏蔽掉也是可以的。</p>
<h2 id="第三遍"><a href="#第三遍" class="headerlink" title="第三遍"></a>第三遍</h2><p>第三遍自然也是第二遍的升级。这个时候我们已经具备了阅读实际问题的能力了，<strong>即使面对几十个数据文档的轮番轰炸也能够应对自如</strong>。那么，这个时候就应该联系<strong>摘要</strong>、<strong>引文</strong>和<strong>图表</strong>，看图表是不是对应着这些摘要和引文。如果不是，那么图表又在说明什么问题？如果是对应的，那么图表又为什么样的结论提供了强有力的证据？作者对这样的证据是如何讨论的？</p>
<p>这个时候就需要对应你了解的引言和摘要，开始对图表进行分析了。就想象你是一名小学语文老师一样，板着一副臭脸，拍着桌子喊着：“你的主题呢？！”那种高高在上的姿态估计很多人都会欲罢不能。这就是坚持到找到乐趣的时候了，相信你也离成功不远了。</p>
<h2 id="第四遍"><a href="#第四遍" class="headerlink" title="第四遍"></a>第四遍</h2><p>这个时候相信你已经入门了。最起码，你能够自己模仿了。这个时候，就开始读一些高级论文吧，因为一篇文章的高级可不是因为一个句子而高级，而是一整篇全程高能才叫高级。从字里行间学习他们行文的规范和规律，再从一字一句中扣出思想和论证方法。</p>
<p>这个阶段更考验的是我们的综合能力了，除了文档的格式规范、图表分析，更是字里行间透露出你对学科的严谨、认真。</p>
<h2 id="第五遍"><a href="#第五遍" class="headerlink" title="第五遍"></a>第五遍</h2><p>能够读第五遍的文章应该只有英文论文了。因为这是我们中文母语的学生所不熟悉的领域，于是对于我们来说相当于又回到了第一遍。但是，学习正是这样一种“<strong>螺旋上升</strong>”的变化过程，不是么？</p>
<h2 id="后面的文章行文规律"><a href="#后面的文章行文规律" class="headerlink" title="后面的文章行文规律"></a>后面的文章行文规律</h2><p>上面我们介绍了读五遍论文的时候每一遍都应当做些什么，所以在写论文的读后感的时候，我们会将文章分成<strong>至少四个部分</strong>，每个部分将会侧重不同的地方，每个地方针对每个不同的阶段都会有不同的侧重点。相信针对每个不同阶段的人都会有不同的收获吧。</p>
<p>祝各位都变得巨牛批！</p>
<p><img src="https://sakebow.gitee.io/images/emoji/牛批.jpg" width="400" /></p>
]]></content>
      <categories>
        <category>电网</category>
      </categories>
      <tags>
        <tag>论文研究</tag>
      </tags>
  </entry>
  <entry>
    <title>小树苗：决策树是什么？</title>
    <url>/2020/09/23/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E5%86%B3%E7%AD%96%E6%A0%91%E7%AE%97%E6%B3%95/%E5%B0%8F%E6%A0%91%E8%8B%97%EF%BC%9A%E5%86%B3%E7%AD%96%E6%A0%91%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>决策树，听起来就像是有许多分支的树，也听起来像是能够帮助我们作出某种决策的方法。</strong></p>
<a id="more"></a>
<h2 id="决策树的定义"><a href="#决策树的定义" class="headerlink" title="决策树的定义"></a>决策树的定义</h2><p>既然是树，那么首先就有<strong>根</strong>，其次有<strong>树枝</strong>，然后有<strong>树叶</strong>。</p>
<p><strong>根</strong>，就是一个对象实体；<strong>树枝</strong>则是一个对象的多种属性；<strong>树叶</strong>则是<strong>基于这个对象实体、对照该对象实体的某种属性，就能够得出某种结果</strong>。</p>
<p>听起来非常难懂？那还是老套路，你还是收集了20万只猫娘的很多种属性，然后对照总结。</p>
<ul>
<li>这只猫娘的眼白有些发红，所以有可能生病了，带进诊所给医生看看；</li>
<li>那只猫娘在检查的时候一直“啊吧啊吧”地流口水，有可能是紧张了，也有可能是口腔有些疾病，带进观察室呆一会；</li>
<li>又有一只猫娘晚上打呼噜很大声，那么她就是单纯的打呼噜很大声，给她一只毛线球去快乐地玩耍吧……</li>
</ul>
<p>看完这个例子，不难发现，<strong>根</strong>就是猫娘这一物种，<strong>树枝</strong>就是眼睛发红、流口水、打呼噜等等特征，<strong>树叶</strong>则是由这些特征的猫娘会有什么样的症状。但是光有根、树枝和果实的树并不能够非常完美地构成猫娘这一物种，而正是这20万组猫娘的数据构成了这颗决策树的树干，丰富了猫娘这一物种，让这一物种更为饱满、更<strong>有依可寻</strong>。</p>
<h2 id="决策树的思想"><a href="#决策树的思想" class="headerlink" title="决策树的思想"></a>决策树的思想</h2><p>“<strong>是什么</strong>”说明白了，接下来要说“<strong>为什么</strong>”了。</p>
<p>决策树和分治算法、动态规划这些<strong>分而治之</strong>的思想不太一样，虽然<strong>都有剪枝</strong>，但是决策树在剪枝的基础上增加了权重。这和<strong>分而治之</strong>思想中<strong>一票否决</strong>的硬杠杆不一样，更像是遇到多个问题的时候逐个投票，然后根据人数占比的统计和可接受度的比较，最终得出了结果。</p>
<p>打个比方，如果使用<strong>分而治之</strong>的思想来对待你的猫娘，那么就会是这个样子：</p>
<p>你的猫娘在你收拾的时候瞎捣乱，</p>
<ul>
<li>你狠狠地责备了她。</li>
</ul>
<p>如果是<code>GalGame</code>的话选了这个选项估计直接就走入<code>Bad End</code>了。</p>
<p>而如果是决策树，就会这样：</p>
<p>你的猫娘在你收拾的时候瞎捣乱，</p>
<ul>
<li><p>首先碰翻了垃圾桶，由于是空桶所以就只是把桶扶起来，摸摸她的头，笑着说：“小捣蛋鬼！”</p>
</li>
<li><p>之后把桌子上的东西都打在地上了，由于掉下去的都是抽纸、不锈钢盘子、遥控器等等，没什么散落一地的东西，也没泼什么东西在地上，就把东西重新放好。她再把东西推下去，你就把拳头扬起来做出一副要打下去的样子。起初她张牙舞爪的准备迎击，看你一直没打下去放松了戒备。然后你趁机弹了一下她的脑门，她就捂着额头跑掉了。你也就有了机会继续收拾。</p>
</li>
<li><p>接着爬到你背上胡抓乱挠，由于收拾得差不多了，你把她从背上抓下来，索陪她性大玩特玩。</p>
</li>
</ul>
<p>有<code>Happy End</code>的感觉了！</p>
<p>仔细看这个例子，你会发现每次遇到事件的时候，你都会好好地根据当前一些特征现象进行选择，比如<strong>不责备和责备</strong>、<strong>陪她玩和继续收拾</strong>。</p>
<p>和每遇到一个条件就剪枝的<strong>分而治之</strong>算法不同，决策树最大的特点就是会根据许多不同的特征<strong>按照权重</strong>筛选。就像给猫娘看病一样，<strong>并不是一开始就从脑袋开始检查</strong>，<strong>也并不是最终一定要把检查脚底放在最后</strong>，<strong>而是从是否健康开始判断</strong>。</p>
<p>这样的话，在与猫娘相处时发生的很多事情来看，决策树往往更灵活、更温柔。当然，这也需要你对很多事情有更多的观察、参照和经历，就过程而言并不容易。</p>
<h2 id="决策树的目的"><a href="#决策树的目的" class="headerlink" title="决策树的目的"></a>决策树的目的</h2><p>决策树，顾名思义，就是为了决策而准备的。我的理解是：决策树的目的实际上就是分类。当然也能够用于回归，只不过往往因为某些特征对应的特定结果实在太明显了，我们通过对比特征马上就能分类。</p>
<p>但是分类还不够，如果只是单纯的分类，用<strong>人海战术</strong>也能够实现。所以决策树在分好类的基础上进行了新的预测。也就是说，<strong>决策树能够从大量的对象实体中总结出一个特定该对象的一些特性，从而在代入新的实体的时候能够预测该实体的属性</strong>。就像你收集了大量的猫娘数据总结出了猫娘在遇到什么病情的时候会有什么样的症状的普遍规律之后，运用到你自己家的猫娘上，给她无微不至的关爱。（<del><em>跑题了啊！</em></del>）</p>
<p>是不是有点能理解了呢？</p>
]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>算法模型</tag>
      </tags>
  </entry>
  <entry>
    <title>瑟瑟发抖的新生活</title>
    <url>/2020/09/23/diary/%E7%91%9F%E7%91%9F%E5%8F%91%E6%8A%96%E7%9A%84%E6%96%B0%E7%94%9F%E6%B4%BB/</url>
    <content><![CDATA[<script src="/crypto-js.js"></script><script src="/mcommon.js"></script><h3 id="encrypt-message">如果你坚持要看，请联系我。</h3><link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.min.css"> <link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap-theme.min.css"> <script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script> <script src="//cdn.bootcss.com/bootstrap/3.3.5/js/bootstrap.min.js"></script> <div id="security"> <div> <div class="input-group"> <input type="text" class="form-control" aria-label="Enter the password." id="pass"/> <div class="input-group-btn"> <button type="button" class="btn btn-default" onclick="decryptAES()">Decrypt</button> </div> </div> </div> </div> <div id="encrypt-blog" style="display:none"> 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 </div>]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>新生入学</tag>
      </tags>
  </entry>
  <entry>
    <title>Electron-vue环境搭建</title>
    <url>/2020/09/22/JavaScript/Vue/Electron-vue%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>一开始<code>Vue</code>生态还尚未完善的时候，<code>Electron</code>和其他框架很难整合。现在<code>Vue</code>生态逐步完善了，整合<code>Electron</code>也方便很多了。注：本篇将默认大家都会使用<code>nodeJS</code>。</strong></p>
<a id="more"></a>
<h2 id="以前的方法"><a href="#以前的方法" class="headerlink" title="以前的方法"></a>以前的方法</h2><p>之前<code>Electron</code>只兼容了<code>Vue2.x</code>，所以只能使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vue init simulatedgreg/electron-vue $&#123;your-project-name&#125;</span><br></pre></td></tr></table></figure>
<p>虽然比较方便，但是很不幸，安装依赖的时候<strong>不管是否翻墙都无法下载</strong>。所以，只能单独使用<code>Electron</code>或者<code>Vue</code>，体验很差。</p>
<h2 id="新的方法"><a href="#新的方法" class="headerlink" title="新的方法"></a>新的方法</h2><p>现在<code>Electron</code>兼容了<code>Vue3.x</code>（实际上还是<code>vue2.x</code>，只是使用<code>vue-cli3</code>构建应用更方便），所以就有了全新的简便方法。</p>
<p>首先，我们先创建一个<code>vue3</code>项目：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vue create demo</span><br></pre></td></tr></table></figure>
<p>在执行之后，<code>vue</code>就会让你选择应该如何做。</p>
<p><img src="https://sakebow.gitee.io/images/javascript/vue-cli.png" alt="很多很多的选项"></p>
<p>如果你使用的是<code>Windows</code>，那么很抱歉，你无法享受直接使用键盘选择命令行中的各种模块；如果你使用的是<code>Ubuntu</code>，但是并不熟悉这些模块分别是干什么，那就默认安装吧。这个仅用于学习的小项目不会很复杂的；如果你非常熟悉这些模块分别有什么作用，那么还需要我说么？开玩笑的啦，一般我们选择<code>Vuex</code>、<code>Router</code>、<code>Bable</code>就够了。如果你需要更严格的标准，请下载<code>ESLint</code>；如果你希望更简洁的编辑方式，那么请坚持使用<code>ES6+</code>。</p>
<p>另外还强调一点，由于<code>Electron</code>在开发的时候并没有强调<code>Vue</code>的版本问题，所以连官方文档都没有强调这一点。于是很坑爹的就是，现在<code>Electron</code>仅支持<code>Vue2.x</code>。</p>
<p><strong>这里当然还是推荐自定义</strong>。一方面，你能明白哪些东西是在干什么。就算没用过，多少查一查嘛；另外，因为<code>Electron</code>目前虽然能够作出跨平台窗口，却有着致命的弱点：<strong>目前为止没有完美的框架模板</strong>。所以<code>Electron</code>就只能完成一个普通的窗口，剩下的还是得<strong>自己造轮子</strong>。是不是一听到“造轮子”就开始头大了？生态还没有完全建立起来，还需要许许多多的开发者共同努力的呀；还有，对于想要集成<code>ElementUI</code>的开发者来说，<code>history mode</code>简直就是噩梦一般的存在。明明一点错误都没有，<strong>但就是编译不通过</strong>。非常痛苦。</p>
<p>言归正传，在新建之后，如果我们直接向项目中加入<code>electron-builder</code>，将会出现很多的问题。目前还没有什么好的办法能够支持这样的问题，即使是大佬遍地的<code>StackOverflow</code>也没有什么很亲民的解法。所以，这里推荐先安装<code>ElementUI</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vue add element</span><br></pre></td></tr></table></figure>
<p>实际上全名是：<code>vue-cli-plugin-element</code>，可以写全，也可以就写后一半，都没有问题。</p>
<p>不过别忘了，<code>3.0</code>可不只更新了库，还有用户界面：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vue ui</span><br></pre></td></tr></table></figure>
<p>运行之后就能够看到一个网页：</p>
<p><img src="https://sakebow.gitee.io/images/javascript/vue-ui.png" alt="web界面"></p>
<p>导入本地项目之后就可以使用非常方便的界面安装库：</p>
<p><img src="https://sakebow.gitee.io/images/javascript/vue-import.png" alt="导包界面"></p>
<p>是不是非常的厉害？但是比起<code>Ubuntu</code>的命令行，<code>ui</code>还是不太确定当前进度在哪。而在安装<code>Electron</code>的时候，大量的包需要下载，没钱买百兆光纤的我实在需要直到现在下载了多少。所以我更喜欢命令行。但是<code>ui</code>其实对于<code>Windows</code>用户还是非常亲切的。可是<code>Windows</code>后台进程实在太多了，相对于简单高效的<code>Ubuntu</code>还是差了很远。这就看各位如何取舍了。</p>
<p>接着，我们来测试一下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm run serve</span><br></pre></td></tr></table></figure>
<p>嗷，弹出了一个网页，这就是<code>Vue</code>的部分，能够成功完成一个普通的网页：</p>
<p><img src="https://sakebow.gitee.io/images/javascript/vue-web.png" alt="Vue网页"></p>
<p>看起来挺不错的，甚至还有来自<code>ElementUI</code>贴心的测试按钮<code>el-button</code>。那么剩下的就是<code>ELectron</code>了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vue add electron-builder</span><br></pre></td></tr></table></figure>
<p>再来：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm run electron:serve</span><br></pre></td></tr></table></figure>
<p>嗷，弹出了个窗口，这就是<code>Electron</code>的部分，能够成功完成一个跨平台的窗口。</p>
<p><img src="https://sakebow.gitee.io/images/javascript/vue-window.png" alt="Electron窗口"></p>
<p><strong>大功告成。</strong></p>
<p>现在看完了这篇教程会不会感觉轻松一点了？接下来的毕竟和<code>ElementUI</code>+<code>Vue</code>开发页面完全一样了嘛。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Swagger集成小贴士</title>
    <url>/2020/09/19/Java/SpringBoot/Swagger%E9%9B%86%E6%88%90%E5%B0%8F%E8%B4%B4%E5%A3%AB/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>Swagger是为了能够方便对接而产生的框架。在本篇中将会默认大家都有一定的<code>Java Web</code>开发基础和<code>SpringBoot</code>框架使用经验，并在这些基础和经验之上说明一些需要注意的点。</strong></p>
<a id="more"></a>
<h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p>首先我们需要导入<code>Swagger</code>的依赖，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;swagger.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;swagger.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后，高度集成的<code>SpringBoot</code>框架还为我们准备了程序入口，我们只需要在<code>{项目根目录}/src/main/java/{自定义包名}</code>下新建<code>java</code>文件。如果你使用的是<code>IDEA</code>，直接新建<code>config.SwaggerConfig</code>文件；如果你使用的是<code>SpringToolSuite</code>（即<code>STS</code>），那么就需要在${自定义包名}下新建包<code>config</code>，再在包下新建<code>java</code>文件，命名为<code>SwaggerConfig</code>。如果你使用的是<code>eclipse</code>，请首先集成<code>STS</code>，然后重复在<code>STS</code>上的操作。</p>
<p>在<code>SwaggerConfig.java</code>文件中，我们只需要在类上声明注解即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger</span>2</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你除了添加两个注解以外什么都不需要做。如果你不是很明白为什么，建议首先将<code>SpringBoot</code>框架启动原理再看一看，预习也好，复习也罢。</p>
<p>启动项目，在浏览器中输入<code>http://localhost:8080/swagger-ui.html</code>，你就能够看到主页面：</p>
<p><img src="https://sakebow.gitee.io/images/spring-boot-web/集成SwaggerUI并运行.png" alt="Swagger界面"></p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>当然，并不是所有人都是这么顺利的，有些人会报<code>404 Error</code>。</p>
<p>如果你集成了其他安全框架，例如<code>Spring Security</code>、<code>Shiro</code>等等具备拦截请求功能的框架，你将无法访问。这个就需要进一步的配置了，也就不是本篇单纯讨论<code>SwaggerUI</code>的文章能够说清楚的问题了。</p>
<p>如果你没有集成其他安全框架，那么应该就是版本的问题了。直到编辑博客的今天（<em>2020-09-19</em>）为止，<code>SwaggerUI3.0.0</code>无法使用。我们只需要将版本重新改为<code>2.9.2</code>，然后右键-&gt;<code>Maven</code>-&gt;<code>Reimport</code>就好了。</p>
<h2 id="注解说明"><a href="#注解说明" class="headerlink" title="注解说明"></a>注解说明</h2><p><code>Swagger</code>提供的注解非常全面，不仅仅能够标记所有的后端接口，还能够标记所有的实体类。所以在前后端交互的时候，前端能够在每一个细节上都能做的非常好，且在每一个细节上都能够完善。</p>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/hello"</span>)</span><br><span class="line"><span class="comment">// 说明该类的作用</span></span><br><span class="line"><span class="meta">@Api</span>(tags=&#123;<span class="string">"test"</span>, <span class="string">"hello"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">  <span class="meta">@RequestMapping</span>(method = RequestMethod.GET, value = <span class="string">"/swagger2"</span>)</span><br><span class="line">  <span class="comment">// 说明方法的作用</span></span><br><span class="line">  <span class="meta">@ApiOperation</span>(value = <span class="string">"test swagger2"</span>)</span><br><span class="line">  <span class="comment">// 说明方法用了哪些参数</span></span><br><span class="line">  <span class="meta">@ApiImplicitParams</span>(</span><br><span class="line">    <span class="comment">// 针对每一个参数进行说明</span></span><br><span class="line">    <span class="meta">@ApiImplicitParam</span>(</span><br><span class="line">      name = <span class="string">"world"</span>,</span><br><span class="line">      value = <span class="string">"nonsense"</span>,</span><br><span class="line">      dataType = <span class="string">"String"</span>,</span><br><span class="line">      paramType = <span class="string">"query"</span>,</span><br><span class="line">      required = <span class="keyword">true</span></span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">  <span class="comment">// 说明方法有哪些返回值</span></span><br><span class="line">  <span class="meta">@ApiResponses</span>(value = &#123;</span><br><span class="line">    <span class="comment">// 针对每一种返回值进行说明</span></span><br><span class="line">    <span class="comment">// 每个方法内置了4种状态，200、401（认证失败）、403（禁止访问）、404（不存在）</span></span><br><span class="line">    <span class="comment">// 这里可以针对这些默认属性的说明修改，比如将“不存在”改为“资源不存在”</span></span><br><span class="line">    <span class="meta">@ApiResponse</span>(code = <span class="number">404</span>, message = <span class="string">"Resource not Found"</span>),</span><br><span class="line">    <span class="meta">@ApiResponse</span>(code = <span class="number">200</span>, message = <span class="string">"Hello World!"</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(@RequestParam String world)</span> </span>&#123; <span class="keyword">return</span> <span class="string">"hello"</span>; &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 在接口文档中不将此方法列入</span></span><br><span class="line">  <span class="meta">@ApiIgnore</span></span><br><span class="line">  <span class="meta">@RequestMapping</span>(method = RequestMethod.POST, value = <span class="string">"/swagger2/ignore"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">world</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"ignore"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，我们还有<code>@ApiModel</code>，但是这些不会一开始就显示在接口文档中，而是在点击每个接口中有一个<code>Try it!</code>按钮之后按照这个类型显示出来。虽然很方便，但也有不太方便的地方。很多教程中都会叫我们封装统一返回类型，于是在原有类型上使用注解就没有任何反馈了。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>随机森林算法</title>
    <url>/2020/09/19/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%AE%97%E6%B3%95%E6%A8%A1%E5%9E%8B/%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>随机森林算法，就像名字一样，是很多树构成的算法。可是随机又是什么？</strong></p>
<a id="more"></a>
<h2 id="随机森林的定义"><a href="#随机森林的定义" class="headerlink" title="随机森林的定义"></a>随机森林的定义</h2><blockquote>
<p>在机器学习中，随机森林是一个包含<strong>多个决策树</strong>的<strong>分类器</strong>， 并且其输出的类别是由个别树输出的类别的<strong>众数</strong>而定。</p>
<p>——摘自百度百科【<a href="https://baike.baidu.com/item/随机森林/1974765" target="_blank" rel="noopener">随机森林</a>】</p>
</blockquote>
<p>光是这句话就已经非常明确了。随机森林是一种<strong>用于分类</strong>的算法，其中包含了<strong>多个决策树</strong>。如果你暂时还不清楚什么是决策树，请<a href="/2020/09/23/人工智能/算法模型/决策树算法/">点击这里查看我以前的文章</a>。</p>
<p>如果再细致些呢？</p>
<h2 id="随机森林的思想"><a href="#随机森林的思想" class="headerlink" title="随机森林的思想"></a>随机森林的思想</h2><h2 id="随机森林的实现"><a href="#随机森林的实现" class="headerlink" title="随机森林的实现"></a>随机森林的实现</h2>]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>算法模型</tag>
      </tags>
  </entry>
  <entry>
    <title>TSNE</title>
    <url>/2020/09/17/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%AE%97%E6%B3%95%E6%A8%A1%E5%9E%8B/TSNE/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>“每个字母都认识，但是连在一起就莫名其妙起来了！”难免会有这样想的。毕竟只有首字母的话完全不知道他想说啥啊！</strong></p>
<a id="more"></a>
<h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p>我们先来看看<a href="https://scikit-learn.org/stable/auto_examples/manifold/plot_t_sne_perplexity.html#sphx-glr-auto-examples-manifold-plot-t-sne-perplexity-py" target="_blank" rel="noopener">一个例子</a></p>
<p>单纯的贴出所有的代码就没意思了。所以这里我将会用注释的方式来解释这个程序到底在干什么：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Author: Narine Kokhlikyan &lt;narine@slice.com&gt;</span></span><br><span class="line"><span class="comment"># License: BSD</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(__doc__) -- 不知道什么用</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导包：numpy，matplotlib，sklearn，time</span></span><br><span class="line"><span class="comment"># 如果你是ubuntu19及以上系统，请使用pip3安装依赖包，因为只内置了pip3</span></span><br><span class="line"><span class="comment"># 如果你是windows或者ubuntu19以下系统，你也可以使用pip下载依赖</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> matplotlib.ticker <span class="keyword">import</span> NullFormatter</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> manifold, datasets</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确定样本数量和支线数量</span></span><br><span class="line">n_samples = <span class="number">300</span></span><br><span class="line">n_components = <span class="number">2</span></span><br><span class="line"><span class="comment"># 绘制图片，图片中包含3行5列图表，每张图表宽15，长8</span></span><br><span class="line">(fig, subplots) = plt.subplots(<span class="number">3</span>, <span class="number">5</span>, figsize=(<span class="number">15</span>, <span class="number">8</span>))</span><br><span class="line"><span class="comment"># 设置不同的困惑度</span></span><br><span class="line">perplexities = [<span class="number">5</span>, <span class="number">30</span>, <span class="number">50</span>, <span class="number">100</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用sklearn库的make_circles方法生成同心圆</span></span><br><span class="line"><span class="comment"># 其中规定一共n_samples个点，两个圆圈的距离比例为0.5，异常点占比5%</span></span><br><span class="line"><span class="comment"># 函数将返回两个值：X - 生成的点集; y - 点集中每个样本的分类</span></span><br><span class="line">X, y = datasets.make_circles(n_samples=n_samples, factor=<span class="number">.5</span>, noise=<span class="number">.05</span>)</span><br><span class="line"><span class="comment"># 如果y是0，记为红色</span></span><br><span class="line">red = y == <span class="number">0</span></span><br><span class="line"><span class="comment"># 如果y是1，记为绿色</span></span><br><span class="line">green = y == <span class="number">1</span></span><br><span class="line"><span class="comment"># 创建第一个子图</span></span><br><span class="line">ax = subplots[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 将生成的模型分为两类：</span></span><br><span class="line"><span class="comment"># 1 - 记录为红色并绘制，x为第一类</span></span><br><span class="line">ax.scatter(X[red, <span class="number">0</span>], X[red, <span class="number">1</span>], c=<span class="string">"r"</span>)</span><br><span class="line"><span class="comment"># 2 - 记录为绿色</span></span><br><span class="line">ax.scatter(X[green, <span class="number">0</span>], X[green, <span class="number">1</span>], c=<span class="string">"g"</span>)</span><br><span class="line"><span class="comment"># 格式化刻度，这里选择了无格式</span></span><br><span class="line">ax.xaxis.set_major_formatter(NullFormatter())</span><br><span class="line">ax.yaxis.set_major_formatter(NullFormatter())</span><br><span class="line">plt.axis(<span class="string">'tight'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, perplexity <span class="keyword">in</span> enumerate(perplexities):</span><br><span class="line">    ax = subplots[<span class="number">0</span>][i + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    t0 = time()</span><br><span class="line">    tsne = manifold.TSNE(n_components=n_components, init=<span class="string">'random'</span>,</span><br><span class="line">                         random_state=<span class="number">0</span>, perplexity=perplexity)</span><br><span class="line">    Y = tsne.fit_transform(X)</span><br><span class="line">    t1 = time()</span><br><span class="line">    print(<span class="string">"circles, perplexity=%d in %.2g sec"</span> % (perplexity, t1 - t0))</span><br><span class="line">    ax.set_title(<span class="string">"Perplexity=%d"</span> % perplexity)</span><br><span class="line">    ax.scatter(Y[red, <span class="number">0</span>], Y[red, <span class="number">1</span>], c=<span class="string">"r"</span>)</span><br><span class="line">    ax.scatter(Y[green, <span class="number">0</span>], Y[green, <span class="number">1</span>], c=<span class="string">"g"</span>)</span><br><span class="line">    ax.xaxis.set_major_formatter(NullFormatter())</span><br><span class="line">    ax.yaxis.set_major_formatter(NullFormatter())</span><br><span class="line">    ax.axis(<span class="string">'tight'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Another example using s-curve</span></span><br><span class="line">X, color = datasets.make_s_curve(n_samples, random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">ax = subplots[<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">ax.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">2</span>], c=color)</span><br><span class="line">ax.xaxis.set_major_formatter(NullFormatter())</span><br><span class="line">ax.yaxis.set_major_formatter(NullFormatter())</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, perplexity <span class="keyword">in</span> enumerate(perplexities):</span><br><span class="line">    ax = subplots[<span class="number">1</span>][i + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    t0 = time()</span><br><span class="line">    tsne = manifold.TSNE(n_components=n_components, init=<span class="string">'random'</span>,</span><br><span class="line">                         random_state=<span class="number">0</span>, perplexity=perplexity)</span><br><span class="line">    Y = tsne.fit_transform(X)</span><br><span class="line">    t1 = time()</span><br><span class="line">    print(<span class="string">"S-curve, perplexity=%d in %.2g sec"</span> % (perplexity, t1 - t0))</span><br><span class="line"></span><br><span class="line">    ax.set_title(<span class="string">"Perplexity=%d"</span> % perplexity)</span><br><span class="line">    ax.scatter(Y[:, <span class="number">0</span>], Y[:, <span class="number">1</span>], c=color)</span><br><span class="line">    ax.xaxis.set_major_formatter(NullFormatter())</span><br><span class="line">    ax.yaxis.set_major_formatter(NullFormatter())</span><br><span class="line">    ax.axis(<span class="string">'tight'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Another example using a 2D uniform grid</span></span><br><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">1</span>, int(np.sqrt(n_samples)))</span><br><span class="line">xx, yy = np.meshgrid(x, x)</span><br><span class="line">X = np.hstack([</span><br><span class="line">    xx.ravel().reshape(<span class="number">-1</span>, <span class="number">1</span>),</span><br><span class="line">    yy.ravel().reshape(<span class="number">-1</span>, <span class="number">1</span>),</span><br><span class="line">])</span><br><span class="line">color = xx.ravel()</span><br><span class="line">ax = subplots[<span class="number">2</span>][<span class="number">0</span>]</span><br><span class="line">ax.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=color)</span><br><span class="line">ax.xaxis.set_major_formatter(NullFormatter())</span><br><span class="line">ax.yaxis.set_major_formatter(NullFormatter())</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, perplexity <span class="keyword">in</span> enumerate(perplexities):</span><br><span class="line">    ax = subplots[<span class="number">2</span>][i + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    t0 = time()</span><br><span class="line">    tsne = manifold.TSNE(n_components=n_components, init=<span class="string">'random'</span>,</span><br><span class="line">                         random_state=<span class="number">0</span>, perplexity=perplexity)</span><br><span class="line">    Y = tsne.fit_transform(X)</span><br><span class="line">    t1 = time()</span><br><span class="line">    print(<span class="string">"uniform grid, perplexity=%d in %.2g sec"</span> % (perplexity, t1 - t0))</span><br><span class="line"></span><br><span class="line">    ax.set_title(<span class="string">"Perplexity=%d"</span> % perplexity)</span><br><span class="line">    ax.scatter(Y[:, <span class="number">0</span>], Y[:, <span class="number">1</span>], c=color)</span><br><span class="line">    ax.xaxis.set_major_formatter(NullFormatter())</span><br><span class="line">    ax.yaxis.set_major_formatter(NullFormatter())</span><br><span class="line">    ax.axis(<span class="string">'tight'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>在这里面涉及了一些非常新颖的词汇：</p>
<h2 id="迷惑度"><a href="#迷惑度" class="headerlink" title="迷惑度"></a>迷惑度</h2><p>迷惑度，又称<code>perplexity</code>，是<code>NLP</code>算法中评价算法拟合度好坏的标准。虽然针对不同的问题，<code>perplexity</code>是越大越好还是越小越好并没有一个非常统一的答案。不过，在大多数情况下，迷惑度基本上是越小越好。</p>
<p>那么什么是迷惑度？我们来打个比方：</p>
<p>你家里的猫娘带着朋友来家里玩了。可是猫娘之间的交流就可以不说人话了，不管是肢体语言、腺体激素分泌还是尾巴的动作，都是她们交流的方式。这个时候你就非常的迷惑：“<strong>我是谁？我在哪？她们在说啥？</strong>”。突然，另一只猫娘冲着你“喵”了一声。突如其来的事情让你在风中零乱，<strong>迷惑度直接飙升到100%</strong>。</p>
<p>突然你家的猫娘看着你在不知所云的神情，用人话说明了她想吃饼干（<em>虽然看起来很没礼貌，但很可爱就原谅她了</em>）。<strong>你恍然大悟，迷惑度降到最低</strong>，然后像个侍奉主子的奴才一样端上了饼干。</p>
]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>算法模型</tag>
      </tags>
  </entry>
  <entry>
    <title>JWT简介</title>
    <url>/2020/09/15/Java/SpringBoot/JWT%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong><code>JWT</code>，全称<code>Json Web Token</code>，我们平常所说的<code>token</code>实际上就是说<code>JWT</code>技术中的<code>T</code>。</strong></p>
<a id="more"></a>
<h2 id="Session和Token的对比"><a href="#Session和Token的对比" class="headerlink" title="Session和Token的对比"></a><code>Session</code>和<code>Token</code>的对比</h2><p>如果你对<code>jsp</code>和<code>Servlet</code>非常熟悉，你应该对<code>Session</code>非常熟悉。每当用户登录的时候都会使用<code>Cookie</code>和<code>Session</code>联动起来，服务端使用<code>session.setAttribute()</code>方法完整地保存用户的信息，并使用<code>session.getAttribute()</code>方法完整地获取用户的信息。听起来非常方便？</p>
<p>可是呢，如果你读过我之前写的<a href="/2020/02/24/Java/面试常考/Session工作原理/"><code>Session</code>工作原理</a>，你会发现：<code>Session</code>对于服务器的压力还是相当大的。如果项目突然迎来了海量数据和大量并发，服务器宕机的概率大大增加，对于已经落地的项目甚至会产生不可逆转的错误。</p>
<p>于是，用户在线时就每时每刻维护一个<code>Session</code>的方法逐渐被摒弃；进而选择了用户每次请求的时候发送用户信息，顺便检查权限。一举两得，岂不美哉？<code>JWT</code>就应运而生了。在分布式场景中，仅在请求时服务器产生少许压力的<code>token</code>也就比始终给服务器施加压力并无法释放的<code>Session</code>更为实用。</p>
<h2 id="Token的结构"><a href="#Token的结构" class="headerlink" title="Token的结构"></a><code>Token</code>的结构</h2><p><code>Token</code>本质上是一串字符串，其中包含三个部分，三个部分分别是<strong>头部</strong>、<strong>负载</strong>和<strong>签名</strong>，每个部分由英文句号<code>.</code>来分开。</p>
<p>为什么这么做？因为这个字符串可以直接作为用户的标识，一旦被其他人截获，便能够直接作为请求使用。所以，我们往往会将这三个部分使用<code>Base64</code>算法进行编码，请求发送到服务器之后再将信息使用<code>Base64</code>算法进行解码。</p>
<h3 id="头部"><a href="#头部" class="headerlink" title="头部"></a>头部</h3><p><strong>头部</strong>主要是包含两段信息：<strong>数据类型</strong>和<strong>签名算法</strong>。</p>
<p><strong>数据类型</strong>一般是选择<code>JWT</code>作为数据类型，不同于一般的<code>Json</code>又不同于普通的字符串；</p>
<p><strong>签名算法</strong>一般是选择<code>HS256</code>，这也是官方推荐的算法。</p>
<h3 id="负载"><a href="#负载" class="headerlink" title="负载"></a>负载</h3><p>第二个部分则是<strong>负载</strong>，也作<strong>有效负载</strong>。其中包含了一些有必要的数据声明。比如，我们可以将用户<code>id</code>和用户权限码等等非常重要的信息。</p>
<p>但是呢，如果你发送的信息真的被截获了，还是会被很简单的解码获得了信息，所以只能在这部分只能尽可能不要放一些敏感信息，否则会被盗号。</p>
<p>同样的，这部分也会使用<code>Base64</code>算法编码。</p>
<h3 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h3><p><strong>签名</strong>就像是交付的时候有个安全员通过唯一指定的识别器来确认操作的用户确实是你，而不是其他的什么人。</p>
<p>所以签名这部分就是头部和负载的结合，再使用一个<strong>随机盐</strong>再次编码。每当用户发送请求的时候，服务器都会首先使用第一部分和第二部分使用<strong>只有服务器知道</strong>的随机盐加密，再和第三部分比对。加密后的信息和第三部分是相同的，那么就是正确的，本次识别器确认了用户信息，否则就是非法登录。</p>
<p>这个算法从逻辑上能够在一定程度上保证请求信息不会被其他用户非法使用。但是呢，这个算法还是不能够保证别有用心的人修改你的个人隐私。这就很无奈了。</p>
<h2 id="一个小例子"><a href="#一个小例子" class="headerlink" title="一个小例子"></a>一个小例子</h2><p>这个小例子虽然用到了<code>SpringBoot</code>，但是只使用了框架内的测试功能，单纯地使用命令行输出所有的结果。</p>
<p>由于我们并没有用到<code>SpringBoot</code>自带的测试类，所以就只是单纯地在<code>{项目根目录}/src/main/test/{自定义包名}</code>下新建<code>JWTTest.java</code>，并直接使用<code>JWT</code>工具类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJWT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// set expire time</span></span><br><span class="line">  Calendar calendar = Calendar.getInstance();</span><br><span class="line">  calendar.add(Calendar.SECOND, <span class="number">90</span>);</span><br><span class="line">  <span class="comment">// create jwt</span></span><br><span class="line">  HashMap&lt;String, Object&gt; headers = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  headers.put(<span class="string">"type"</span>, <span class="string">"JSON"</span>);</span><br><span class="line">  String token = JWT.create()</span><br><span class="line">                    .withHeader(headers)</span><br><span class="line">                    .withClaim(<span class="string">"user"</span>, <span class="string">"sakebow"</span>)</span><br><span class="line">                    .withClaim(<span class="string">"id"</span>, <span class="string">"20202104126"</span>)</span><br><span class="line">                    .withExpiresAt(calendar.getTime())</span><br><span class="line">                    .sign(Algorithm.HMAC256(<span class="string">"~@#sakebow?!~"</span>));</span><br><span class="line">  System.out.println(token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码运行之后就会生成一长串代码：</p>
<p><code>eyJ0eXAiOiJKV1QiLCJ0eXBlIjoiSlNPTiIsImFsZyI6IkhTMjU2In0.eyJpZCI6IjIwMjAyMTA0MTI2IiwiZXhwIjoxNjAwNjAwNjM1LCJ1c2VyIjoic2FrZWJvdyJ9.xigradwatkwZYO1QZJ98_sa6qH9L-_8uYyi5_HUSRjE</code></p>
<p>看起来毫无章法？不过没有关系，我们还能解码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDecodeJWT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  String token =  <span class="string">"eyJ0eXAiOiJKV1QiLCJ0eXBlIjoiSlNPTiIsImFsZyI6IkhTMjU2In0.eyJpZCI6IjIwMjAyMTA0MTI2IiwiZXhwIjoxNjAwNjAwNjM1LCJ1c2VyIjoic2FrZWJvdyJ9.xigradwatkwZYO1QZJ98_sa6qH9L-_8uYyi5_HUSRjE"</span>;</span><br><span class="line">  JWTVerifier jwtVerifier = JWT</span><br><span class="line">          .require(Algorithm.HMAC256(<span class="string">"~@#sakebow?!~"</span>))</span><br><span class="line">          .build();</span><br><span class="line">  DecodedJWT decodedJWT = jwtVerifier.verify(token);</span><br><span class="line">  System.out.println(decodedJWT.getHeader() + <span class="string">", "</span> + decodedJWT.getPayload());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>JWTVerifier</code>除了解码以外，还会核对前面两个部分合在一起加密是否与最后一段相等。同时，<code>JWT</code>还会经常变化，这也正为<code>JWT</code>提供了一定的安全性。</p>
<h2 id="随机盐"><a href="#随机盐" class="headerlink" title="随机盐"></a>随机盐</h2><p>不知道你们注意到没有，在<code>JWT</code>加密中有一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sign(Algorithm.HMAC256(<span class="string">"~@#sakebow?!~"</span>));</span><br></pre></td></tr></table></figure>
<p>实际上这个<code>~@#sakebow?!~</code>就是我们自己规定的<strong>随机盐</strong>，也就是根据这个片段对我们发送的数据进行加密。因为这个片段基本上只有开发着自己知道，所以安全性还是可以保证的。但是，安全性可不仅限于用户自己使用。</p>
<p>如果说其他别有用心的用户拿到了这个数据，伪造了其他人的信息，发送了非法请求，到了服务器结果就会被当成已经授权的人，然后回应请求。这将会让整个程序会变得非常危险。所以，这段随机盐<strong>决不可以保存在客户端</strong>。</p>
<p>是不是有点能理解了呢？</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>遗传算法</title>
    <url>/2020/09/15/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%AE%97%E6%B3%95%E6%A8%A1%E5%9E%8B/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>机器学习中有非常多的算法，遗传算法就是其中之一。正因为有所特点，所以才被人们广为使用。</strong></p>
<a id="more"></a>
<h2 id="遗传算法的定义"><a href="#遗传算法的定义" class="headerlink" title="遗传算法的定义"></a>遗传算法的定义</h2><blockquote>
<p>遗传算法是根据<strong>大自然中生物体进化规律</strong>而设计提出的，是模拟达尔文<strong>生物进化论</strong>的<strong>自然选择</strong>和<strong>遗传学机理</strong>的生物进化过程的<strong>计算模型</strong>，是一种通过模拟自然进化过程搜索<strong>最优解</strong>的方法。该算法通过数学的方式,利用计算机仿真运算,将问题的求解过程转换成类似生物进化中的<strong>染色体基因的交叉</strong>、<strong>变异</strong>等过程。在求解较为复杂的组合优化问题时,相对一些常规的优化算法,<strong>通常能够较快地获得较好的优化结果</strong>。</p>
<p>——摘自<a href="https://baike.baidu.com/item/遗传算法/838140" target="_blank" rel="noopener">百度百科【遗传算法】</a></p>
<p>遗传算法正是借鉴生物的自然选择和遗传进化机制而开发出的一种<strong>全局优化自适应概率搜索算法</strong>。</p>
<p>——摘自《遗传算法原理及应用》 周明，孙树陈 著</p>
</blockquote>
<p>知晓了这些，是不是有大概的概念了？也就是说，遗传算法是一种<strong>模拟自然界变异和选择的过程</strong>而诞生的算法，目的是为了<strong>较快地获得较好的结果</strong>，也就是相较于其他的机器学习算法有着更快的收敛速度。</p>
<p>为什么偏偏把这个算法叫做<strong>遗传</strong>算法？那是因为这个算法是一种<strong>进化算法</strong>，基本原理是效仿生物界中<strong>物竞天择，适者生存</strong>的演化法则。具体来说就是这个样子：</p>
<ul>
<li>在算法开始之前，所有的数据就作为一个<strong>生态圈</strong>出现在了我们的面前。</li>
<li>生态圈中的任何一个个体都遵循一样的规律：<strong>有血</strong>、<strong>有肉</strong>、<strong>要呼吸</strong>；也就是说这个数据集中需要按照一定的结构表示成基本相似的数据类型。</li>
<li>等到所有的生物都就位了之后（<em>数据集准备好了之后</em>），生态圈残酷的斗争和竞争就开始了。类比到数据集的筛选就是针对每个数据使用<strong>同一个适应度</strong>来评估数据的优劣。同样的，在这里优胜劣汰就对应这个筛选的过程，<strong>高</strong>于规定的适应度就能够<strong>保留</strong>下来，<strong>低</strong>于适应度的就会被<strong>剔除</strong>。<strong>多次迭代</strong>之后就会留下优秀的个体，也就是我们最终希望得到的结果。</li>
<li><strong>每个问题的适应度并不是千篇一律的</strong>，而是针对每一个不同的问题有完全不同的解决方案，就像是羚羊更擅长跑而狮子更擅长撕咬。</li>
</ul>
<p>算法思想又是如何呢？</p>
<ul>
<li><strong>选择</strong>：选择是为了能够选出优秀的个体，并使用这些个体产生后代</li>
<li><strong>交叉</strong>：如果是生物学，这里应该就是称为<strong>交配</strong>了。当然，这里是人为地选择一些个体进行信息交换，而不是任由这些数字胡乱交换</li>
<li><strong>变异</strong>：如果是生物学，这里应该就是对应<strong>基因突变</strong>了。当然，这里是人为地选择一些个体，按照一定的概率强行修改数据集中的某一个数据。</li>
</ul>
<h2 id="遗传算法的特点"><a href="#遗传算法的特点" class="headerlink" title="遗传算法的特点"></a>遗传算法的特点</h2><p>遗传算法之所以成为遗传算法，肯定是和生物学的“遗传”这个概念有很多是重合的。</p>
<ul>
<li>正因为遗传发生在单个个体上，所以算法能够<strong>独立</strong>地为每一个样本进行计算和筛选，<strong>并行性非常优秀</strong>；</li>
<li>因为遗传是所有生物<strong>通用</strong>的，所以算法也能够<strong>涵盖绝大多数的问题</strong>；</li>
<li>因为遗传能够通过自然选择使得一个物种<strong>在多个物种之间脱颖而出</strong>，所以具有<strong>非常优秀的全局优化性能</strong>；</li>
<li>因为有时我们可以通过<strong>人工配种</strong>的方式使得某一个基因比较突出，所以遗传算法也有着<strong>非常高的可操作性</strong>；</li>
</ul>
<p>当然，有优点就肯定有缺点。</p>
<ul>
<li>因为基因变异的概率极低，所以收敛速度也相当慢；</li>
<li>因为基因变异是完全随机的，能够产生适应环境的个体，也能够产生不适应环境的个体。所以在收敛结果上也不是一直很完美；</li>
</ul>
<p>但是，也正因为这些可靠的优点和突出的缺点，在一些领域上也是备受瞩目的，如：函数优化、<code>TSP</code>优化、生产调度、智能控制、模式识别等等。</p>
<h2 id="遗传算法流程简介"><a href="#遗传算法流程简介" class="headerlink" title="遗传算法流程简介"></a>遗传算法流程简介</h2><p>当然，算法最重要的是思考与实践。所以这里也讲一下《遗传算法原理及应用》一书中对遗传算法地解释。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>为了更好地根据我们的要求开展进化的选择，我们需要人工设定进化次数（<em>当然你也可以叫他“进化代数”，为了避开“代数”造成的歧义，我这里使用“次数”</em>）。</p>
<p>设置允许最多进化次数$T$，并记录当前已进行的进化次数$t$，也就是一开始设置$t=0$。</p>
<p>由于并没有具体的数据进行分析，所以这里我们选择随机生成一大批数据模拟一个群体$P$。所以，随机生成数量为$M$的个体组成初始群体$P(0)$。</p>
<h3 id="个体评价"><a href="#个体评价" class="headerlink" title="个体评价"></a>个体评价</h3><p>好了，大舞台已经准备好了，接下来就是相互交叉变异外加筛选了。逐个评估第$t$次进化保留下来的群体$P(t)$中每一个个体的适应度$adaptability$，这里就简写为$adp_i(t)$。</p>
<h3 id="选择运算"><a href="#选择运算" class="headerlink" title="选择运算"></a>选择运算</h3><p>刚刚我们已经得到了群体$P(t)$中每个个体的适应度，接下来就是通过和固定的标准适应度进行对比，剔除较低的个体、保留较高的个体，重新组成新的群体$P(t+1)$。</p>
<p>就像是大自然中的“<strong>物竞天择</strong>”一样，只不过现在你就是规则，逐一选择你希望获得的个体。</p>
<h3 id="交叉运算"><a href="#交叉运算" class="headerlink" title="交叉运算"></a>交叉运算</h3><p>直接说“交叉”可能不太好理解。所以，这里就直接使用生物界的词语：“交配”。</p>
<p>“交配”在生物学中就是整个种群进行基因交流的过程。通过不断的交配、产生后代，通过我们所熟知的遗传学定律，就能够在自然选择中选出一些优秀的个体。</p>
<p>同样的，交叉也就是让我们在数据集里面搜寻我们最希望在迭代中最希望出现的数据。</p>
<h3 id="变异运算"><a href="#变异运算" class="headerlink" title="变异运算"></a>变异运算</h3><p>刚刚使用了交叉运算，也就是“交配”，这个运算是能够使用遗传学定律产生较为优秀地数据。但是交配并不是严格地产生相应比例的后代，而是有一定的概率产生突变体。虽然概率很小，这也是该群体能够在严格的自然选择中最终保留下来的重要原因。</p>
<p>同样的，在遗传算法中，交叉就是使群体中的各种数据按照一定的比例进行交换。在这样的交换下，群体就有一定的概率向着你所期望的方向进化。从这个进化的群体里面筛选出优秀的个体，下一步进化也就会更快地朝着你所期望的方向继续进化。</p>
<h3 id="终止判断"><a href="#终止判断" class="headerlink" title="终止判断"></a>终止判断</h3><p>还记得我们初始化的时候获得的$T$吗？那就是终止判断的标志。只不过是到了应该停下来的时间而已，没有什么需要注意的点。把生于群体中得分最高的数据拉出来当最优解就好了。</p>
<h2 id="遗传算法数学原理"><a href="#遗传算法数学原理" class="headerlink" title="遗传算法数学原理"></a>遗传算法数学原理</h2><p>这一整套六个步骤下来就是遗传算法的全部内容了。到这里相信你还有很多不能理解的地方，接下来就是遗传算法的数学原理了。</p>
<p>首先我们需要确定一个先决条件：</p>
<ul>
<li>群体是有限个</li>
</ul>
<p>如果有无限的数据，比如从0到1的所有小数，这就没有任何的意义。</p>
<p>所以，我们能够拿到的数据应当是离散的。这里就用这组数据：</p>
<script type="math/tex; mode=display">
\left\{\begin{matrix}
  S&=&\{1,2,3,4,5,6,7\}\\
  x_1&\in&S\\
  x_2&\in&S
\end{matrix}\right.</script><p>这下最起码有$7*7=49$种排列组合。</p>
]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>算法模型</tag>
      </tags>
  </entry>
  <entry>
    <title>python进阶训练：聊天室</title>
    <url>/2020/08/20/python/%E8%80%81%E5%85%B5%E6%96%B0%E7%BB%83/python%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%EF%BC%9A%E8%81%8A%E5%A4%A9%E5%AE%A4/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>既然我们完成了基本的链表功能，相信也对<code>Python</code>语言有了一定的了解。那么我们现在开始进阶：<code>Python</code>聊天室（命令行版）。</strong></p>
<a id="more"></a>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>使用<code>UDP</code>代码库，使得两个进程之间得以通信。接收的时候直接输出到终端；发送的时候直接发送到指定端口，并使用死循环监听信息。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义全局变量udp</span></span><br><span class="line">udp = socket(AF_INET, SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_data</span><span class="params">(send_data, target_ip)</span>:</span></span><br><span class="line">  udp.sendto(send_data.encode(encoding = <span class="string">'utf-8'</span>), target_ip)</span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 接受数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recv_data</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="comment"># 拿到传输数据和源地址</span></span><br><span class="line">  socket_data, addr = udp.recvfrom(<span class="number">1024</span>)</span><br><span class="line">  <span class="comment"># 当前时间</span></span><br><span class="line">  current_time = time.strftime(<span class="string">'%Y-%m-%d %X'</span>, time.localtime(time.time()))</span><br><span class="line">  print(<span class="string">'================================================='</span>)</span><br><span class="line">  <span class="comment"># 输出到终端</span></span><br><span class="line">  print(<span class="string">f'now: <span class="subst">&#123;current_time&#125;</span>, IP: <span class="subst">&#123;addr[<span class="number">0</span>]&#125;</span>:<span class="subst">&#123;addr[<span class="number">1</span>]&#125;</span>\ncontent: <span class="subst">&#123;socket_data.decode(encoding = <span class="string">"utf-8"</span>)&#125;</span>'</span>)</span><br><span class="line">  print(<span class="string">'================================================='</span>)</span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>最后，我们在主函数中使用死循环监听这两个函数就好了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  <span class="comment"># 客户端1用8998端口</span></span><br><span class="line">  addr_bind = (<span class="string">''</span>, <span class="number">8998</span>)</span><br><span class="line">  udp.bind(addr_bind)</span><br><span class="line">  <span class="comment"># 客户端2用8999端口 / 本机IP192.168.1.111</span></span><br><span class="line">  target_ip = (<span class="string">'192.168.1.111'</span>, <span class="number">8999</span>)</span><br><span class="line">  <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    send_text = input(<span class="string">'say something: '</span>)</span><br><span class="line">    <span class="keyword">if</span> send_text == <span class="string">'bye'</span>:</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    <span class="comment"># 客户端1 - 先发送再接收</span></span><br><span class="line">    <span class="comment"># 客户端2 - 先接收再发送</span></span><br><span class="line">    send_data(send_text, target_ip)</span><br><span class="line">    recv_data()</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>到这里，简单的聊天室就完成了。</p>
<h2 id="结束？"><a href="#结束？" class="headerlink" title="结束？"></a>结束？</h2><p>你以为这样就能交作业了吗？<strong>还早着呢</strong>。这样只能实现两个端的交流，而且还只能限定从客户端1开始，从客户端2结束。作为多对多的<code>UDP</code>觉得自己非常吃亏，而且没有<code>GUI</code>的项目就不是一个好项目。</p>
<p>所以，在这里划一条线，我们将认真开始。</p>
<hr>
<h2 id="进阶1-添加服务器"><a href="#进阶1-添加服务器" class="headerlink" title="进阶1 - 添加服务器"></a>进阶1 - 添加服务器</h2><p><strong>前排提示</strong>：所有的文件都将放到<a href="https://github.com/sakebow/python-chat" target="_blank" rel="noopener"><code>GitHub</code></a>上，不会在这里花很多篇幅展示。所以希望学习的同学们可以两边结合起来看。</p>
<h3 id="综述"><a href="#综述" class="headerlink" title="综述"></a><strong>综述</strong></h3><p>就拿我们最常用的<strong>QQ</strong>和<strong>微信</strong>来说，都是由腾讯提供服务器，我们交流的时候首先提交到服务器上，然后再由服务器回显到各个客户端中。</p>
<p>所以，我们的首要目标就是<strong>建立服务器</strong>并让客户端和服务器能够<strong>正常连接</strong>。</p>
<p>首先我们需要明确服务器的功能。每次有数据提交到服务器的时候，服务器其实没有<strong>长期保留</strong>这个数据的必要，只不过是拿到了数据，并<strong>转发</strong>给所有的客户端而已。所以，实际上服务器只是需要做到<strong>接收</strong>和<strong>发送</strong>两个功能就足够了。</p>
<p>于是，这个项目的架构就差不多定下来了：</p>
<p>/ 根目录</p>
<p>┣ <code>config.py</code> 项目配置文件</p>
<p>┣ <code>ssocket.py</code> 基础socket实现类</p>
<p>┣ <code>server.py</code> 服务器实例类和功能实现</p>
<p>┣ <code>wrapper.py</code> 数据帧封装类</p>
<p>┗ <code>test.py</code> 输出测试类</p>
<p>看起来没什么毛病。就算有毛病估计你现在也是一脸蒙。接下来我将详细展开每个文件是干什么。</p>
<p>那么我们就开始准备了。既然是服务器的实现，那么就需要完善基本的网络通信，即<code>socket</code>库的具体业务实现。</p>
<h3 id="步骤一：确定基本配置项和底层实现方法"><a href="#步骤一：确定基本配置项和底层实现方法" class="headerlink" title="步骤一：确定基本配置项和底层实现方法"></a><strong>步骤一：确定基本配置项和底层实现方法</strong></h3><p><code>Python</code>的<code>socket</code>库和<code>C</code>语言的<code>socket</code>库有着异曲同工之妙，如果是使用<code>Ubuntu</code>系统编程的话应该能够很明显地感觉到这两者几乎很多都是相同的，只不过是再封装而已。发送就是<code>send()</code>，接收就是<code>recv()</code>。即：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">soc = socket()</span><br><span class="line"><span class="comment"># 发送 / 开辟大小为1024B的缓冲区，并对发送的Python对象使用*utf-8*编码为二进制数据</span></span><br><span class="line">soc.send(<span class="number">1024</span>).encode(<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="comment"># 接收 / 开辟大小为1024B的缓冲区，并对接收的二进制数据使用*utf-8*解码为Python对象</span></span><br><span class="line">soc.recv(<span class="number">1024</span>).decode(<span class="string">'utf-8)</span></span><br></pre></td></tr></table></figure>
<p>看起来没什么问题。但是如果就这么写进项目中，每次收发都这么写绝对很累赘，大量重复的<code>utf-8</code>和<code>1024</code>，如果有一天需要修改的话将会是一场恶梦。</p>
<p><strong>所以新建<code>config.py</code>记录配置。</strong></p>
<p>这里需要说明的是，如果是这么定义：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这是作为配置项很不*方便*的写法，仅供参考，请勿模仿</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SOCKET_CONFIG</span><span class="params">(object)</span>:</span></span><br><span class="line">  SOCKET_MAX_CACHE = <span class="number">1232896</span> <span class="comment"># 2的20次方</span></span><br><span class="line">  SOCKET_CHARSET_ENCODING = <span class="string">'utf-8'</span></span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>这样的话你的<code>SOCKET_MAX_CACHE</code>和<code>SOCKET_CHARSET_ENCODING</code>都被<code>Python</code>记为私有变量，不可访问。需要画很多时间构建<code>getter</code>和<code>setter</code>。虽然可以使用<code>@property</code>简化，但是需要我们手动编辑，而且我在<code>Ubuntu2004</code>中使用<code>VScode</code>直接编译不通过，他有自己的想法。所以我放弃了<code>@property</code>并选择了使用<strong>枚举类型</strong>简化：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SOCKET_CONFIG</span><span class="params">(Enum)</span>:</span> <span class="comment"># 继承Enum枚举类，属性直接用</span></span><br><span class="line">  SOCKET_MAX_CACHE = <span class="number">1232896</span></span><br><span class="line">  SOCKET_CHARSET_ENCODING = <span class="string">'utf-8'</span></span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>这样的话我们在任何地方就可以直接使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> config <span class="keyword">import</span> * <span class="comment"># 这么引入的前提是当前文件和config.py是同级</span></span><br><span class="line">a = SOCKET_CONFIG.SOCKET_MAX_CAHCE.value </span><br><span class="line"><span class="comment"># 枚举类直接用&#123;名称.value&#125;，直接使用名称得不到值</span></span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/sakebow/python-chat/blob/master/config.py" target="_blank" rel="noopener">点击这里查看config.py文件具体内容</a></p>
<p>当然，你也可以选择使用<code>yaml</code>、<code>properties</code>、<code>csv</code>、<code>json</code>和<code>xml</code>文件记录配置，这就看你愿意怎么使用了。如果想省事，直接用<code>py</code>吧；如果是想探索知识、需要构建大型项目或者说已经有一整套配置文件读取的代码库，建议使用单独的配置文件。</p>
<h3 id="步骤2：封装底层方法"><a href="#步骤2：封装底层方法" class="headerlink" title="步骤2：封装底层方法"></a><strong>步骤2：封装底层方法</strong></h3><p>使用<code>socket</code>创建专门针对某一个特定点的服务的时候，我们更倾向于使用端对端的<code>TCP/IP</code>协议，简单的说就是<strong>针对特定IP的特定端口号发送数据</strong>。根据这个定义我们就知道，需要我们确定<code>IP</code>和<code>端口号</code>，也就是在收发数据之前绑定<code>IP</code>和<code>端口号</code>。但是每一次都绑定肯定会显得累赘。</p>
<p><strong>所以我们创建<code>ssocket.py</code>封装<code>socket</code>用以绑定基本信息</strong></p>
<p>其中创建了继承自<code>socket.socket</code>的<code>ServerSocket</code>类，使用<code>AF_INET</code>协议（<code>TCP/IP</code>协议簇中的<code>IPv4</code>协议）和<code>SOCK_STREAM</code>（<code>TCP</code>流，即使用可靠的、端对端的连接进行通信；与之对应的是<code>SOCK_DGRAM</code>，是<code>UDP</code>流，不可靠的、多对多的连接进行通信）。</p>
<p>接着，我们使用<code>socket.bind()</code>方法传入<code>IP</code>信息和<code>端口号</code>。是以<strong>元组</strong>的形式传入的，即：<code>socket.bind((&#39;127.0.0.1&#39;, 8080))</code>。</p>
<p>最后，打开监听：<code>socket.listen(128)</code>。</p>
<p><a href="">点击这里查看ssocket.py文件具体内容</a></p>
<p>有了这个准备好的<code>ServerSocket</code>，我们就能开始准备<code>Server</code>实体类了。</p>
<p>在这里插入一个小技巧：</p>
<p><em><code>Server</code>类其实没有必要继承<code>ServerSocket</code>类，因为可以在<code>Server</code>类中使用<code>ServerSocket</code>对象；当然也可以继承，因为两者在本质上就是对<code>socket</code>进行操作，<code>Server</code>完全可以继承<code>ServerSocket</code>的操作，并在类内对<code>ServerSocket</code>进行拓展。</em></p>
<p>由于一个小项目，所以就不弄那么复杂了。直接使用实例化对象。</p>
<p><strong>所以接下来新建<code>server.py</code>，编辑<code>Server</code>类</strong></p>
<h3 id="步骤三：如何启动服务器"><a href="#步骤三：如何启动服务器" class="headerlink" title="步骤三：如何启动服务器"></a><strong>步骤三：如何启动服务器</strong></h3><p>定义了类之后，我们就需要开始定义具体的服务了。用过<code>Tomcat</code>的应该都知道，我们在配环境的时候会使用<code>startup</code>语句，所以我们这里也定义一个启动服务的<code>start</code>方法。</p>
<p>具体我们需要做什么呢？因为我们的监听已经开启了，所以我们需要做的就是等待客户端的连接，即使用<code>socket.accept()</code>方法获得两个返回值，一个是从客户端发送过来的数据帧，另一个则是数据源，也就是<strong>IP地址</strong>和<strong>端口号</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soc, addr = socket.accept()</span><br><span class="line"><span class="comment"># soc是包含了此次传输的内容二进制编码等很多种数据的套接字</span></span><br><span class="line"><span class="comment"># addr则是数据源，是个元组，addr[0]是IP，addr[1]是端口号</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拿到套接字我们可以顺势接收发送的数据，也能返回对套接字的响应</span></span><br><span class="line">print(soc.recv(<span class="number">1024</span>).decode(<span class="string">'utf-8'</span>)) <span class="comment"># 打印是为了查看是否正常</span></span><br><span class="line">soc.send(<span class="string">"hello world!"</span>.encode(<span class="string">'utf-8'</span>))</span><br></pre></td></tr></table></figure>
<p>当然，还是一样的问题：每次都这么做要重复太多的<code>utf-8</code>和<code>1024</code>，所以封装起来。</p>
<p><strong>所以我们新建<code>wrapper.py</code>封装客户端套接字</strong></p>
<p>由于我们之前已经将缓冲区大小、默认编码封装在了<code>config.py</code>里面，所以直接拿来使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recv_data</span><span class="params">(self)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> socket.recv(SOCKET_CONFIG.SOCKET_MAX_CACHE.value).decode(SOCKET_CONFIG.SOCKET_CHARSET_ENCODING.value)</span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_data</span><span class="params">(self, message)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> socket.send(message.encode(SOCKET_CONFIG.SOCKET_CHARSET_ENCODING.value))</span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>为了保证使用之后还能够关闭<code>socket</code>以释放资源，最后再加上一个关闭的方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">socket.close()</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/sakebow/python-chat/blob/master/wrapper.py" target="_blank" rel="noopener">点击这里查看wrapper.py文件内容</a></p>
<p>有了<code>wrapper</code>封装之后，我们就直接在<code>Server</code>类中使用<code>wrapper.py</code>定义的实例化对象，这里我定义的是<code>SocketWrapper</code>类，所以<code>Server</code>类在使用<code>accept</code>方法获得套接字后这么使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soc, addr = socket.accept()</span><br><span class="line">client_soc = SocketWrapper(soc)</span><br></pre></td></tr></table></figure>
<p>针对单个客户端的单次接入，我们直接使用我们封装好的<code>client_soc</code>就好了。因为是服务器，所以是先<strong>接收</strong>来自客户端的信息，再发送回显给客户端。最后，使用<code>wrapper,py</code>中封装好的<code>close</code>方法关闭连接释放资源。</p>
<p>具体来说就是这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 严重警告：此处的完整代码仅展示用，有缺陷，请勿模仿</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self)</span>:</span></span><br><span class="line">  <span class="comment"># 获得数据和数据源</span></span><br><span class="line">  soc, addr = self.server_socket.accept()</span><br><span class="line">  <span class="comment"># 绑定封装好的IP和端口，并开启监听</span></span><br><span class="line">  client_soc = SocketWrapper(soc)</span><br><span class="line">  <span class="comment"># 输出查看数据是否正确</span></span><br><span class="line">  print(client_soc.recv_data())</span><br><span class="line">  <span class="comment"># 回显客户端</span></span><br><span class="line">  client_soc.send_data(<span class="string">'connection established!'</span>)</span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>看起来没有问题，但是这样子一个客户端发完一条信息之后，整个服务进程都结束了，再也不能接收客户端传来的消息，除非重启服务器。每条信息都要重启服务器的话也实在是太反人类了。所以我们需要服务器一直在线，那么就加上一个死循环：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 严重警告：此处的完整代码仅展示用，有缺陷，请勿模仿</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self)</span>:</span></span><br><span class="line">  <span class="comment"># 获得数据和数据源</span></span><br><span class="line">  soc, addr = self.server_socket.accept()</span><br><span class="line">  <span class="comment"># 绑定封装好的IP和端口，并开启监听</span></span><br><span class="line">  client_soc = SocketWrapper(soc)</span><br><span class="line">  <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 输出查看数据是否正确</span></span><br><span class="line">    print(client_soc.recv_data())</span><br><span class="line">    <span class="comment"># 回显客户端</span></span><br><span class="line">    client_soc.send_data(<span class="string">'connection established!'</span>)</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>好了，客户端能够一直发信息了。</p>
<p>但是，这依然不够。这可是聊天室，客户端连接到服务器之后直接使用主进程的死循环收发信息，这样必然导致其他的<strong>任何客户端都不能和服务器交互</strong>，相当于莫名其妙的全员禁言了。这可要不得。</p>
<p>如果是以前用过<code>SpringBoot</code>开发<code>Web</code>的话，应该非常熟悉<code>@Asyn</code>这个注解，也就是使用子进程实现来自<code>Controller</code>的请求、调用<code>Service</code>的方法、操作<code>Dao</code>的接口等等。为何不借鉴一下这种思想呢？</p>
<p>所有的客户端一旦接入服务器便立马开启新的子进程，让所有的交互在子进程中完成。这样的话，主进程就可以完完全全地监听信息的接入，就像是<strong>前台接待</strong>一样，全权负责将到店的客户送到指定的房间（<em>子进程</em>）中。这就完成了<code>Server</code>的最终版。</p>
<p><a href="https://github.com/sakebow/python-chat/blob/master/server.py" target="_blank" rel="noopener">点击这里查看server.py文件具体内容</a></p>
<p>最后，我们来测试一下结果如何。</p>
<p><strong>这里就新建<code>test.py</code>来模拟客户端发送<code>socket</code>到服务器</strong></p>
<p><a href="https://github.com/sakebow/python-chat/blob/master/test.py" target="_blank" rel="noopener">点击这里查看<code>test.py</code>文件内容</a></p>
<p>到这里，这个聊天室就能够支持多个客户端收发信息、服务器处理多个请求了。但是他依然存在一个问题：<strong>不能显示其他人发送的信息</strong>。</p>
<p>而给其他人发送信息则又必须使用<code>socket</code>给其他<code>IP</code>发送消息。可是服务器一次只能处理一个请求，这就导致<strong>每次处理的时候只能弄到一个<code>IP</code>地址</strong>。虽然你可以写在文件里，但是这就把一个小项目写复杂了，也因为增加了硬盘的<code>IO</code>而大大降低了速度。所以，为了能够将速度发挥到极致，我这里使用<strong>单线程多路复用</strong>的<code>redis</code>来保存<strong>注册的用户信息</strong>和<strong>登录的用户信息</strong>。你可能会想这不是一样的么？<strong>实际上不一样</strong>。因为登录信息是需要写在当前在线人数表中的，同时服务器也只能给当前在线的人发送信息，否则给不在线的用户发送信息时会因为连接未建立<strong>给每个人抛了个错</strong>，结果所有在线的人一脸蒙逼地给不在线的人背锅。这明显不合理。</p>
<p>当然，还有一个优点就是<code>redis</code>还能当非关系型数据库使用，可以用于聊天记录的保存。这就是后话了。</p>
<p>那么问题来了，既然需要<code>redis</code>就需要服务器跑起来。所以这里就使用<code>Docker</code>运行一个简单的<code>redis</code>服务器。</p>
<p>首先准备<code>docker-compose.yml</code>文件，用于<code>docker</code>镜像的构建：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">redis-30xx:</span> <span class="comment"># 因为端口号不好记，所以记录端口号前两位到三位</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">'redis:latest'</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">'redis-30xx'</span> <span class="comment"># 方便以后避开这些端口号，名字也改改</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">'3079:6379'</span> <span class="comment"># 使用30xx端口映射默认的6379</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/usr/local/docker/redis/config:/conf</span> <span class="comment"># 配置文件</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/usr/local/docker/redis/data:/data</span> <span class="comment"># 数据文件</span></span><br></pre></td></tr></table></figure>
<p>然后在你的<code>Ubuntu</code>系统下使用超管权限运行<code>docker-compose up -d</code>，这样你的<code>redis</code>就启动起来了。</p>
<p>这里由于需要操作两个用户组，所以使用<code>redis</code>的集合和<code>python</code>的集合相对应，都是<code>sadd</code>方法用于添加用户，应用在登录和注册上；而<code>srem</code>用于移除用户，应用在用户注销上。</p>
<h2 id="进阶2-GUI"><a href="#进阶2-GUI" class="headerlink" title="进阶2 - GUI"></a>进阶2 - <code>GUI</code></h2><p>这里就直接使用<code>PyQT</code>作为<code>GUI</code>的搭建。虽然有<code>Qt Creator</code>用来简便绘制用户界面，但是底层却是<code>C++</code>。为了保证这个教程不掺杂一点与<code>Python</code>无关的东西，并为了能够让<code>Python</code>体现出网络编程中标准库的便捷性，这里直接使用一整套<code>Python</code>解决方案。</p>
<p>既然我们用的最熟悉的是QQ和微信，那么我们就干脆模仿微信的界面。当然，因为技术原因不能很好的模仿，所以就干脆就作出一点点小小的改变。不会很离谱，但也相当乱来。</p>
]]></content>
      <categories>
        <category>编程进阶综合测验</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础综合：链表</title>
    <url>/2020/08/17/python/%E8%80%81%E5%85%B5%E6%96%B0%E7%BB%83/python%E5%9F%BA%E7%A1%80%E7%BB%BC%E5%90%88%EF%BC%9A%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>因为研究生生涯开始了，所以需要暂时停掉<code>Java</code>的学习，开始使用<code>Python</code>的学习和实践了。于是花了一个小时从完全没学过到实现了最基础的单链表。这里就记录一下。</strong></p>
<a id="more"></a>
<h2 id="链表结构复习"><a href="#链表结构复习" class="headerlink" title="链表结构复习"></a>链表结构复习</h2><p>首先我们回顾链表由什么构成。在<code>C</code>语言中，对链表的定义就是：</p>
<blockquote>
<p>链表是一种动态数据结构。它主要是利用动态内存分配、使用结构体并配合之镇来实现的一种数据结构。</p>
<p>——摘自《C语言程序设计（第三版）》苏小红、王宇颖、孙志岗等编著</p>
</blockquote>
<p>也就是说，链表有以下几个特点：</p>
<ul>
<li><p>是类似数组的链式结构</p>
</li>
<li><p>内存分配并不像数组一样完全连续</p>
</li>
<li><p>每个节点使用结构体，每个节点也就有了更高的自由度和更大的存储量</p>
</li>
<li><p>下一个节点的位置保存在上一个节点中</p>
</li>
</ul>
<h2 id="Python对比预习"><a href="#Python对比预习" class="headerlink" title="Python对比预习"></a><code>Python</code>对比预习</h2><p>复习了链表之后，让我们再看看<code>Python</code>语言相对于<code>C</code>语言和<code>Java</code>有什么不同：</p>
<ul>
<li><p>不需要显式声明<code>private</code>、<code>protected</code>和<code>public</code></p>
</li>
<li><p>对象名直接对应对象的地址，这一点和<code>Java</code>非常相似</p>
</li>
<li><p>没有括号限制函数体，直接用缩进表示</p>
</li>
<li><p><code>None</code>对应<code>C</code>语言和<code>Java</code>的<code>null</code></p>
</li>
<li><p><code>self</code>代替了<code>C</code>语言和<code>Java</code>的<code>this</code>指针</p>
</li>
<li><p>魔法函数<code>__init__</code>直接定义了结构体的属性构成，而不需要显式定义结构体具体有哪些属性</p>
</li>
</ul>
<p>主要就是这些了。具体的细节我们遇到了再去查<a href="https://www.runoob.com/python3/python3-tutorial.html" target="_blank" rel="noopener"><strong>菜鸟教程</strong></a>就好了。当然，如果能够直接查<a href="https://docs.python.org/zh-cn/3/" target="_blank" rel="noopener"><code>Python</code></a>官方文档更好，毕竟都贴心地给出了中文版（但是点进去每个函数的解释还是<strong>英文</strong>，而且没有实例）。</p>
<h2 id="从节点的定义开始编码"><a href="#从节点的定义开始编码" class="headerlink" title="从节点的定义开始编码"></a>从节点的定义开始编码</h2><p>那么，为了先熟悉<code>Python</code>的语法，我们先来个小小的结构体试试水：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="comment"># 链表节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data, next, index)</span>:</span></span><br><span class="line">    self.data = data</span><br><span class="line">    self.next = next</span><br><span class="line">    self.index = index</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试节点</span></span><br><span class="line">node = Node(<span class="number">0</span>, <span class="literal">None</span>, <span class="number">0</span>)</span><br><span class="line">print(node.data)</span><br></pre></td></tr></table></figure>
<p>当然，没有悬念，输出<code>0</code>。</p>
<p>第一行首先是确认字符编码。默认是<code>UTF-8</code>，根据需要可以更换成别的；其次是使用<code>__init__</code>函数定义一个具有三个属性的类作为结构体；最后的pass则是占位符，表示一个域的结束，相当于<code>}</code>。因为<code>Python</code>直接使用缩进表示是否结束，所以这个仅仅作为个人习惯出现在这里。</p>
<h2 id="从链表的功能开始完善"><a href="#从链表的功能开始完善" class="headerlink" title="从链表的功能开始完善"></a>从链表的功能开始完善</h2><p>既然我们完成了节点的构造，那么我们一口气把整个链表攻下来吧！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Link</span>:</span></span><br><span class="line">  <span class="comment"># 初始化 / 不需要参数，自带空的头节点</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.head = <span class="literal">None</span></span><br><span class="line">    self.length = <span class="number">0</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  <span class="comment"># 尾插法插入数据</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">insert_tail</span><span class="params">(self, index, data)</span>:</span></span><br><span class="line">    <span class="comment"># 当尾节点为空时，使用头插法确定尾节点</span></span><br><span class="line">    <span class="keyword">if</span> self.tail <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">      self.insert_head(index, data)</span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    <span class="comment"># 在尾节点非空时往后接节点</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      node = Node(data, <span class="literal">None</span>, index)</span><br><span class="line">      self.tail.next = node</span><br><span class="line">      self.tail = node</span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  <span class="comment"># 头插法插入数据</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">insert_head</span><span class="params">(self, index, data)</span>:</span></span><br><span class="line">    node = Node(data, self.head, index)</span><br><span class="line">    self.head = node</span><br><span class="line">    self.length += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 当只有一个元素的时候，确定尾节点</span></span><br><span class="line">    <span class="keyword">if</span> self.length == <span class="number">1</span>:</span><br><span class="line">      self.tail = node</span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  <span class="comment"># 输出链表 / 从头开始顺序输出</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">output</span><span class="params">(self)</span>:</span></span><br><span class="line">    node = self.head</span><br><span class="line">    <span class="keyword">while</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">      print(<span class="string">f'<span class="subst">&#123;node.index&#125;</span>: <span class="subst">&#123;node.data&#125;</span>'</span>, end = <span class="string">' '</span>)</span><br><span class="line">      node = node.next</span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    print()</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">link = Link()</span><br><span class="line">link.insert_head(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">link.insert_tail(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">link.output()</span><br></pre></td></tr></table></figure>
<p>在这里的<code>self</code>关键字在<strong>函数体内</strong>就是<strong>作为<code>this</code>指针</strong>使用，而作为<strong>参数</strong>出现的时候就是声明该函数是一个<strong>成员函数</strong>。后面有一句：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">f'<span class="subst">&#123;node.index&#125;</span>: <span class="subst">&#123;node.data&#125;</span>'</span>, end = <span class="string">' '</span>)</span><br></pre></td></tr></table></figure>
<p>这是<code>Python</code>3.6以后的新特性，使用<code>f</code>直接将字符串格式化，另外使用<code>end</code>规定输出结尾是空格而不是默认的换行结尾。</p>
<p>于是，这次的输出就是：<code>1:2 3:4</code>。</p>
<h2 id="全自动构造链表"><a href="#全自动构造链表" class="headerlink" title="全自动构造链表"></a>全自动构造链表</h2><p>但是这还差一个输入。不想一个字一个字输入的我直接定义了一个随机生成的函数，让链表自己随便生成什么东西。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文件开头加上：</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">LETTERS = <span class="string">'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'</span></span><br><span class="line">LETTERS_LEN = len(LETTERS)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在Link类中添加成员函数</span></span><br><span class="line"><span class="comment"># 随机生成链表</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_link</span><span class="params">(self)</span>:</span></span><br><span class="line">  size = random.randint(<span class="number">0</span>, <span class="number">20</span>)</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, size):</span><br><span class="line">    self.insert_tail(i + <span class="number">1</span>, LETTERS[random.randint(<span class="number">0</span>, LETTERS_LEN - <span class="number">1</span>)])</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 全自动生成</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  link = Link()</span><br><span class="line">  link.random_link()</span><br><span class="line">  link.output()</span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>于是每次编译输出都有完全不一样的结果。</p>
<p>好了，到这里构造链表就没有什么大问题了。</p>
<h2 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h2><p>接下来就是很恼人的删除节点了。和<code>C++</code>一样，可以直接使用<code>del</code>命令显式删除对象。值得一提的是，这里显式删除之后只是将内存标记为“<strong>可使用</strong>”，该部分内存并没有被回收。之后<code>GC</code>会过来打扫的。</p>
<p>为了能够保持数组每次都是一致的，方便查看位置，这里添加了文件读取，能够在每次运行的时候从<code>linklist.csv</code>中读取一模一样的数据。</p>
<p>数据文件<code>linklist.csv</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">3</span><br><span class="line">1000</span><br><span class="line">7</span><br><span class="line">p</span><br><span class="line">q</span><br><span class="line">h</span><br><span class="line">@</span><br><span class="line">!</span><br><span class="line">,</span><br><span class="line">&gt;</span><br><span class="line">shift</span><br></pre></td></tr></table></figure>
<p>然后是读取文件并删掉<code>readline</code>方法读取时最后的字符<code>\n</code>误读的情况：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 读取固定的链表</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_file</span><span class="params">(self, filepath)</span>:</span></span><br><span class="line">  index = <span class="number">1</span></span><br><span class="line">  <span class="keyword">with</span> open(filepath, <span class="string">'r'</span>) <span class="keyword">as</span> lines:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">      self.insert_tail(index, line.rstrip(<span class="string">'\n'</span>))</span><br><span class="line">      index += <span class="number">1</span></span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>接着是删除某个位置的节点。这里虽然没有难点，但是很难在细节上保持平衡。需要考虑以下几种情况：</p>
<ul>
<li><p>链表<strong>没有节点</strong></p>
</li>
<li><p>链表<strong>有且仅有</strong>一个节点</p>
</li>
<li><p>中间<strong>任意位置</strong>删除</p>
</li>
<li><p>要删除的是<strong>第一个元素</strong></p>
</li>
<li><p>要删除的是<strong>最后一个元素</strong></p>
</li>
</ul>
<p>如果面面俱到，代码一定会纷繁复杂。所以我们需要根据这些非常神奇的地方巧妙避雷：</p>
<ul>
<li><p>如果链表没有节点，<strong>直接结束</strong></p>
</li>
<li><p>如果链表仅一个节点，删除时需要同时解除<code>head</code>指针、<code>tail</code>指针，<strong>避免指针指了个寂寞</strong>，然后一脸哀怨的给你报了个错</p>
</li>
<li><p>在删除的时候，使用临时指针<code>node</code>指向<code>head</code>指针或者<code>tail</code>指针，并删除<code>node</code>指针的时候，你会发现<code>head</code>和<code>tail</code>实际指向的地址依然存在原有的实例对象。所以实际步骤应当是<strong>先重置原先指向需要删除地址的指针，再删除临时指针</strong></p>
</li>
<li><p>删除的时候需要在最后修改链表长度，避免下次使用的时候<strong>索引超限</strong></p>
</li>
</ul>
<h2 id="删除节点实现"><a href="#删除节点实现" class="headerlink" title="删除节点实现"></a>删除节点实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用索引删除节点</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_node_by_index</span><span class="params">(self, index)</span>:</span></span><br><span class="line">  <span class="comment"># 没有节点</span></span><br><span class="line">  <span class="keyword">if</span> self.head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  <span class="comment"># 删除头</span></span><br><span class="line">  <span class="keyword">elif</span> index == <span class="number">1</span>:</span><br><span class="line">    node = self.head</span><br><span class="line">    self.head = self.head.next</span><br><span class="line">    <span class="keyword">del</span> node</span><br><span class="line">    <span class="comment"># 检查是不是只有这个节点</span></span><br><span class="line">    <span class="comment"># 如果无视tail，head将会为None而tail保持原样</span></span><br><span class="line">    <span class="keyword">if</span> self.head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">      self.tail = self.head</span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  <span class="comment"># 中间任意位置删除</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    node = self.get_node(index - <span class="number">1</span>)</span><br><span class="line">    temp = node.next</span><br><span class="line">    <span class="keyword">if</span> temp <span class="keyword">is</span> self.tail:</span><br><span class="line">      node.next = <span class="literal">None</span></span><br><span class="line">      self.tail = node</span><br><span class="line">      <span class="keyword">del</span> temp</span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      node.next = temp.next</span><br><span class="line">      <span class="keyword">del</span> temp</span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>然后我们来测试一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 测试删除是否成功</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  link = Link()</span><br><span class="line">  link.read_file(<span class="string">'/home/sakebow/python/linklist/linklist.csv'</span>)</span><br><span class="line">  link.delete_node_by_index(link.length)</span><br><span class="line">  link.output()</span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>这里要强调的是<code>read_file</code>命令需要<strong>完整的绝对路径</strong>，否则无法读取文件。</p>
<p>当然，很完美地删掉了最后一个元素：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1: 1 2: 2 3: 3 4: 10 5: 11 6: a 7: b 8: 3 9: 1000 10: 7 11: p 12: q 13: h 14: @ 15: ! 16: , 17: &gt;</span><br></pre></td></tr></table></figure>
<h2 id="删除节点进阶"><a href="#删除节点进阶" class="headerlink" title="删除节点进阶"></a>删除节点进阶</h2><p>接着我们再来完善匹配所有项的方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 匹配内容删除节点</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_node_by_data</span><span class="params">(self, data)</span>:</span></span><br><span class="line">  <span class="comment"># 强行改为有头节点的链表 / 内容随意，仅需保证next指向head</span></span><br><span class="line">  node = Node(<span class="string">'a'</span>, self.head, <span class="number">0</span>)</span><br><span class="line">  <span class="comment"># 保持标识，最后需要删除</span></span><br><span class="line">  <span class="comment"># 如果head移动了也不要紧，node将会控制下一跳的位置</span></span><br><span class="line">  stay_head = node</span><br><span class="line">  <span class="comment"># 游标，规定temp为必删项，node为上一项</span></span><br><span class="line">  temp = self.head</span><br><span class="line">  <span class="comment"># 遍历链表</span></span><br><span class="line">  <span class="keyword">while</span> temp <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="comment"># 如果要删第一个</span></span><br><span class="line">    <span class="keyword">if</span> temp <span class="keyword">is</span> self.head <span class="keyword">and</span> temp.data == data:</span><br><span class="line">      <span class="comment"># 先重置</span></span><br><span class="line">      node.next = temp.next</span><br><span class="line">      <span class="comment"># 检查tail</span></span><br><span class="line">      <span class="keyword">if</span> temp <span class="keyword">is</span> self.tail:</span><br><span class="line">        self.tail = self.head = node.next</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">      <span class="comment"># 再删除</span></span><br><span class="line">      <span class="keyword">del</span> temp</span><br><span class="line">      <span class="comment"># 因为下次循环依然需要使用temp，所以重置为node下一跳</span></span><br><span class="line">      temp = node.next</span><br><span class="line">      <span class="comment"># 修改长度</span></span><br><span class="line">      self.length -= <span class="number">1</span></span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    <span class="comment"># 中间任意项删除</span></span><br><span class="line">    <span class="comment"># 原理同上</span></span><br><span class="line">    <span class="keyword">elif</span> temp <span class="keyword">is</span> <span class="keyword">not</span> self.head <span class="keyword">and</span> temp.data == data:</span><br><span class="line">      node.next = temp.next</span><br><span class="line">      <span class="keyword">if</span> temp <span class="keyword">is</span> self.tail:</span><br><span class="line">        self.tail = node</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">      <span class="keyword">del</span> temp</span><br><span class="line">      temp = node.next</span><br><span class="line">      self.length -= <span class="number">1</span></span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    <span class="comment"># 如果不匹配，全部下一跳，且长度不变</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      temp = temp.next</span><br><span class="line">      node = node.next</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  <span class="comment"># 最终删除辅助节点</span></span><br><span class="line">  <span class="keyword">del</span> stay_head</span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>那我们来测试一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  link = Link()</span><br><span class="line">  link.read_file(<span class="string">'/home/sakebow/python/linklist/linklist.csv'</span>)</span><br><span class="line">  <span class="comment"># 因为数据集里面3出现了两次，所以选择3</span></span><br><span class="line">  link.delete_node_by_data(<span class="string">'3'</span>)</span><br><span class="line">  link.output()</span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>当然，最终结果把两个3全部删掉了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1: 1 2: 2 4: 10 5: 11 6: a 7: b 9: 1000 10: 7 11: p 12: q 13: h 14: @ 15: ! 16: , 17: &gt; 18: shift</span><br></pre></td></tr></table></figure>
<p>也没有问题！</p>
<p>当然你也可以使用各种各样的数据测试。就算是60万行数据也能用$1’32’’$秒给出答案。（<em>实际测量可能和电脑运算能力有误差</em>）</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后，为了代码简洁、项目结构清晰，我们将各个部分拆开。这里贴上各个部分的文件内容：</p>
<h3 id="Node-py"><a href="#Node-py" class="headerlink" title="Node.py"></a>Node.py</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 链表节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data, next, index)</span>:</span></span><br><span class="line">    self.data = data</span><br><span class="line">    self.next = next</span><br><span class="line">    self.index = index</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h3 id="Link-py"><a href="#Link-py" class="headerlink" title="Link.py"></a>Link.py</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Node <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># 链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Link</span>:</span></span><br><span class="line">  <span class="comment"># 初始化 / 不需要参数，自带空的头节点</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.head = <span class="literal">None</span></span><br><span class="line">    self.tail = <span class="literal">None</span></span><br><span class="line">    self.length = <span class="number">0</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 尾插法插入数据</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">insert_tail</span><span class="params">(self, index, data)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> self.tail <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">      self.insert_head(index, data)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      node = Node(data, <span class="literal">None</span>, index)</span><br><span class="line">      self.tail.next = node</span><br><span class="line">      self.tail = node</span><br><span class="line">      self.length += <span class="number">1</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 头插法插入数据 </span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">insert_head</span><span class="params">(self, index, data)</span>:</span></span><br><span class="line">    node = Node(data, self.head, index)</span><br><span class="line">    self.head = node</span><br><span class="line">    self.length += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 当只有一个元素的时候，确定尾节点</span></span><br><span class="line">    <span class="keyword">if</span> self.length == <span class="number">1</span>:</span><br><span class="line">      self.tail = node</span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 输出链表</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">output</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> self.head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">      print(<span class="string">'Nothing'</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      node = self.head</span><br><span class="line">      <span class="keyword">while</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        print(<span class="string">f'<span class="subst">&#123;node.index&#125;</span>: <span class="subst">&#123;node.data&#125;</span>'</span>, end=<span class="string">' '</span>)</span><br><span class="line">        node = node.next</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">      print()</span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 随机生成链表</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">random_link</span><span class="params">(self)</span>:</span></span><br><span class="line">    size = random.randint(<span class="number">0</span>, <span class="number">20</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, size):</span><br><span class="line">      self.insert_tail(i + <span class="number">1</span>, LETTERS[random.randint(<span class="number">0</span>, LETTERS_LEN - <span class="number">1</span>)])</span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 读取固定的链表</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">read_file</span><span class="params">(self, filepath)</span>:</span></span><br><span class="line">    index = <span class="number">1</span></span><br><span class="line">    <span class="keyword">with</span> open(filepath, <span class="string">'r'</span>) <span class="keyword">as</span> lines:</span><br><span class="line">      <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        self.insert_tail(index, line.rstrip(<span class="string">'\n'</span>))</span><br><span class="line">        index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 通过索引获得指定节点</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get_node</span><span class="params">(self, index)</span>:</span></span><br><span class="line">    node = self.head</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, index):</span><br><span class="line">      node = node.next</span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 匹配内容删除节点</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">delete_node_by_data</span><span class="params">(self, data)</span>:</span></span><br><span class="line">    <span class="comment"># 强行改为有头节点的链表</span></span><br><span class="line">    node = Node(<span class="string">'a'</span>, self.head, <span class="number">0</span>)</span><br><span class="line">    <span class="comment"># 保持标识，最后需要删除</span></span><br><span class="line">    stayHead = node</span><br><span class="line">    <span class="comment"># 游标，规定temp为必删项，node为上一项</span></span><br><span class="line">    temp = self.head</span><br><span class="line">    <span class="keyword">while</span> temp <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">      <span class="keyword">if</span> temp <span class="keyword">is</span> self.head <span class="keyword">and</span> temp.data == data:</span><br><span class="line">        node.next = self.head = temp.next</span><br><span class="line">        <span class="keyword">if</span> temp <span class="keyword">is</span> self.tail:</span><br><span class="line">          self.tail = self.head = node.next</span><br><span class="line">          <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">del</span> temp</span><br><span class="line">        temp = node.next</span><br><span class="line">        self.length -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">      <span class="keyword">elif</span> temp <span class="keyword">is</span> <span class="keyword">not</span> self.head <span class="keyword">and</span> temp.data == data:</span><br><span class="line">        node.next = temp.next</span><br><span class="line">        <span class="keyword">if</span> temp <span class="keyword">is</span> self.tail:</span><br><span class="line">          self.tail = node</span><br><span class="line">          <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">del</span> temp</span><br><span class="line">        temp = node.next</span><br><span class="line">        self.length -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">        temp = temp.next</span><br><span class="line">        node = node.next</span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">del</span> stayHead</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 使用索引删除节点</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">delete_node_by_index</span><span class="params">(self, index)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> self.head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">elif</span> index == <span class="number">1</span>:</span><br><span class="line">      node = self.head</span><br><span class="line">      self.head = self.head.next</span><br><span class="line">      <span class="keyword">if</span> self.head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        self.tail = self.head</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">      <span class="keyword">del</span> node</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      node = self.get_node(index - <span class="number">1</span>)</span><br><span class="line">      temp = node.next</span><br><span class="line">      <span class="keyword">if</span> temp <span class="keyword">is</span> self.tail:</span><br><span class="line">        node.next = <span class="literal">None</span></span><br><span class="line">        self.tail = node</span><br><span class="line">        <span class="keyword">del</span> temp</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">        node.next = temp.next</span><br><span class="line">        <span class="keyword">del</span> temp</span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h3 id="linklist-csv"><a href="#linklist-csv" class="headerlink" title="linklist.csv"></a>linklist.csv</h3><p>这个文件后来我改得非常大，一共22932行数据，不方便展开，各位可以自行<a href="https://github.com/sakebow/python-linklist/blob/master/linklist.csv" target="_blank" rel="noopener">点击我的<code>GitHub</code></a>下载。</p>
<h3 id="linklist-py（主文件）"><a href="#linklist-py（主文件）" class="headerlink" title="linklist.py（主文件）"></a>linklist.py（主文件）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> Link <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">LETTERS = <span class="string">'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'</span></span><br><span class="line">LETTERS_LEN = len(LETTERS)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  link = Link()</span><br><span class="line">  link.read_file(<span class="string">'/home/sakebow/python/linklist/linklist.csv'</span>)</span><br><span class="line">  <span class="comment"># 测试</span></span><br><span class="line">  link.delete_node_by_data(<span class="string">'3'</span>)</span><br><span class="line">  link.output()</span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>如果觉得大段大段的代码在这里看不怎么清楚的话，直接在<a href="https://github.com/sakebow/python-linklist" target="_blank" rel="noopener">我的GitHub</a>中下载也可以。</p>
]]></content>
      <categories>
        <category>编程基础综合测验</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>回老家的四天假期</title>
    <url>/2020/08/06/diary/%E5%9B%9E%E8%80%81%E5%AE%B6%E7%9A%84%E5%9B%9B%E5%A4%A9%E5%81%87%E6%9C%9F/</url>
    <content><![CDATA[<script src="/crypto-js.js"></script><script src="/mcommon.js"></script><h3 id="encrypt-message">如果你坚持要看，请联系我。</h3><link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.min.css"> <link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap-theme.min.css"> <script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script> <script src="//cdn.bootcss.com/bootstrap/3.3.5/js/bootstrap.min.js"></script> <div id="security"> <div> <div class="input-group"> <input type="text" class="form-control" aria-label="Enter the password." id="pass"/> <div class="input-group-btn"> <button type="button" class="btn btn-default" onclick="decryptAES()">Decrypt</button> </div> </div> </div> </div> <div id="encrypt-blog" style="display:none"> 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 </div>]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>假期</tag>
      </tags>
  </entry>
  <entry>
    <title>多元梯度函数的梯度下降</title>
    <url>/2020/08/01/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E5%A4%9A%E5%85%83%E6%A2%AF%E5%BA%A6%E5%87%BD%E6%95%B0%E7%9A%84%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>当然，本篇完全有理由和我之前写的<a href="/2020/07/26/人工智能/算法模型/梯度下降/">梯度下降</a>一文并在一起。但是，我还是觉得应当单独拉出来。前一篇<a href="/2020/07/26/人工智能/算法模型/梯度下降/">梯度下降</a>仅仅只是针对梯度下降的原理和流程作了一些阐释，用三个维度的例子说明了一个通用解法。而这里才是实际应用的具体表现，同时也包含很多小技巧。从这里开始，就是动真格的了！</strong></p>
<a id="more"></a>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>当然，还是那个海拔图，有高有低，有近有远。你要做的，就是从山顶上下山。环顾四周，一跳接一跳地往山下走。</p>
<h2 id="代价函数的确定"><a href="#代价函数的确定" class="headerlink" title="代价函数的确定"></a>代价函数的确定</h2><p>当然，代价函数就是我们需要训练的目标函数。只要代价函数最小，我们最后训练的结果就会接近事实。</p>
<p>可是，光是二元函数构成的三维图就已经包含了很多的不确定性，陷入局部最优解、收敛慢、内存溢出……这都是很无奈但是可控的问题。不如我们逆转过来：既然没有便利，就创造便利。</p>
<p>这里就还是用你的猫娘作为例子，但是这次代入了更多自变量：</p>
<blockquote>
<p>你再次收集了20万猫娘的信息，包括年龄（<code>age</code>）、体重（<code>weight</code>）、身高（<code>height</code>）、最大跳跃距离（<code>distence</code>）、胸围（<code>bust</code>）、腰围（<code>waist</code>）、臀围（<code>hip</code>）、基础社会科学考试分数（<code>score</code>）……</p>
</blockquote>
<p>虽然可能还有很多指标，但是现在就先列举这8项。是不是觉得非常的麻烦？而且这下我们连图都画不出来了，甚至无法想象8个自变量如何构成一个解空间，更无法想象涉及8个自变量的函数将会是怎样一个扭曲的形态。</p>
<p>行，套公式嘛，<strong>矩阵求解</strong>。</p>
<h2 id="函数化简"><a href="#函数化简" class="headerlink" title="函数化简"></a>函数化简</h2><blockquote>
<p>你整理出了一张含有$n$行数据的表，其中每一行数据都代表一只猫娘的所有收集到的信息，所以你为每一行整理了一个矩阵：</p>
<script type="math/tex; mode=display">\left[\begin{matrix}
age_i（岁） \\weight_i（千克）\\height_i（米）\\distance_i（米）\\bust_i（厘米）\\waist_i（厘米）\\hip_i（厘米）
\end{matrix}\right],i\in\{1,2,3,\ldots,n\}</script></blockquote>
<p><strong>这里插播一句：</strong></p>
<p><em>因为面对这样一个生物，对于科研人员来说就是个名副其实的黑匣子：什么都不知道，只知道输入和输出。所以在确定函数关系式的时候相当的麻烦。所以往往是一个个变量分析，优先找出一个个独立不相关的变量，然后分析相关变量的影响。这里就完全不是拟合算法能够做到的了，而是来自不同领域的科研人员齐心协力研究发现最终的出来的结果。这里因为赌的成分过高，并且和梯度下降并没有什么直接的关系，所以直接跳过。现在就直接跳到你找到了每个自变量的精确幂指数和对数底数以及对应的线性关系的情况。</em></p>
<blockquote>
<p>然后你又双叒叕凭着你对猫娘的热爱找出了这8个变量的大致关系：</p>
<script type="math/tex; mode=display">
y=f(age,weight,height,distance,bust,waist,hip)\\
\Downarrow\\
y=\epsilon+\alpha_1a+\alpha_2weight^2+\alpha_3height+\alpha_4d^3+\frac{\alpha_5}{3}(b^2+waist^2+hip^2)</script><p>其中，</p>
<script type="math/tex; mode=display">\epsilon,\alpha_1,\alpha_2,\alpha_3,\alpha_4,\alpha_5\in\mathbb{R}</script></blockquote>
<p><em>如果你还有印象，那么你应该记得$\epsilon$服从正态分布$N(0,\sigma^2)$，是随机误差。在一开始决定各种自变量的系数的时候往往会先忽视这个小东西，然后在全部得出结果之后加上以保证函数能够兼容一些“<strong>偶然</strong>”</em></p>
<blockquote>
<p>看到这样群魔乱舞的函数，你感觉到背脊发凉。完全没办法想象的解空间、完全无法想象的图形走向，更不用说最终目标的图像意义都无法解释……（<em>当然，这里是为了节目效果如此设计的</em>。）</p>
<p>这没难倒你。你把式子化为<strong>矩阵</strong>形式表达，就变成了这样：</p>
<script type="math/tex; mode=display">
y=\left[\begin{matrix}
  1&\alpha_1&\alpha_2&\alpha_3&\alpha_4&\alpha_5\over3&\alpha_5\over3&\alpha_5\over3
\end{matrix}
\right]\times\left[\begin{matrix}
\epsilon\\age\\weight^2\\height\\distance^3\\bust^2\\waist^2\\hip^2
\end{matrix}\right]\\
\Downarrow\\y=
\left[\begin{matrix}
  1&\alpha_1&\alpha_2&\alpha_3&\alpha_4&\alpha_5\over3&\alpha_5\over3&\alpha_5\over3
\end{matrix}
\right]\\
\times
\left[\begin{matrix}
  \epsilon\\age\\weight\\height\\distance\\bust\\waist\\hip
\end{matrix}
\right]\\
\times
\left[\begin{matrix}
  \epsilon\\&1\\&&weight\\&&&height\\&&&&distance\\&&&&&bust\\&&&&&&waist\\&&&&&&&hip
\end{matrix}
\right]\\
\times
\left[\begin{matrix}
  1\\&1\\&&1\\&&&1\\&&&&distance\\&&&&&1\\&&&&&&1\\&&&&&&&1
\end{matrix}
\right]</script></blockquote>
<p><em>由于版面问题，这个公式只能勉强这么写着了……</em></p>
<p><img src="https://sakebow.gitee.io/images/emoji/fuck-off.jpg" width="150" /></p>
<p>先不管版面了，若稍微简化一些，我们发现系数和幂指数<strong>完全相同</strong>的$bust$、$waist$和$hip$可以<strong>合并</strong>为一个变量$\eta_1$。</p>
<blockquote>
<p>再简化一些，更抽象一些，那就成为了：</p>
<script type="math/tex; mode=display">y=\alpha^T\eta</script><p>其中，$\alpha$是待定系数的矩阵，而$\eta$则是自变量经过各自合适变化之后的矩阵，即：</p>
<script type="math/tex; mode=display">
\alpha^T=\left[\begin{matrix}
  \alpha_1&\alpha_2\cdots\alpha_n
\end{matrix}\right]_n,\\
\eta=\left[\begin{matrix}
  \eta_1\\\eta_2\\\vdots\\\eta_n
\end{matrix}\right]_n,</script><p>而$\eta_i$则能代表很多，可以是$x_i$，也可以是$(x_i+x_{i+1})^2$等等。</p>
</blockquote>
<p>到这里，也就只是单纯的将变量合并，将复杂的公式变成简单易懂的矩阵向量，强行转成2个矩阵维度的<strong>解空间</strong>。当然，我们还是想象不到，只不过大致可以理解为某种类似$x$轴和$y$轴的神奇坐标轴在帮助我们标记位置。这么一想的话，就算是不能想象数轴的样子，也能够想象出解空间是个什么样了，而我们最终要求的目标函数最小值大概也能模模糊湖地猜出来在哪。</p>
<h2 id="目标函数最终展开"><a href="#目标函数最终展开" class="headerlink" title="目标函数最终展开"></a>目标函数最终展开</h2><p>但是你发现，到这里还是和上次讲到的梯度下降没有区别。没错，后面还有内容。</p>
<p>由于我们已经将目标函数改成了多元一次函数，所以，我们需要将目标函数彻底展开成为级数的形式，方便我们进一步设计算法。</p>
<p>还记得我们最初的公式么？</p>
<script type="math/tex; mode=display">\beta_i=\beta_i-\frac{\alpha}{m}\sum^n_{i=1}(f(x_i)-y_i)^2</script><p>我们的目标就是让$\frac{1}{m}\sum^n_{i=1}(f(x_i)-y_i)^2$尽可能地小。那么问题就简单了，针对这个函数分析就好了。另：</p>
<script type="math/tex; mode=display">\phi(\beta)=\frac{1}{m}\sum^n_{i=1}(f(x_i)-y_i)^2</script><p>求个导：</p>
<script type="math/tex; mode=display">\dot{\phi(\beta)}=\frac{2}{m}\sum^n_{i=1}[f(x_i)-y_i]\dot{f(x_i)}</script><p>这里最核心的部分就是$\dot{f(x_i)}$的理解。首先，我们寻找的是有关系数的函数，所以在这里的自变量是$\beta$，所以求导的时候不应当是已经知道具体数值的$x_i$，而是完全未知的$\beta_i$，故求导结果为$x_i$。即：</p>
<script type="math/tex; mode=display">\dot{\phi(\beta)}=\frac{2}{m}\sum^n_{i=1}[\dot{f(x_i)}-y_i]x_i</script><p>为了求导不要新增太多没有意义的单项式或多项式，所以我们将系数$2$删掉，也就是将目标函数改为：</p>
<script type="math/tex; mode=display">\phi(\beta)=\frac{1}{2m}\sum^n_{i=1}(f(x_i)-y_i)^2</script><p>这也就是吴恩达教授的课程中一直使用的函数的由来。求导之后就是：</p>
<script type="math/tex; mode=display">\dot{\phi(\beta)}=\frac{1}{m}\sum^n_{i=1}[f(x_i)-y_i]x_i</script><p>简单多了，不是么？</p>
<p>所以我们进而修改一下机器学习的算法：</p>
<script type="math/tex; mode=display">\theta_j=\theta_j-\frac{\alpha}{m}\sum^n_{i=1}[f(x_i)-y_i]x_i</script><p>到这，似乎就对计算机来说非常的方便了。</p>
<h2 id="theta-0-和-x-0"><a href="#theta-0-和-x-0" class="headerlink" title="$\theta_0$和$x_0$"></a>$\theta_0$和$x_0$</h2><p>对于一些课程中，你一定会遇到加设待定常数$\theta_0$和固定初始参数$x_0=1$的教师。为什么要这么做？我个人认为和数列添加初项是一样的。有些算法并不能很好地概括初项，所以强行加上去方便计算机处理。有些非常巧合的数列能够不需要初项，这就看怎么处理了。</p>
]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>算法模型</tag>
      </tags>
  </entry>
  <entry>
    <title>建模工具：octave</title>
    <url>/2020/07/26/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E5%BB%BA%E6%A8%A1%E5%B7%A5%E5%85%B7%EF%BC%9Aoctave/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>终于，使用<code>Ubuntu</code>系统的我遇到了最尴尬的问题：建模工具<code>Matlab</code>没有<code>linux</code>发行版。虽然可以使用<code>wine</code>勉强跑起来，但毕竟不是运行在<code>Windows</code>内核下，所以往往有很多事情都非常尴尬。所以，我看上了这一款：<code>octave</code>。不仅支持<code>Ubuntu</code>，还能够兼容<code>Matlab</code>，是非常不错的替代品。</strong></p>
<a id="more"></a>
<h2 id="界面展示"><a href="#界面展示" class="headerlink" title="界面展示"></a>界面展示</h2><p>先看看<code>octave</code>的软件界面，体验一下吧。</p>
<p><img src="https://sakebow.gitee.io/images/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/octave%E7%95%8C%E9%9D%A2.png" alt="octave界面"></p>
<p>可以看到左边由上至下依次是：文件目录、工作空间和历史记录，而左边则是命令行界面。</p>
<p>是不是非常熟悉？没错，这简直不能再像<code>Matlab</code>了。即使顶部功能菜单并没有<code>Matlab</code>那么丰富，却也足够了。</p>
<h2 id="更换命令行"><a href="#更换命令行" class="headerlink" title="更换命令行"></a>更换命令行</h2><p>如果你有丰富的<code>shell</code>编程经验，那么你应该对这个<code>&gt;&gt;</code>非常熟悉。<code>Matlab</code>使用的是<code>&gt;&gt;</code>，<code>MySQL</code>使用的是<code>&gt;</code>，<code>sqlplus</code>（<em><code>Oracle</code></em>）使用的是<code>&gt;</code>，<code>Python</code>使用的是<code>&gt;&gt;&gt;</code>，<code>Ubuntu</code>普通用户使用的是<code>$</code>，<code>Ubuntu</code>超管使用的是<code>#</code>……</p>
<p>如果说你用惯了想要换，还是可以的。直接输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 这段字符串复制自我的Ubuntu终端</span></span><br><span class="line">PS1("sakebow@Lenovo-V310-14IKB:~$ ")</span><br></pre></td></tr></table></figure>
<p>这样就能够保持和终端一模一样的风格了。当然为了区分也可以改称其他的，比如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ……懂的都懂……</span></span><br><span class="line">PS1("お兄ちゃん、頑張るね、大好きだよ❤　")</span><br></pre></td></tr></table></figure>
<h2 id="基于Linux的特点"><a href="#基于Linux的特点" class="headerlink" title="基于Linux的特点"></a>基于<code>Linux</code>的特点</h2><p>当然，因为开源免费的<code>octave</code>是使用<code>C</code>语言基于<code>Linux</code>系统开发的，所以也会保留一些<code>Linux</code>系统的命令。比如：</p>
<ul>
<li><code>pwd</code>显示当前所在文件夹</li>
<li><code>ls</code>显示当前文件夹中所有的文件</li>
<li><code>cd</code>跳转到制定文件夹</li>
<li><code>exit</code>退出程序</li>
</ul>
<p>即使是安装在<code>Windows</code>系统下的<code>octave</code>也是能够使用这些命令的。</p>
<h2 id="清空矩阵"><a href="#清空矩阵" class="headerlink" title="清空矩阵"></a>清空矩阵</h2><p>在<code>Ubuntu</code>系统中你可以直接使用<code>Ctrl+L</code>清空命令行。所有的指令会存在历史记录<code>Command History</code>栏内</p>
<p>当然你也可以输入<code>clc</code>并回车就能够清空命令行</p>
<h2 id="快速矩阵"><a href="#快速矩阵" class="headerlink" title="快速矩阵"></a>快速矩阵</h2><blockquote>
<p>这些<code>Octave</code>内置的快速矩阵摘自摘自<a href="https://www.youtube.com/watch?v=X0xLTKRWPgo&amp;list=PL1A2CSdiySGJ6oZe6" target="_blank" rel="noopener">油土鳖上一位印度阿三的教程</a>（<em>英语略微有一些咖喱味，但已经很不错了</em>）</p>
</blockquote>
<script type="math/tex; mode=display">
ones(n, m) = \left[
  \begin{matrix}
    1, \cdots, 1\\\vdots\\
    1, \cdots, 1
  \end{matrix}
\right]_{n\times m}
\\
zeros(n, m) = \left[
  \begin{matrix}
    0, \cdots, 0\\\vdots\\
    0, \cdots, 0
  \end{matrix}
\right]_{n\times m}
\\
eye(n) = \left[
  \begin{matrix}
    1, 0, 0, \cdots, 0\\
    0, 1, 0, \cdots, 0\\
    0, 0, 1, \cdots, 0\\\vdots\\
    0, 0, 0, \cdots, 1
  \end{matrix}
\right]_n = E
\\
eye(n, n + 1) = \left[
  \begin{matrix}
    1, 0, 0, \cdots, 0, 0\\
    0, 1, 0, \cdots, 0, 0\\
    0, 0, 1, \cdots, 0, 0\\\vdots\\
    0, 0, 0, \cdots, 1, 0
  \end{matrix}
\right]_{n\times(n+1)}
\\</script><p>而<code>rand(n,m)</code>则是生成<strong>n行m列</strong>的<strong>均匀分布随机数矩阵</strong>（<em>uniformly random matrix</em>），每个数字都是<strong>介于0到1之间的7位小数</strong>，且每个数字出现概率服从均匀分布$U(0, 1)$；</p>
<p><code>randn(n,m)</code>是生成一共<strong>n列m行</strong>的<strong>正态分布随机数矩阵</strong>（<em>normally random matrix</em>），每个数字服从正态分布$N(0, 1)$。乍一看这组数据毫无特点，实际上是$P(\mu-\sigma&lt;x&lt;\mu+\sigma)\approx0.6826$。这也就说明了为什么数字里面会有<strong>大于$1$和小于$-1$的数字了</strong></p>
<h2 id="矩阵构造"><a href="#矩阵构造" class="headerlink" title="矩阵构造"></a>矩阵构造</h2><p>在<code>C</code>、<code>C++</code>、<code>Java</code>、<code>C#</code>等等语言中构造矩阵永远是一个很难受的工程，拿<code>Java</code>中的<code>List&lt;List&lt;?&gt;&gt;</code>来说，向其中添加元素是一项无比复杂的工程。</p>
<p>而在<code>octave</code>和<code>Matlab</code>中，就只需要使用</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; s = [<span class="number">1</span>, <span class="number">2</span>; <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">s = </span><br><span class="line">  <span class="number">1</span> <span class="number">2</span></span><br><span class="line">  <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>在这里你可以使用<strong>逗号</strong>作为分割符，也可以仅用<strong>空格</strong>作为分割符。</p>
<p>如果你要用<strong>克莱姆法则</strong>解多元一次方程组，那么就需要几个矩阵拆拆解解。这个时候可以把一整个矩阵当作数字：</p>
<ul>
<li><code>[A B]</code>像是<code>[1 2]</code>，将两个数字横着拼起来</li>
<li><code>[A; B]</code>则是<code>[1; 2]</code>，将两个数字竖着拼起来</li>
<li><code>A&#39;</code>是矩阵的转置，就是$A^T$</li>
</ul>
<p>当然，我们还有矩阵的选择：</p>
<ul>
<li><code>S(m, n)</code>是选取矩阵<code>S</code>中<strong>第m行第n列</strong>的一个元素</li>
<li><code>S(m, [x, y, z])</code>是选择矩阵中<strong>第m行第x、y、z列</strong>的一共三个元素。如果还需要添加元素则在<code>[]</code>内追加</li>
<li><em>下方冒号表达式继续介绍</em></li>
</ul>
<h2 id="冒号表达式"><a href="#冒号表达式" class="headerlink" title="冒号表达式"></a>冒号表达式</h2><p>如果你熟悉<code>C</code>、<code>C++</code>、<code>Java</code>、<code>C#</code>等等（<em><code>Python</code>除外</em>），你应该会经常使用到冒号表达式，即是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输出该学生是否可以购买打折的火车票</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; 学生.学生证 === null ? <span class="string">"火车票不能打折"</span> : <span class="string">"火车票可以打折"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>但是在<code>octave</code>和<code>Matlab</code>就完全不一样了。冒号表达式会这么用：<code>start[:step]:end</code>，即创建一个从<code>start</code>到<code>end</code>的数组，其中每个数字之间间隔<code>step</code>，默认<code>step</code>值为<strong>1</strong>，即依次递增。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; s = <span class="number">1</span> : <span class="number">5</span></span><br><span class="line">&gt;&gt; <span class="built_in">ans</span> =</span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line">&gt;&gt; </span><br><span class="line">&gt;&gt; s = <span class="number">1</span>:<span class="number">3</span>:<span class="number">10</span></span><br><span class="line">&gt;&gt; <span class="built_in">ans</span> =</span><br><span class="line">[<span class="number">1</span> <span class="number">4</span> <span class="number">7</span> <span class="number">10</span>]</span><br></pre></td></tr></table></figure>
<p>当然冒号不止这一个用途。刚刚我们说了矩阵的构造，在矩阵中冒号还能够用作选择器。</p>
<p>我们在选择矩阵中元素的时候会使用一个<strong>数组</strong>作为范围，而如果这个范围<strong>正好</strong>可以用冒号表示的时候，就可以是这样：</p>
<ul>
<li><p><code>S(m, [start : end])</code>，也就是说选取<strong>第m行从start开始到end结束的所有元素</strong></p>
</li>
<li><p>如果没有规定<code>start</code>和<code>end</code>，也就像是：<code>S(m, :)</code>，那么就是选取<strong>第m行一整行</strong></p>
</li>
</ul>
<h2 id="个数计算"><a href="#个数计算" class="headerlink" title="个数计算"></a>个数计算</h2><p><code>Java</code>中，对集合使用<code>size()</code>方法求集合内元素个数，对数组使用<code>length()</code>方法求数组内元素个数。</p>
<p>在<code>octave</code>中，我们两个都可以用，但是<code>size()</code>方法返回的是行和列两个数字，而<code>length</code>方法则是从<code>size()</code>方法返回的两个数字中选择一个最大的。举个例子：</p>
<p>假设你这个时候又闲着没事创建了一个随机数组<code>rand(5, 1)</code>，那么<code>size()</code>方法返回的是<code>[5 1]</code>两个数字，前者是行数，后者是列数；而<code>length()</code>方法返回的是<strong>5</strong>，是<strong>5</strong>和<strong>1</strong>中较大的数。</p>
<p>同样的，如果你只有一个数组<code>[1 2 4]</code>，<code>size()</code>方法返回的依然是<code>[1 3]</code>两个数，而<code>length()</code>方法就返回<strong>3</strong>。</p>
<h2 id="其他数学函数"><a href="#其他数学函数" class="headerlink" title="其他数学函数"></a>其他数学函数</h2><ul>
<li><code>ceil(x)</code> - 取比x大的第一个最近的整数，即向上取整</li>
<li><code>floor(x)</code> - 取比x小的第一个最近的整数，即向下取整</li>
<li><code>round(x)</code> - 取距离x最近的一个整数。如果$x=0.7$，则结果为$1$；如果$x=0.3$，则结果为$0$</li>
<li><code>max(x)</code> / <code>min(x)</code> - 取一个数组中最大/最小的数</li>
</ul>
<p>对于<code>max(x)</code>和<code>min(x)</code>在官方给的说明里面指明的是vector，也就是说这个函数同样适用于矩阵、向量等等。但是实际测试的时候是这样的：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; <span class="built_in">rand</span>(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"> <span class="number">0.097667</span>   <span class="number">0.295360</span>   <span class="number">0.710065</span></span><br><span class="line"> <span class="number">0.858128</span>   <span class="number">0.141471</span>   <span class="number">0.729432</span></span><br><span class="line"> <span class="number">0.073253</span>   <span class="number">0.503299</span>   <span class="number">0.379730</span></span><br><span class="line"> <span class="number">0.329683</span>   <span class="number">0.839168</span>   <span class="number">0.076656</span></span><br><span class="line"> <span class="number">0.662468</span>   <span class="number">0.514276</span>   <span class="number">0.020735</span></span><br><span class="line">&gt;&gt;</span><br><span class="line">&gt;&gt; <span class="built_in">min</span>(<span class="built_in">ans</span>)</span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"> <span class="number">0.073253</span>   <span class="number">0.141471</span>   <span class="number">0.020735</span></span><br></pre></td></tr></table></figure>
<p>不难发现，对比的时候将一整列作为一个数组进行纵向的对比，每一列选出了一个最小的。在上面这个例子中，数组<code>ans[0..4][0..2]</code>每一列选出了最小的，也就是<code>ans[2, 0]</code>、<code>ans[1, 1]</code>和<code>ans[3, 2]</code>。<code>max(ans)</code>也是一样的算法，只不过会每列找出一个最大的。</p>
<h2 id="数据集的导入和导出"><a href="#数据集的导入和导出" class="headerlink" title="数据集的导入和导出"></a>数据集的导入和导出</h2><p>如果有一天我们使用计算机去证明歌德巴赫猜想，把所有的数字塞进去日复一日地算，终于算出来了一大批数字。我们不可能使用人工一个个抄下来，肯定是让计算机自己保存。这个时候就用<code>save</code>命令让计算机保存所有的数字。</p>
<p>例如，我现在弄出了很大一批随机数<code>randn(1000, 1000)</code>，但是我突然发现笔记本电不够了，得保存下来。就这么使用：<code>save ${文件名} ${变量名}</code>，意思就是：将变量的值保存在指定中。当然你也可以指定别的后缀名，比如我这里选择：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">save <span class="built_in">randn</span>.json <span class="built_in">ans</span></span><br></pre></td></tr></table></figure>
<p>于是就有了如下效果：</p>
<p><img src="https://sakebow.gitee.io/images/机器学习/octave保存数据.png" alt="保存了十万条随机数"></p>
<p>但是呢，为了能够更直观地区分各个文件，我们尽可能按照大家默认的规矩来，这里推荐万能的<code>.csv</code>文件；官方更是推荐使用<code>.mat</code>文件。更何况，我这里导出的文件并不符合<code>json</code>文件的编写规范。</p>
<p>就像是<code>Java</code>的导包一样，我们会使用<code>import</code>导入一整个<code>jar</code>包。而在<code>octave</code>中，我们将会使用<code>load</code>命令导入文件。</p>
<p>如果再次使用，我们就使用<code>load</code>命令，即：<code>load randn.dat</code>（<em>我这里是.json</em>）</p>
<p><strong>看起来很简单？我们再来点奇葩的：</strong></p>
<p>有一天你们哥几个凑一起跑数据，结果突然发现两个人风格极其相近以至于命名都完全一样。现在重新改已经很头疼了，怎么办？</p>
<p>我们就用<strong>临时文件</strong>。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 创建临时文件</span></span><br><span class="line">f = tmpfile</span><br><span class="line"><span class="comment">% 将变量存入临时文件</span></span><br><span class="line">save f variable</span><br><span class="line"><span class="comment">% &#123;</span></span><br><span class="line">  拿同名变量处理一大堆事情</span><br><span class="line">&#125; <span class="comment">%</span></span><br><span class="line"><span class="comment">% 读取临时文件</span></span><br><span class="line">load f</span><br><span class="line"><span class="comment">% 这个时候同名变量就被覆盖了</span></span><br></pre></td></tr></table></figure>
<p>打个比方的话，就像是<code>C</code>语言的<strong>局部变量</strong>和<strong>全局变量</strong>一样。</p>
<p>当然，这只是一个非常极端的例子，我们强烈建议各小组之间事先商量好再码字，正如<code>SpringBoot</code>所倡导的：“<strong>约束大于业务</strong>”、“<strong>习惯大于编码</strong>”</p>
<h2 id="统计图绘制"><a href="#统计图绘制" class="headerlink" title="统计图绘制"></a>统计图绘制</h2><p>统计图必定是有数据支持的，但是现在没有数据……那么就随机生成吧：<code>rand(1, 100)</code>。于是工作空间中就有了<code>ans</code>这个变量，同时还有了一个共<strong>1行</strong>、<strong>100列</strong>的矩阵，也就是数组。</p>
<p>然后，我们就画图：<code>plot(ans)</code>，于是产生了一个很简单的折线图：</p>
<p><img src="https://sakebow.gitee.io/images/机器学习/基本折线图.png" alt="最简单的折线图"></p>
<p>因为是随机生成的数字，所以也看不出什么规律。</p>
<p>你可能会有点惊讶，为什么明明只有<code>ans</code>一个变量，谈不上所谓因变量和自变量，他是怎么画出来的？实际上这里是将<strong>下标</strong>作为横坐标、<strong><code>ans</code>的值</strong>作为纵坐标画出来的。</p>
<h2 id="统计图绘制样式"><a href="#统计图绘制样式" class="headerlink" title="统计图绘制样式"></a>统计图绘制样式</h2><p>如果说你不需要折线图，而是散点图，那么就更改绘图样式吧：<code>plot(ans, &#39;*&#39;)</code></p>
<p><img src="https://sakebow.gitee.io/images/机器学习/更换样式.png" alt="把折线图换成散点图"></p>
<p>当然你觉得<code>*</code>不太美观的话也可以换成中文的<code>·</code>（<em>中文输入下波浪线按钮不加<code>shift</code></em>）或者日文的<code>・</code>（<em>日文输入下问号按钮不加<code>shift</code></em>）</p>
<p>为了防止很多图像看混了，可以使用不同的颜色标记：<code>plot(ans, &#39;1&#39;)</code></p>
<p><img src="https://sakebow.gitee.io/images/机器学习/更换颜色.png" alt="更改颜色"></p>
<p>各种各样的数字代表了各种各样的<strong>颜色</strong>，而各种各样的字符代表了各种各样的<strong>描点</strong>。</p>
<p>如果你什么都不写，那么默认就是使用<code>-</code>，也就是折线图。</p>
<h2 id="散点图"><a href="#散点图" class="headerlink" title="散点图"></a>散点图</h2><p>好吧，用<code>plot</code>画出来的散点图多少还是有点点奇怪。那么我们干脆用专门画散点图的方法：<code>scatter</code>。</p>
<p>还是一样的，我们拿到了一组数据：<code>x = randn(1, 100)</code>，另外我们再来一组数据：<code>y = randn(1, 100)</code>，然后画出随机散点图：</p>
<p><img src="https://sakebow.gitee.io/images/机器学习/散点图.png" alt="散点图"></p>
<p>同样的，我们能够使用家参数的方式改变图像的样式：<code>scatter(x, y, &#39;*&#39;)</code>。只不过这里支持的字符就比较少了，经测试似乎仅支持将圆圈更换为<code>*</code>。</p>
<h2 id="柱状图"><a href="#柱状图" class="headerlink" title="柱状图"></a>柱状图</h2><p>柱状图也是一种重要的工具，在统计总数并比较多条数据的差值时用得多。就比如100个服从正态分布的随机数构成的柱状图中，能够清晰地看出各个概率之间分布的差值：</p>
<p><img src="https://sakebow.gitee.io/images/机器学习/柱状图.png" alt="柱状图"></p>
<p>我们知道，$P(0-1&lt;x&lt;0+1)\approx0.6826$，所以数据比较倾向于向$(-1, 1)$这个区间集中。</p>
<h2 id="等高线"><a href="#等高线" class="headerlink" title="等高线"></a>等高线</h2><p>就像是地理的等高线、电磁场的等势线一样，存在的目的就是为了说明哪一段是数值上相等的。在绘制的时候，我们需要提供一个至少<strong>两行两列</strong>的矩阵，然后就由<code>contour</code>方法寻找矩阵中值算出等高线。</p>
<p>比如对于$ans=\left[\begin{matrix}1&amp;2\\3&amp;4\\5&amp;6\\7&amp;8\end{matrix}\right]$这个矩阵画出来的等高线就是<code>contour(ans)</code>：</p>
<p><img src="https://sakebow.gitee.io/images/机器学习/等高线.png" alt="等高线"></p>
<h2 id="极坐标"><a href="#极坐标" class="headerlink" title="极坐标"></a>极坐标</h2><p>高中我们认识并狠狠地练习了<strong>极坐标</strong>这些题目，所以我们就直接从最简短的开始：$\rho=2\cos\theta$。相信你很清楚这个等式可以化为$x^2+y^2=x$，是以$(1,0)$为圆心、$1$为半径的圆。</p>
<p>那么就确定两个变量：<code>p = linspace(0, 1)</code>和<code>o = linspace(0, 2 * pi)</code></p>
<p><em>注：linspace(x, y) = x:0.01:y，即从x到y中每隔0.01取一个点</em></p>
<p>然后，画极坐标：polar(p, o)</p>
<p>就出现了这样的图：</p>
<p><img src="https://sakebow.gitee.io/images/机器学习/极坐标.png" alt="极坐标"></p>
<p>似乎和我们平常见到的直角坐标系不一样。不过没有关系，是不是在很多影视作品中看到类似的？<strong>雷达</strong>嘛。在战场上，你发送了敌机的$(x, y, z)$坐标，<strong>这谁懂啊</strong>。干脆点，报哪个方向方向多少度，往那打。这种情况下极坐标比直角坐标好用多了。</p>
<p>还有其他很有意思的：比如我们将刚刚的<code>p</code>和<code>o</code>调换一下位置，就成了螺旋线。</p>
<p><img src="https://sakebow.gitee.io/images/机器学习/螺旋线.png" alt="螺旋线"></p>
<h2 id="饼状图"><a href="#饼状图" class="headerlink" title="饼状图"></a>饼状图</h2><p>饼状图只是为了查看占比，所以大批量的随机数在这里并不适合作为样本。所以这里就随机生成三个数：<code>ans = randn(1, 3)</code></p>
<p><em>由于饼状图是组内比较，所以只能使用一组数据，即<strong>行向量</strong>或者<strong>列向量</strong>作为参数。如果生成<code>ans = randn(10, 10)</code>作为样本则会报错。使用时还请注意。</em></p>
<p><img src="https://sakebow.gitee.io/images/机器学习/饼状图.png" alt="饼状图"></p>
<p>可以看到，<code>octave</code>拿到数据之后立马进行了权重的计算，最终得出了这个结果。所以我们在实际实验中就只需要把数据整理成<strong>行向量</strong>或者<strong>列向量</strong>传入，<code>octave</code>就能够在一定程度上。</p>
<p>既然饼状图是查看一个部分或者多个部分的占比，为了让图片更清晰，就可以让一些部分联系起来。</p>
<p>时间回溯到你收集猫娘数据的那些日子（<del>别吐槽了，听就是了</del>）</p>
<p>你了解到全世界的猫娘们的年龄从0岁开始往上的数量依次是<code>neko = [16247, 18752, 19165, 17251, 11471, 18714, 10961, 5428, 13725, 8715, 10031, 13298, 8715, 9716, 4562, 9612, 3610]</code>（<em>随手瞎打的</em>）。你想清晰地看出在0到3岁的猫娘占比，于是你使用第二个参数：<code>explode</code>。这个参数应当是一个数组。如果数值为0，则会与下一个块区相接；而如果非0，即使是负数也会明显分开。</p>
<p>于是我们为了清晰地看出0到3岁的小猫娘的数量，我们使用<code>pie (neko, [1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])</code>，就会产生这样的效果：</p>
<p><img src="https://sakebow.gitee.io/images/机器学习/突出部分元素的饼图.png" alt="突出部分元素"></p>
<p>可以看到，设置为非零的前三个部分被分开了，占比$8\%+9\%+10\%=27\%$。这是不是比不突出任何元素的饼图看起来更直观呢？</p>
<h2 id="选择支"><a href="#选择支" class="headerlink" title="选择支"></a>选择支</h2><p>当然，作为一门高级语言，选择支是必要的。</p>
<p>如果你是想通过选择支筛选不同年龄段，那么就使用：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> age &lt; <span class="number">3</span>,</span><br><span class="line">  <span class="comment">% filter for age &lt; 3</span></span><br><span class="line"><span class="keyword">elseif</span> age &lt; <span class="number">10</span>,</span><br><span class="line">  <span class="comment">% filter for 3 &lt; age &lt; 10</span></span><br><span class="line"><span class="keyword">else</span>,</span><br><span class="line">  <span class="comment">% filter for age &gt; 10</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<p>这个逗号估计就是在命令划分的时候不太好识别标志加上的。虽然和<code>Java</code>、<code>Python</code>略有出入，但我相信这绝对有他的道理。</p>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p><code>while</code>循环相信各位都熟悉得不能再熟悉了。实际上<code>while</code>和<code>if</code>的用法实际上是一样的。毕竟都是判断条件并转入选择支。唯一的区别估计就是<code>if</code>语句能够接<code>else if</code>和<code>else</code>来筛选不同的条件，而<code>while</code>只能始终选择同一个条件。</p>
<p><code>for</code>循环相比<code>while</code>循环又多了一个神奇的功能：将一个集合里的每一个元素创建索引，并这个索引仅作用于<code>for</code>循环中，是区域变量。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 假设nekos里面保存了每只猫娘的年龄(age)和姓名(name)</span></span><br><span class="line"><span class="keyword">for</span> neko = nekos,</span><br><span class="line">  <span class="keyword">if</span> neko.age &gt; <span class="number">10</span>,</span><br><span class="line">    sprintf(<span class="string">"%i"</span>, neko.name)</span><br><span class="line">  <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<p>如果你确定这些猫娘有着不同的名字，并且你一定要找到那只叫做“<strong>chocola</strong>”的猫娘（<em>没……没夹带私货……真的！</em>），那么就这么来：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> neko = nekos,</span><br><span class="line">  <span class="keyword">if</span> neko.name == <span class="string">'chocola'</span>,</span><br><span class="line">    sprintf(<span class="string">"%i"</span>, neko.age)</span><br><span class="line">    <span class="keyword">break</span>; <span class="comment">% 跳出一层循环</span></span><br><span class="line">  <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<p>有了这个<code>break</code>，一旦找到了<strong>chocola</strong>就会退出并显示她的年龄。</p>
<p>而如果这些猫娘有重名却有着不容的铃铛编号呢？那么就全找出来。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> neko = nekos,</span><br><span class="line">  <span class="keyword">if</span> neko.name == <span class="string">'chocola'</span>,</span><br><span class="line">    sprintf(<span class="string">"%i"</span>, neko.id)</span><br><span class="line">    <span class="keyword">continue</span>; <span class="comment">% 强制结束本次循环</span></span><br><span class="line">  <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<p>有了<code>continue</code>，程序就不会结束，反而是直接结束<code>continue</code>后面的所有步骤，强行结束本次循环。全部显示出来之后我们再对比这些编号是不是我们想要的编号。</p>
<p>和<code>Java</code>、<code>Python</code>等等有着非常多的相似之处呢。即使完全没接触过<code>matlab</code>，相信你们也能用丰富的编程经验理解用法。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数看起来非常高端，实际上你可以看成多个普通命令的合集。</p>
<p>函数是有固定的套路的：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> $&#123;<span class="title">variable</span>&#125; = $&#123;<span class="title">function</span> <span class="title">name</span>&#125; <span class="params">($&#123;argument list&#125;)</span></span></span><br><span class="line">  <span class="comment">% to do list</span></span><br><span class="line">endfunction;</span><br></pre></td></tr></table></figure>
<p>但是你得明白：函数毕竟是一个包含了很多行的整体。如果你使用纯命令行编辑整个函数，一旦某个地方有所疏忽，一运行函数就有可能会报错，然后<strong>整个函数重写</strong>。这是相当考验熟练度、耐心和细心的工作。当然，肯定不会让你有这么难受的体验的。</p>
<p><code>octave</code>为了能够在数学处理上由所优势，就决定兼容<code>matlab</code>所使用的<code>.m</code>文件。在这个文件中，我们能够使用各种各样的变量记录函数的定义，这样即使出现了错误我们也能够通过错误信息定位到不正确的地方并修改。这样就避免了整个函数重写的惨痛经历。</p>
<p>如果你只有命令行，或者说只愿意使用命令行，<code>octave</code>也是提供了专门的命令：<code>edit ${file name}</code>。如果是<code>Ubuntu</code>系统，<code>octave</code>将会在<code>~/octave</code>文件夹下创建或者修改文件。在这里尤其注意文件的命名，一方面是因为这样子能够很清晰地弄清楚什么文件保存了什么函数，另一方面也是因为有些文件名是<code>octave</code>内定的<strong>特殊文件</strong>，比如<code>test.m</code>是<code>octave</code>规定的测试文件，其中含有非常多的内置函数和测试函数供用户调用、测试。而如果只是一般的命名就没有什么特殊的，只是会加上很多版权说明，并默认提供一个空函数模板以供用户根据需求修改。</p>
<p>有点难懂？那我们举个例子，主人公还是那个热爱猫娘的你。这次的你尽了全力也没能收集全所有的数据，有些猫娘一被问到年龄就狠狠地挠你的嘴，有些则因为怕生逃掉了，也有些则在接近之前你就被主人当成可疑人物带走了……总之，你虽然找到了20万只猫娘，却只收集了5000条残缺不全的数据，不是掉了这个就是少了那个。但是该寻找的还是要寻找，那就是查清相同年龄里成绩最好和成绩最差的两只猫娘的信息。</p>
<p>在写这个函数之前，我们首先明白几个非常重要的点：</p>
<ul>
<li><code>octave</code>是以<code>matlab</code>为模板创建的全平台兼容的软件，所以有什么不懂可以直接查询<code>matlab</code>的教程；</li>
<li><code>octave</code>与<code>matlab</code>非常相似，都是以<code>C</code>为基础搭建的，所以并没有<strong>面向对象编程</strong>的概念，整个程序就是为了<strong>面向过程</strong>而设定的。</li>
</ul>
<p>所以，我们如果使用<code>octave</code>处理猫娘们的数据的时候，只能把所有想要的全部<strong>手打</strong>或者<strong>通过脚本筛选</strong>，最终达成只包含需要被处理的部分的、单纯列出所有而不是分类整合的数据集。如果是使用各种各样括号分开的<code>json</code>数据则无法被处理为一个个对象，却只能分成许许多多的单条数据。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 文件名：filter.m</span></span><br><span class="line"><span class="comment">% 从一堆数据中寻找最小的数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter_mini</span> = <span class="title">filter</span><span class="params">(x)</span></span></span><br><span class="line">  ret = x(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">2</span>:<span class="built_in">length</span>(x),</span><br><span class="line">    <span class="keyword">if</span> x(<span class="built_in">i</span>) &lt; ret,</span><br><span class="line">      ret = x(<span class="built_in">i</span>)</span><br><span class="line">    endif;</span><br><span class="line">  endfor;</span><br><span class="line">endfunction;</span><br></pre></td></tr></table></figure>
<p>在这里需要非常注意的是：<strong>一个文件只能编辑一个函数</strong>，<strong>每个函数的名称必须和文件名保持一致</strong>，否则会报警告：<strong>函数名和文件名不匹配</strong>。调用则是很普通的使用文件名即可，代入参数便能得到结果。</p>
<p>可是，我要找出猫娘的<code>id</code>啊，你这只能找出分数欸。那就这样，我们先按照猫娘的<code>id</code>顺序排列，我们找出最大和最小的索引，再从这些索引中找出<code>id</code>就好咯。</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[low, low_index, high, high_index]</span> = <span class="title">filter</span><span class="params">(x)</span></span></span><br><span class="line">  low = x(<span class="number">1</span>); high = x(<span class="number">1</span>); low_index = <span class="number">0</span>; high_index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">2</span>:<span class="built_in">length</span>(x),</span><br><span class="line">    <span class="keyword">if</span> x(<span class="built_in">i</span>) &lt; low,</span><br><span class="line">      low = x(<span class="built_in">i</span>)</span><br><span class="line">      low_index = <span class="built_in">i</span></span><br><span class="line">    <span class="keyword">elseif</span> x(<span class="built_in">i</span>) &gt; high,</span><br><span class="line">      high = x(<span class="built_in">i</span>)</span><br><span class="line">      high_index = <span class="built_in">i</span></span><br><span class="line">    endif</span><br><span class="line">  endfor</span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure>
<p>这样看起来没什么问题。但是却依然引出了另一个问题：一旦找出符合<code>if</code>语句的分数，程序就会立马返回并打印，然后你就发现了一大堆数字堆在那里，并只能通过肉眼筛选真正符合条件的数字。如果说明得学术一点，那就是：“<strong>打印出大量的局部最优解，并只能通过肉眼寻找全局最优解</strong>”。是不是很让人抓狂？</p>
<p>还是有解决办法的。也就是在调用的时候规定返回值：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">[a, b, c, d] = filter(param)</span><br></pre></td></tr></table></figure>
<p>这样的话虽然还是会打印一大堆数字，却能够很明显地看出全局最优解的结果了。</p>
<p>当然，有函数就一定有错误处理：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[low, low_index, high, high_index]</span> = <span class="title">filter</span><span class="params">(x)</span></span></span><br><span class="line">  <span class="comment">% 如果不是列向量或者行向量，报错。</span></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">isvector</span>(x),</span><br><span class="line">    error(<span class="string">"filter expects a vector"</span>)</span><br><span class="line">  endif</span><br><span class="line">  low = x(<span class="number">1</span>); high = x(<span class="number">1</span>); low_index = <span class="number">0</span>; high_index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">2</span>:<span class="built_in">length</span>(x),</span><br><span class="line">    <span class="keyword">if</span> x(<span class="built_in">i</span>) &lt; low,</span><br><span class="line">      low = x(<span class="built_in">i</span>)</span><br><span class="line">      low_index = <span class="built_in">i</span></span><br><span class="line">    <span class="keyword">elseif</span> x(<span class="built_in">i</span>) &gt; high,</span><br><span class="line">      high = x(<span class="built_in">i</span>)</span><br><span class="line">      high_index = <span class="built_in">i</span></span><br><span class="line">    endif</span><br><span class="line">  endfor</span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>如果你是<code>Windows</code>环境下的纯命令行，那么你在执行了上面提到的一些画图命令之后，还需要执行<code>hold on</code>命令让图像显示出来，而<code>close</code>命令则是关闭图像。当然，毕竟是<code>Windows</code>窗体程序，你也可以选择点击右上角的<strong>关闭窗口</strong>按钮关掉这张图片。</p>
]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>建模工具</tag>
      </tags>
  </entry>
  <entry>
    <title>梯度下降</title>
    <url>/2020/07/26/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>你可能又觉得梯度下降是一个完全没有接触过的新词。不过放心，依然能对上。</strong></p>
<a id="more"></a>
<h2 id="方向导数和梯度"><a href="#方向导数和梯度" class="headerlink" title="方向导数和梯度"></a>方向导数和梯度</h2><p>在说明怎么进行梯度下降之前，我们需要复习一下方向导数和梯度。</p>
<p>就拿最简单的两个变量为例：</p>
<blockquote>
<p>下图就是一张海拔图。</p>
<p><img src="https://sakebow.gitee.io/images/机器学习/二元函数梯度下降演示.jpg" alt="下降演示"></p>
<p>有一天，你乘坐的飞机失事了，在山顶坠毁，只有你一个人活了下来。弹尽粮绝的你几近绝望。但是你看到眼前有一大片水源，你想着找到了水源就能够活下去。所以你决定在你饿倒、冻死、被野兽咬杀之前，<strong>尽快达到山底的水源</strong>，越快越好。在这种紧急情况下，已经<strong>没有时间让你把所有的路全都探索一遍</strong>了，因为你随时可能在山上出事。</p>
<p>在陡峭的山上，有若干个比较平缓的落脚点。你站在出发的落脚点上，环顾四周，发现了若干能够安全到达的落脚点。于是你在这几个里面选择了最低的一个，跳了过去。接着在下一个落脚点继续寻找更低的落脚点。</p>
</blockquote>
<p>这就是“<strong>下降</strong>”，而<strong>梯度</strong>则是选择一条<strong>最优下降方向</strong>的参考。</p>
<p>所以问题来了，怎么样才能选出<strong>最优下降方向</strong>？如果就只是找遍目力所及的所有落脚点、计算落差，这样当然可行，但是代价太大。所以，我们在这里将使用一定的<strong>数学方法</strong>推算出来。</p>
<p>首先对于在平面$D$（<em>海平面</em>）上具有连续一阶偏导数的二元函数$z=f(x,y)$（<em>山高计算式</em>）上的任意一点，都有一个向量：</p>
<script type="math/tex; mode=display">\vec{grad}f(x,y)=\{\frac{\partial f}{\partial x},\frac{\partial f}{\partial y}\}</script><p>又由于方向导数：</p>
<script type="math/tex; mode=display">\vec{f_L}(x_0,y_0)=({\partial f\over\partial x},{\partial f\over\partial y})\cdot(cos\theta,sin\theta)</script><p>所以，不难得出：</p>
<blockquote>
<p>方向导数是二元函数$z=f(x,y)$在各个方向上的变化量，而当方向导数最大的时候，必定是方向导数和梯度方向重合的时候。而<strong>方向导数最大时</strong>，<strong>函数增长最快</strong>；反之亦然，<strong>方向导数最大时的反方向函数减少最快</strong>。</p>
<p>也就是说，我们在下山的时候唯一需要注意的就是：寻找梯度。</p>
</blockquote>
<p>当然我们还有一些需要注意的细节，<strong>下山的速度</strong>就是其中之一，它有个学术名称叫做<strong>学习率（<em><code>learning rate</code></em>）</strong>，多记为$\eta$。当学习率提高的时候，下山的速率就非常快，很快你就会达到一个区域最优解，但也可能因为步长太大忽略了某个关键点甚至可能导致不收敛；而学习率降低的时候，下山速率就非常低，只不过这样的话你能够找到更多的落脚点，从而一定程度上减少了陷入局部最优解的可能。</p>
<p>拿下面这个图举个例子：</p>
<p><img src="https://sakebow.gitee.io/images/机器学习/梯度说明图.png" alt="梯度说明"></p>
<p>很清楚地看到，在$x\in(0,1)$和$x\in(4,5)$的时候，函数下降速度和上升速度都非常快，这个时候可以<strong>适当减少学习率</strong>，就像是<strong>单机FPS游戏里放慢步伐寻找隐藏点</strong>一样，避免错过了任何一个细节。但是过小的步伐会导致收敛速度非常慢，一直再重复无效的学习；而在$x\in(1,4)$的时候，函数不管是上升还是下降都非常缓慢，基本没有什么起伏，可以<strong>适当加快步伐</strong>，就像是<strong>GalGame二刷回收CG</strong>一样，只抓重点，忽略细节。但是过大的步伐会导致你忽略掉$x\in(3,4)$的极值点。</p>
<p>总的来说，<strong>步长小了可能会陷入局部最优解；而步长大了可能会离最优解越来越远，最终得出错误的结果</strong>。</p>
<p><em>不过呢，三维我们还能勉强想象，但是拓展到四维、五维等超越3个维度的坐标系时，作为三次元的我们将无法想象那样的存在。所以，我们目前所能做的极限就是讨论三元变量的关系了。有没有三维以上的方向导数解法？当然有，本篇说明的就是<strong>通用解法</strong>，只不过对于三维以上的数据就<strong>无法说明几何意义</strong>了。</em></p>
<h2 id="梯度下降是什么"><a href="#梯度下降是什么" class="headerlink" title="梯度下降是什么"></a>梯度下降是什么</h2><p>经过复习，聪明的你应该能够明白，所谓梯度下降即是：</p>
<ul>
<li><p>从图像的意义上来看，就可以总结为：任意选取一个落脚点，然后搜索周边看能不能找到更低的落脚点。这个点不出意外的话应该在梯度方向的反方向上。</p>
</li>
<li><p>从数学的意义上来看，就可以总结为：任意选取<strong>损失函数</strong>上的一个点，一步一步寻找区域极值，并坚信其中一个极值是全域最小值，逐渐逼近使得<strong>损失函数</strong>的值最小的点。</p>
</li>
</ul>
<p><em>数学的角度听起来有点贪心算法的味道了？有一说一，确实。当然，不出意外的话，极值中确实会有最值；只不过时常会有意外，也就是说，最值不在极值中，而是在边界。</em></p>
<p>“<strong>不识庐山真面目，只缘身在此山中</strong>”。这也正是贪心算法的“贪心”所在啊，偏偏想要<strong>使用最少的次数碰运气似的找到最优解</strong>。实际上，你朝梯度的反方向看到的“<strong>最低点</strong>”，也仅仅是通过一般的数学计算才出现的<strong>预测的点</strong>，实际最低点甚至可能出现在<strong>任何地方</strong>。虽然异常的尴尬，但这也正是贪心算法想要解决的，不是么？起码7位数的数据遍历起来实在是有点难受啊……</p>
<h2 id="为什么选择梯度下降"><a href="#为什么选择梯度下降" class="headerlink" title="为什么选择梯度下降"></a>为什么选择梯度下降</h2><p>这个方法不仅用于线性方程求解，而且还适用于机器学习的很多个领域。找到代价函数最小值和各维度的值，同时找出根据很多自变量变化的因变量拟合函数，可以在非常多的方面说明问题，比如<strong>决策</strong>、<strong>推荐</strong>、<strong>预测</strong>、<strong>分类</strong>等等。</p>
<p>其实最重要的是，他能够用比较低的时间复杂度找到最好的一个解。这对于信息爆炸式增长的今天是非常有必要的。中国14亿人，就算只有一半的网民，也是7亿的并发量；面对这7亿用户的偏好分析，实在是等不起十几天慢慢磨出一份精简的报告。</p>
<h2 id="随机梯度下降"><a href="#随机梯度下降" class="headerlink" title="随机梯度下降"></a>随机梯度下降</h2><p>好了，现在开始进入正题：梯度下降的步骤。</p>
<p>我们先不要弄得太复杂，还是老例子：</p>
<blockquote>
<p>时间回溯到你研究猫娘食量那会。你确确实实拿到了20万数据，每个数据都是以（年龄，食量）这样的坐标形式出现。这看起来没什么问题，只不过你突然发现猫娘们的食量增长速度在成年之后随着年龄的增长而不断趋于平稳，成年之前却疯狂增长。你觉得线性方程不再适用。这样的函数你似乎希望是对数函数，可是这是不是因为有其他因素的影响？</p>
<p>于是，你凭着对猫娘疯狂的热爱，开始了第二波数据收集。这次你拿到了年龄(age)、身高(height)、体重(weight)和食量(quantity)四个数据，构成了函数$Q=f(a,h,w)$。</p>
</blockquote>
<p>这次涉及了三个维度和一个自变量，虽然复杂了很多，但也勉强能够画出来。只不过梯度下降的图像意义便不再是<strong>下山</strong>了，而是构建一个平面或者瞄准某一个中心。</p>
<blockquote>
<p><del>你凭着自己的性癖</del>……你随机选择了一位猫娘，将她的数据使用矩阵形式记录了下来：</p>
<script type="math/tex; mode=display">neko_0=\left[\begin{matrix}
  a_0\\h_0\\w_0
\end{matrix}\right]</script><p>紧接着，下一个数据就是：</p>
<script type="math/tex; mode=display">neko_1=\left[\begin{matrix}
  a_1\\h_1\\w_1
\end{matrix}\right]
=\left[\begin{matrix}
  a_0\\h_0\\w_0
\end{matrix}\right]
-\eta\left[\begin{matrix}
{\partial\over\partial a} f(a_0,h_0,w_0)\\
{\partial\over\partial h} f(a_0,h_0,w_0)\\
{\partial\over\partial w} f(a_0,h_0,w_0)
\end{matrix}\right]</script></blockquote>
<p>当然，$neko_1$是有实际数值的，而使用<code>学习率</code>、$neko_0$和<code>损失函数的偏导数</code>计算出来的$neko_1$并不是真实的数据。那么使用哪一个数据？当然是都使用。因为现在猫娘的食量和年龄变成了非线性关系，也就是说在<strong>x取值范围同样长的情况下</strong>，不同取值范围中函数的<strong>变化量不一样</strong>，部分密集，部分稀疏。所以应对<strong>密集部分</strong>我们需要<strong>加大学习率</strong>，尽快过渡到稀疏部分，从而减少重复学习的时间；应对<strong>稀疏部分</strong>我们要<strong>减少学习率</strong>，尽量避免忽略了重要区间的情况。</p>
<blockquote>
<p>好了，现在你通过数学计算拿到了$neko_1$，于是你准备获取$neko_2$。同样的，代入公式：</p>
<script type="math/tex; mode=display">neko_2=\left[\begin{matrix}
  a_2\\h_2\\w_2
\end{matrix}\right]
=\left[\begin{matrix}
  a_1\\h_1\\w_1
\end{matrix}\right]
-\eta\left[\begin{matrix}
{\partial\over\partial a} f(a_1,h_1,w_1)\\
{\partial\over\partial h} f(a_1,h_1,w_1)\\
{\partial\over\partial w} f(a_1,h_1,w_1)
\end{matrix}\right]</script><p>经过一番辛苦，你也得出来了这个数据。但是你实在算不下去了，虽然对猫娘包含热情，但是在完全机械的计算过程中，再怎么高涨的热情都会逐渐被消耗殆尽。于是你希望计算机能够帮助运算，便大致写下了一串伪代码：</p>
<p><code>repeat until convergence {</code></p>
<script type="math/tex; mode=display">\left[\begin{matrix}
  a_i\\h_i\\w_i
\end{matrix}\right]
:=
\left[\begin{matrix}
  a_i\\h_i\\w_i
\end{matrix}\right]
-\eta
\left[\begin{matrix}
  {\partial\over\partial a} f(a_i,h_i,w_i)\\
  {\partial\over\partial h} f(a_i,h_i,w_i)\\
  {\partial\over\partial w} f(a_i,h_i,w_i)
\end{matrix}\right]</script><p><code>}</code></p>
</blockquote>
<p><em>伪代码中<code>=</code>和<code>:=</code>略有区别，分别是<strong>相等</strong>和<strong>赋值</strong>的意思</em></p>
<p>这样看似乎没有什么大问题，但是在实际代码实现中，我们尤其需要注意一个很难注意到的细节：</p>
<p><strong>这个矩阵形式的写法意味着$a_i$、$h_i$、$w_i$是同步更新的！！！</strong></p>
<p><strong>这个矩阵形式的写法意味着$a_i$、$h_i$、$w_i$是同步更新的！！！</strong></p>
<p><strong>这个矩阵形式的写法意味着$a_i$、$h_i$、$w_i$是同步更新的！！！</strong></p>
<p>重要的事情说三遍！如果不是同步的话，<strong>错误的梯度下降</strong>伪代码将会变成这样：</p>
<blockquote>
<p><code>repeat until convergence {</code></p>
<script type="math/tex; mode=display">
 temp_a={\partial\over\partial a} f(a_i,h_i,w_i)\cdots①\\
 a_i = temp_a\\
 temp_h={\partial\over\partial h} f(a_i,h_i,w_i)\cdots②\\
 \ldots</script><p><code>}</code></p>
</blockquote>
<p>注意到了吗？①式和②式中，$a_i$的值不同了！这是严重的逻辑错误！</p>
<p><strong>正确的梯度下降</strong>伪代码就应该是这样：</p>
<blockquote>
<p><code>repeat until convergence {</code></p>
<script type="math/tex; mode=display">
 temp_a=a_i-\eta{\partial\over\partial a} f(a_i,h_i,w_i)\\
 temp_h=h_i-\eta{\partial\over\partial h} f(a_i,h_i,w_i)\\
 temp_w=w_i-\eta{\partial\over\partial w} f(a_i,h_i,w_i)\\
 a_i = temp_a\\
 h_i = temp_h\\
 w_i = temp_w</script><p><code>}</code></p>
</blockquote>
<p><strong>要么全部修改，要么全不修改</strong>。像极了数据库的<strong>原子性</strong>不是么？</p>
<p><em>在说明时我强调了是<strong>错误的梯度下降伪代码</strong>，而不是<strong>错误的伪代码</strong>，这是因为这本来就是一种正确的算法，但不是梯度下降，而是一种其他的什么代码。这就要各位读者继续读下去来寻找正确答案了。</em></p>
<p>没错，这就是通用解法，无论多少维，用这个矩阵解法都会有一个结果。随着学习的进行，导数或者偏导数都会逐渐变化，$\eta$也应当随之而变化。他也有另外一个名字，叫<strong>随机梯度下降</strong>，因为我们刚刚是随机选择初始点、根据梯度寻找下一跳、逐步靠近最优解，所以收敛的时候有很大的随机性，收敛时也会在局部最优附近疯狂抖动。还是用个反常的例子类比：</p>
<blockquote>
<p>你的猫娘很生气，你想逗她开心。你身边有很多东西，毛球、老鼠玩具、吉他、钢琴等等。你知道这些她都喜欢，但是你不知道这次怎么样才能让她开心。于是你开始疯狂试探。</p>
<p>有时候她笑了一下，有时候又挠你几下，有时候保持冷漠……在心情在变好和变坏之间反复横跳。最后，你终于拿出口琴吹起了她喜欢的音乐，把她哄好了。</p>
</blockquote>
<p>当然，公式归公式，解法是解法，这两个可以不需要严格意义上保持一致。也就是说，如果$f(a,h,w)$在求导的时候极大地增加了复杂度，就比如$\sqrt{\frac{1+sinx}{1-cosx}}$，我们可以人为地分段、化简，变成方便计算的其他公式，就像吴恩达教授的视频课程中将线性方程$Y=\beta_0+\beta_1x$中待定系数的求解从二次通过求导降为一次。（<em>如果你不清楚为什么是二次，请查看我之前写的<a href="/2020/07/26/人工智能/算法模型/代价函数">代价函数</a>一文</em>）</p>
<h2 id="一个尴尬的细节"><a href="#一个尴尬的细节" class="headerlink" title="一个尴尬的细节"></a>一个尴尬的细节</h2><p>好了，到了这里，相信各位读者对梯度下降也有一定的了解了。那么，各位有没有注意到一个小小的细节：<strong>我们是为什么需要根据一定的步长移动</strong>？其实是基于“<strong>最初随机选到的点并不是极值点</strong>”这一前提下展开的。那么我们就极端一点，最初就那么运气不好，选到了极值点，会怎么样呢？很显然，极值点的导数或偏导数都是0，最终我们的计算式也就化简成为了：</p>
<script type="math/tex; mode=display">\left[\begin{matrix}
  a_i\\h_i\\w_i
\end{matrix}\right]
:=
\left[\begin{matrix}
  a_i\\h_i\\w_i
\end{matrix}\right]
-\eta
\left[\begin{matrix}
  {\partial\over\partial a} f(a_i,h_i,w_i)\\
  {\partial\over\partial h} f(a_i,h_i,w_i)\\
  {\partial\over\partial w} f(a_i,h_i,w_i)
\end{matrix}\right]
=
\left[\begin{matrix}
  a_i\\h_i\\w_i
\end{matrix}\right]
-\eta\times0=
\left[\begin{matrix}
  a_i\\h_i\\w_i
\end{matrix}\right]</script><p>也就是说在这里我们将原地踏步。如果这里并不是全域最优解，而是局部最优解，我们也就像一开始介绍梯度下降是所说的一样：<strong>陷入局部最优解</strong>。这也正是<strong>步长过小</strong>造成的<strong>必然结果</strong>。</p>
<p>当然，既然有让你陷入局部最优解的情况，也有只能收敛到全局最优解的情况。用比较学术一点的话来说，就是“<strong>目标函数$f(a,h,w)$是一个凹函数</strong>”（<em>国外这里叫<strong>凸函数</strong>，因为看的方向不一样所以叫法不一样</em>），即目标函数的二阶偏导数<strong>恒大于0</strong>。这就导致一阶偏导数最多也就1个零点，即最多有一个极值，原函数要么是个碗，极值即最值；要么就单调，端点是最值。</p>
<p>很尴尬，也很无奈。当然办法还是有的，也就是<strong>贪心算法</strong>。这就依靠大家打怪升级之后解锁新篇章了，这里只介绍这么多有关梯度的内容。</p>
<h2 id="批量（Bacth）梯度下降"><a href="#批量（Bacth）梯度下降" class="headerlink" title="批量（Bacth）梯度下降"></a>批量（<code>Bacth</code>）梯度下降</h2><p>我相信你会等不及找答案的。所以这里提供一个临时的解决办法：批量梯度下降。</p>
<p>为什么是批量？在这里我们每次迭代都会整个训练集都试一遍，然后找到一个局部最优解，然后剪枝，重新遍历整个数据集，然后又找到下一个局部最优解，再剪枝……整个过程将会行走在非常标准的直通线路上。</p>
<p>当然，缺点也非常明显，整个训练一遍意味着需要大量的内存和大量的计算。如果训练集足够大，内存将无法一次性执行完，要么直接<code>OutOfMemoryException</code>，要么在内存加载的内容全部计算完后等待磁盘经过漫长的时间加载所需的下一批数据。整体来说还是相当的憋屈，所以也在逐渐的弃用这个方法。</p>
<p>是不是有点能理解了呢？</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>在吴恩达教授的课程中，解向量是这么求的：</p>
<script type="math/tex; mode=display">
\left[\begin{matrix}
  a_i\\h_i\\w_i
\end{matrix}\right]
:=
\left[\begin{matrix}
  a_i\\h_i\\w_i
\end{matrix}\right]
-\eta
\left[\begin{matrix}
  {\partial\over\partial a} f(a_0,h_0,w_0)\\
  {\partial\over\partial h} f(a_0,h_0,w_0)\\
  {\partial\over\partial w} f(a_0,h_0,w_0)
\end{matrix}\right]</script><p>其中在循环之中不停调整$a_0$、$h_0$、$w_0$的值。实际上这么做的核心目的依然是保持同步，只不过用本篇所讲述的方法是普遍都在使用的方法，因为看起来更简洁。</p>
]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>算法模型</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo添加数学公式渲染器</title>
    <url>/2020/07/26/hexo/hexo%E6%B7%BB%E5%8A%A0%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E6%B8%B2%E6%9F%93%E5%99%A8/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong><code>markdown</code>作为非常强大的编辑器，在公式编辑和网页兼容上做的非常不错。但是，还是有非常多没能兼顾的地方，这里就以我正在使用的<code>NexT</code>主题为例详细讲述公式编辑插件的安装。参考教程为<code>ShadowLearner</code>的<a href="https://www.jianshu.com/p/7ab21c7f0674" target="_blank" rel="noopener">在Hexo中渲染MathJax数学公式</a>一文。</strong></p>
<a id="more"></a>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>如果你是<code>Windows</code>系统，直接使用<code>Git Bash</code>的命令行在<code>Hexo</code>根目录下使用命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure>
<p>即删除默认的<code>hexo-renderer-marked</code>插件、安装<code>hexo-renderer-kramed</code>插件。</p>
<p>如果你是<code>Ubuntu</code>系统，请使用超管权限：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo npm uninstall hexo-renderer-marked --save</span><br><span class="line">sudo npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure>
<p>否则<code>NodeJS</code>就根本不会卸载或下载。</p>
<p>当然，其他的教程上也说明了语义冲突，你也可以对根目录下的<code>/node_modules/kramed/lib/rules/inline.js</code>稍加修改：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">var inline = &#123;</span><br><span class="line">  // 第2行修改</span><br><span class="line">  escape: /^\\([`*\[\]()#$+\-.!_&gt;])/,</span><br><span class="line">  ...</span><br><span class="line">  // 第20行修改（也可能是21行）</span><br><span class="line">  em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="打开开关"><a href="#打开开关" class="headerlink" title="打开开关"></a>打开开关</h2><p>教程中会有很多说明要打开开关，于是你无脑地复制了教程中的代码，贴在了自己的配置中，然后发现一点动静都没有，怒砸电脑。</p>
<p>实际上，你应该这么想：既然是有人已经做成了类似<code>SpringBoot</code>这种开箱即用的插件式模块，那么肯定是所有配置都齐全了的。所以，找到根目录下的<code>/themes/next/_config.yml</code>文件，按下<code>Ctrl+F</code>，在弹出的搜索框中输入<code>mathjax</code>查找匹配项，然后你找到了这样几行字：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># MathJax Support</span></span><br><span class="line"><span class="attr">mathjax:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">cdn:</span> <span class="string">//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML</span></span><br></pre></td></tr></table></figure>
<p><img src="https://sakebow.gitee.io/images/hexos/mathjax配置位置.png" alt="查到配置的位置"></p>
<p>把所有的<code>false</code>改成<code>true</code></p>
<p><code>enable</code>就是配置<code>mathjax</code>插件的启用与否；而<code>per_page</code>则是确认渲染所有还是逐个查找开启渲染的页进行渲染。</p>
<h2 id="页面渲染"><a href="#页面渲染" class="headerlink" title="页面渲染"></a>页面渲染</h2><p>这是在<code>per_page</code>配置为<code>true</code>的基础上才需要做的。如果你删除了这个配置项，那么就是默认选择<code>false</code>；如果你依然保持<code>false</code>，那么所有的页面将会渲染，这一步对你来说没有意义；如果你选择了<code>true</code>，那么你需要在<code>Hexo</code>的标题区（学术一点的称呼是<code>Front-matter</code>）中声明：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">这里是标题</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2020</span><span class="number">-07</span><span class="number">-26</span> <span class="number">09</span><span class="string">:27</span></span><br><span class="line"><span class="attr">categories:</span> <span class="string">自定义分类</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">自定义标签1</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">自定义标签2</span></span><br><span class="line"><span class="attr">mathjax:</span> <span class="literal">true</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>
<p>于是，你就可以使用<code>mathjax</code>作为你的公式渲染器了。</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>使用时即使使用``包裹住依然会被强行转码，所以尽可能在不需要转码的地方使用</p>
<p>为了给大家看看效果，这里就摆出所有可以使用的公式：</p>
<blockquote>
<p>以下内容全部整理自<strong>DanielGavin</strong>的<a href="https://www.jianshu.com/p/e74eb43960a1" target="_blank" rel="noopener"><code>Markdown</code>数学公式语法</a>一文。</p>
</blockquote>
<h3 id="单项式"><a href="#单项式" class="headerlink" title="单项式"></a>单项式</h3><ul>
<li><p>一对<code>$</code>包裹的就是嵌入一行文字内任意位置的公式： $xyz$</p>
</li>
<li><p>两对就是单独另起一行的公式：</p>
</li>
</ul>
<script type="math/tex; mode=display">abc</script><ul>
<li><p>用<code>^</code>标记含有上标的公式：$x^4y$</p>
</li>
<li><p>绝对值能够开平方：${\sqrt[2]{x^2}}=|x|$</p>
</li>
<li><p>用对数表示时间复杂度：$O(n\log_2(n))$</p>
</li>
<li><p>硫代硫酸根的化学式：${S}_{2}O_{3}^{2-}$</p>
</li>
</ul>
<h3 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h3><ul>
<li><p>x的<strong>向量</strong>（<em>也叫<strong>矢量</strong></em>）：$\vec{x}$</p>
</li>
<li><p>a的<strong>最小二乘估计量</strong>：$\hat{a}$</p>
</li>
<li><p>a的<strong>样本平均值</strong>：$\bar{a}$</p>
</li>
<li><p>函数$f(x)$的<strong>一阶导数</strong>：$\dot{f(x)}$</p>
</li>
<li><p><strong>二阶导数</strong>：$\ddot{f(x)}$</p>
</li>
<li><p>$f(x)$在一个范围内<strong>单调递增</strong>。这里的<code>uparrow</code>可以把<code>U</code>大写</p>
</li>
<li><p>极限里面的<strong>x趋近于0</strong>：$x\rightarrow0$，也可以用$\to$。两者虽然不同，但是非常相似，看你的喜好。趋近于无穷就是$x\to\infty$</p>
</li>
<li><p>限定范围：$\forall x\in\mathbb{R}，s.t.\dot{f(x)}^2=\ddot{f(x)f(x)}$</p>
</li>
</ul>
<h3 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h3><ul>
<li><p>普通的两项相加：$x+y$</p>
</li>
<li><p>虚数：$2-\imath$</p>
</li>
<li><p>二元虚数：$a\imath+b\jmath$</p>
</li>
<li><p>表示误差：$20\pm0.5$</p>
</li>
<li><p>分段函数：</p>
</li>
</ul>
<script type="math/tex; mode=display">y=\left\{\begin{aligned}
-x+10 &,  &x  &\in  &(-\infty, -10) \\
20    &,  &x  &\in  &(-10, 10)      \\
x+10  &,  &x  &\in  &(10, +\infty)
\end{aligned}\right.</script><ul>
<li>化学方程式</li>
</ul>
<script type="math/tex; mode=display">2H_2O_2 \xlongequal[\Delta]{M_nO_2} 2H_2O+O_2\uparrow</script><ul>
<li>化学表达式</li>
</ul>
<script type="math/tex; mode=display">C_{6}H_{12}O_{6} \xrightarrow{酶} H_2O+CO_2+ATP</script><ul>
<li><p>常用多项式展开式</p>
<ul>
<li><strong>三次方的展开式</strong>：</li>
</ul>
</li>
</ul>
<script type="math/tex; mode=display">a^3 \pm b^3 = (a \pm b)(a^2 \mp ab + b^2)</script><ul>
<li><strong>泰勒展开式</strong>：</li>
</ul>
<script type="math/tex; mode=display">e^x = 1 + x + {1\over2!}x^2 + {\frac{1}{3!}}x^3</script><ul>
<li><p>逻辑运算也是毫无压力的：</p>
<ul>
<li><p>大于小于等于没有区别，分别是：$x+y&gt;z$、$x+y&lt;z$、$x+y=z$</p>
</li>
<li><p>大于等于：$x+y \geq z$。这里由于<code>geq</code>可能会和<code>z</code>连在一起变成歧义，所以<strong>必须要有个空格</strong>避免歧义。下同。</p>
</li>
<li><p>小于等于：$x+y \leq z$</p>
</li>
<li><p>不等于：$x+y \neq z$</p>
</li>
<li><p>不大于等于：$x+y \ngeq z$</p>
</li>
<li><p>不小于等于：$x+y \nleq z$</p>
</li>
<li><p>约等于：$x+y \approx z$</p>
</li>
<li><p>恒等于：$x+y \equiv z$</p>
</li>
</ul>
</li>
<li><p>集合运算：</p>
<ul>
<li><p>表示<strong>元素x</strong>属于<strong>集合y</strong>：$x \in y$</p>
</li>
<li><p>表示<strong>元素x</strong>不属于<strong>集合y</strong>：$x \notin y$，当然也可以是$x \not\in y$</p>
</li>
<li><p>表示<strong>集合x</strong>的全部元素和<strong>集合y</strong>的部分元素相同：$x \subset y$</p>
</li>
<li><p>表示<strong>集合y</strong>的全部元素和<strong>集合x</strong>的部分元素相同：$x \supset y$。和刚刚的区别就是，开口向哪边，哪边就比较大。下同。</p>
</li>
<li><p>表示<strong>集合x</strong>的全部元素和<strong>集合y</strong>的一部分元素相同，但<strong>集合y</strong>还有<strong>集合x</strong>所没有的元素：$x \subseteq y$。和<code>subset</code>的区别在于这里明确说明了<strong>集合y</strong>比<strong>集合x</strong>更多，而<code>subset</code>没有说明，可以多，可以等，但不能少。</p>
</li>
<li><p>表示<strong>集合x</strong>是<strong>集合y</strong>的真子集，也就是说，<strong>集合y</strong>包含了<strong>集合x</strong>的全部元素，但是<strong>集合y</strong>和<strong>集合x</strong>不能完全相等：$x \subsetneq y$</p>
</li>
<li><p>$x \supseteq y$</p>
</li>
<li><p>$x \supsetneq y$</p>
</li>
<li><p>$x \not\subset y$</p>
</li>
<li><p>$x \not\supset y$</p>
</li>
<li><p>表示<strong>集合x</strong>和<strong>集合y</strong>所有元素合成新集合，但是要剔除重复的：$x \cup y$</p>
</li>
<li><p>表示选出<strong>集合x</strong>和<strong>集合y</strong>相同的元素组成新集合：$x \cap y$</p>
</li>
<li><p>表示将<strong>集合x</strong>中的元素选出和<strong>集合y</strong>相同的元素并删除，剩下的组合成新集合：$x \setminus y$</p>
</li>
<li><p>实数集合：$\mathbb{R}$</p>
</li>
<li><p>自然数集合：$\mathbb{Z}$</p>
</li>
<li><p>空集：$\emptyset$</p>
</li>
<li><p>同或运算，如：$x \bigodot y$</p>
</li>
<li><p>同与运算，如：$x \bigotimes y$</p>
</li>
</ul>
</li>
</ul>
<h3 id="高级运算"><a href="#高级运算" class="headerlink" title="高级运算"></a>高级运算</h3><ul>
<li>找规律类的给定项数运算，也可以求均值：</li>
</ul>
<script type="math/tex; mode=display">\overline{a}=\overbrace{a_1+a_2+ \cdots +a_n}^{200}=E(a)</script><ul>
<li>求一元极限：</li>
</ul>
<script type="math/tex; mode=display">\lim_{x \to 0} (1 + x)^{1 \over x} = e</script><ul>
<li>求二元极限：</li>
</ul>
<script type="math/tex; mode=display">\displaystyle \lim^{x \to \infty}_{y \to \infty}{\frac{(xy)^2}{x^2+y^2}}</script><ul>
<li>级数求和：</li>
</ul>
<script type="math/tex; mode=display">\sum^{n \rightarrow \infty}_{i=1}{\frac{i}{n^2}} = {1\over2}</script><ul>
<li>级数化简：</li>
</ul>
<script type="math/tex; mode=display">\sum^{n \rightarrow \infty}_{i=1}{\frac{i}{n^2}} = \int^1_0{xdx} = \frac{x^2}{2} | ^1_0 = {1\over2}</script><ul>
<li>偏微分:</li>
</ul>
<script type="math/tex; mode=display">\int^{+\infty}_{-\infty}\int^{+\infty}_{-\infty}\frac{\partial f(x,y)}{\partial y} dx + \frac{\partial f(x,y)}{\partial x} dy</script><ul>
<li>矩阵</li>
</ul>
<script type="math/tex; mode=display">\left[\begin{matrix}
  a+b   &a      &0      &\cdots &0      &0\\
  b     &a+b    &a      &\cdots &0      &0\\
  0     &b      &a+b    &\cdots &0      &0\\
  \vdots&\vdots &\vdots &\ddots &\vdots &\vdots\\
  0     &0      &0      &\cdots &a+b    &a\\
  0     &0      &0      &\cdots &b      &a+b\\
\end{matrix}\right]_n = \frac{a^{n+1}-b^{n+1}}{a-b}</script><h3 id="希腊符号"><a href="#希腊符号" class="headerlink" title="希腊符号"></a>希腊符号</h3><p><strong>注：<code>代码</code>栏首字母大写只能写出部分字母，而其他和英文字母重复的则不被支持</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>大写</th>
<th>字符</th>
<th>代码</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>$\alpha$</td>
<td>\alpha</td>
</tr>
<tr>
<td>B</td>
<td>$\beta$</td>
<td>\beta</td>
</tr>
<tr>
<td>$\Gamma$</td>
<td>$\gamma$</td>
<td>\gamma</td>
</tr>
<tr>
<td>$\Delta$</td>
<td>$\delta$</td>
<td>\delta</td>
</tr>
<tr>
<td>E</td>
<td>$\epsilon$</td>
<td>\epsilon</td>
</tr>
<tr>
<td>Z</td>
<td>$\zeta$</td>
<td>zeta</td>
</tr>
<tr>
<td>H</td>
<td>$\eta$</td>
<td>\eta</td>
</tr>
<tr>
<td>$\Theta$</td>
<td>$\theta$</td>
<td>\theta</td>
</tr>
<tr>
<td>I</td>
<td>$\iota$</td>
<td>\iota</td>
</tr>
<tr>
<td>K</td>
<td>$\kappa$</td>
<td>\kappa</td>
</tr>
<tr>
<td>$\Lambda$</td>
<td>$\lambda$</td>
<td>\lambda</td>
</tr>
<tr>
<td>M</td>
<td>$\mu$</td>
<td>\mu</td>
</tr>
<tr>
<td>N</td>
<td>$\nu$</td>
<td>\nu</td>
</tr>
<tr>
<td>$\Xi$</td>
<td>$\xi$</td>
<td>\xi</td>
</tr>
<tr>
<td>O</td>
<td>$\omicron$</td>
<td>\omicron</td>
</tr>
<tr>
<td>$\Pi$</td>
<td>$\pi$</td>
<td>\pi</td>
</tr>
<tr>
<td>P</td>
<td>$\rho$</td>
<td>\rho</td>
</tr>
<tr>
<td>$\Sigma$</td>
<td>$\sigma$</td>
<td>\sigma</td>
</tr>
<tr>
<td>T</td>
<td>$\tau$</td>
<td>\tau</td>
</tr>
<tr>
<td>$\Upsilon$</td>
<td>$\upsilon$</td>
<td>\upsilon</td>
</tr>
<tr>
<td>$\Phi$</td>
<td>$\phi$</td>
<td>\phi</td>
</tr>
<tr>
<td>X</td>
<td>$\chi$</td>
<td>\chi</td>
</tr>
<tr>
<td>$\Psi$</td>
<td>$\psi$</td>
<td>\psi</td>
</tr>
<tr>
<td>$\Omega$</td>
<td>$\omega$</td>
<td>\omega</td>
</tr>
</tbody>
</table>
</div>
<h2 id="最后给点小玩意"><a href="#最后给点小玩意" class="headerlink" title="最后给点小玩意"></a>最后给点小玩意</h2><p>当然，<code>markdown</code>也并不是万能的，因为还有很多类似序号等特殊段首标记无法打出来。<code>Windows10</code>现在自带的微软输入法可能会带这些东西，但是<code>Ubuntu</code>的<code>iBus-pinyin</code>就是没有，很无奈，所以在这里贴出来一些：</p>
<blockquote>
<p>⓪ ① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ ㉑ ㉒ ㉓ ㉔ ㉕ ㉖ ㉗ ㉘ ㉙ ㉚ ㉛ ㉜ ㉝ ㉞ ㉟ ㊱ ㊲ ㊳ ㊴ ㊵ ㊶ ㊷ ㊸ ㊹ ㊺ ㊻ ㊼ ㊽ ㊾ ㊿</p>
<p>⓿ ❶ ❷ ❸ ❹ ❺ ❻ ❼ ❽ ❾ ❿⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴</p>
<p>——摘自<strong>Applied Sciences</strong>的<a href="https://blog.csdn.net/appleyuchi/article/details/84036985" target="_blank" rel="noopener">带圆圈的数字和markdown常用表达式记录(持续更新中)</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>NexT主题踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title>代价函数</title>
    <url>/2020/07/26/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E4%BB%A3%E4%BB%B7%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>这里将会从一个简单的例子引入话题。例子是一个自变量和一个因变量构成的一元一次函数。因为同时兼顾了有趣和浅显，例子也是相当的乱来，能会意就行，吐槽就免了吧。</strong></p>
<a id="more"></a>
<h2 id="回归函数"><a href="#回归函数" class="headerlink" title="回归函数"></a>回归函数</h2><p>在说明代价函数前我们先复习回归函数。</p>
<blockquote>
<p>现在你突发奇想，想知道<strong>猫娘年龄和猫粮食用量之间的关系</strong>，你跑遍了全世界找了所有的<strong>20万只猫娘</strong>，问到了食量，作了个匿名记录，记下了<strong>年龄</strong>和<strong>食量</strong>的关系，并总结出了一张<strong>散点图</strong>。你看着你家幼小的猫娘，看了看散点表，<strong>预测</strong>出了她这个年龄大概吃多少。当然，你非常疼爱你的猫娘，<strong>不够吃的话肯定还是会加</strong>，<strong>吃不下也会多加调整</strong>。</p>
<p><img src="https://sakebow.gitee.io/images/background/illust_80183815_20200714_143825.jpg" width="200" alt="pid=143825"></p>
</blockquote>
<p><strong>我知道你很想吐槽，现在憋着。</strong></p>
<p>首先，通过这个例子，我们先重点强调一些细节：</p>
<ul>
<li><p>十几万只猫娘是你的<strong>样本容量</strong>，虽然数量不是很大，但是足以说明问题；</p>
</li>
<li><p>这里自变量是年龄，因变量是食量，只是一个单纯的<strong>一元一次方程</strong>;</p>
</li>
<li><p>虽然能够收集非常多数据，但是你<strong>只能画出散点图</strong>；</p>
</li>
<li><p>你需要为你的小猫娘<strong>预测</strong>食量；</p>
</li>
</ul>
<p>明白了这些细节之后，我们应该怎么操作呢？从初中到大学我们学到的<strong>线性回归方程</strong>就是为了这个问题服务的。</p>
<p>通过散点图，你可以使用一条直线贯穿大部分的点，一些<strong>少有偏离可能是个体差异</strong>，比如活泼、好动、成长期<del>还有发情期</del>等等；同样也一定有<strong>过于偏离</strong>这条直线的散点数据，<strong>少量则有可能是记录错误</strong>，而大量的话要么是<strong>有其他决定条件</strong>，要么是<strong>数学模型选择错误</strong>。<strong>这里我们就假定没有其他条件而且数学模型就是一元一次函数</strong>。</p>
<p>如果你大学认真学习了《概率论与数理统计》，那么你应该对线性回归方程不陌生。</p>
<p>于是你熟练地写出：</p>
<blockquote>
<p>猫娘的食量<code>Y</code>和猫娘的年龄<code>x</code>之间有线性关系，设</p>
<p>Y = $\beta_0$ + ${\beta_1}x+\epsilon$，其中$\beta_0$和$\beta_1$是待定系数，$\epsilon$是随机误差，满足$\epsilon$~$N(0,\sigma^2)$</p>
</blockquote>
<p>既然$\epsilon$服从正态分布，那么<code>Y</code>呢？</p>
<p>由于<code>Y</code>与<code>x</code>的关系为线性关系，所以就有：</p>
<p>$EY=E(\beta_0+{\beta_1}x)=\beta_0+{\beta_1}E(x)$</p>
<p>所以你接着写下：</p>
<blockquote>
<p>依题意，$Y$~$N(\beta_0+{\beta_1}x,\sigma^2)$</p>
</blockquote>
<p>你可能会怀疑到这一步能够得出什么。这个只能说在一定的正确率范围内预测这个事实，而不能完完全全的当作必然。</p>
<p>那么，怎么预测呢？在这个只有离散型数据的图表中，如何才可以制定一个尽可能正确的线性方程呢？这就需要<strong>最小二乘估计</strong>。</p>
<p>我们先忽略$\epsilon$的影响，因为无法预测；然后将线性方程简化为我们能够预测的样子，并将我们所收集的样本值一一对应进去。所以你写着：</p>
<script type="math/tex; mode=display">\hat{y_i}=\hat{\beta_0}+\hat{\beta_1}x_i</script><p>需要注意的是，这个是我们的预测函数，而不是实际规律。没人知道实际规律，因为总有这样那样的误差，只能说尽可能的出一个大家都认同的规律。</p>
<p>代入每一个实际的$x_i$，我们都能获得一个预测的$\hat{y_i}$。而实际的$x_i$却又对应事实成立的$y_i$，两者的差就是偏离度。为了尽可能拟合数据，我们应当尽可能缩小这个偏差。于是，我们准备求出每一组偏差距离，也就是<strong>y坐标差的绝对值</strong>，即$|y_i-\hat{y_i}|$，也就是$|y_i-\beta_0-{\beta_1}x|$，并让他最小。这部分就是高数的<strong>拉格朗日定理</strong>了。</p>
<p>于是你接着写下：</p>
<blockquote>
<p>由20组已知数据组$(x_i,y_i)$，则将x、y设为已知量，令n=200,000，且</p>
<script type="math/tex; mode=display">L(\beta_0,\beta_1)=\sum^{n}_{i=1}(y_i-\beta_0-{\beta_1}x_i)^2</script><p>分别对$\beta_0$和$\beta_1$求偏导，并令偏导为0，能够得出两个等式：</p>
<script type="math/tex; mode=display">{\frac{\partial L(\beta_0,\beta_1)}{\partial\beta_0}}=-2\sum^{n}_{i=1}(y_i-\beta_0-{\beta_1}x)=0\cdots①</script><script type="math/tex; mode=display">{\frac{\partial L(\beta_0,\beta_1)}{\partial\beta_1}}=-2\sum^{n}_{i=1}(y_i-\beta_0-{\beta_1}x)x=0\cdots②</script><p>解得：</p>
<script type="math/tex; mode=display">\beta_0=\frac{(\sum^n_{i=1}y_i)(\sum^n_{i=1}x_i^2)-(\sum^n_{i=1}x_i)(\sum^n_{i=1}x_iy_i)}{n(\sum^n_{i=1}x_i^2)-(\sum^n_{i=1}x_i)^2}</script><script type="math/tex; mode=display">\beta_1=\frac{n(\sum^n_{i=1}x_iy_i)-(\sum^n_{i=1}x_i)(\sum^n_{i=1}y_i)}{n(\sum^n_{i=1}x_i^2)-(\sum^n_{i=1}x_i)^2}</script></blockquote>
<p>相信你解到这一步的时候都快疯掉了，直接看答案的估计也蒙圈了。你放心，这玩意在2020年绝对不会靠人算，如果真的碰到了那也只能祝你好运了。</p>
<p>不过就算是这种算式也是能够简化到一定地步的。别忘了还有这些：</p>
<blockquote>
<p>记$\bar{x}=\frac{\sum^n_{i=1}x_i}{n}$，$\bar{y}=\frac{\sum^n_{i=1}y_i}{n}$</p>
<p>整理得：</p>
<script type="math/tex; mode=display">\hat{\beta_1}=\frac{\sum^n_{i=1}x_iy_i-n\bar{x}\bar{y}}{\sum^n_{i=1}x_i^2-n\bar{x}^2}</script><script type="math/tex; mode=display">\hat{\beta_0}=\bar{y}-\bar{x}\hat{\beta_1}</script></blockquote>
<p>是不是觉得好看多了？而且这样子也更便于计算。</p>
<blockquote>
<p>故代入方程得：</p>
<script type="math/tex; mode=display">\hat{Y}=\hat{\beta_0}+\hat{\beta_1}x</script></blockquote>
<p>这下子你就能够用这个方程来预测你的小猫娘会吃多少啦！</p>
<p><img src="https://sakebow.gitee.io/images/background/illust_79288093_20200714_142659.png" width="250" alt="pid=142659"></p>
<h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><p>好了，讲了这么久的回归函数，是不是完全不知道这玩意和代价函数有什么关系？别担心，慢慢来。</p>
<p>在机器学习中，我们主要希望计算机尽可能贴近事实，也就是尽可能计算最为贴近所有样本的一元线性函数（<em>当然也有可能是别的什么函数，这里以一元线性为例</em>）。</p>
<p>既然是尽可能贴近，我们就会在其中筛选不贴近的、折衷较为贴近的、选取最为贴近的。于是：</p>
<ul>
<li><p>针对<strong>单个样本</strong>，我们规定了<strong>损失函数</strong>，也就是在整个线性规划的过程中产生偏差的量；</p>
</li>
<li><p>针对<strong>全部取样样本</strong>，我们规定了<strong>代价函数</strong>，也就是研究在线性规划中整个取样的样本产生偏差的量；</p>
</li>
<li><p>针对<strong>最终结果</strong>，我们规定了<strong>目标函数</strong>，也就是在尽可能照顾到所有取样样本之后研究出的最贴近事实的函数</p>
</li>
</ul>
<p>一开始听起来像是三个新词？这么一说明，是不是开始和以前的线性规划对上了？</p>
<p><strong>损失函数</strong>，其实就是<strong>残差</strong>，以前我们记为$e$；而<strong>代价函数</strong>其实就是残差的绝对值的和，但是因为计算不方便，我们全部平方了，也就是残差的平方和，最后求导再除2就是最终结果；而<strong>目标函数</strong>，就是在<strong>代价函数在取值范围内最小</strong>的情况下拟合出来的函数。</p>
<p>好了，到这里答案就出来了。代价函数就是求解线性方程时使用的拉格朗日定理构造的函数。之前我们定义的是：</p>
<script type="math/tex; mode=display">L(\beta_0,\beta_1)=\sum^{n}_{i=1}(y_i-\beta_0-{\beta_1}x_i)^2</script><p>但是同时要兼顾到计算的简便，我们再取一个求导之后不会有系数的函数：</p>
<script type="math/tex; mode=display">L(\beta_0,\beta_1)=\frac{\sum^{n}_{i=1}(\beta_0+{\beta_1}x_i-y_i)^2}{2n}</script><p>不仅在求导的时候去掉了系数$2$，还避免了符号问题，顺便还提供了一个$\frac{1}{n}$方便计算均值。不得不说，<strong>NICE</strong>！</p>
<p>你担心这样复杂的算法会拖垮计算机速度？当然不是把这个模型直接搬给计算机去算的啦，这只不过是数学推导过程，最后还是要根据计算机的特点尽可能化简成只有次数不多的加减、涵盖了几乎全部的重复劳动的算法。</p>
]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>算法模型</tag>
      </tags>
  </entry>
  <entry>
    <title>模型描述</title>
    <url>/2020/07/25/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E6%A8%A1%E5%9E%8B%E6%8F%8F%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>我们在描述算法的时候，往往也会提到“算法模型”这个概念。模型是什么？算法和模型之间有什么联系？</strong></p>
<a id="more"></a>
<h2 id="算法的定义"><a href="#算法的定义" class="headerlink" title="算法的定义"></a>算法的定义</h2><p>如果你在大学学过了数据结构，这句话你应该耳熟能详：</p>
<blockquote>
<p>通俗地讲，算法是解决问题的一种方法或一个过程。更严格地讲，算法是由若干条指令组成的有穷序列，且满足下述4条性质</p>
<ul>
<li><p>输入：0个或者多个外部提供的量作为算法输入项</p>
</li>
<li><p>输出：算法应当产生至少一个量作为输出项</p>
</li>
<li><p>确定性：组成算法的每条指令是清晰的、没有歧义的</p>
</li>
<li><p>有限性：算法中每条指令的执行次数是有限的，执行每条指令的时间也是有限的</p>
</li>
</ul>
<p>——摘自《计算机算法设计与分析》（第五版），王晓东著</p>
</blockquote>
<p>那，模型又是什么？</p>
<h2 id="原型的概念"><a href="#原型的概念" class="headerlink" title="原型的概念"></a>原型的概念</h2><p>在说明模型之前必须说说原型是什么。原型，简单的说，就是最原始的模型。动漫里经常有作者以身边的谁为原型创作的，打个比方的话，应该就是40原老师笔下的猫娘了。（<del><em>吐槽：胖次专业户画猫娘有什么不对嘛</em></del>）</p>
<p><img src="https://sakebow.gitee.io/images/数学建模/20201003_193337.jpg" alt="40原老师笔下的猫娘" width=400></p>
<p>当然原型不限于这个。还有其他的比如：</p>
<p>实际生产中经理最关心的实际上也是一种原型，即生产、管理的实际对象。</p>
<p>或者是研究员在解决实际问题的时候，对于新假设的提出有启发作用的也叫原型。</p>
<h2 id="模型的概念"><a href="#模型的概念" class="headerlink" title="模型的概念"></a>模型的概念</h2><p>当我们拿到一个问题之后，如果分析出了原型，我们就能够进行一定程度的<strong>总结</strong>，然后<strong>忽略部分细节</strong>、<strong>加强部分计算</strong>，最终就能够将一个实际问题的解法<strong>提取成一套数学方程式</strong>。</p>
<p>一个很简单的例子：你想带你家的几只猫娘出去玩，可是考虑到在玩上需要多花钱，于是你选择在路费上尽可能节省。这个问题大家应该熟悉得不能再熟悉了吧，就是线性规划。把一个实际的问题整理成多条直线的相交问题，这就是建模。</p>
<p>我们知道，现在普遍使用的算法例如深度搜索、哈密顿回路等等经典算法都是经过很长时间的发现、假说、论证、优化的不停循环才产生出来，而这个论证的过程就是将算法抽象为一系列的数学模型，然后计算时间复杂度、空间复杂度，最终在比较中筛选更为优秀的。所以我们平常所说的“<strong>模型</strong>”都是指“<strong>数学模型</strong>”。</p>
<p>也就是说：</p>
<blockquote>
<p>模型是一类问题的解题步骤，亦即一类问题的算法。</p>
<p>——摘自<strong>慕码人2483693</strong>对<a href="http://www.imooc.com/wenda/detail/447305" target="_blank" rel="noopener"><strong>模型与算法之间是什么关系</strong></a>一问的回答</p>
</blockquote>
<h2 id="建模的必要性"><a href="#建模的必要性" class="headerlink" title="建模的必要性"></a>建模的必要性</h2><p>那么，为什么建模呢？</p>
<p><img src="https://sakebow.gitee.io/images/emoji/young.jpg" alt="年幼的目光"></p>
<p>一个实际问题往往涉及很多很多个方面。举个例子：你们家的小猫娘突然有一天看着像浑身没劲，往往有<strong>无数个原因</strong>，被你冷落了、陪你玩累了、有点生病了、<del>发情期到了</del>等等。</p>
<p>但是，这么多因素谁知道是什么情况啊，万一没病给整出病了，那不得心疼得要命。所以，你拿出了猫娘观察记录小本本，查询了你们家的猫娘从小以来点点滴滴的反应，高兴了、伤心了、痛苦了、冷漠了等等应有尽有。然后针对这些表现，你一项项对比，并得出一个<strong>相关系数</strong>。找出所有项目中<strong>相关系数最大的一项</strong>，然后发现你的猫娘就只是玩累了而已。给她铺条毯子好好睡吧。</p>
<p>这就是建模的好处，能够从所有的选项中<strong>找出</strong>相关变量并<strong>剔除</strong>无关变量，甚至能够分析<strong>相关变量到底如何影响最终结果</strong>。</p>
<h2 id="算法和模型"><a href="#算法和模型" class="headerlink" title="算法和模型"></a>算法和模型</h2><p>算法和模型往往都是分不开的。算法是一类问题的抽象解答，而模型则是一系列算法的数学表达。</p>
<p>如果问题不是一类问题，就单单类似<strong>这只猫接下来要做什么</strong>这样的问题，算法也就失去了存在的必要；同样的，算法如果也不是一系列算法，就单单类似<strong>这只狗吃骨头的流程</strong>这样的算法，模型也没有存在的必要。就像是数据结构中的抽象实体类<code>ADT</code>一样，它的存在就是为了描述一系列相似问题的解法的。</p>
<p>所以，你能够理解为什么会有<strong>推荐算法模型</strong>了么？因为一系列的<code>APP</code>都将会根据用户的使用情况收集偏好并提高用户体验，这些<code>APP</code>囊括了生活中的方方面面，包括<strong>美食</strong>、<strong>服饰</strong>、<strong>手办</strong>、<strong>模玩</strong>、<strong>家具</strong>还有<strong>电子产品</strong>甚至<strong>性癖</strong>（<del><em>比方说<code>pixiv</code></em></del>）等等。因为类似，这就抽象出来了。</p>
<h2 id="机器学习中模型的描述"><a href="#机器学习中模型的描述" class="headerlink" title="机器学习中模型的描述"></a>机器学习中模型的描述</h2><p>正如一开始所说的，算法需要有<strong>0个以上的输入</strong>、<strong>1个以上的输出</strong>，机器学习中的算法也是一样的，有着0个以上的<strong>数据集</strong>输入，输出至少一个<strong>结果</strong>。数据集中包括了大量的具有相似数据结构的信息，可以是事实，也可以是虚拟信息；而输出则是根据结果的预测、分类等等。就如下图所示：</p>
<p><img src="https://sakebow.gitee.io/images/机器学习/模型描述流程图1.png" alt="机器学习模型描述"></p>
<p>这个机器学习的算法并不是一成不变的，同样也是在不断的实践和训练中逐渐发现最贴近事实、最能概括所有内容的数学模型和算法。</p>
<p>是不是能理解了？</p>
]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>算法模型</tag>
      </tags>
  </entry>
  <entry>
    <title>监督学习</title>
    <url>/2020/07/24/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>监督学习，就如同字面意思，有人一直作为督工一直监督机器学习。</strong></p>
<a id="more"></a>
<h2 id="监督学习的定义"><a href="#监督学习的定义" class="headerlink" title="监督学习的定义"></a>监督学习的定义</h2><blockquote>
<p>监督学习是从标记的训练数据来推断一个功能的机器学习任务。训练数据包括一套训练示例。在监督学习中，每个实例都是由一个输入对象（通常为矢量）和一个期望的输出值（也称为监督信号）组成。监督学习算法是分析该训练数据，并产生一个推断的功能，其可以用于映射出新的实例。一个最佳的方案将允许该算法来正确地决定那些看不见的实例的类标签。这就要求学习算法是在一种“合理”的方式从一种从训练数据到看不见的情况下形成。</p>
<p>摘自<a href="https://baike.baidu.com/item/监督学习/9820109?fr=aladdin" target="_blank" rel="noopener">百度百科：监督学习</a></p>
</blockquote>
<p>是不是非常非常拗口而且难懂？这可能是中国学术的悲哀，说的非常的生涩难懂，似乎不是为了给别人看。这里就简单概括一下：</p>
<blockquote>
<p>监督学习是给定一组数据作为正确答案输入计算机程序中并完成适当的训练。在训练结束后机器能够在满足一定正确率的情况下进行预测。</p>
</blockquote>
<p>举个例子：</p>
<blockquote>
<p>你想要一夜暴富，但是你明白你要脚踏实地，所以你开始了一夜暴富的可行性分析。首先你收集了全球富豪的姓名、年龄、婚姻状况、政治身份、民族、家庭住址、教育背景，然后找到了全球富豪祖宗三代的同样的信息。长时间的整理之后，你作出了多张图表，分别是每个人不同属性和现持有资金的离散型数据关系。然后，你得出结论：一夜暴富的可能性几乎没有。</p>
</blockquote>
<p>虽然这个例子有点乱来，但是相信大家还是明白这个道理的。就是说，这些全球成功暴富的人，也就是以正确答案输入程序的<strong>训练集</strong>，在经过一段时间的分析，也就是<strong>适当的训练</strong>。为什么是适当呢？如果训练不够，你就会轻易地觉得自己没有希望，最终自闭。这也叫<strong>欠拟合</strong>；如果训练过当，你就会盲目自信，然后赔得内裤都没得穿。这也叫<strong>过拟合</strong>。适当训练之后，你就能够<strong>在一定正确率的情况下预测</strong>自己能不能一夜暴富。当然，这也只是说一定的正确率，是不是实际发生谁也不知道。</p>
<p>是不是多少明白了一点点呢？</p>
]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>非监督学习</title>
    <url>/2020/07/24/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E9%9D%9E%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>非监督学习，就如同字面意思，没有人监督的，也就是机器自学。</strong></p>
<a id="more"></a>
<h2 id="非监督学习的定义"><a href="#非监督学习的定义" class="headerlink" title="非监督学习的定义"></a>非监督学习的定义</h2><blockquote>
<p>现实生活中常常会有这样的问题：缺乏足够的先验知识，因此难以人工标注类别或进行人工类别标注的成本太高。很自然地，我们希望计算机能代我们完成这些工作，或至少提供一些帮助。根据类别未知(没有被标记)的训练样本解决模式识别中的各种问题，称之为无监督学习。</p>
<p>——摘自<a href="https://baike.baidu.com/item/无监督学习/810193" target="_blank" rel="noopener">百度百科：无监督学习</a></p>
</blockquote>
<p>这个定义似乎比<strong>监督学习</strong>更简单，最起码而言没有涉及过多的理科专有词汇。不过这个定义依然比较抽象，我们来举个例子看看：</p>
<blockquote>
<p>你是一个大老板，能赚很多钱，但是除了赚钱一无所知。这一天，你拿到了一车黑色液体，里面有酱油，有生抽，有可乐，甚至有枇杷膏。你知道这些是你能够发财致富的东西，可你却<strong>完全不知道它们之间的区别是什么</strong>。于是你请了一队人<strong>工具人</strong>来帮你鉴定分类，他们都是各种菜系的国家级厨师，能够很快根据自己的经验捕捉到这瓶黑色液体的显著特点，并鉴定出这到底是什么；然后给你分好类、装好箱、上好架。最后，你根据他们分好的类别去货架上贴好标签，你的店铺就被<strong>整理得整整齐齐</strong>的了。</p>
</blockquote>
<p>听起来这个例子无论是<strong>机器</strong>还是<strong>学习</strong>都扯不上半点关系，但这个例子确实说明了<strong>无监督学习的几个特点</strong>：</p>
<ul>
<li><p>缺乏足够的先验知识，因此你没有办法直接给这些黑色液体标注类别；</p>
</li>
<li><p>因为量太大，自己标注所需要花费的时间成本太高，只好交给别人，而且是极其有耐心的<strong>工具人</strong>；</p>
</li>
</ul>
<p>那么，我们在这两条特点的基础上继续整理出<strong>无监督学习的使用条件</strong>：</p>
<ul>
<li><p>从<strong>庞大的样本</strong>集合中选出一些具有代表性的加以标注用于分类器的训练；</p>
</li>
<li><p>先将所有样本自动分为不同的类别，再<strong>由人类对这些类别进行标注</strong>；</p>
</li>
<li><p>在<strong>无类别信息</strong>情况下，寻找好的特征；</p>
</li>
</ul>
<p>也就是说，只要这组数据并没有明确分类，只是整个数据集一股脑地全扔给了程序，那就需要使用无监督学习。而如果你已经明确知道了这一大串数据集中哪些是第一类，哪些是第二类，就像是垃圾邮件和星标邮件的明显区别，就是监督学习。</p>
<p>是不是能理解一点了？</p>
]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习是什么</title>
    <url>/2020/07/24/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>这里我参考的教程是吴恩达在2019年录制的课程，在B站上有链接，只不过是全英文，<a href="https://bilibili.com/BV164411S78V" target="_blank" rel="noopener">点我跳转</a>。当然，如果你选择<a href="https://bilibili.com/BV1JE411g7XF" target="_blank" rel="noopener">李宏毅的机器学习课程</a>也可以，因为是中文所以对于更多人来说更亲切一点。</strong></p>
<a id="more"></a>
<h2 id="机器学习的定义"><a href="#机器学习的定义" class="headerlink" title="机器学习的定义"></a>机器学习的定义</h2><p><code>Arthur Samuel</code>早在1959年就给即去学习下了个定义：</p>
<blockquote>
<p><code>Field of study that gives computers the ability to learn without being explicitly programmed</code></p>
<p>译：在没有明确设置的情况下是计算机具有学习能力的研究领域</p>
</blockquote>
<p>当然，这个定义稍微有些陈旧了。1998年，<code>Tom Mitchell</code>更新了这个定义：</p>
<blockquote>
<p><code>A computer program is said to *learn* from experience E with respect to some task T and some performace measure P, if its performace on T, as measured by P, improves with E</code></p>
<p>译：计算机程序从经验<code>E</code>中学习，解决某一任务<code>T</code>，进行某一性能度量<code>P</code>，通过<code>P</code>测定在<code>T</code>上的表现因经验<code>E</code>而提高。</p>
</blockquote>
<p>听起来非常的绕口？当然啦，这是人家的比喻，吴恩达老师在这里给出了一个例子：</p>
<blockquote>
<p>你需要参加研究生招生考试，最终考上心仪的大学，走向人生巅峰。在这次考试中，你将会面对很多题目，每个题目可能对应一个甚至多个知识点。为了掌握这些知识点，刷题便是我们现在400万考研的大学生正在做的事。</p>
<p>那么，针对这个例子，请找出任务<code>T</code>、性能度量<code>P</code>和经验<code>E</code>。</p>
</blockquote>
<p>这个例子虽然并不是那么的恰当，但是也相当具有代表性。<strong>考上心仪的大学</strong>就是任务<code>T</code>，而<strong>考试得分</strong>就是性能度量<code>P</code>，<strong>刷题</strong>就是经验<code>E</code>。通过监测你的<strong>得分</strong><code>P</code>，<strong>考上心仪大学</strong>的任务<code>T</code>将会因为你大量的<strong>刷题</strong><code>E</code>而一步一步靠近。</p>
<p>如果是好不容易考上研究生的你是不是能理解了？</p>
<p><img src="https://sakebow.gitee.io/images/emoji/滑稽-屑狐狸版.jpg" alt="滑稽"></p>
<h2 id="机器学习的分类"><a href="#机器学习的分类" class="headerlink" title="机器学习的分类"></a>机器学习的分类</h2><p>机器学习主要就是<strong>监督学习</strong>和<strong>非监督学习</strong>。当然我们还有非常多的，例如强化学习、推荐系统等等。这些都是其他的具体应用了，<strong>监督学习</strong>和<strong>非监督学习</strong>更像是这一切的基础。正所谓：</p>
<blockquote>
<p>公欲善其事，必先利其器</p>
</blockquote>
<p>当然，如果你是程序大佬，你也可以直接看推荐系统的源代码，并从中学到非常多的算法，积累非常多的经验。但是，正如我曾经的足球教练所说的，完全凭着经验能够做的非常好、非常快。但是，这些人<strong>遇到瓶颈也非常快</strong>，遇到了更强的人将<strong>无法战胜</strong>。这就是<strong>基本功的重要性</strong>。</p>
<p>在将来的几篇中，我将详细展开这两个基本的机器学习模式。请直接点击链接跳转到相应的教程：<a href="/2020/07/24/机器学习/监督学习/">监督学习</a>、<a href="/2020/07/24/机器学习/非监督学习/">非监督学习</a></p>
]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>针对SQL语句本身的查询优化</title>
    <url>/2020/07/19/MySQL/%E9%92%88%E5%AF%B9SQL%E8%AF%AD%E5%8F%A5%E6%9C%AC%E8%BA%AB%E7%9A%84%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>现在项目愈加复杂的需求中越来越离不开数据库了。而实际项目中，查询往往占绝大多数。所以查询的优化是整个项目的关键。</strong></p>
<a id="more"></a>
<h2 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h2><p>在我之前写的<a href="/2020/07/29/MySQL/SQL基础/">SQL基础</a>中，描述了<code>SQL</code>语句的执行顺序，还是那个手办的例子：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> 手办表.对应人物, 手办表.服饰, 手办表.价格, 番剧表.番剧名称, 番剧表.出场人物</span><br><span class="line"><span class="keyword">FROM</span> 手办表, 番剧表</span><br><span class="line"><span class="keyword">WHERE</span> 手办表.对应人物 = 番剧表.出场人物</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> 手办表.对应人物, 手办表.服饰, 手办表.价格, 番剧表.番剧名称, 番剧表.出场人物</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> 手办表.价格 <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>
<p>按照之前的顺序，我们一步一步分析：</p>
<h2 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a><code>FROM</code></h2><p>我们将会把<code>FROM</code>后面跟着的所有的表全部加载到内存。听起来是为了方便筛选数据，但是这么做对于海量数据的表将会是毁灭性的。就单纯的像学生管理系统的学生表，涉及姓名、密码、民族、政治面貌、入学时间、毕业时间、奖惩记录等等可能上百个字段，几万行数据，相当的消耗内存。如果真的是联立表，推荐使用<code>JOIN</code>进行联立。</p>
<h2 id="JOIN-amp-ON"><a href="#JOIN-amp-ON" class="headerlink" title="JOIN&amp;ON"></a><code>JOIN</code>&amp;<code>ON</code></h2><p><code>ON</code>将会在联立两个表的数据之前仅加载一张表的数据，然后另一张表通过一定的条件合并到第一张表中，相对于直接联立会减小很多压力。所以，本例中的<code>SQL</code>语句可以修改为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> 手办表.对应人物, 手办表.服饰, 手办表.价格, 番剧表.番剧名称, 番剧表.出场人物</span><br><span class="line"><span class="keyword">FROM</span> 番剧表</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> 手办表</span><br><span class="line"><span class="keyword">ON</span> 手办表.对应人物 = 番剧表.出场人物</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> 手办表.对应人物, 手办表.服饰, 手办表.价格, 番剧表.番剧名称, 番剧表.出场人物</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> 手办表.价格 <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>
<p>虽然在本例中查询出来的结果是一样的，但是查询过程略有不同：<code>LEFT JOIN</code>会保留左表所有数据，即使没有匹配成功也会显示，<code>RIGHT JOIN</code>则是保留右表；两者在查询时间上也略有区别，但是这里数据实在太少，区别不明显。如果是查询中国街道表将会有非常明显的变化。</p>
<h2 id="WHERE"><a href="#WHERE" class="headerlink" title="WHERE"></a><code>WHERE</code></h2><p><code>WHERE</code>作为筛选条件，虽然说没有非常明显的优化方式，但是还是想说：尽量少用字符串作为匹配条件。在匹配的时候往往会整个串遍历，时间复杂度最少也是<code>KMP</code>算法的$O(m+n)$，而数字则为$O(1)$，相对来说会少一个复杂度。不过如果字符串很短，例如学号、教工号这类不超过15个字符的就随意了。</p>
<h2 id="GROUP-BY-amp-HAVING"><a href="#GROUP-BY-amp-HAVING" class="headerlink" title="GROUP BY&amp;HAVING"></a><code>GROUP BY</code>&amp;<code>HAVING</code></h2><p><code>GROUP BY</code>和<code>HAVING</code>作为分组条件没有什么可以优化的了，只能说根据业务需求进行调整。</p>
<h2 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a><code>SELECT</code></h2><p><code>SELECT</code>将会从内存中选择列，这没什么争议。但是如果使用<code>*</code>作为属性列表将会让系统首先查找哪些字段符合条件，是极其消耗资源的方法。哪怕表内几百的字段都是需要查询的，最好也要一个个写上去。</p>
<h2 id="DISTINCT"><a href="#DISTINCT" class="headerlink" title="DISTINCT"></a><code>DISTINCT</code></h2><p>只是普通的剔除重复的，因为大量重复的情况很少出现，所以如果不是为了特殊业务有或无都没什么。</p>
<h2 id="ORDER-BY"><a href="#ORDER-BY" class="headerlink" title="ORDER BY"></a><code>ORDER BY</code></h2><p>正如我们在<a href="/2020/07/29/MySQL/SQL基础/">SQL基础</a>中说明的一样，数据库会根据<strong>索引</strong>优化树形结构。所以，排序的优化就转变为了索引的优化。这就是另外一门学问了。</p>
<h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><p>看起来和<code>SQL</code>语句完全没有关系，实际上正如上面<code>ORDER BY</code>一栏所述，优化结构使得查询更为便捷也是优化的一种。</p>
<p><code>MySQL</code>支持的最大索引数量是<strong>57</strong>个，但是实际上最好还是不超过<strong>5</strong>个，因为过多的索引不便于表结构专门针对某一个字段优化，正所谓“<strong>过犹不及</strong>”。</p>
<p>索引优化并没有一个定性公式，而是根据需求和实际不断权衡、各取利弊，最终达到极限。依然举个有些乱来的例子：</p>
<blockquote>
<p>你找到了一家手办店。你相当的喜欢这里面的手办，每一款都非常好看。但是因为你当前的经济能力由不得你全都要，只能购买其中最喜欢的几个。所以店长专门为整个手办店创建了索引。</p>
<p>说是创建索引，实际上也是根据番剧名称重新分类、重新整理数据结构而已。于是你在找你喜欢的手办（<em>数据库查询</em>）的过程中，你发现你头顶有一些标牌，标明了哪些区域是哪些番剧（<em>根据番剧创建的索引</em>）。</p>
<p>于是你根据这些标语找到了《Re:从零开始的异世界生活》。</p>
<p>但是蕾姆人气实在是太高了，魔术师、泳装、女仆装、便装、睡衣装、等身手办等等都一一展示在这个区域。于是店长精心整理了一下这里的展示柜，从下到上模型逐渐变得小巧、服饰逐渐变少；从1:4逐渐过渡到1:8（<em>根据模型大小创建的索引</em>），从羽绒服逐渐过渡到浴巾（<em>根据服饰创建的索引</em>）。这么一整理是不是比胡乱摆放的仓库好多了？</p>
</blockquote>
<p>是不是有点能理解了呢？</p>
]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>突如其来的反思</title>
    <url>/2020/07/19/diary/%E7%AA%81%E5%A6%82%E5%85%B6%E6%9D%A5%E7%9A%84%E5%8F%8D%E6%80%9D/</url>
    <content><![CDATA[<script src="/crypto-js.js"></script><script src="/mcommon.js"></script><h3 id="encrypt-message">如果你坚持要看，请联系我。</h3><link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.min.css"> <link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap-theme.min.css"> <script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script> <script src="//cdn.bootcss.com/bootstrap/3.3.5/js/bootstrap.min.js"></script> <div id="security"> <div> <div class="input-group"> <input type="text" class="form-control" aria-label="Enter the password." id="pass"/> <div class="input-group-btn"> <button type="button" class="btn btn-default" onclick="decryptAES()">Decrypt</button> </div> </div> </div> </div> <div id="encrypt-blog" style="display:none"> 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 </div>]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>docker创建服务器</title>
    <url>/2020/07/11/%E8%BF%90%E7%BB%B4/docker/docker%E5%88%9B%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>本文主要参考了<a href="https://blog.csdn.net/qq_21429153/article/details/80867813" target="_blank" rel="noopener">lzssing的“<code>Docker</code>搭建<code>CentOS</code>系统，并配置<code>ssh</code>环境”</a>，并补充了一些相关细节。本篇将按照我的尝试全过程依次排雷，这样也能够让各位看到更清晰的问题解决方案，但是照着做时需要避开明确标注了“不正确”的地方。</strong></p>
<a id="more"></a>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>无论是什么系统，只需要下载安装<code>Docker</code>就好了。参照我之前写的<a href="/2020/07/11/运维/docker/docker的简介与安装">docker的简介与安装</a>。如果你是<code>Ubuntu</code>系统，那么这些就够了。如果你是<code>Windows</code>系统，你可能还需要一个<a href="https://pan.baidu.com/s/1VFQVelcYuw30nd1B0jXOZA" target="_blank" rel="noopener"><code>XShell</code>（提取码：88kv）</a>用于远程连接。这里就以我使用的<code>Ubuntu</code>系统编写流程，如果你是<code>Windows</code>，你可以选择<code>Docker for Windows</code>并用<code>CMD（管理员）</code>执行同样的命令，也可以选择使用<code>Windows</code>子系统。</p>
<h2 id="第一次尝试"><a href="#第一次尝试" class="headerlink" title="第一次尝试"></a>第一次尝试</h2><p>首先肯定是确保自己进入了超级管理员权限，并使用docker命令下载我们需要的<code>CentOS</code>镜像。为什么是<code>CentOS</code>？因为全都是<code>Ubuntu</code>的话比较容易弄混，所以就用个其他的系统区分一下。</p>
<p>请求超管权限，输入密码认证之后进入超管权限。<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo su</span><br></pre></td></tr></table></figure></p>
<p><strong>从这里之后便全是CentOS。</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull centos # 拉取镜像</span><br><span class="line">docker run -itd centos /bin/bash # 创建容器运行镜像</span><br><span class="line">docker exec -it 18 /bin/bash # 进入容器操作镜像</span><br></pre></td></tr></table></figure>
<p>这里需要说明的是，<code>run</code>命令中当我们使用<code>-d</code>作为参数时，容器将支持后台运行。<code>run</code>命令之后便会生成一个<strong>容器id</strong>，我的是：</p>
<p><code>18b400110fc8772d23016358e60b4b5ff00e3892d1ad7db4bbbc4b6d1bb13e45</code></p>
<p>这实在是太长了。于是我在确认了没有重复项之后缩减了长度，只写了<code>18</code>，也就是<code>exec</code>命令所示的那样。</p>
<p><img src="https://sakebow.gitee.io/images/运维/拉取镜像.png" alt="拉取镜像"></p>
<p>然后我们开始搭建<code>ssh</code>环境，因为需要使用<code>ssh</code>工具进行连接。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install passwd openssl openssh-server openssh-clients initscripts vim -y # 安装软件</span><br></pre></td></tr></table></figure>
<p>此处<code>-y</code>代表<strong>确认安装</strong>。这个过程实在太长而且都是一样的输出就不截图了。你担心出错？<strong>放心好了</strong>。只要你不断网，这些输出必定每个人都是一样的。</p>
<p><img src="https://sakebow.gitee.io/images/运维/各种包已下载完成.png" alt="下载完成"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -f /etc/ssh/ssh_host_rsa_key -N ""</span><br><span class="line">ssh-keygen -t ecdsa -f /etc/ssh/ssh_host_ecdsa_key -N ""</span><br><span class="line">ssh-keygen -t ed25519 -f /etc/ssh/ssh_host_ed25519_key -N ""</span><br></pre></td></tr></table></figure>
<p>运行sshd服务一共需要三种密钥，<code>rsa</code>、<code>ecdsa</code>、<code>ed25519</code>。这三种都是<strong>数字签名</strong>的算法，能够保证服务器和客户端之间有能够认证身份的<strong>唯一指定</strong>令牌。在这里就不持续展开了，总之都是<strong>世界级</strong>的加密算法。</p>
<p>好了，准备工作差不多就到这里了，我们不如先存个档？</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">exit # 从CentOS中退出来，回到超管权限下的Ubuntu</span><br><span class="line"></span><br><span class="line">docker commit -a "sakebow" -m "ssh complete" 18 centos_server/save:v1 # 保存镜像</span><br></pre></td></tr></table></figure>
<p><img src="https://sakebow.gitee.io/images/运维/保存修改后的镜像.png" alt="保存镜像"></p>
<p>既然我们已经保存了镜像，之前使用的<code>18</code>容器就不再需要了，删除了吧。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker stop 18 # 之前是保持后台运行，现在需要手动关闭容器</span><br><span class="line">docker rm 18 # 删除容器</span><br><span class="line">docker ps -a # 确认容器是否存在</span><br></pre></td></tr></table></figure>
<p>好了，我们再次使用新的镜像跑一下。</p>
<p><strong>友情提醒：从现在开始会出现错误情况，我将郑重标明</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 错误示范</span></span><br><span class="line">docker run -itd 79 /bin/bash # 创建容器并运行镜像</span><br><span class="line">docker exec -it da /bin/bash # 进入容器</span><br></pre></td></tr></table></figure>
<p><img src="https://sakebow.gitee.io/images/运维/进入新镜像.png" alt="进入新镜像"></p>
<p>这里的<code>79</code>是<strong>新镜像的id</strong>，而<code>da</code>是<strong>新容器的id</strong>。各位在这一步需要更换为<strong>自己的对应id</strong>。现在，我们已经进入了<code>CentOS</code>系统中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start sshd.service # 启动服务</span><br></pre></td></tr></table></figure>
<p>然后，噩梦开始了。这是第一个错误：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@daa9499a8f9f /]# systemctl start sshd.service</span><br><span class="line">System has not been booted with systemd as init system (PID 1). Can't operate.</span><br><span class="line">Failed to connect to bus: Host is down</span><br></pre></td></tr></table></figure>
<p>就很奇怪。后来在<a href="https://blog.csdn.net/baidu_38558076/article/details/103890319" target="_blank" rel="noopener">baidu_38558076的“System has not been booted with systemd as init system”一文</a>中找到了解决方案：<code>/bin/bash</code>修改为<code>/sbin/init</code>，这样才会注册主线程<code>PID 1</code>。</p>
<h2 id="第二次尝试"><a href="#第二次尝试" class="headerlink" title="第二次尝试"></a>第二次尝试</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">exit # 退出失败的容器</span><br><span class="line"><span class="meta">#</span><span class="bash"> 以下修改稿1 - 这说明他依然有问题</span></span><br><span class="line">docker ps -a # 确认出错容器</span><br><span class="line">docker stop da # 停掉后台的容器</span><br><span class="line">docker rm da # 删除容器</span><br><span class="line">docker run --privileged=true 94 /sbin/init # 使用不一样的方式创建镜像</span><br><span class="line">docker exec -it 94 /bin/bash # 运行</span><br></pre></td></tr></table></figure>
<p>截图之前没注意，参数还有顺序要求，闹了很多错误。我也就不回避这些，给大家排个雷。</p>
<p><img src="https://sakebow.gitee.io/images/运维/修改1.png" alt="排雷式截图：进入新容器"></p>
<p><code>run</code>命令一定是要<code>--privileged=true</code>在<strong>镜像id</strong>之前。</p>
<p>再来试试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start sshd.service # 启动服务</span><br><span class="line">ps -e | grep sshd # 查看sshd服务运行情况</span><br></pre></td></tr></table></figure>
<p>这次没有报错。你有些后怕？放心好了，<code>Linux</code>的哲学就是：“<strong>没有报错就是没有错误！</strong>”相信自己，他不说你有错误你就是没错误。</p>
<p><img src="https://sakebow.gitee.io/images/运维/成功开启服务.png" alt="成功开启服务"></p>
<p>我们试着用<code>ssh</code>工具连接一下。另外开一个窗口，输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh root@192.168.1.111 # 这个192.168.1.111是我的IP地址</span><br></pre></td></tr></table></figure>
<p><strong>好像行不通</strong>。以下是错误信息。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sakebow@sakebow-Lenovo-V310-14IKB:~$ ssh root@192.168.1.111</span><br><span class="line">ssh: connect to host 192.168.1.111 port 22: Connection refused</span><br></pre></td></tr></table></figure>
<p>为什么？因为<code>Docker</code>是运行在本机的，开的端口就是本机的端口，也就是默认监听<code>22</code>端口。这个端口又是其他机器连接本机的关键，<strong>不允许被占用</strong>，所以直接被拒绝了。</p>
<p>那怎么搞嘛！<strong>换端口</strong>。</p>
<h2 id="第三次尝试"><a href="#第三次尝试" class="headerlink" title="第三次尝试"></a>第三次尝试</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 这次是正确的</span></span><br><span class="line"></span><br><span class="line">exit # 同样退出错误的容器</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 同样重开重进</span></span><br><span class="line">docker ps -a</span><br><span class="line">docker stop 94 e5 10</span><br><span class="line">docker rm 94 e5 10</span><br><span class="line">docker run -itd --privileged=true -p 1000:22 79 /sbin/init</span><br><span class="line">docker exec -it be /bin/bash</span><br><span class="line"></span><br><span class="line">systemctl start sshd # 同样在CentOS里面开启服务</span><br></pre></td></tr></table></figure>
<p>没有错误提示。连接试试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh root@192.168.1.111 -p 1000</span><br></pre></td></tr></table></figure>
<p>出现了新的对话！</p>
<p><img src="https://sakebow.gitee.io/images/运维/连接成功.png" alt="连接成功"></p>
<p>确定继续连接吗？确定的话<code>CentOS</code>（服务器）中的指纹就会保存在<code>Ubuntu</code>（客户机）中，方便下次连接。输入<code>yes</code>录入指纹，也就是以后允许这台机器输入密码认证，这样其他任何机器输入的密码即使是正确的也不会核对；如果选择<code>no</code>将会终止连接，虽然指纹依然在服务器<code>CentOS</code>上，但是客户机<code>Ubuntu</code>没有指纹，将不会核对密码。</p>
<p>密码正确后，进入服务器。</p>
<p>到这里全部完成。</p>
<h2 id="总结正确的全过程"><a href="#总结正确的全过程" class="headerlink" title="总结正确的全过程"></a>总结正确的全过程</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Ubuntu</span></span><br><span class="line">sudo su</span><br><span class="line">docker pull centos # 此处获得mirror_id_1</span><br><span class="line">docker run -itd $&#123;mirror_id_1&#125; /bin/bash # 此处填入你的mirror_id_1，执行后生成container_id_1</span><br><span class="line">docker exec -it $&#123;container_id_1&#125; /bin/bash # 填入你获得的container_id_1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> CentOS</span></span><br><span class="line">yum install passwd openssl openssh-server openssh-clients initscripts vim -y</span><br><span class="line">ssh-keygen -t rsa -f /etc/ssh/ssh_host_rsa_key -N ""</span><br><span class="line">ssh-keygen -t ecdsa -f /etc/ssh/ssh_host_ecdsa_key -N ""</span><br><span class="line">ssh-keygen -t ed25519 -f /etc/ssh/ssh_host_ed25519_key -N ""</span><br><span class="line">systemctl start sshd.service # sshd.service可以简写为sshd</span><br><span class="line">exit</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Ubuntu</span></span><br><span class="line">docker commit -a "$&#123;custom_author&#125;" -m "$&#123;custom_comments&#125;" $&#123;container_id_1&#125; $&#123;custom_mirror_name&#125; # 输入自定义的作者信息、备注信息 和 container_id_1，并获得mirror_id_2</span><br><span class="line">docker stop $&#123;container_id_1&#125; # 输入你的container_id_1</span><br><span class="line">docker rm $&#123;container_id_1&#125; # 输入你的container_id_1</span><br><span class="line">docker ps -a</span><br><span class="line">docker run -itd --privileged=true -p $&#123;custom_port&#125;:22 $&#123;mirror_id_2&#125; /sbin/init # 此处填入你的自定义端口号custom_port，mirror_id_2</span><br><span class="line">ssh root@$&#123;IP_HOST&#125; -p $&#123;port&#125; # 此处填入你的IP_HOST和custom_port</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker的简介与安装</title>
    <url>/2020/07/11/%E8%BF%90%E7%BB%B4/docker/docker%E7%9A%84%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p>简介部分主要参考了<strong>尚硅谷周阳</strong>的<a href="https://bilibili.com/BV1Vs411E7AR" target="_blank" rel="noopener">B站视频</a>，安装部分主要参考了<a href="https://www.cnblogs.com/walker-lin/p/11214127.html" target="_blank" rel="noopener"><code>walker_lin</code>的<code>docker</code>学习（一）<code>ubuntu</code>上安装<code>docker</code>一文</a></p>
<a id="more"></a>
<h2 id="第一感觉"><a href="#第一感觉" class="headerlink" title="第一感觉"></a>第一感觉</h2><p><img src="https://sakebow.gitee.io/images/%E8%BF%90%E7%BB%B4/docker.png" alt="docker"></p>
<p>什么是<code>Docker</code>？<code>Dock</code>是容器的意思，那么<code>Docker</code>也就有容器管理员的意思了。既然是管理员，那么也就有容器的来源、状态和去向三个属性的管理。</p>
<h2 id="Docker架构"><a href="#Docker架构" class="headerlink" title="Docker架构"></a><code>Docker</code>架构</h2><p><code>Docker</code>是一个<code>C/S</code>架构的应用，虽然我们能看到的非常有限，却在设计之初就已经构想了一整套完美的生态。整个生态包括<code>Docker镜像仓库</code>、<code>Docker</code>容器和<code>Docker</code>客户端，这三个分别掌管来源、状态和去向。</p>
<h3 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h3><p>来源虽说是容器的来源，其实就是说<code>Docker</code>镜像的来源，也就指向<code>Docker</code>庞大的代码仓库。从代码仓库中下载最小限度的镜像之后，在确定运行这些镜像之后，就会自动创建一个容器，并塞入镜像。而这个仓库则是在开发人员和众多社区大佬的共同努力下逐渐丰富起来的一个网站，叫<a href="https://hub.docker.com" target="_blank" rel="noopener"><code>Docker Hub</code></a>。</p>
<p>听起来就像<strong>超市购物</strong>一样，我在超市里找到了我想要的商品（<em>镜像</em>），然后装进袋子（<em>容器</em>）里。</p>
<h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p>状态普遍只会用到两种，一种是<strong>停止</strong>，另一种是<strong>运行中</strong>。这是两种正确执行之后才会出现的状态，而其他则是<strong>由命令不正确导致空容器</strong>、由<strong>无网络造成的创建失败</strong>等等状态。由于其他状态相当于<strong>错误</strong>，需要被处理，所以就没有一一列出的必要。</p>
<p>要管理容器状态，其实也就是操作容器，<strong>关闭</strong>、<strong>打开</strong>、<strong>创建</strong>、<strong>删除</strong>四大基本操作，其他的操作都类似这四大操作的<strong>旁支</strong>，比如<strong>后台挂起</strong>，也相当于<strong>打开</strong>。当然，如果遇到了刚刚所说的<strong>错误</strong>，这些<strong>旁支</strong>就<strong>没有效果</strong>了。</p>
<p>如果要打比方的话，状态就类似守门的大爷，对一个个的停车位是选择<strong>开门</strong>、<strong>关门</strong>、<strong>监视</strong>还是<strong>放任</strong>。</p>
<h3 id="去向"><a href="#去向" class="headerlink" title="去向"></a>去向</h3><p>去向说的是容器的去向，实际上也就是容器到底是<strong>留存</strong>还是<strong>删除</strong>。无论是<strong>停止</strong>还是<strong>保持运行</strong>，容器都还在，是<strong>留存</strong>；<strong>删除</strong>则是将容器<strong>彻底删除</strong>，在容器运行期间对镜像的<strong>一切修改将不会保存</strong>，但是最初的镜像将会完好地保存下来，因为容器中运行的是镜像的备份。</p>
<p>这就像是快递检货一样，无论发往哪里，都是<strong>检验合格（<em>确认要用</em>）</strong>；而<strong>检验不合格（<em>确认不用</em>）</strong>将会直接<strong>处理掉（<em>删除</em>）</strong>。这里的合不合格则是由<strong>快递员（<em>开发者</em>）来</strong>决定。</p>
<h2 id="为什么是Docker"><a href="#为什么是Docker" class="headerlink" title="为什么是Docker"></a>为什么是<code>Docker</code></h2><p><code>Docker</code>能够下载镜像、创建容器并运行镜像。这就像是虚拟机一样，我们去网上下载镜像，然后挂载到机器上，成为虚拟系统。但是这两者完全不相同。</p>
<p>这里使用<a href="https://www.zhihu.com/question/48174633" target="_blank" rel="noopener">知乎中针对“<code>docker</code>容器与虚拟机有什么区别？”这一问题<code>water Cc</code>给出的回答（3楼）</a>中的图片来说明：</p>
<p><img src="https://pic1.zhimg.com/80/20006deca0fccda0d536edd626835e9e_720w.jpg?source=1940ef5c" alt="虚拟机和docker的区别"></p>
<p>我们可以看到，左边是<strong>虚拟机</strong>的架构，而右边是<strong>Docker</strong>的架构。最底下的<code>Server</code>和<code>Host OS</code>合起来构成物理主机，也就是我们平常所用的个人电脑。</p>
<p>其中，<strong>虚拟机</strong>使用了<code>Hypervisor</code>，全称是<strong>虚拟机监视器</strong>，是一种运行在基础物理服务器和操作系统之间的中间软件层，可允许多个操作系统和应用共享硬件。也就是说，我们在针对<strong>虚拟机</strong>中挂载的系统操作的时候，<strong>挂载的系统</strong>监听到了操作，并交给挂载的操作系统处理，然后被<strong>虚拟机监视器</strong>监听到，收集数据后发送给<strong>物理主机</strong>，最终由<strong>物理主机</strong>完成系统调用，最后返还给<strong>挂载的系统</strong>并回显结果。这一整串过程是不是非常复杂？是不是能够理解为什么虚拟机挂载的时候慢一点了？</p>
<p>而<strong>Docker</strong>就不一样，取消了<strong>Hypervisor</strong>和<strong>挂载的系统</strong>，直接使用对应的基础代码库。这个基础代码库甚至可以不是操作系统，可以是<strong>单纯的某个应用</strong>，比如<code>MySQL</code>、<code>Zookeeper</code>等等，这就在灵活性上提升了一个数量级；其次，取消了<code>Hypervisor</code>能够让<code>Docker</code>运行中容器里的操作直接交给物理主机进行系统调用，速度上非常占优，相应非常迅速。</p>
<p>但是相对而言两者也同样有利有弊。</p>
<p>对于虚拟机来说，经过<strong>Hypervisor</strong>和<strong>挂载的系统</strong>能够实现非常完美的隔离性；而仅使用<strong>Docker Engine</strong>运行的几个容器隔离性相对较弱。</p>
<p>不仅如此，直接将请求传送给物理主机进行系统调用的<strong>Docker</strong>是非常依赖物理主机的架构和操作系统内核的。例如：<code>Windows</code>能够使用<code>Docker</code>运行<code>Windows Server</code>和<code>Linux</code>系统，但是<code>Linux</code>系统则只能够使用<code>Docker</code>运行<code>Linux</code>系统，因为内核完全不支持；而使用<strong>Hypervisor</strong>的<strong>虚拟机</strong>则使用中间件屏蔽了操作系统内核和架构的具体实现，从而使得<strong>虚拟机</strong>能够挂载<code>Windows</code>、<code>Linux</code>甚至<code>MacOS</code>。</p>
<p>二者差别还是非常大的，但在不同的环境下也各有千秋，开发者们需要根据自己的需求选择合适的实现方法。当然实际生产环境中还是希望能够使用更为轻量级的<code>Docker</code>来实现比较不错的响应速度。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>简介主要介绍了<code>Docker</code>相关，包括生态和优缺点。相信大家已经对<code>Docker</code>有了基本的了解。由于<code>Windows</code>有一键安装<code>Docker</code>的安装包，所以接下来我们就在<code>Ubuntu</code>下安装<code>Docker</code>，就不考虑<code>Windows</code>了。</p>
<p>首先确认我们要<strong>删除旧版本</strong>（<em>如果没有可以跳过</em>）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get purge docker</span><br><span class="line">sudo apt-get purge docker-ce</span><br><span class="line">sudo apt-get remove -y docker-*</span><br></pre></td></tr></table></figure>
<p>然后<strong>开始安装</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Ubuntuan安装Docker</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 0 - 进入root权限</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 没有设置root用户的密码使用如下语句</span></span><br><span class="line">sudo su</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置了root用户的密码使用如下语句</span></span><br><span class="line">su</span><br><span class="line"><span class="meta">#</span><span class="bash"> 1 - 下载必要的包</span></span><br><span class="line">apt-get install \</span><br><span class="line">  apt-transport-https \</span><br><span class="line">  ca-certificates \</span><br><span class="line">  curl gnupg-agent \</span><br><span class="line">  software-properties-common -y</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2 - 添加国内阿里云docker-ce镜像的GPG-key</span></span><br><span class="line">curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | apt-key add -</span><br><span class="line"><span class="meta">#</span><span class="bash"> 3 - 添加国内阿里云docker-ce镜像源</span></span><br><span class="line">add-apt-repository \</span><br><span class="line">  "deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \</span><br><span class="line"><span class="meta">  $</span><span class="bash">(lsb_release -cs) \</span></span><br><span class="line">  stable"</span><br><span class="line"><span class="meta">#</span><span class="bash"> 4 - 更新包</span></span><br><span class="line">apt-get update</span><br><span class="line"><span class="meta">#</span><span class="bash"> 5 - 安装包</span></span><br><span class="line">apt-get install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>
<p><code>CentOS</code>安装<code>Docker</code>的方法也附上，你会用到的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> CentOS安装Docker</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1 - 下载必要的包</span></span><br><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2 - 配置源</span></span><br><span class="line">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"><span class="meta">#</span><span class="bash"> 3 - 列出所有版本</span></span><br><span class="line">yum list docker-ce --showduplicates | sort -r</span><br><span class="line"><span class="meta">#</span><span class="bash"> 4 - 选择安装版本并填入<span class="variable">$&#123;version&#125;</span></span></span><br><span class="line">yum install docker-ce-$&#123;version&#125; -y</span><br></pre></td></tr></table></figure>
<p>到这里大致上就<strong>结束</strong>了。我们来检验一下是不是安装好了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker --version</span><br></pre></td></tr></table></figure>
<p>如果输出是这样的，那么就是安装成功：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Docker version 19.03.12, build 48a66213fe</span><br></pre></td></tr></table></figure>
<p>当然，这其中的数字和字符串可能每个人选择的版本不同就会显示不一样的结果，这一点无需担心，只要确认能够出现这样的信息就是<strong>安装成功</strong>。</p>
<p>下面是<strong>安装失败</strong>的输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Command 'docker' not found, but there are 21 similar ones.</span><br></pre></td></tr></table></figure>
<p>安装完之后就是使用了。但是由于客户端默认连接的<code>Docker Hub</code>是国外的镜像仓库，所以下载速度非常慢，这里就需要更改默认配置为国内镜像仓库。</p>
<p><strong>首先是确认用什么仓库</strong>。目前比较好的库就是<strong>Docker CN</strong>、网易、阿里云等等。但是阿里云镜像需要自行申请，手续麻烦而且界面不够人性化，所以我选择网易，也就是<code>http://hub-mirror.c.163.com</code>。</p>
<p>其次，来<strong>确认<code>Docker</code>服务是否启动</strong>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker images # 查看镜像列表，如果报错则服务未启动</span><br><span class="line">systemctl status docker # 系统调用查看服务</span><br></pre></td></tr></table></figure>
<p><strong>如果没有启动就打开</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start docker # 安装后第一次运行需要启动服务</span><br></pre></td></tr></table></figure>
<p>启动之后就会生成<code>/etc/docker</code>文件夹，如果没有请检查是否启动失败。</p>
<p>在里面添加<code>daemon.json</code>文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /etc/docker</span><br><span class="line">sudo touch daemon.json</span><br><span class="line">sudo vi daemon.json</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输入文本：</span></span><br><span class="line">&#123;</span><br><span class="line">  "registry-mirrors": ["http://hub-mirror.c.163.com"]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我是选择了网易镜像，你也可以替换为其他镜像。</p>
<p>然后拉取速度就非常快了。</p>
<p><strong>愉快的玩耍吧</strong>！</p>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL基础</title>
    <url>/2020/07/09/MySQL/SQL%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong><code>SQL</code>语句是所有数据库系统没有办法绕开的。与其说是基础，不如说是所有数据库系统遵循的“行业规范”。</strong></p>
<a id="more"></a>
<h2 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h2><p>因为数据库的数据非常多，内存往往不能满足所有数据的存储，而且当服务器断电后，内存中的所有数据将会立即消失，是非常严重的事故。如果涉及交易，这将会是毁灭性的灾难。</p>
<p>所以数据往往都是存在硬盘中，也作“<strong>磁盘</strong>”，大容量、信息不随着电的消失而消失，是非常不错的载体。但是速度奇慢，无法在有效时间内回复大量的查询请求。于是，人们发明了<strong>B+树</strong>。</p>
<p><strong>B+树</strong>的特点就是非叶子节点并不占用内存，只有真正找到了位置并读取数据的时候才有一次磁盘IO，在此之前完全基于内存的操作极大提升了查询速度。而使得数据按照一定规律排列成B+树的就是数据库的<strong>索引</strong>。</p>
<p>索引能够根据指定的字段重构数据库表用于存储的树形结构，从而能够在一定程度上优化查询，从$O(n)$降到$O(\log(n))$，如果是4000行数据，将会从4000次对比降到20次以内，这是非常贴近理想的优化。</p>
<h2 id="SQL语句基本公式"><a href="#SQL语句基本公式" class="headerlink" title="SQL语句基本公式"></a><code>SQL</code>语句基本公式</h2><p>每个计算机语言都有他的公式，比如<strong>C语言</strong>的<code>printf(&quot;%d&quot;, &amp;n)</code>，又如<strong>Java</strong>的<code>System.out.println(&quot;Hello World&quot;)</code>，都是有规律可循。依照规律，无论是平时作业还是大型项目都是信手拈来。下面给出<code>SQL</code>语句的公式：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> &lt;选择字段&gt;</span><br><span class="line"><span class="keyword">FROM</span> &lt;左表&gt; &lt;<span class="keyword">join</span>类型&gt;</span><br><span class="line"><span class="keyword">JOIN</span> &lt;右表&gt; <span class="keyword">ON</span> &lt;<span class="keyword">join</span>条件&gt;</span><br><span class="line"><span class="keyword">WHERE</span> &lt;选择条件&gt;</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;集合条件&gt;</span><br><span class="line"><span class="keyword">HAVING</span> &lt;聚合条件&gt;</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;排序条件&gt;</span><br><span class="line"><span class="keyword">LIMIT</span> &lt;每页选择行数&gt; <span class="comment">-- 这里是MySQL特有的分页</span></span><br></pre></td></tr></table></figure>
<h2 id="运行解析"><a href="#运行解析" class="headerlink" title="运行解析"></a>运行解析</h2><p>当然，<code>SQL</code>是一门高级语言，机器无法识别，只能说是由机器解释后运行。解析便和编辑完全是两回事了。我们假设有这么一句<code>SQL</code>和上面给出的公式完全一样的顺序，解析之后就会变成这样：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">FROM &lt;左表&gt; -- 获得笛卡尔积</span><br><span class="line">ON &lt;join条件&gt; -- 主表保留</span><br><span class="line">&lt;JOIN类型&gt; JOIN &lt;右表&gt; -- 不符合ON的数据也添加进去</span><br><span class="line">WHERE &lt;选择条件&gt; -- 非聚合数据</span><br><span class="line">GROUP BY &lt;集合条件&gt; -- 改变对表的引用</span><br><span class="line">HAVING &lt;聚合条件&gt; -- 之作用分组后</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">DISTINCT</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;排序条件&gt; <span class="comment">-- 可使用SELECT别名</span></span><br><span class="line"><span class="keyword">LIMIT</span> &lt;每页选择行数&gt; <span class="comment">-- 行数、偏移量</span></span><br></pre></td></tr></table></figure>
<p>有些人估计就直接蒙圈了。来举个例子吧：</p>
<blockquote>
<p>你迷恋上了手办，准备搜罗一下有没有自己喜欢的，然后统一入手。初期，你收集了一点点信息，并做成了表格：</p>
<p><strong>手办表</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>手办id</th>
<th>对应人物</th>
<th>服饰</th>
<th>价格</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>蕾姆</td>
<td>蓝色比基尼</td>
<td>99.00</td>
</tr>
<tr>
<td>2</td>
<td>巧克力</td>
<td>红色长袖睡衣</td>
<td>258.00</td>
</tr>
<tr>
<td>3</td>
<td>香草</td>
<td>蓝色短袖睡衣</td>
<td>258.00</td>
</tr>
</tbody>
</table>
</div>
<p><strong>番剧表</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>番剧id</th>
<th>番剧名称</th>
<th>出场人物</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>NEKOPARA</td>
<td>巧克力</td>
</tr>
<tr>
<td>1</td>
<td>NEKOPARA</td>
<td>香草</td>
</tr>
<tr>
<td>2</td>
<td>Re:从零开始的异世界生活</td>
<td>蕾姆</td>
</tr>
</tbody>
</table>
</div>
<p>然后，你想把这两个表对应起来，于是编写<code>SQL</code>：</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> 手办表.对应人物, 手办表.服饰, 手办表.价格, 番剧表.番剧名称, 番剧表.出场人物</span><br><span class="line"><span class="keyword">FROM</span> 手办表, 番剧表</span><br><span class="line"><span class="keyword">WHERE</span> 手办表.对应人物 = 番剧表.出场人物</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> 手办表.对应人物, 手办表.服饰, 手办表.价格, 番剧表.番剧名称, 番剧表.出场人物;</span><br><span class="line">ORDER BY 手办表.价格 DESC</span><br></pre></td></tr></table></figure>
<blockquote>
<p>运行这样的语句之后，你的表格就变成了这样：</p>
<p><strong>番剧手办表</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>对应人物</th>
<th>服饰</th>
<th>番剧名称</th>
<th>价格</th>
</tr>
</thead>
<tbody>
<tr>
<td>蕾姆</td>
<td>蓝色比基尼</td>
<td>Re:0</td>
<td>99</td>
</tr>
<tr>
<td>巧克力</td>
<td>红色长袖睡衣</td>
<td>NEKOPARA</td>
<td>258.00</td>
</tr>
<tr>
<td>香草</td>
<td>蓝色短袖睡衣</td>
<td>NEKOPARA</td>
<td>258.00</td>
</tr>
</tbody>
</table>
</div>
<p>看起来挺不错的。</p>
<p>在系统里面他们又是怎么运行的呢？</p>
</blockquote>
<p>首先，我们<strong>向内存中加载</strong><code>FROM</code>语句后面所有的表，并<strong>交叉相联合</strong>，也就是我们最为熟悉的<strong>排列组合</strong>，番剧表三条记录、手办表三条记录，所以内存一共加载了$3\times3=9$条记录；</p>
<p>其次，没有发现<code>ON</code>、<code>JOIN</code>语句，跳过；</p>
<p>然后发现有<code>WHERE</code>语句，所以系统将会按照<code>WHERE</code>语句给出的条件筛选手办对应任务和番剧出场人物相同的行。这里一共匹配到了三项，也就是上面的“<strong>番剧手办表</strong>”所显示的内容；</p>
<p>接着就发现了<code>GROUP BY</code>语句，于是根据所有选择的项进行分组。一般情况下应当是所有出现在<code>SELECT</code>列表上的<strong>所有项都应该出现在这里</strong>；</p>
<p><code>HAVING</code>是分组条件，也就是在<code>GROUP BY</code>存在的情况下才能使用。具体使用其实和<code>WHERE</code>是完全一样的。只不过分组的时候更倾向于使用范围，也就是<code>HAVING field &gt; 0</code>之类的语句；</p>
<p>分组完成后就是列出所有项了。<code>SELECT</code>将会从已经加载在内存里所有的列中选取指定的列；后面紧跟着的<code>DISTINCT</code>就是保证选出来的所有行不会有相同的数据；</p>
<p>最后就是<code>ORDER BY</code>对最终得出的行根据指定的字段进行排列，整段代码最后的<code>DESC</code>是倒序排列的意思；而默认情况是<code>ASC</code>，即正序排列。</p>
<p>这么过了一遍原理，会不会有点理解了？</p>
]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud简介</title>
    <url>/2020/07/08/Java/SpringCloud/SpringCloud%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>不得不说，<code>Java</code>行业变动实在太大。从一开始的<code>J2EE</code>，到<code>SSH</code>、<code>SSM</code>，接着就马上迎来了<code>SpringBoot</code>和<code>SpringCloud</code>。这里我使用的是<a href="https://bilibili.com/BV1jJ411S7xr" target="_blank" rel="noopener">狂神说Java的SpringCloud视频</a>，说的非常浅显，也很全面。</strong></p>
<a id="more"></a>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>首先声明，<code>SpringCloud</code>严格意义上来说不是一个新的框架，而是一个由旧的技术抽象出统一的规范而形成的很大的生态。从<code>SpringCloud</code>官网中就能看出，它不是一个配一配就能用的框架，而是一个很大的工程，下面附带非常多的子项目，包括网关、分布式、权限管理等等非常多的内容，但是本质还是<code>Spring</code>，模块也是基于<code>SpringBoot</code>，是一个典型的旧事新篇。</p>
<h2 id="怎么学"><a href="#怎么学" class="headerlink" title="怎么学"></a>怎么学</h2><p>如果你是完全没有编程基础，或者说从未接触过分布式，那就来跟着我一起学吧，不要有任何怀疑。如果你有一定的基础，还请多看看<code>JVM</code>，有余力甚至可以尝试当前热门的<code>Python</code>和<code>Go</code>，这个框架学习笔记已经满足不了你了。</p>
<p>另外呢，许多社区的共同努力也让<code>SpringCloud</code>有了足够的拓展了，目前的热门开源项目就是原生的<code>SpringCloud</code>和阿里的<code>SpringCloud Alibaba</code>。但是两者有着较大的差别。更详细的差别还请查看<a href="https://blog.csdn.net/feichitianxia/article/details/92682828" target="_blank" rel="noopener">木子雷的“通过对比<code>Dubbo</code>和<code>SpringCloud</code>，综合选择最合适的”</a>，这里简单总结就是：阿里的<code>SpringCloud Alibaba</code><strong>生态还未成熟</strong>，许多关键点还未有对应成熟框架开源，而且集成第三方框架也有些许困难，在技术成熟度上，原生的<code>SpringCloud</code>更胜一筹，这也是为什么目前原生的使用更广泛。</p>
<h2 id="知识储备"><a href="#知识储备" class="headerlink" title="知识储备"></a>知识储备</h2><p>不管是做什么都是要事先做一点知识储备的，学习也不例外。这里并不推荐什么学习顺序，因为每个人的学习方式都有所不同，有些人喜欢实践优先，而有些人喜欢理论优先，大家还是根据自己的步调，急也急不来。</p>
<p>另外，多多少少还是需要有一点点<code>Maven</code>基础，如果没有深入了解的话起码应该有一个<code>SSM</code>项目经验，这个就是典型的<code>Maven</code>应用。如果对<code>Spring</code>没有更深入的了解，有最基本的<code>API</code>使用经验也是足够的，最起码学会如何使用<code>SpringCloud</code>是够了。如果还需要进阶的话就需要<code>JVM</code>和<code>Spring</code>以及<code>SpringMVC</code>的基础了。当然，这些都是后话了。这篇笔记本来就是入门笔记，所以要求比较低，各位还请放心观看。如果避开所有说明就是一个快速无原理速通秘籍。在这里还是希望各位不要在掌握了<code>API</code>的调用之后沾沾自喜，想要生活得更体面还是需要进阶的。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>首先是<strong>硬件</strong>的选择。一台足够顺手的电脑是一个好的开始，比如键盘短路、内存不足等等都是很让人头疼的问题。这些可以尽快联系专业人士或者多关注拆装机博客自行安装。如果是比较小的问题，比如更换键盘、加装内存等等建议自行解决，拆机装机能够极大锻炼一些小技巧，面对众多螺丝钉的时候也能够极大地锻炼你的耐心和细心。</p>
<p>接着就是<strong>系统</strong>的选择。如果你已经厌烦了<code>Windows</code>冗赘的后台，不妨尝试免费的<code>Ubuntu</code>、<code>CentOS</code>等，或者国产的<code>Deepin</code>、<code>UOS</code>等。当然，你也可以选择有些昂贵的<code>MacOS</code>，这些都是需要认真考虑的。如果你自制力较差，选择了<code>Windows</code>却学一会了马上打开了游戏，可以考虑更换系统协助戒网瘾。如果希望尝试新系统却无法抛弃原先<code>Windows</code>的使用习惯，<code>Deepin</code>和<code>MacOS</code>将会是一个很不错的选择；如果你有条件，建议直接选择<code>MacOS</code>或者选择<strong>黑苹果</strong>，因为这一系统设计的初衷就是为了设计人员和编程人员；如果没有条件还是建议选择<code>Ubuntu</code>系统，因为是专为编程人员打造的专业系统，也因为它比较方便而且美观，对<code>Linux</code>新手来说是一个不错的选择。</p>
<p><strong>配置环境</strong>就不再赘述了，无论是<code>Windows</code>还是<code>Ubuntu</code>抑或<code>MacOS</code>，都有非常多、非常详细的说明，这里大家自行根据自己的情况选择合适的教程，需要安装的有<code>jdk</code>、<code>Maven</code>。</p>
<p>然后就是<strong>应用</strong>。当前<code>IntelliJ</code>公司做的一系列产品已经足够优秀了，但是收费。能够通过一些其他方式获得或者有条件支持正版的话推荐使用，毕竟代码自动补充、源码追溯、全域查找等功能实在是太人性化了。而<code>Eclipse</code>虽然逊色一点，却也是经典的<code>Java</code>程序编辑器。很多企业还是喜欢使用自己魔改的<code>Eclipse</code>来进行各种各样的操作，到目前为止也有较多的社区在为<code>Eclipse</code>插件做贡献，总能找到你喜欢的一款。但是由于我弄到了一款<code>IntelliJ</code>的<code>IDEA</code>，所以就不再使用<code>Eclipse</code>演示了。</p>
<p>最后，<strong>寻找合适的教程开始吧</strong>！我选择了狂神，如果你觉得可以，就跟上我一起吧！</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>版本控制的另一种打开方式</title>
    <url>/2020/07/08/Java/SpringCloud/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>节奏越来越开的现今社会，项目完成速度也越发加快，于是一个项目的人数也就越来越多。这个时候版本控制也就尤为重要。本篇将不再说明使用<code>coding</code>、<code>Gitee</code>或者<code>GitHub</code>进行托管的方法，而是使用<code>GitLab</code>和<code>Nenux</code>实现的<code>DIY</code>托管平台</strong></p>
<a id="more"></a>
<h2 id="什么是GitLab"><a href="#什么是GitLab" class="headerlink" title="什么是GitLab"></a>什么是GitLab</h2><p><code>GitLab</code>实际上也是一种<code>GitHub</code>，只不过<code>GitLab</code>可以本地部署，这样就能够实现<code>GitHub</code>的私有代码库，并且<code>GitLab</code>免费开源。细心的你应该很容易就发现了<code>GitHub</code>官网在创建代码库的时候能够让用户选择创建开源仓库或者私有仓库，可是还有一行小字：<strong>每个月$7</strong>。这就很伤心了。所以<code>GitLab</code>实际上也是给了我们一个自己动手创建私有仓库的小办法。</p>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p><code>GitLab</code>使用<code>Ruby on Rails</code>搭建，虽然有一定的便利性，却安装步骤极其麻烦，是现在不可多得的<strong>反人类</strong>开源框架。不过，就算再怎么反人类，也是有办法制服他的。<del><em>以下就是早期人类制服野生<code>GitLab</code>的记录。</em></del></p>
<p>首先是<code>GitLab</code>。我们选择中文版的安装包：<code>twang2218/gitlab-ce-zh</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull twang2218/gitlab-ce-zh</span><br></pre></td></tr></table></figure>
<p>这个包一共<strong>1.61G</strong>，非常庞大，下载需要一些时间。如果是国外镜像很容易下载失败。如果可以的话尽可能使用国内镜像。</p>
<p>紧接着我们需要一份<code>docker-compose.yml</code>文件，通过<code>docker-compose</code>我们能够更快速、更一体化地完成镜像的创建。</p>
<p>下面是<code>docker-compose.yml</code>文件的具体内容：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span> <span class="comment"># 版本号</span></span><br><span class="line"><span class="attr">services:</span> <span class="comment"># 开启服务</span></span><br><span class="line">  <span class="attr">gitlab:</span> <span class="comment"># 服务名称</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">'twang2218/gitlab-ce-zh:latest'</span> <span class="comment"># 使用镜像</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">'GitLab'</span> <span class="comment"># 主机名称（自定义）</span></span><br><span class="line">    <span class="attr">environment:</span> <span class="comment"># 环境配置</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">'Asia/Shanghai'</span></span><br><span class="line">      <span class="attr">GITLAB_OMNIBUS_CONFIG:</span> <span class="string">|</span></span><br><span class="line">        <span class="string">external_url</span> <span class="string">'http://192.168.1.112:8080'</span></span><br><span class="line">        <span class="string">gitlab_rails['gitlab_shell_ssh_port']</span> <span class="string">=</span> <span class="number">4022</span></span><br><span class="line">        <span class="string">unicorn['port']</span> <span class="string">=</span> <span class="number">8888</span></span><br><span class="line">        <span class="string">nginx['listen_port']</span> <span class="string">=</span> <span class="number">8080</span></span><br><span class="line">    <span class="attr">ports:</span> <span class="comment"># 端口映射</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">'4080:8080'</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">'4443:8443'</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">'4022:22'</span></span><br><span class="line">    <span class="attr">volumes:</span> <span class="comment"># 挂载卷</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/usr/local/docker/gitlab/config:/etc/gitlab</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/usr/local/docker/gitlab/data:/var/opt/gitlab</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/usr/local/docker/gitlab/logs:/var/log/gitlab</span></span><br></pre></td></tr></table></figure>
<p><strong>在文件中尤其注意以下几点</strong>：</p>
<ul>
<li><p><code>external_url</code>规定了我们访问地址，但是映射之后就变成了<code>192.168.1.111:4080</code>，连规定的<code>IP</code>地址都掰成了物理主机的<code>IP</code>地址，即<code>192.168.1.111</code>。</p>
</li>
<li><p><code>nginx</code>的监听端口一定要和<code>external_url</code>的端口保持一致</p>
</li>
</ul>
<p>好了，我们开始吧。既然文件中规定了各种配置文件的位置，那么我们就把<code>docker-compose.yml</code>文件放到<code>/usr/local/docker/gitlab</code>中吧！接着跳转到这个文件夹中输入命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>
<p><img src="https://sakebow.gitee.io/images/SpringCloud/Docker开启GitLab服务.png" alt="输入流程"></p>
<p>这里需要声明一点：命令<code>docker-compose up -d</code>中的<code>-d</code>千万不可省略，是使容器后台运行的参数。因为是服务器，所以需要持续监听，也就是说将会有大量的日志信息会<strong>不间断输出</strong>。所以不加上<code>-d</code>的同学就只是干看着命令行一行行滚动，实际上什么时候编译好了都不知道。就像下面这样不停的输出：</p>
<p><img src="https://sakebow.gitee.io/images/SpringCloud/无止境的日志文件.png" alt="无休止的等待界面"></p>
<p>然后就是漫长的等待……好吧其实也不是很漫长。启动之后访问，不停的刷新，首先出来的是这个页面：</p>
<p><img src="https://sakebow.gitee.io/images/SpringCloud/等待界面.png" alt="等待界面"></p>
<p>然后就到了这里。</p>
<p><img src="https://sakebow.gitee.io/images/SpringCloud/进入界面.png" alt="正确界面"></p>
<p>由于我使用的内存是<strong>4+16G</strong>，全过程一共90秒。</p>
<h2 id="帐号登陆"><a href="#帐号登陆" class="headerlink" title="帐号登陆"></a>帐号登陆</h2><p>然后，到这一步，就尬住了。新账号？确认密码？什么东西？<code>GitLab</code>官网还上不去怎么办？</p>
<p>别担心，我们可以直接操作服务器。</p>
<p>我们不是已经用<code>Docker</code>启动了一个本地服务器嘛，就直接用<code>docker exec</code>命令接入服务器，修改用户名和密码就好了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Ubuntu</span></span><br><span class="line">sudo su # 超管权限</span><br><span class="line">docker ps -a # 查看我们启动的容器编号是多少，我这里是45d3728d94c4</span><br><span class="line">docker exec -it 45 /bin/bash # 进入容器</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 容器内</span></span><br><span class="line">gitlab-rails console production # 操作gitlab</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> GitLab操作台</span></span><br><span class="line">user = User.where(id:1).first # 显示默认用户信息</span><br><span class="line">user.password = $&#123;YOUR PASSWORD&#125; # 设置自定义密码</span><br><span class="line">user.save! # 保存用户信息</span><br></pre></td></tr></table></figure>
<p><img src="https://sakebow.gitee.io/images/SpringCloud/修改默认用户信息.png" alt="输入"></p>
<p>这时我们再进去修改密码就可以使用了。</p>
<p><img src="https://sakebow.gitee.io/images/SpringCloud/成功.png" alt="进入界面"></p>
<p>其他的就是和<code>GitHub</code>一样的用了。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL简介</title>
    <url>/2020/07/07/MySQL/MySQL%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong><code>MySQL</code>是最流行的关系型数据库管理系统之一，因为其轻量级、自由度高、免费开源而备受青睐。现在国内也有非常多的大型企业魔改<code>MySQL</code>而特化某种极端场景，其中以阿里为典型代表。</strong></p>
<a id="more"></a>
<blockquote>
<p><code>Oracle</code>数据库是它是一种高效率、可靠性好的、适应高吞吐量的数据库方案。（<em>摘自百度百科：<a href="https://baike.baidu.com/item/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93" target="_blank" rel="noopener">Oracle数据库</a></em>）</p>
</blockquote>
<p>这是<code>Oracle</code>留给我们的印象。现在许多政府主导的项目多使用的就是<code>Oracle</code>，因为适应高并发且安全稳定，但是相当的重量级，对服务器的配置要求相当的高，安装时也要求图形化界面，对于少有<code>GUI</code>界面的<code>Linux Server</code>并不是非常的友好，对于后台线程繁多的<code>Windows</code>系统也并没有好很多。但是它最大的特点就是数据恢复。每次的操作都保存在了磁盘上，可以随时恢复，<code>Oracle</code>公司也能够对企业提供对应的收费服务。</p>
<p>而与之对应的，MySQL不仅数据容易丢失，而且诊断调优解决方案少，安全上也更容易被仿冒进而被攻击，可以说在各种程度上还在起跑阶段。但是由于其开源、免费两个特点，不少社区已经逐渐在丰富<code>MySQL</code>的性能和缺陷。许多公司也在根据自己的需求修改并使用。</p>
<p>更详细的对比情况如下所示：（总结自<a href="https://www.cnblogs.com/xu-cceed3w/p/8824199.html" target="_blank" rel="noopener">IT小黑的博客</a>）</p>
<h2 id="MySQL和Oracle的对比"><a href="#MySQL和Oracle的对比" class="headerlink" title="MySQL和Oracle的对比"></a>MySQL和Oracle的对比</h2><h3 id="事务提交"><a href="#事务提交" class="headerlink" title="事务提交"></a>事务提交</h3><div class="table-container">
<table>
<thead>
<tr>
<th>MySQL</th>
<th>Oracle</th>
</tr>
</thead>
<tbody>
<tr>
<td>自动提交</td>
<td>手动使用<code>commit</code>命令</td>
</tr>
</tbody>
</table>
</div>
<h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><div class="table-container">
<table>
<thead>
<tr>
<th>MySQL</th>
<th>Oracle</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>limit</code>命令</td>
<td>伪列<code>ROWNUM</code>和嵌套查询</td>
</tr>
</tbody>
</table>
</div>
<h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><p>两者都支持<code>serializable</code>串行化事务隔离级别，都实现了最高级别的读一致性，即一个<code>session</code>提交后其他<code>session</code>才能够看到提交的修改</p>
<ul>
<li><p>MySQL</p>
<p><code>read commited</code>的隔离级别。</p>
</li>
<li><p>Oracle</p>
<p><code>repeatable commit</code>的隔离级别。不同的是，Oracle会在undo表中构造多个版块，能够让开发者能够查询旧数据块。举一个比较简单的例子，当插入学生数据的时候系统自动确定学号，并添加10点积分。代码如下：</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">TRIGGER</span> JWXT.TRI_STUDENT_ID_CALC</span><br><span class="line"><span class="comment">-- 在JWXT中创建触发器TRI_STUDENT_ID_CALC</span></span><br><span class="line"><span class="keyword">BEFORE</span> <span class="keyword">INSERT</span></span><br><span class="line"><span class="comment">-- 在插入数据之前触发该触发器定义的事件</span></span><br><span class="line"><span class="keyword">ON</span> TB_STUDENT</span><br><span class="line"><span class="comment">-- 对应TB_STUDENT表进行操作</span></span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span></span><br><span class="line"><span class="comment">-- 触发器针对每一行触发</span></span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">  student_no <span class="built_in">VARCHAR</span>(<span class="number">100</span>);</span><br><span class="line">  <span class="comment">-- 定义字段 student_no 记录当前是第几个学生</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="comment">-- 触发器主体</span></span><br><span class="line"><span class="comment">-- 假设 TB_STUDNET 表建立了序列 SEQ_STUDNET</span></span><br><span class="line"><span class="comment">-- 假设 TB_STUDENT 表记录学生学号的字段是 student_id</span></span><br><span class="line">  <span class="keyword">SELECT</span> SEQ_STUDENT.NEXTVAL <span class="keyword">INTO</span> student_no <span class="keyword">FROM</span> SYS.dual;</span><br><span class="line">  <span class="comment">-- 将当前序列输入变量 student_no</span></span><br><span class="line">  :NEW.student_id := to_char(sysdate, "yyyyMMddhhmmss") || student_no;</span><br><span class="line">  <span class="comment">-- 修改student_id</span></span><br><span class="line">  :NEW.count := :OLD.count + 10;</span><br><span class="line">  <span class="comment">-- 给帐务添加10点积分</span></span><br><span class="line"><span class="comment">-- 错误处理</span></span><br><span class="line">EXCEPTION</span><br><span class="line">  RAISE_APPLICATION_ERROR(100031, "学号生成出错"); <span class="comment">-- 抛出异常</span></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>
<p>这里的<code>:NEW</code>和<code>:OLD</code>就是典型的访问<strong>新数据</strong>和<strong>旧数据</strong>。</p>
<h3 id="事务支持"><a href="#事务支持" class="headerlink" title="事务支持"></a>事务支持</h3><div class="table-container">
<table>
<thead>
<tr>
<th>MySQL</th>
<th>Oracle</th>
</tr>
</thead>
<tbody>
<tr>
<td>仅在<code>InnoDB</code>引擎中开启行级所的情况下才支持事务</td>
<td>完全支持</td>
</tr>
</tbody>
</table>
</div>
<h3 id="数据持久"><a href="#数据持久" class="headerlink" title="数据持久"></a>数据持久</h3><div class="table-container">
<table>
<thead>
<tr>
<th>MySQL</th>
<th>Oracle</th>
</tr>
</thead>
<tbody>
<tr>
<td>重启服务将会完全丢失所有数据、数据库更新字段后立即丢失原先数据</td>
<td>提交数据的操作全部存在磁盘上，随时可恢复；并且<code>Oracle</code>公司提供数据恢复的收费服务</td>
</tr>
</tbody>
</table>
</div>
<h3 id="并发支持"><a href="#并发支持" class="headerlink" title="并发支持"></a>并发支持</h3><ul>
<li><p>MySQL</p>
<p><code>MyISAM</code>引擎下仅支持表级锁，即当一个<code>session</code>修改表后，整个表被锁住，其他任何会话无法对表进行任何操作。这对高并发要求极不友好，大量的时间都在等待上一个甚至几个<code>session</code>退出</p>
</li>
<li><p>Oracle</p>
<p>完全支持行锁。在当前<code>session</code>修改表的过程中，其他<code>session</code>能够访问并修改其他行，单位时间内能够处理更多的请求</p>
</li>
</ul>
<h3 id="逻辑备份"><a href="#逻辑备份" class="headerlink" title="逻辑备份"></a>逻辑备份</h3><div class="table-container">
<table>
<thead>
<tr>
<th>MySQL</th>
<th>Oracle</th>
</tr>
</thead>
<tbody>
<tr>
<td>锁住整张表，影响数据库的增删改操作</td>
<td>不锁表，对其他操作无影响</td>
</tr>
</tbody>
</table>
</div>
<h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><ul>
<li><p>MySQL</p>
<p>复制服务器配置简单。但主库出问题时，从库有可能丢失一定的数据。且需要手工切换从库到主库</p>
</li>
<li><p>Oracle</p>
<p>既有推或拉式的传统数据复制，也有dataguard的双机或多机容灾机制，主库出现问题是，可以自动切换备库到主库，但配置管理较复杂。</p>
</li>
</ul>
<h3 id="性能诊断"><a href="#性能诊断" class="headerlink" title="性能诊断"></a>性能诊断</h3><div class="table-container">
<table>
<thead>
<tr>
<th>MySQL</th>
<th>Oracle</th>
</tr>
</thead>
<tbody>
<tr>
<td>调优方法较少，主要是<code>慢查询日志</code></td>
<td>调优方法成熟，可实现多种自动分析、诊断调优功能，有<code>awr</code>、<code>addm</code>、<code>sqltrace</code>、<code>tkproof</code>等</td>
</tr>
</tbody>
</table>
</div>
<h3 id="权限安全"><a href="#权限安全" class="headerlink" title="权限安全"></a>权限安全</h3><div class="table-container">
<table>
<thead>
<tr>
<th>MySQL</th>
<th>Oracle</th>
</tr>
</thead>
<tbody>
<tr>
<td>仅和主机IP有关，容易被仿冒</td>
<td>安全认证思想比较传统，中规中矩</td>
</tr>
</tbody>
</table>
</div>
<h3 id="分区索引"><a href="#分区索引" class="headerlink" title="分区索引"></a>分区索引</h3><div class="table-container">
<table>
<thead>
<tr>
<th>MySQL</th>
<th>Oracle</th>
</tr>
</thead>
<tbody>
<tr>
<td>技术不成熟</td>
<td>技术成熟</td>
</tr>
</tbody>
</table>
</div>
<h3 id="管理工具"><a href="#管理工具" class="headerlink" title="管理工具"></a>管理工具</h3><div class="table-container">
<table>
<thead>
<tr>
<th>MySQL</th>
<th>Oracle</th>
</tr>
</thead>
<tbody>
<tr>
<td>除了自带的命令行就是第三方</td>
<td>有多种应用程序解决方案</td>
</tr>
</tbody>
</table>
</div>
<h3 id="附加服务"><a href="#附加服务" class="headerlink" title="附加服务"></a>附加服务</h3><div class="table-container">
<table>
<thead>
<tr>
<th>MySQL</th>
<th>Oracle</th>
</tr>
</thead>
<tbody>
<tr>
<td>无</td>
<td>数据恢复等由<code>Oracle</code>公司提供的完整服务</td>
</tr>
</tbody>
</table>
</div>
<h3 id="其他条件"><a href="#其他条件" class="headerlink" title="其他条件"></a>其他条件</h3><div class="table-container">
<table>
<thead>
<tr>
<th>MySQL</th>
<th>Oracle</th>
</tr>
</thead>
<tbody>
<tr>
<td>免费开源、轻量级</td>
<td>付费服务、超重量级</td>
</tr>
</tbody>
</table>
</div>
<h2 id="为什么选择MySQL"><a href="#为什么选择MySQL" class="headerlink" title="为什么选择MySQL"></a>为什么选择MySQL</h2><p>这么一罗列似乎<code>MySQL</code>始终处于劣势。但是<code>MySQL</code>它本身的轻量级提供了非常方便的部署环境。众多中小企业还是非常喜欢使用<code>MySQL</code>的。其次就是因为他灵活的架构。</p>
<p>他是这么一个架构：（图源来自<a href="https://blog.csdn.net/weixin_42358062/article/details/80730694" target="_blank" rel="noopener">CSDN</a>）</p>
<p><img src="https://images2018.cnblogs.com/blog/1411859/201806/1411859-20180617124155105-273948974.png" alt="MySQL架构图"></p>
<p>形象一点地说，大概就是这样子：</p>
<ul>
<li><p>连接层——守门大爷</p>
<p>首先就是数据库连接池管理所有的连接，基本上所有的数据库都有这么一个东西。比如<code>Oracle</code>的<code>ODAC</code>就是其中之一。对外于各种语言连接器相对应，对内则于数据的读写相对应。</p>
</li>
<li><p>服务层——客服中心</p>
<ul>
<li><p>事务管理器——客服小姐</p>
<p>事务管理器接到请求之后立马转发到<code>SQL</code>接口，即立马转告对应工厂部门</p>
</li>
<li><p>优化器——技术顾问</p>
<p><code>SQL</code>并不像<code>C</code>语言，所写即所运行，而是有专门的优化器来根据系统自己的想法来优化当前的算法，也就像是一个了解技术的顾问一样帮助挑选较优的选择。</p>
<p>当然，这个选择不一定是最好的，也不一定适合当前环境，但确实是根据系统特定的优化算法算出来的最优解。就像是店家推荐不一定是用户所爱，但也象征了一些什么。</p>
<p>当然，<code>SQL</code>调优可不单纯是根据数学算算就好了，是结合实际不断的调整，不断的放弃，最终得出来无限接近极限的算法。这就不是系统自带的优化器能够做到的了。就像阿里，既然已经有可靠的<code>DBA</code>数据库管理员就直接魔改<code>MySQL</code>，删掉相对来说没多大作用的优化器，更接近极限响应时间。</p>
</li>
<li><p>缓存和缓冲——搬运工</p>
<p>就如字面意思，搬运数据、暂存数据等等</p>
</li>
</ul>
</li>
<li><p>引擎层——办公中心</p>
<p>这里可以说是整个<code>MySQL</code>的精髓所在。这部分最大的特点就是<strong>可插拔</strong>，也就是按需添加删除存储引擎，对应不同的应用场景魔改成不同的<code>MySQL</code>，这是<code>Oracle</code>没有的，也是<code>MySQL</code>无限的潜能所在。各种社区、各种企业、各种研究所都在慢慢魔改，并生成贴合对应生产环境的数据库系统，同时兼顾了轻量级和高可用，相对于什么都有的超重量级<code>Oracle</code>而言是非常大的优点。</p>
<p>目前用的最多的就是支持行锁的<code>InnoDB</code>引擎。当然也有使用其他引擎的，这都是看企业自己的选择了。</p>
</li>
<li><p>存储层——仓库</p>
<p>这部分主要是文件系统，所有的数据都保存在磁盘上来实现数据的持久化。对于<code>InnoDB</code>而言，这部分就是通过<code>B+树</code>实现的文件系统，由于非叶子节点不占用实际内存，所以减小了内存压力，同时也减少了磁盘IO，极大加快了查询速度。这也是<code>InnoDB</code>这么受欢迎的原因之一。</p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>有关<code>MySQL</code>的基础知识大概就是这些了。之后将会逐步深挖，从入门的索引、<code>SQL</code>再到进阶的调优、主从等，逐步了解<code>MySQL</code>数据库。</p>
]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>笔记本拆机初体验</title>
    <url>/2020/07/07/hardware/%E7%AC%94%E8%AE%B0%E6%9C%AC%E6%8B%86%E6%9C%BA%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>四年没有被水泼键盘的我，最终在第四年因为一个小疏忽整杯水泼到了键盘上，导致<code>G</code>、<code>H</code>等几个关键的键短路了。苦于暂时没钱买好点脑，就有了这次拆机换键盘的体验。</strong></p>
<a id="more"></a>
<h2 id="准备活动"><a href="#准备活动" class="headerlink" title="准备活动"></a>准备活动</h2><p>就像运动前的准备活动一样，在拆机之前我们需要了解足够多的词汇和小技巧，在后面我们也方便说明和使用。</p>
<h3 id="知识储备"><a href="#知识储备" class="headerlink" title="知识储备"></a>知识储备</h3><ul>
<li><p>笔记本分为4个面，分别是屏幕外壳、屏幕边框、键盘和底部。为了方便，我们依次编号为<code>A</code>、<code>B</code>、<code>C</code>、<code>D</code>。这次是我的键盘坏掉了，所以主要换<code>C</code>面。</p>
</li>
<li><p>相较于以前，笔记本的各种连接线已经集成在一张可以<strong>随意翻折</strong>的绝缘胶套，多为白色套、蓝色头，偶有黑色套、黑色头。这种胶套非常扁平，就像纸一样，仅在接口处暴露极小的接点，确保了连通性的同时保证了线路的安全、高自由度和占用空间小。</p>
</li>
<li><p>请记住，<strong>人体是导体</strong>。所以一定要小心，尤其注意拆卸过程中拔掉交流电电源。</p>
</li>
</ul>
<h3 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h3><ul>
<li><p>人体多多少少也是有一些静电的，电压极大，很有可能对电路板造成不可逆的影响。所以只要是要触摸电路板，首先要做到<strong>防静电</strong>。爱干净的可以去用洗手液好好地<strong>洗个手</strong>，而不那么讲究的就<strong>摸一下地板</strong>把身上的电导走就好了。</p>
</li>
<li><p>在拆机的整个过程中，一定要<strong>明确你的目标</strong>，不要把四个面全拆了之后才发现你只需要加一条内存。其次重要的就是<strong>从易到难</strong>。不要一上来就开始卸主板的螺丝，从简单的开始，比如机械硬盘、电源等。</p>
</li>
<li><p>如果你有<strong>足够大的桌子</strong>和<strong>格子比较多的收纳盒</strong>，请务必使用。因为这中间涉及很多不同种类的螺丝钉、卡扣等可拆卸的部件，一旦混在一起就不知所措了。如果你不擅长记忆，<strong>每当拆掉一个部分的时候记得拍个照</strong>，记录一下特征，绝对要<strong>保证自己能够拆开后重新拼回去</strong>。</p>
</li>
<li><p>年代非常久远的笔记本很多螺丝都老化严重，当螺丝刀不能转动时<strong>切忌加大力度</strong>。否则螺丝很容易劈，也就是槽型从正常的国家标准形状被拧成了圆形，再也拧不动了。这种时候如果有条件的可以用专业的长型喷嘴喷一点点稀盐酸到槽内，既除锈还润滑；如果没有那么好的条件可以使用洗手液，用螺丝刀沾一点，小心的灌到槽内，起到润滑的作用。总之一定不要正面硬刚，很容易造成不可逆的后果，这种没有很高技术要求的过失往往很容易让人陷入深深的抑郁和自我怀疑中。</p>
</li>
<li><p>点名批评联想笔记本，从导线到外壳用的各种材料都比较劣质。如果有条件的话尽量换一台新电脑，因为很多东西用久了甚至稍微一动就出大问题。</p>
</li>
</ul>
<p><strong>那么我们现在开始吧！</strong></p>
<h2 id="查资料"><a href="#查资料" class="headerlink" title="查资料"></a>查资料</h2><p>当然，有以上的知识储备还不够。你要仔细查你的电脑型号和与之匹配的键盘型号，否则货到了也只能干瞪眼。</p>
<p>比如我的电脑是<code>V310-14IKB</code>，是键盘焊死在<code>C</code>面的型号。第一次没注意，直接买了键盘，发现自己并没有这个条件自己装，更没这个技术把键盘焊下来。</p>
<p><img src="https://sakebow.gitee.io/images/装机/第一次失败.jpg" alt=""></p>
<p>有了这次的经验后就直接在淘宝店上找到了带键盘的<code>C</code>面，整个换上去就好了。</p>
<h2 id="光驱位拓展电源"><a href="#光驱位拓展电源" class="headerlink" title="光驱位拓展电源"></a>光驱位拓展电源</h2><p>光驱位拓展电源是极少电脑型号拥有的附加电源，能够在一定程度上提高续航能力。拓展电源能够在给主板供电的情况下持续给笔记本原装电源充电。</p>
<p>但是这个玩意毕竟是可插入式的，会阻碍后盖的拆除。在拆后盖前先把拓展电源拿下来。怎么拿很简单，在底部有一个暴露在外面的卡扣，拉开就能拔出来。</p>
<p><img src="https://sakebow.gitee.io/images/装机/拓展电源.jpg" alt="拓展电源"></p>
<h2 id="后盖"><a href="#后盖" class="headerlink" title="后盖"></a>后盖</h2><p><strong>后盖并不是最重要的，但是没有后盖是最要命的</strong>。后盖上面没有什么电路需要保护，但是他却需要保护里面的电路。所以各位在拆的时候还是要谨慎，有条件的尽量使用<strong>撬片</strong>，没条件的尽量用刀片等超薄的东西撬开。如果能够确保这台电脑再也不会怎么用，就可以不那么爱惜，使用银行卡、一字螺丝刀、剪刀等略粗、对塑料制品伤害较大的工具撬开。</p>
<p>比较有年代的机器还有<code>COM</code>口，也就是多媒体接口。这种接口会挡住后盖，加大拆卸难度。这时<strong>切忌大力出奇迹</strong>，一定要小心拆卸。实在挡住了拆不下来就先拆别的地方，有可能其他地方全部拆完最后这个地方不需要拆。</p>
<p>为了美观，有些会将螺丝和底部颜色做成一样的，这时一定要擦亮眼睛，尤其是黑色底壳难以分辨，很容易一不小心掰断；而有些则会将螺丝藏在橡胶垫下方，这对强迫症非常不友好，但是为了维修还是把橡胶垫撕下来吧。</p>
<p><img src="https://sakebow.gitee.io/images/装机/初步安装测试.jpg" alt="打开后盖"></p>
<h2 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h2><p>机械硬盘的拆装应该就是最简单的了。当然，是在你有的情况下。如果没有，请直接跳过这一步。</p>
<p>机械硬盘除了固定用的螺丝之外，一般都会有一个方便拉扯的地方，一定要记得先拉开，确保完全分离再抬起拿开。就像下图一样。</p>
<p><img src="https://sakebow.gitee.io/images/装机/拆硬盘.jpg" alt="拆硬盘"></p>
<p>这里有一个方便拉扯的地方，先拉开，再捏住抬起。同理，安装时先放下，再推进去。</p>
<h2 id="电源"><a href="#电源" class="headerlink" title="电源"></a>电源</h2><p>这里只讨论自带的电源，而不是光驱位拓展电源，因为光驱位拓展电源在第一步就给拆掉了。先给个图说明一下。</p>
<p><img src="https://sakebow.gitee.io/images/装机/拆电源.jpg" alt="拆电源"></p>
<p>没错，图中<strong>带有黄色警示标语的模块</strong>就是电源。这部分看起来像是连接在电脑显示屏上所以很多人并没有注意，包括我也是，我也是拆完才知道这玩意是电源。图中用橙色的线圈起来了一个接口，小心地拔出来。这个就是电源充电供电的接口。</p>
<p>为什么优先级仅次于机械硬盘？因为拔掉电源线之后主板所有电流立即停止，所有模块立即变为等电势，也就是失去电压。在一开始我们强调了人体是导体，<strong>在没有电压后既保护了你，也保护了电路。</strong></p>
<p>细心的你可能会发现电源上有两个上螺丝的地方。别担心，这些是在底部外壳上攻的螺丝，拔掉供电接口后你就只需要小心的将电源拉出来就好了。</p>
<h2 id="导热铜管"><a href="#导热铜管" class="headerlink" title="导热铜管"></a>导热铜管</h2><p>由于我从未使用过水冷，所以没有办法说明。<strong>如果有需要请务必找专业人士</strong>，一旦漏水导致整个主板短路烧坏，将会是很大一笔损失。这里就只对导热铜管进行说明。</p>
<p><img src="https://sakebow.gitee.io/images/装机/拆导热铜管.jpg" alt="拆导热铜管"></p>
<p>从图中我们可以看出，除了六个固定的螺丝以外，没有任何限制铜管的卡扣或者部件，所以除了硬盘之外优先拆除这个部分。</p>
<h2 id="散热风扇"><a href="#散热风扇" class="headerlink" title="散热风扇"></a>散热风扇</h2><p>就借用刚刚导热铜管的图片说明吧。</p>
<p>你会发现，散热风扇只有三颗十字螺丝固定，小心地把螺丝卸下来，就能把风扇拿掉。</p>
<p>但是你会发现，风扇还有一个接口接到了主板上，这是风扇的供电口。我这边供电口实在攻的太紧了，拔不出来，就干脆不拔了。因为我的目标只是带键盘的<code>C</code>面而已，只要我能确保接口的安全就好了。</p>
<h2 id="显示屏"><a href="#显示屏" class="headerlink" title="显示屏"></a>显示屏</h2><p>风扇除了散热，还有一个很细节的功能，就是集线。风扇拿起来之后，压在下面的电源线和显示屏的线就暴露出来了。</p>
<p><img src="https://sakebow.gitee.io/images/装机/拆显示器.jpg" alt="拆显示器"></p>
<p>按照上图的标号顺序，先定位到标着<code>1</code>的三个部分，上面两个是两个橡胶套，轻轻掀开便能连带蓝色的固定胶套一起掀起来；下面一个是接口，轻轻拉出来，标着<code>1</code>的所有部件便分离出来了。</p>
<p>其次是<code>2</code>。原来是有一个黑色的胶布固定住的，我以为没有什么用，直接撕下来了。没想到的是他居然保护着一红一黑两根线。这两根线不是焊上去的，而是<strong>通过很微小的卡扣卡上去的</strong>。所以这部分拆卸时一定要小心。</p>
<p>紧接着就是<code>3</code>，这是拆下风扇后暴露出来的线。它的特点是，<strong>有一个黑色的可掀开的盖子固定住</strong>，这时轻轻捏住线扁平的地方向上抬，这样黑色的盖子就掀起来了一点点，这时再用一字螺丝刀、刀片或者手掀起来，这样黑色的线就能轻松抽出来。</p>
<p><img src="https://sakebow.gitee.io/images/装机/拆显示器完成.jpg" alt="成功分离所有显示器模块"></p>
<p>最后，将<code>C</code>面电源两边的螺丝卸下来，抬起<code>C</code>、<code>D</code>面大于45度，整个底部就能抽出来了。当然你也可以先抬起来再卸螺丝，但是这样就需要更高的角度，避免卸完螺丝整个底部塌下来。</p>
<p>到这里，<code>A</code>、<code>B</code>和<code>C</code>、<code>D</code>两个部分就<strong>彻底分离</strong>了，也就是显示屏和底部分离。</p>
<p><img src="https://sakebow.gitee.io/images/装机/显示屏.jpg" alt="显示屏"></p>
<p>由于我只是换键盘，所以显示屏的<code>A</code>、<code>B</code>面就不分开了。想要分开也很简单，使用撬片小心撬开，没有螺丝钉。接下来就是<code>C</code>、<code>D</code>面的分离。</p>
<h2 id="指纹"><a href="#指纹" class="headerlink" title="指纹"></a>指纹</h2><p>指纹模块也是只有特定机器才有，尤其是<code>ThinkPad</code>全部产品和联想部分产品。在拆的时候也有一些细节。这里就以我的指纹模块为例。首先指纹模块是这样的：</p>
<p><img src="https://sakebow.gitee.io/images/装机/拆指纹模块.jpg" alt="拆指纹模块"></p>
<p>细心的你可能注意到途中有些地方没有螺丝。这些没有螺丝的地方不是我不上螺丝，是和其他模块相关联。</p>
<p>首先就是这个黑黑的挡板了。螺丝卸掉，然后就可以轻松取出。取出来后就是这样子的：</p>
<p><img src="https://sakebow.gitee.io/images/装机/拆U口.jpg" alt="拆U口"></p>
<p>这里画圈圈的地方就是需要卸螺丝或者拔线的地方。<em>其实这个接口拔不拔无所谓，因为总归是要整个移到新的<code>C</code>面上。</em></p>
<p>最后就是指纹模块了。</p>
<p><img src="https://sakebow.gitee.io/images/装机/拆指纹.jpg" alt="拆指纹"></p>
<p>这个银色挡板非常巧妙地卡在了很多卡扣中间。我们需要小心的从标着<code>1</code>的地方使用一字螺丝刀或者刀片撬开，用手是捏不到那里的，除非你的指甲又硬又长。接着就是2处的接口。你会发现这次接口的黑色盖子在反方向，同样还是掀起来，这次就算没有指甲也可以轻松扳开。当然，由于是整个模块移走，这个接口也是没有必要拆下来的。</p>
<p>换到新的<code>C</code>面上就是将上述步骤反过来，先指纹模块、再银色挡板，然后安装<code>USB</code>接口，最后搭上黑色挡板，上螺丝。</p>
<p>在我拆这部分的时候也是发生了一点点小插曲，<strong>螺丝劈了</strong>。</p>
<p><img src="https://sakebow.gitee.io/images/装机/指纹模块翻车.jpg" alt="指纹模块翻车"></p>
<p><strong>所以你知道提前准备一些小技巧的重要性了嘛？</strong></p>
<h2 id="清除主板上剩余的线"><a href="#清除主板上剩余的线" class="headerlink" title="清除主板上剩余的线"></a>清除主板上剩余的线</h2><p>主板是整台电脑非常重要的地方。很多电路都是将铜通过化学手段铺上去，而不是使用导线，不存在什么藕断丝连。<strong>要是板子掰断了就彻底没救了</strong>。</p>
<p>首先，整个板子所有的固定螺丝应当卸下来，这部分没有什么好说的。还是提醒一点，如果对记忆力没有自信，拧了哪些螺丝拍个照。</p>
<p>在上述所有步骤结束之后，主板上面应该是没有什么东西了的（<em>我这里还有一个散热风扇拆不掉，但是不影响</em>），最后就清一下剩余的连接线，比如这些：</p>
<p><img src="https://sakebow.gitee.io/images/装机/电源附近的细节.jpg" alt="电源附近的细节"></p>
<p>还有这些：</p>
<p><img src="https://sakebow.gitee.io/images/装机/去掉剩余连接线.jpg" alt="剩余连接线"></p>
<p>由于我够买的<code>C</code>面只有触摸板和键盘，所以这些细节连接线都要撕下来粘到新的<code>C</code>面上。</p>
<p>到这里，主板就独立出来了。</p>
<h2 id="最后一步"><a href="#最后一步" class="headerlink" title="最后一步"></a>最后一步</h2><p>我们小心地将主板抬起来，要注意键盘的线是在主板正下方的，<strong>千万不要</strong>直接一掀开，把接口掀断了。</p>
<p>确认位置后，往合适的方向<strong>180度翻转过来</strong>，就像这样：</p>
<p><img src="https://sakebow.gitee.io/images/装机/完全拆开.jpg" alt="完全拆开"></p>
<p>看到主板和<code>C</code>面的连接线了吗？那就是目标了。</p>
<h2 id="拆机结束"><a href="#拆机结束" class="headerlink" title="拆机结束"></a>拆机结束</h2><p>到现在，拆除部分就完全结束了。我们把新的<code>C</code>面换上，将上述所有步骤反过来执行，就是整个电脑的安装步骤了。</p>
<p>最后放上成功的图片：</p>
<p><img src="https://sakebow.gitee.io/images/装机/安装成功.jpg" alt="安装成功"></p>
<p><img src="https://sakebow.gitee.io/images/装机/最终完成版.jpg" alt="成功点亮"></p>
<p>如果你希望这台电脑再用一会（<em>我相信笔记本电脑折腾成这样肯定是想的</em>），那就加一点内存，加一块光驱位电池或者更换全新的电池，这样能够在续航和使用上稍微增强一点。这些就比较容易了，最起码是不需要动主板上面任何一枚螺丝的。</p>
]]></content>
      <categories>
        <category>硬件</category>
      </categories>
      <tags>
        <tag>笔记本拆机</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue钩子的一点小坑</title>
    <url>/2020/07/02/JavaScript/Vue/Vue%E9%92%A9%E5%AD%90%E7%9A%84%E4%B8%80%E7%82%B9%E5%B0%8F%E5%9D%91/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>Vue中不同的钩子有不同的功能，应对不同的场景灵活使用可以实现很不错的效果。但是还是就算会用框架，基本功还是不能丢。Vue里面有个小坑实际上是ES5和ES6的小区别，在框架中有着完全不同的效果。</strong></p>
<a id="more"></a>
<h2 id="正常的写法"><a href="#正常的写法" class="headerlink" title="正常的写法"></a>正常的写法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">mounted () &#123;</span><br><span class="line">  <span class="comment">// 具体方法</span></span><br><span class="line">&#125;,</span><br><span class="line">created () &#123;</span><br><span class="line">  <span class="comment">// 具体方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...其他钩子</span></span><br></pre></td></tr></table></figure>
<p>这种写法是<code>ES5</code>标准中拥有的写法，就是很普通的<code>方法名(参数){ 方法体 }</code>，在很多语言中都能看到类似的写法。</p>
<h2 id="不一样的写法"><a href="#不一样的写法" class="headerlink" title="不一样的写法"></a>不一样的写法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">mounted: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 具体方法</span></span><br><span class="line">&#125;,</span><br><span class="line">created: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 具体方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...其他钩子</span></span><br></pre></td></tr></table></figure>
<p>也许你们能注意到，这里使用了<code>箭头函数</code>，是典型的<code>ES6</code>标准。<code>箭头函数</code>和<code>普通函数</code>的最大区别就是<code>this</code>指针，前者没有而后者有。所以如果使用了<code>箭头函数</code>，这个钩子里将无法访问该组件中的<code>data</code>集合，因为没有指向自己的指针。</p>
<p>这种写法不会报错，因为是正确的写法，在不访问<code>data</code>集合的时候是没有问题的。如果业务需要访问，那么这个问题将很难发现。</p>
<p>说到底还是<code>JavaScript</code>基本功的问题。所以还是希望各位不要急于求成，稳扎稳打才能提高正确率。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>JMM简介</title>
    <url>/2020/03/01/Java/%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%80%83/JMM/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>JMM，英文全称就不说明了，将单词直译很简单地平在一起，就有了中文释义：Java内存模型。这也是Java必考基础知识。内存模型虽然是内存相关的知识，却是CPU、磁盘之间沟通的桥梁，也是程序运行的基本环境之一。所以内存模型往往和垃圾回收、线程安全等问题综合。这也是为什么内存模型更为重要的原因。</strong></p>
<a id="more"></a>
<h2 id="概念梳理"><a href="#概念梳理" class="headerlink" title="概念梳理"></a>概念梳理</h2><p>Java内存结构包含<strong>栈</strong>、<strong>堆</strong>、<strong>方法区</strong>等等，而<strong>Java内存模型</strong>则是完全不同的概念。</p>
<p><strong>Java内存模型</strong>是一种规范，也是一种抽象的概念，描述了Java程序中各种<strong>线程共享变量</strong>的访问规则，以及在JVM中将变量在内存中存取的底层实现细节。由于这些存取细节屏蔽了不同操作系统的底层实现细节，Java也就自然而然成为一种跨平台语言。具体分为<strong>主内存</strong>和<strong>工作内存</strong>：</p>
<h3 id="主内存"><a href="#主内存" class="headerlink" title="主内存"></a>主内存</h3><p>Java的共享变量全部保存在主内存中，不管是普通对象还是静态对象都保存在这。</p>
<h3 id="工作内存"><a href="#工作内存" class="headerlink" title="工作内存"></a>工作内存</h3><p>所有的方法对共享变量进行操作的时候都只能在工作内存中运行。运行时，会将共享变量<strong>复制</strong>到工作内存中进行处理，处理完成后返回到主内存中。</p>
<p>这个过程就像是GitHub代码托管一样：</p>
<ul>
<li><p>先从代码库中下载代码（<em>先从主存中获得共享变量的拷贝</em>）</p>
</li>
<li><p>再本地编码（<em>然后在工作内存中对共享变量的拷贝进行处理</em>）</p>
</li>
<li><p>完成后推送到代码库（<em>拷贝处理结束后，将结果返回到主内存并覆盖原有数据</em>）</p>
</li>
</ul>
<p>就这三步过程，一共包含了8个<strong>原子</strong>步骤：</p>
<ul>
<li><p><strong>Lock</strong>：线程访问时，给共享变量加锁</p>
</li>
<li><p><strong>Read</strong>：线程读取主内存的数据</p>
</li>
<li><p><strong>Load</strong>：线程获得主内存的拷贝，并加载到工作内存</p>
</li>
<li><p><strong>Use</strong>：线程对拷贝进行处理</p>
</li>
<li><p><strong>Assign</strong>：将处理结果返回</p>
</li>
<li><p><strong>Store</strong>：保存返回值并覆盖原有拷贝</p>
</li>
<li><p><strong>Write</strong>：使用新的拷贝覆盖主内存的对应变量</p>
</li>
<li><p><strong>Unlock</strong>：对变量解锁</p>
</li>
</ul>
<p>其中<strong>Lock</strong>和<strong>Unlock</strong>是可选的，也就是添加了<code>synchronized</code>关键字才会生效，否则不生效。其余6个步骤不管是否加锁都一定会进行。</p>
<p>但是对一个变量执行<strong>Lock</strong>操作的时候，将会相对应地清空工作内存中此变量的值；</p>
<p>而对一个变量执行<strong>Unlock</strong>操作的时候，将会首先将该变量的拷贝加载到主内存中。</p>
<h2 id="synchronized关键字保证三大特性的原理"><a href="#synchronized关键字保证三大特性的原理" class="headerlink" title="synchronized关键字保证三大特性的原理"></a><code>synchronized</code>关键字保证三大特性的原理</h2><h3 id="synchronized保证原子性"><a href="#synchronized保证原子性" class="headerlink" title="synchronized保证原子性"></a><code>synchronized</code>保证原子性</h3><p>复习一下，原子性是指<strong>同步语句对应的汇编指令在全部执行完之前，不能有其他线程从中插进来</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 关键字需要传入函数名或者Object类型变量</span></span><br><span class="line">    <span class="keyword">synchronized</span> ((Object) count) &#123;</span><br><span class="line">        <span class="comment">// 10条线程重复1000次累加</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// lambda表达式简化写法</span></span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="comment">// 注意这里不要写i，否则会和上层循环冲突</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 查看结果</span></span><br><span class="line">                <span class="comment">// 不要将结果写在线程外，否则会由主线程执行，最后输出10个0</span></span><br><span class="line">                System.out.println(count);</span><br><span class="line">            &#125;).start();<span class="comment">// 开启线程，否则不运行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于<code>synchronized</code>给<code>count</code>加了锁，所以保证了仅有一条线程可以对<code>count</code>共享变量进行操作，从而保证了操作的原子性。</p>
<h3 id="synchronized保证可见性"><a href="#synchronized保证可见性" class="headerlink" title="synchronized保证可见性"></a><code>synchronized</code>保证可见性</h3><p>复习一下，可见性是指<strong>当线程2对共享变量进行修改的时候，线程1还是拿着工作空间的变量拷贝进行操作</strong>。而<code>synchronized</code>则因为线程2无法在线程1处理过程中进入修改，所以从另外一种层面上，也就是加锁，保证了代码的可见性。</p>
<h3 id="synchronized保证有序性"><a href="#synchronized保证有序性" class="headerlink" title="synchronized保证有序性"></a><code>synchronized</code>保证有序性</h3><p>JVM会在运行时对代码进行重排序以按照<strong>系统认为</strong>的最优解进行运作，这种重排序将遵循一定的算法，也就是<strong>as-if-serial语义</strong>，大致上就是规定了不可重排序的语句有：</p>
<ul>
<li><p><strong>写后读</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">System.out.println(a);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>写后写</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">a = user.getAge();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>读后写</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User user = preparedStatement.executeQuery();</span><br><span class="line"><span class="keyword">int</span> a = user.getAge();</span><br><span class="line">user = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>当然也有可以随意重排序的，比如<strong>读后读</strong>、<strong>两个完全独立的变量进行写操作</strong>等。</p>
<p><strong>但是这种算法只能保证单线程情况下最优，多线程情况下则无法保证。</strong></p>
<p>即使<code>synchronized</code>本身不能阻止JVM对代码进行重排序，也能够通过保证仅有一条线程可以执行同步代码块，从而避免了重排序带来的混乱，也算是保证了代码的有序性。</p>
<h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><p><code>volatile</code>关键字用于修饰共享变量，作用是当有线程将共享变量的拷贝更改了以后，便会将所有工作空间中的共享变量全部设置为<strong>失效</strong>，使得其他线程只能再次从主内存中寻找新的共享变量进行操作。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Java的线程安全问题</title>
    <url>/2020/02/29/Java/%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%80%83/Java%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>线程安全发生的情况非常单一，但是其中包含的技术点非常多。在这里强调一遍，这是Java面试重点考察内容，是个公司都会考。各位萌新一定要引起重视，各位大学生一定要引起重视。</strong></p>
<a id="more"></a>
<h2 id="并发编程的三个问题"><a href="#并发编程的三个问题" class="headerlink" title="并发编程的三个问题"></a>并发编程的三个问题</h2><h3 id="可见性问题"><a href="#可见性问题" class="headerlink" title="可见性问题"></a>可见性问题</h3><p>可见性是指<strong>一个线程对共享变量进行修改，另一个线程能立即得到修改后的最新值</strong>。</p>
<p>当另一个线程没能立即拿到修改后的新值时，就产生了<strong>线程安全问题</strong>。举个简单的例子，就是最简单的累加。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以使用JUnit工具对普通函数进行测试，用静态main函数对静态函数测试</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 由于计算机计算速度越来越快，必须使用大量的数据才可以让问题凸显，几十个都已经不算问题了。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 匿名对象新建线程</span></span><br><span class="line">        <span class="comment">// lambda表达式简化写法，函数式编程已经成为趋势</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 计算</span></span><br><span class="line">            count ++;</span><br><span class="line">            <span class="comment">// 查看结果</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">": "</span> + count);</span><br><span class="line">        <span class="comment">// 执行线程，否则不会显示</span></span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>于是，经过仔细比对观察，终于发现了不对劲的地方！</p>
<p><img src="http://47.111.252.78/images/Java的线程安全问题/重复数据.png" alt="线程不安全的证据"></p>
<p>这就是<strong>没能立刻拿到修改后的数据</strong>。</p>
<h3 id="原子性问题"><a href="#原子性问题" class="headerlink" title="原子性问题"></a>原子性问题</h3><p>原子性是指<strong>在一次或多次执行中，要么所有的操作都会执行，并且不会受到其他因素干扰而中断；要么所有的操作都不执行</strong>。</p>
<p>同样的，我们使用累加的例子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// CPU的速度对循环次数有影响，博主的i7-7500U能够在30次的1000次累加表现优异，所以只能用50次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                count ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 每次循环完查看结果，如果大量测试都刚好是1000的整数倍，那么就是线程安全，否则线程不安全</span></span><br><span class="line">            System.out.println(count);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>终于，在第34次的1000次累加中终于出现了线程安全问题：</p>
<p><img src="https://sakebow.gitee.io/images/Java的线程安全问题/出现零头.png" alt="原子性不能保证"></p>
<p>如果你足够强，你可以去查看字节码文件，也就是运行时生成的<code>.class</code>文件。然后使用反汇编程序<code>javap</code>，在管理员权限下的命令行工具，在其中输入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javap -p -v .\Test<span class="class">.<span class="keyword">class</span></span></span><br></pre></td></tr></table></figure>
<p>其中<code>-p</code>是显示私有属性，<code>-v</code>是显示详细信息，最后跟上你想要查看的字节码文件名，在这里博主就简单说一下：<code>count++</code>实际上反汇编了是四条汇编指令，分别是：<strong>取原始值</strong>、<strong>获取常量1</strong>、<strong>原始值加上常量1</strong>、<strong>将结果返回</strong>。在多线程的环境下，有可能会还没执行完，下一个线程就开始了，于是第一个线程返回了自己的结果1，第二个线程在第一个线程<strong>返回之前</strong>就已经拿到了原始数据0，那么还是返回了1，而不是2。最后，产生了1000次累加总和不是1000的倍数这种问题。</p>
<h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>有序性是指程序中代码的执行顺序。Java在编译时和运行时会对代码进行优化，最后会导致程序最终执行顺序不一定就是我们编写代码时的顺序。</p>
<p><em>这里有个并发压力测试工具jcstress，在<code>Spring</code>框架的<code>pom.xml</code>文件中添加依赖，让编译器自动导包。依赖如下：</em></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.openjdk.jcstress/jcstress-core --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jcstress<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jcstress-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>、</span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>不建议</strong>使用<code>SpringBoot</code>框架测试，因为<code>SpringBoot</code>集成度过高，不一定会显示在终端上，结果也就不得而知。</p>
<p>我们使用这个工具编写测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> ready = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">// 标注这个方法需要新的线程</span></span><br><span class="line"><span class="meta">@Actor</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor1</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// I_Result中提供了各种各样保存数据的方法</span></span><br><span class="line">    <span class="keyword">if</span> (ready) &#123;</span><br><span class="line">        r.r1 = num + num;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r.r1 =  <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Actor</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor2</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line">    num = <span class="number">2</span>;</span><br><span class="line">    ready = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>压力测试会将上面两个方法的代码反复执行。如果出现了不同的结果，则表明<code>JVM</code>会将代码进行自动优化，然后代码重新排序。<strong>对于完全没有前后必然逻辑关系的两行代码更有可能会出现代码重构的情况</strong>，比如<code>a++；b*=5</code>；这两句没有必然联系，<code>JVM</code>执行时就会有一定概率变动顺序。</p>
<h2 id="LOCK"><a href="#LOCK" class="headerlink" title="LOCK"></a>LOCK</h2><p>相信大家一定听过了这个单词，就算没学过也应该听别人说过。对，这也是<strong>面试必考</strong>。</p>
<h3 id="LOCK和synchronized的区别"><a href="#LOCK和synchronized的区别" class="headerlink" title="LOCK和synchronized的区别"></a>LOCK和synchronized的区别</h3><ul>
<li><p><code>synchronized</code>是<strong>关键字</strong>，而<code>Lock</code>是一种<strong>接口</strong></p>
</li>
<li><p><code>synchronized</code>会<strong>自动释放</strong>锁，而<code>Lock</code>需要<strong>手动释放</strong>锁</p>
</li>
<li><p><code>synchronized</code>是<strong>不可中断的</strong>，而<code>Lock</code><strong>可以中断也可以不中断</strong></p>
</li>
<li><p><code>synchronized</code><strong>不能直观</strong>地观察到线程有没有拿到锁，而<code>Lock</code><strong>可以很直观</strong>的看到线程有没有拿到锁</p>
</li>
<li><p><code>synchronized</code>可以锁住<strong>方法和代码块</strong>，但是<code>Lock</code>只能锁住<strong>代码块</strong></p>
</li>
<li><p><code>Lock</code>可以使用<strong>读锁</strong>提高多线程读效率</p>
</li>
<li><p><code>synchronized</code>是<strong>非公平锁</strong>，<code>ReentrantLock</code>可以判断是不是公平锁</p>
</li>
</ul>
<blockquote>
<p><strong>非公平锁</strong>是指从就绪的线程中<strong>随机</strong>选择下一个运行线程，而不是遵循先来后代的原则。</p>
</blockquote>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Session的线程安全问题</title>
    <url>/2020/02/29/Java/%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%80%83/Session%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>服务器虽然能够为每一个会话维护一个Session，在一定程度上确保了线程安全，但是往往在一些细节上还是不能如愿地保证线程安全。这里将详细介绍线程不安全的情况。</strong></p>
<a id="more"></a>
<h2 id="HttpServletRequest源码"><a href="#HttpServletRequest源码" class="headerlink" title="HttpServletRequest源码"></a><code>HttpServletRequest</code>源码</h2><p>通过<code>CTRL</code>+<code>鼠标左键</code>，你找到了源码。（<em>Tomcat相关的jar包有三个，直接找需要很久</em>）</p>
<p>先来看注释：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Extends the javax.servlet.ServletRequest <span class="class"><span class="keyword">interface</span> <span class="title">to</span> <span class="title">provide</span> <span class="title">request</span> <span class="title">information</span> <span class="title">for</span> <span class="title">HTTP</span> <span class="title">servlets</span>. <span class="title">The</span> <span class="title">servlet</span> <span class="title">container</span> <span class="title">creates</span> <span class="title">an</span> <span class="title">HttpServletRequest</span> <span class="title">object</span> <span class="title">and</span> <span class="title">passes</span> <span class="title">it</span> <span class="title">as</span> <span class="title">an</span> <span class="title">argument</span> <span class="title">to</span> <span class="title">the</span> <span class="title">servlet</span>'<span class="title">s</span> <span class="title">service</span> <span class="title">methods</span>(<span class="title">doGet</span>, <span class="title">doPost</span>, <span class="title">etc</span>).</span></span><br></pre></td></tr></table></figure>
<p>继承了<code>ServletRequest</code>类，为<code>HTTP Servlet</code>一共请求头信息。这个<strong>Servlet容器</strong>创建了一个<code>HttpServletRequest</code>对象并作为参数传递给Servlet的服务方法，比如doGet、doPost等。</p>
<p>非常清晰了吧？就算<code>HttpServletRequest</code>是一个接口，他在运行的时候还是创建了一个提供请求头信息的容器。而其中的<code>getSession</code>方法一共有两个，一个是带有<code>create</code>参数的方法，一个是无参方法。</p>
<p>首先是有参方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> HttpSession <span class="title">getSession</span><span class="params">(<span class="keyword">boolean</span> create)</span></span></span><br></pre></td></tr></table></figure>
<p>他的注释是：<em>传入true，就会在必要的时候为请求新建一个Session，返回值将会是与请求头相关联的HttpSession对象；而如果是false则会在当前没有Session的时候直接返回null，最后也会因为没有对应的有效对象直接返回null</em>。</p>
<p>而无参方法则是<code>getSession(true)</code>的调用。</p>
<h2 id="HttpSession的源码"><a href="#HttpSession的源码" class="headerlink" title="HttpSession的源码"></a>HttpSession的源码</h2><p>你似乎还是不明白这到底是怎么回事。于是，为了弄清楚getSession到底返回了个什么，你又找到了HttpSession的源码，然后发现他依然是一个接口。</p>
<p>老规矩，先来看看注释：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Provides a way to identify a user across more than one page request or visit to a Web site and to store information about that user.</span><br></pre></td></tr></table></figure>
<p><em>提供了在多个页面请求中确认其中一个用户身份的方法，或者说是访问Web服务器并存储用户信息的方法。</em></p>
<p>说白了这就是实现了Session的功能。下面更是有一句你非常熟悉的：<code>The session persists for a specified time period, across more than one connection or page request from the user.</code>。相信不翻译大家也能明白HttpSession是个啥玩意了吧。</p>
<p>但是接口怎么实现？继续顺藤摸瓜，你找到了<code>StandardSession</code>，这部分参考了CSDN中<a href="https://www.cnblogs.com/digdeep/p/4429098.html" target="_blank" rel="noopener">digdeep的博客</a>。</p>
<p>而在<code>StandardSession</code>中，第一行就使用了<code>ConcurrentHashMap</code>作为容器存储信息。这是个什么？因为这又是一个大坑所以还是另外用一个单独的版块来进行阐述，<a href="">点击这里查看ConcurrentHashMap详解</a>。这里就直接说结论了：<code>ConcurrentHashMap</code>为<code>HttpSession</code>保证了线程安全，这个是不容置疑的。</p>
<h2 id="Session线程不安全的真正原因"><a href="#Session线程不安全的真正原因" class="headerlink" title="Session线程不安全的真正原因"></a>Session线程不安全的真正原因</h2><p>事实上，<code>Servlet</code>本身不是线程安全的，就算你的<code>Session</code>再怎么线程安全，最后<code>Servlet</code>中修改变量值的时候永远都会出现问题。举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在Servlet中定义属性</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"><span class="comment">// 在Servlet中编写方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 属性修改</span></span><br><span class="line">    count++;</span><br><span class="line">    <span class="comment">// 线程暂停，放大效果</span></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">"count: "</span> + count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用tomcat自带的JMETER压力测试工具模拟五次访问，输出结果就是这样：</span></span><br><span class="line"><span class="comment"> * http-bio-8080-exec-6 count: 5</span></span><br><span class="line"><span class="comment"> * http-bio-8080-exec-9 count: 5</span></span><br><span class="line"><span class="comment"> * http-bio-8080-exec-8 count: 5</span></span><br><span class="line"><span class="comment"> * http-bio-8080-exec-5 count: 5</span></span><br><span class="line"><span class="comment"> * http-bio-8080-exec-7 count: 5</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>很明显，五次输出中四次都拿到了<strong>脏数据</strong>，这不是能够让系统中断的错误，这是逻辑错误，往往比编译器报错更让人头疼。会出现这种情况的原因有两点：</p>
<ul>
<li>容器<strong>只会创建一个</strong><code>Servlet</code>实例，也就是说，这个<code>Servlet</code>中定义的所有变量，只会出现一次。</li>
<li>容器收到请求之后，会启动一个线程来处理该请求。当有多个请求同时访问同一个<code>Servlet</code>值后，这只会出现一次的变量在被多个线程修改的时候就会出现线程安全问题。</li>
</ul>
<p>所以这个问题实际上有点迷惑，<strong>真正线程不安全的并不是<code>Session</code>，而是<code>Servlet</code></strong>。</p>
<p>那么怎么解决呢？同样的，这里涉及<strong>JVM的多线程机制</strong>，因为内容颇多，而且是面试重点，所以单独拉出来讲解。<a href="">点击这里查看JVM多线程机制</a>。这里只给出结果：加上关键字<code>synchronized</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在Servlet中定义属性</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"><span class="comment">// 在Servlet中编写方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 加锁，this是指当前类</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"count: "</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用tomcat自带的JMETER压力测试工具模拟五次访问，输出结果就是这样：</span></span><br><span class="line"><span class="comment"> * http-bio-8080-exec-5 count: 1</span></span><br><span class="line"><span class="comment"> * http-bio-8080-exec-9 count: 2</span></span><br><span class="line"><span class="comment"> * http-bio-8080-exec-7 count: 3</span></span><br><span class="line"><span class="comment"> * http-bio-8080-exec-8 count: 4</span></span><br><span class="line"><span class="comment"> * http-bio-8080-exec-6 count: 5</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>现在就正常了。</p>
<p>虽然加锁能够避免线程安全问题，但是加锁会<strong>牺牲性能</strong>。</p>
<p>所以尽量我们不要修改<code>Servlet</code>的属性。如果你使用了框架，相对应的就是<code>Controller</code>部分，尽量不要修改这些部分。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Collection，Set和List以及Map</title>
    <url>/2020/02/24/Java/%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%80%83/Java%E9%9B%86%E5%90%88%E6%A2%B3%E7%90%86/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>如果你是Java后台开发人员，这四个将会伴随你整个面试。而且，想要爬到更高的层次，这是谁也跑不掉的数据结构。</strong></p>
<a id="more"></a>
<h2 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h2><p>先来看一下Java所有的容器类：</p>
<ul>
<li><p><code>Collection</code>：接口（不是实体类！）</p>
<ul>
<li><p><code>List</code>：接口（不是实体类！）</p>
<ul>
<li><p><code>LinkedList</code>：链表实体类</p>
</li>
<li><p><code>ArrayList</code>：集合实体类</p>
</li>
<li><p><code>Vector</code>：<code>vector</code>实体类（比较接近数组）</p>
<ul>
<li><code>Stack</code>：链表实体类</li>
</ul>
</li>
</ul>
</li>
<li><p><code>Set</code>：接口（不是实体类！）</p>
<ul>
<li><code>HashSet</code>：哈希集合实体类</li>
<li><code>LinkedHashSet</code>：链表哈希集合实体类</li>
<li><code>TreeSet</code>：树状集合实体类</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>但是这些有什么区别吗？弄了这么多花里胡哨的，他们都是为了什么而产生的？</p>
<p>我们通过源码来看看。（又双叒叕是源码）</p>
<h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a><code>Collection</code></h2><p><strong><code>Collection</code>是一种接口，其下又衍生出了”Set“和”List“两种接口，而且具有不同的功能。</strong></p>
<p>但是<code>Collection</code>不支持直接实例化，而需要通过对两个子接口中的一个进行实例化才可以间接地将Collection进行实例化。</p>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a><code>Set</code></h2><p><strong><code>Set</code>中不包含任何重复元素，就像是数学术语中的“集合”一样。</strong></p>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a><code>HashSet</code></h3><p><strong><code>HashSet</code>在源码中使用了<code>HashMap</code>进行了所有功能的实现，所以本质上<code>HashSet</code>是<code>HashMap</code>的再封装，顶多是加了不重复这个功能。</strong></p>
<p><code>HashSet</code>支持向里面添加<strong>null</strong>对象，但是<strong>会进行简单的排序</strong>。</p>
<h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a><code>LinkedHashSet</code></h3><p><code>LinkedHashSet</code>和<code>HashSet</code>都是继承自<code>Set</code>，所以也有基本的集合属性。唯一不同的就是，<code>LinkedHashSet</code>将会严格按照添加元素的<code>add</code>方法的顺序进行元素的添加，而<code>HashSet</code>会自动排序。</p>
<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a><code>TreeSet</code></h3><p><code>TreeSet</code>与其说是实现了<code>Set</code>，应该说是实现了<code>NavigableSet</code>接口，而<code>NavigableSet</code>接口又是继承自<code>SortedSet</code>接口。相信大家看到这个名字都知道是干嘛的吧？也就是说，<code>TreeSet</code>将会遍历整个集合的元素并按<strong>升序排列</strong>。</p>
<p>但是要强调一点，<code>TreeSet</code><strong>不支持加入null元素</strong>，因为无法升序排列。</p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a><code>List</code></h2><p><strong><code>List</code>是一个有序的数据集。与Set不同的是List允许同样的值反复插入，而且<code>List</code>可以直接使用数据在集合中的索引位置直接访问，非常快速方便。</strong></p>
<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a><code>LinkedList</code></h3><p><code>LinkedList</code>中是使用<code>Node</code>类实现的，也就是在<code>LinkedList</code>类中另外定义了私有的Node类进行实现，也就是说，本质上是链表。</p>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a><code>ArrayList</code></h3><p><code>ArrayList</code>中使用了<code>Object</code>数组实现的，也就是说，<code>ArrayList</code>本质上就是数组。但是数据结构比较严格，必须整个数组都是同样的类型，不能<code>Integer</code>和<code>String</code>混在同一个数组内。</p>
<h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p><code>Vector</code>中使用了<code>Object</code>数组。其实由<code>ArrayList</code>继承而来的<code>Vector</code>也必定是数组实现的。</p>
<h4 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a><code>Stack</code></h4><p><code>Stack</code>由<code>Vector</code>继承而来，本质也是数组，只不过增加了栈一样先进后出的逻辑控制。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Session工作原理</title>
    <url>/2020/02/24/Java/%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%80%83/Session%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>在Web面试的时候，后台一定要清楚Session的工作原理，因为总有一些数据需要从后台传入前端。而在说Session的时候，不可避免地会谈到Cookies。本篇将详细阐述二者的区别。</strong></p>
<a id="more"></a>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="TCP-IP网络协议"><a href="#TCP-IP网络协议" class="headerlink" title="TCP/IP网络协议"></a>TCP/IP网络协议</h3><p>根据计算机网络原理，双方在通信时往往会互相发送报文，也就是把数据处理成了多个压缩包逐个发送。而在这个过程中，双方会建立一个虚拟连接通道。你问我为什么不是物理的？因为物理连接是一开始就存在的。如果是有线连接，物理连接就是网线；如果是无线连接，空气也能算介质。</p>
<p>那么，这个虚拟连接什么时候开始什么时候结束呢？</p>
<p>1、当我们要发送数据包前，快递员会先跟他提个醒：“快递到了，签收一下”</p>
<p>2、对面听到了之后回应：“好嘞”，然后把门打开了</p>
<p>3、快递员听到了回应之后，虚拟连接就成立了，搬运也就开始了</p>
<p>这就是我们俗称“<strong>三次握手</strong>”。</p>
<p>最后搬运完了之后，开始执行同样的操作。</p>
<p>1、快递员这边提个醒：“全部搬完了！”</p>
<p>2、对面听到了之后回应：“好嘞”，然后把钱递了出去</p>
<p>3、快递员收到钱之后，清点了一下，喊一声：“收齐啦！谢谢！”（<em>没收齐是不会进入结束阶段的</em>）</p>
<p>4、对面听到了，直接“砰”地就把门关上了，虚拟连接断开</p>
<p>你也可以叫他“<strong>四次握手</strong>”，也有人叫他“<strong>四次挥手</strong>”，这都无所谓了。</p>
<h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><p>会话在计算机术语中是指<strong>一个终端用用户与交互系统进行通讯的过程</strong>。“三次握手”建立了一个会话，“四次挥手”关闭了一个会话。例如，<strong>从你登录</strong>求职网<strong>一直到退出</strong>账号这整个过程都是会话。（摘自<a href="https://baike.baidu.com/item/HTTP%E4%BC%9A%E8%AF%9D/4376108?fr=aladdin" target="_blank" rel="noopener">百度百科</a>）</p>
<p>我们一般所说的“会话”，其实全称是“<strong>HTTP会话</strong>”。</p>
<h3 id="HTTP网络协议"><a href="#HTTP网络协议" class="headerlink" title="HTTP网络协议"></a>HTTP网络协议</h3><p>只要你访问了互联网，网址栏永远会显示<a href="http://或者https://，这就是HTTP协议的作用，也就是客户端和服务端之间的相互通信。但是HTTP是无状态协议，也就是说不管你去哪访问，服务器永远不会管你先前干了什么，这也就是为什么好好的填了在线简历一刷新全都没了。" target="_blank" rel="noopener">http://或者https://，这就是HTTP协议的作用，也就是客户端和服务端之间的相互通信。但是HTTP是无状态协议，也就是说不管你去哪访问，服务器永远不会管你先前干了什么，这也就是为什么好好的填了在线简历一刷新全都没了。</a></p>
<p>这无疑是非常恐怖的。但是不用担心，我们有<strong>Session和Cookie</strong>。</p>
<h2 id="Session和Cookie"><a href="#Session和Cookie" class="headerlink" title="Session和Cookie"></a>Session和Cookie</h2><p>Session运行在服务端，当我们在连接中接入steam的时候，你就有了<strong>唯一一个</strong>SessionID，这样服务器就确认了是你购买了这款游戏。与此同时，运行在客户端的Cookie就帮我们保存了一小段的信息，一般是保存在内存中，用来记录各种各样的信息。正因如此，我们能<strong>免认证直接登录</strong>就是因为这段Cookie在会话结束后<strong>存在了硬盘中</strong>，在有效时间内再次访问就会使用这段Cookie；而一些做的并不是很好的网站却没有这个功能，直接关掉浏览器，甚至是关掉网页Cookie就消失了，在登录和登出之间反复横跳。</p>
<p>你可能会怀疑：如果一个人登录修改了Session，第二个人登进去会不会把第一个人顶出去？</p>
<h2 id="Session的工作原理"><a href="#Session的工作原理" class="headerlink" title="Session的工作原理"></a>Session的工作原理</h2><p>服务器系统会为<strong>每一个会话维护一个Session</strong>，<strong>不同的会话对应不同的Session</strong>。下面会详细解释为什么系统对每一个会话使用并一直保持使用<strong>完全不同</strong>的Session来处理不同的会话。</p>
<h3 id="写入Session列表"><a href="#写入Session列表" class="headerlink" title="写入Session列表"></a>写入Session列表</h3><p>这也是整个会话管理的第一步。</p>
<p>服务器对当前应用中的Session是以<strong>Map</strong>的形式进行管理的，这个Map成为Session列表。我们知道，Map是以<strong>键值对（key-value）</strong>的形式存储的，所以最终将会是一个多行两列的表格，每一行代表一个键值对。而Session里面都是些什么啊？用表格表示的话就是这样：</p>
<p>key|value<br>|-|-|<br>| D329C89C88DEC2189888FDF365961A87 | org.apache.catalina.session.StandardSessionFacade@1878aab4 |<br>|9C7B848D2CCF19DC00B80218BC181838|org.apache.catalina.session.StandardSessionFacade@78dded51|</p>
<p>（<em>以上数据均为举例，并不是真实数据</em>）</p>
<p>左边的<code>key</code>为32位随机串，是根据某种算法生成的字符串，被称为<code>JSessionID</code>，也就是Java类型的Session对象的ID值。右边的<code>value</code>值就是HttpSession对象的引用，存放在<strong>服务器的堆内存中</strong>。</p>
<p>当用户<strong>第一次提交请求</strong>的时候，<strong>服务端</strong>的Servlet执行到<code>request.getSession()</code>方法后，会自动生成一个<code>Map.Entity</code>对象，也就是键值对对象。<strong>一定要明确写明调用了getSession方法，因为只有在这种情况下服务端才会生成Session</strong></p>
<h3 id="服务器生成并发送Cookie客户端"><a href="#服务器生成并发送Cookie客户端" class="headerlink" title="服务器生成并发送Cookie客户端"></a>服务器生成并发送Cookie客户端</h3><p>在服务器写入<code>Session</code>列表后，系统还自动将<code>JSessionID</code>以<strong>Cookie</strong>的形式保存在响应报头中，并随着这个报头，传送给客户端。</p>
<h3 id="客户端接受并发送Cookie到服务器"><a href="#客户端接受并发送Cookie到服务器" class="headerlink" title="客户端接受并发送Cookie到服务器"></a>客户端接受并发送<code>Cookie</code>到服务器</h3><p>客户端接收到<code>JSessionID</code>后，将这个存在浏览器缓存中。只要浏览器不关闭，<code>Cookie</code>就不会消失。<strong>每次请求的时候，缓存中的<code>Cookie</code>就会被封装到响应报头中发送到服务器</strong>。</p>
<h3 id="服务器接收Cookie并在表中查找发送的JSessionID"><a href="#服务器接收Cookie并在表中查找发送的JSessionID" class="headerlink" title="服务器接收Cookie并在表中查找发送的JSessionID"></a>服务器接收<code>Cookie</code>并在表中查找发送的<code>JSessionID</code></h3><p>服务端从请求中读取到客户端发送回来的<code>Cookie</code>，并根据<code>Cookie</code>中的<code>JSessionID</code>的值，在<code>Map</code>中查找相应的<code>key</code>所对应的<code>value</code>，即<code>Session</code>对象。然后，服务器才可以对Session对象中的对应属性进行读写操作。</p>
<p>这一整套流程像极了银行卡的办理和使用。</p>
<ul>
<li><p>你到了银行，<strong>请求</strong>办一张卡</p>
</li>
<li><p>通过银行的某种随机算法，银行给了你一个<strong>随机的字符串</strong>，这就变成了你的<strong>唯一标识</strong>了</p>
</li>
<li><p>银行<strong>只给了你一张卡</strong>，卡上有你的<strong>唯一标识</strong></p>
</li>
<li><p>你以后就可以拿着卡去找银行存取了。同样的，银行就通过你银行卡上的<strong>唯一标识</strong>来查找你的真实数据，然后修改</p>
</li>
</ul>
<h2 id="Session的线程安全问题"><a href="#Session的线程安全问题" class="headerlink" title="Session的线程安全问题"></a>Session的线程安全问题</h2><p>虽然说银行能够对每一个客户的业务处理独立进行，线程安全问题可以在一定程度上得到保证。但是开发中Session多少还是有一定的线程安全问题。这一部分由于涉及源码，将会单独拉出来一个板块进行讲解。而且这个板块涉及的内容非常多，请务必在确保你了解<code>synchronized</code>关键字、<code>ConcurrentHashMap</code>类的基础上查看<a href="">此教程</a>。</p>
<h2 id="附：Cookie被禁后的Session运行流程"><a href="#附：Cookie被禁后的Session运行流程" class="headerlink" title="附：Cookie被禁后的Session运行流程"></a>附：<code>Cookie</code>被禁后的<code>Session</code>运行流程</h2><p>上面我们讲了，<code>Session</code>的运行少不了<code>Cookie</code>，在一定程度上说，<code>Cookie</code>就是维持两边通信的基础。</p>
<p>但是别忘了，<code>IE</code>是可以<strong>禁用</strong><code>Cookie</code>的。这种情况怎么办？禁用了<code>Cookie</code>之后，客户端中将不再保存服务端送来的<code>JSessionID</code>，下一次请求将是全新的请求，服务器会分配全新的<code>JSessionID</code>，用户已保存的信息也就不能通过正常访问方式访问了，最后随着失效时间的到来而消失。</p>
<p>细心的你似乎已经发现了，我说的是<strong>不能通过正常方式</strong>。非正常的访问方式是：你通过抓包抓住了JSessionID，然后使用<code>同样的网址</code>+<code>;</code>+<code>JSessionID=</code>+<code>记录下来的JSessionID</code>。这个时候你就能在请求的同时把原来的JSessionID强行送出去，然后服务器就知道了你的身份。</p>
<p><strong>但是，这个身份不一定是你，而是能够使用抓包工具抓到包的任何人。更可怕的是，抓包工具就集成在浏览器中，也就是我们所熟知的F12开发者选项</strong>。</p>
<p>这也引出了另一个问题：<strong>会话到底是什么时候结束</strong>？</p>
<p>答案是：<strong>Session消失了会话才会结束</strong>。我们一开始就已经强调了，<strong>服务器会为每一个会话维护一个Session</strong>。这也是为什么电商平台往往要有退出按钮。</p>
<p>但是我们该怎么在Cookie被禁掉之后重新找到原来的数据呢？Servlet有<strong>重定向</strong>和<strong>非重定向</strong>方法。</p>
<h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先确定接口位置</span></span><br><span class="line">String uri = request.getContextPath() + <span class="string">"/api"</span>;</span><br><span class="line"><span class="comment">// 解决Cookie禁用后重定向时Session的跟踪问题</span></span><br><span class="line">uri = response.encodeRedirecrtURL(uri);</span><br><span class="line">response.sendRedirect(uri);</span><br></pre></td></tr></table></figure>
<p>这样不管是否禁止Cookie就都能找到我的用户数据啦！简直不要太完美！</p>
<p>可现实是：<strong>你的JSessionID明晃晃地挂在地址栏上</strong>。这可了不得，你把自己的位置都给暴露了，还不怕别人暗中狙你一枪？</p>
<h3 id="非重定向"><a href="#非重定向" class="headerlink" title="非重定向"></a>非重定向</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先确定接口</span></span><br><span class="line">String uri = <span class="string">"api"</span>;</span><br><span class="line"><span class="comment">// 解决Cookie禁用后非重定向时Session的跟踪问题</span></span><br><span class="line">uri = response.encodeURL(uri);</span><br><span class="line">out.println(<span class="string">"&lt;a href='"</span> + uri + <span class="string">"'&gt;跳转&lt;/a&gt;"</span>);</span><br></pre></td></tr></table></figure>
<p>同样的，这样不管是否禁用<code>Cookie</code>都可以访问到原有的<code>JSessionID</code>。但是别忘了，a标签可是<code>GET</code>请求啊！明明白白地打在地址栏上的啊！</p>
<p>以上，就是<code>Session</code>的全部内容。实际上<code>Session</code>还有非常多的细节问题，但是<strong>最重要的还是工作原理的部分</strong>。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap详细探究</title>
    <url>/2020/02/23/Java/%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%80%83/HashMap%E8%AF%A6%E7%BB%86%E6%8E%A2%E7%A9%B6/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>本文将分为两个部分，一个是HashMap原理讲解，一个是HashMap面试常考。当然，这里没有实战内容，全都是生涩的理论知识，比较枯燥而且难懂。但是这可是非常重要的必考部分呢。</strong></p>
<a id="more"></a>
<h2 id="原理讲解"><a href="#原理讲解" class="headerlink" title="原理讲解"></a>原理讲解</h2><p>HashMap是Map接口的实现类。确实，HashMap也是一种容器，可以类比C#中的字典类型，是标准的键值对，即Key-Value存储模式。</p>
<p>想必大家都听说过：HashMap其实就是<strong>散列表</strong>，使用链表处理冲突。而链表长度大于8的时候，链表会被重构为<strong>红黑树</strong>。</p>
<p>为什么是红黑树？因为红黑树中红色节点和黑色节点在重构是会不停的旋转，从而使得整个树无论怎么增删改查时间复杂度永远只有O(log(n))。这无疑比链表的$O(n)$要快。</p>
<p>而为什么是8？因为链表平均查找长度为</p>
<script type="math/tex; mode=display">(1 + 2 + ... + n) / 2 = (n + 1) / 2</script><p>，而红黑树是$\log_2(n)$，当$n = 8$的时候，链表和红黑树相差$1$个节点以上的消耗，这个时候才有了显著的提升。</p>
<p>但是，当$n=6$时，红黑树平均查找长度是$2.5$，链表是$3.5$，也是一个节点的长度，为什么偏偏要选$8$？这是因为如果消耗严格控制在$1$个节点将会在树和链表中反复横跳，这个转换的代价远远超过了增删改查的代价。</p>
<p><strong>当然仅仅大于8是不够的</strong>。如果散列表始终只有一个数据，转换为红黑树的代价是毁灭性的。为什么？如果你们在大学期间有幸能够接触到红黑树，应该会了解到红黑树其实是按照一定的规律将节点标记为红色和黑色，并且对红色和黑色的节点有严格地排列规律，如果不正确就需要重新修改排列顺序。那么，我将会为这唯一一个散列表的数据反复的重构、再排列，<strong>已经远远不如原来的链表了</strong>。所以源码中还另外规定了：需要<strong>散列表长度超过64</strong>。</p>
<p>好了，接下来我们开始看源码。</p>
<p>首先我们来看看注释：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Hash table based implementation of the Map <span class="class"><span class="keyword">interface</span>.</span></span><br><span class="line"><span class="class"><span class="title">This</span> <span class="title">implementation</span> <span class="title">provides</span> <span class="title">all</span> <span class="title">of</span> <span class="title">the</span> <span class="title">optional</span> <span class="title">map</span> <span class="title">operations</span>, <span class="title">and</span> <span class="title">permits</span> <span class="title">null</span> <span class="title">values</span> <span class="title">and</span> <span class="title">the</span> <span class="title">null</span> <span class="title">key</span>.</span></span><br><span class="line"><span class="class"><span class="title">The</span> <span class="title">HashMap</span> <span class="title">class</span> <span class="title">is</span> <span class="title">roughly</span> <span class="title">equivalent</span> <span class="title">to</span> <span class="title">Hashtable</span>,</span></span><br><span class="line"><span class="class">  <span class="title">except</span> <span class="title">that</span> <span class="title">it</span> <span class="title">is</span> <span class="title">unsynchronized</span> <span class="title">and</span> <span class="title">permits</span> <span class="title">nulls</span>.</span></span><br><span class="line"><span class="class"><span class="title">This</span> <span class="title">class</span> <span class="title">makes</span> <span class="title">no</span> <span class="title">guarantees</span> <span class="title">as</span> <span class="title">to</span> <span class="title">the</span> <span class="title">order</span> <span class="title">of</span> <span class="title">the</span> <span class="title">map</span></span>;</span><br><span class="line">in particular, it does not guarantee that the order will remain constant over time.</span><br></pre></td></tr></table></figure>
<p>大致意思上就是说：这个继承类提供了<code>Map</code>的所有操作，并且支持<strong>null:null</strong>这样的键值对。在某种程度上，<code>HashMap</code>和<code>HashTable</code>是类似的，但是<code>HashMap</code>是线程不安全的。同样的，<code>HashMap</code>不能保证顺序。</p>
<p>为什么不能保证顺序？我们看看添加元素的方法：<code>put</code>。结果<code>put</code>中<strong>只是调用了<code>putVal</code>方法</strong>，我们再转到<code>putVal</code>中查看详细的内容。</p>
<p>同样的，看方法之前先看注释：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.put and related methods ：实现了Map.put和其他相关方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment"> * hash字段是键的哈希值，是我们通过一定的计算产生的，常见的算法有MD5，SHA-1等等。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * key字段是需要加入的键值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment"> * value字段是键值所对应的数据，和key一起构成“键值对”</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyIfAbsent if true, don't change existing value</span></span><br><span class="line"><span class="comment"> * onlyIfAbsent翻译过来是“仅在缺省情况下生效”</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment"> * evict翻译过来是“驱逐”的意思</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment"> * 返回值是当前值，如果为空则什么都没有</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>先说明一下：由于<code>hash</code>值是使用<code>key</code>值进行计算得出来的，所以只要<code>key</code>值相同，<code>hash</code>值一定相同。</p>
<p>这也是为什么<code>HashMap</code>会略微快一点，因为他的位置是根据<code>key</code>算出来的。</p>
<p>获取<code>hash</code>值除以特定长度后的余数，余数重复的元素将会放在同一个节点，以链表或者红黑树的形式绑在一起。这也就是数据结构的散列表处理冲突。</p>
<p>这个概念比较重要，马上我们就会用到。</p>
</blockquote>
<p>在开始我们的函数之前，我们要先理清一个问题：<code>Node</code>这个玩意为什么在那么多容器里面都有？</p>
<p>首先，<code>Node</code>这个类并不是单独拉个文件出来写的，而是在每个类中按需定制。比如<code>LinkedList</code>就是在自己的类里面定义了一个<code>private class Node</code>，而<code>HashMap</code>中，<code>Node</code>则是实现了<code>Map.Entity</code>接口。</p>
<p>而有过<code>Web</code>开发经验的同学们应该就非常清楚了吧，<code>Entity</code>就是和数据库表中字段一一对应的<strong>实体类</strong>，也就是专门用来封装数据的对象的通用名称。来看看他的解释：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">A map <span class="title">entry</span> <span class="params">(key-value pair)</span></span></span><br></pre></td></tr></table></figure>
<p>注释第一句话都写成这样了，大家应该熟悉得不能再熟悉了吧。没错，<code>Node</code>在<code>HashMap</code>中就是一对键值对。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 一开始定义了Node数组和Node变量</span></span><br><span class="line">  <span class="comment">// 需要注意的是，Node是自定义的结构体，不进行任何初始化的情况时默认为null</span></span><br><span class="line">  Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">  <span class="comment">// table是HashMap类定义之初就声明的Node数组，以transient关键字声明的变量不参与序列化过程</span></span><br><span class="line">  <span class="comment">// 将table中的值全部放到tab中，如果为空，那么就调用resize方法，将数组扩容。</span></span><br><span class="line">  <span class="comment">// 如果数组不为0，容量扩大两倍；如果为0，按照默认大小配置。这里是为0的情况，数组将以默认值进行初始化</span></span><br><span class="line">  <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">    n = (tab = resize()).length;</span><br><span class="line">  <span class="comment">// 这里使用了单个“&amp;”符号，表示两边同时满足，即i在已经获取hash值之后成为n-1</span></span><br><span class="line">  <span class="comment">// 如果这个Node节点为空，新建节点</span></span><br><span class="line">  <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">    tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">  <span class="comment">// 如果这里已经有节点占着了</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e; K k;</span><br><span class="line">    <span class="comment">// 你可能会怀疑这里的p会不会是空的</span></span><br><span class="line">    <span class="comment">// 实际上，前面p = tab[i = (n - 1) &amp; hash]的时候，这里p被强行赋值了</span></span><br><span class="line">    <span class="comment">// 所以p所指向的是当前插入节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这段有点长，我们静下心来好好分析：这些条件是：</span></span><br><span class="line">    <span class="comment">// 1、如果当前节点p的哈希值和传入哈希值（就是要插入元素的哈希值）相等</span></span><br><span class="line">    <span class="comment">// 2.1、k暂存当前节点的key值，如果当前节点的key值和传入key值相等</span></span><br><span class="line">    <span class="comment">// 2.2、如果传入key值不为空，而且key值与当前节点key值相同</span></span><br><span class="line">    <span class="comment">// 首先，2.1和2.2先判断，两者中只要有一个为真，2就为真</span></span><br><span class="line">    <span class="comment">// 其次判断1是否为真。好了，我们分析一下这么做是为什么。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、hash可以定位一组元素。hash仅用于快速定位，在数据处理中没有实际意义。</span></span><br><span class="line">    <span class="comment">// 2、hash + key可以精确定位一个元素</span></span><br><span class="line">    <span class="comment">// 重复的key无法给出唯一的value值</span></span><br><span class="line">    <span class="comment">// 所以一旦检测到有重复的key，就用新插入的value替换原有的value</span></span><br><span class="line">    <span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">      e = p; <span class="comment">// 这里只是暂存原有节点p，否则会被替换</span></span><br><span class="line">    <span class="comment">// 如果p是TreeNode类型，则加到树中。</span></span><br><span class="line">    <span class="comment">// 文章开头我们说了，8个节点以上的话将会转变成红黑树，所以当他成为树的时候，调用树的方法就好了。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">      e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 最后，既没有重复的key、也没有转变为树，即节点数小于8且无重复键</span></span><br><span class="line">      <span class="comment">// 就很平常的使用循环寻找链表尾节点</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">        <span class="comment">// 到头了</span></span><br><span class="line">        <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 插入</span></span><br><span class="line">          p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">          <span class="comment">// 但是如果你插入这个节点就到8了</span></span><br><span class="line">          <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">            <span class="comment">// 转变成红黑树</span></span><br><span class="line">            treeifyBin(tab, hash);</span><br><span class="line">          <span class="comment">// 由于循环也不知道写什么条件，就干脆自己控制跳出循环好了</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先前我们看到，e是暂存了p，也就是当前节点</span></span><br><span class="line">        <span class="comment">// 1、暂存节点的hash值和插入hash值相等</span></span><br><span class="line">        <span class="comment">// 2.1、k最后变回暂存节点的key，并且判断是否和插入的key相同</span></span><br><span class="line">        <span class="comment">// 2.2、key不为空且key和k相同</span></span><br><span class="line">        <span class="comment">// 也就是说，如果键值重复了，将会直接结束</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// p还原</span></span><br><span class="line">        p = e;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后，如果暂存的e节点存在</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">      V oldValue = e.value;</span><br><span class="line">      <span class="comment">// 缺省情况下不生效 或者 旧值为空，则将暂存的e节点的value变为新的value</span></span><br><span class="line">      <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">        e.value = value;</span><br><span class="line">      afterNodeAccess(e);<span class="comment">// 这个实际上是空函数</span></span><br><span class="line">      <span class="comment">// 最后返回旧值</span></span><br><span class="line">      <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ++modCount;</span><br><span class="line">  <span class="comment">// 如果容量不够了，两倍扩容</span></span><br><span class="line">  <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">    resize();</span><br><span class="line">  afterNodeInsertion(evict);<span class="comment">// 这个实际上是空函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，不能保持原有数据的原因是：<code>HashMap</code>会变成<strong>红黑树</strong>，然后整个结构就<strong>转起来</strong>了，原来的链表将会被拉成树，原来的树将会被重构，再回过头来看的时候原来的顺序已经被转得不像样子了。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM类加载器</title>
    <url>/2020/02/06/Java/JVM/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>在Java代码中，类型的加载、链接与初始化过程都是程序运行期间完成的。类加载给程序提供了更大的灵活性。</strong></p>
<a id="more"></a>
<h2 id="导读的解读"><a href="#导读的解读" class="headerlink" title="导读的解读"></a>导读的解读</h2><ul>
<li><p>运行的时候，我们往往就是直接点击编译器的运行按钮；而C、C++则是先点击编译，再点击运行。所以类似C、C++这类语言就是在程序运行之前的编译期间完成，而Java则是在运行期间完成。</p>
</li>
<li><p>这里的类型是特指一些类，而不是对象，比如我们一开始所写的public class HelloWorld，这个HelloWorld就是这里所指的类<strong>其中一种情况</strong>。</p>
</li>
<li><p>还有一种情况就是<strong>动态代理</strong>。在动态代理中获得生成类的增强类，也会加载、链接、初始化。</p>
</li>
</ul>
<h2 id="类加载器深入剖析"><a href="#类加载器深入剖析" class="headerlink" title="类加载器深入剖析"></a>类加载器深入剖析</h2><p>顾名思义，类加载器就是<strong>用于加载类的工具</strong>。首先先来了解一下Java虚拟机的结束时间。</p>
<h3 id="Java虚拟机结束生命周期的时机"><a href="#Java虚拟机结束生命周期的时机" class="headerlink" title="Java虚拟机结束生命周期的时机"></a>Java虚拟机结束生命周期的时机</h3><ul>
<li><p>执行了System.exit()方法</p>
</li>
<li><p>程序正常执行结束</p>
</li>
<li><p>程序在执行过程中遇到了异常或错误而终止</p>
<blockquote>
<p><em>异常或错误会被Java虚拟机在当前位置一直向上抛出。但是如果没有什么机制接住异常的话，将会一直抛出到main方法中，最后因为无法处理而终止。</em></p>
</blockquote>
</li>
<li><p>由于操作系统出现错误而导致Java虚拟机进程终止 <em>（不可控，所以不展开讨论）</em></p>
</li>
</ul>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>类的加载过程是“查找并加载类的二进制数据”，也就是<strong>生成字节码</strong>，并将字节码<strong>放入内存中</strong>。</p>
<p>jdk<strong>1.7</strong>以及以前的版本会将这些放入<strong>运行时数据区的方法区</strong>内，而jdk8添加了<strong>原空间</strong>来存放这些字节码。接着在内存中创建<strong>唯一一个java.lang.Class对象</strong>用于<strong>封装方法区内的数据结构</strong>。</p>
<p><strong>这正是反射机制的源头</strong>。不觉得“是什么”慢慢填补了之后“为什么”也就迎刃而解了吗？</p>
<p>但是规范中并没有规定这些Class对象应该位于哪里，Oracle的HotSpot虚拟机导师把这些放在了方法区内。这倒不是什么重点。</p>
<p>虽说这些字节码是编译器自动生成的，但是这些字节码可以被人为修改，所以在链接之前将会在<strong>后续阶段</strong>中好好地验证一遍。</p>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><ul>
<li><p>验证：确保被加载类的正确性（验证字节码）</p>
</li>
<li><p>准备：为类的<strong>静态变量</strong>分配内存，将其初始化为默认值。</p>
<blockquote>
<p>需要强调的是，这里的默认值是编译器定义的默认值。也就是说，在加载这个类的时候，将会给类内的静态变量分配一个内存空间，而这个变量立马就被规定为默认值。比如int类型将会获得数字“0”等等。</p>
</blockquote>
</li>
<li><p>解析：将类中的<strong>符号引用</strong>转换为<strong>直接引用</strong>。</p>
</li>
</ul>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>在连接完成后，为类的静态变量<strong>赋予正确的初始值</strong>。举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>链接阶段的准备工作，a被赋予了数字“0”，但是在连接完成后的初始化阶段中，将会重新将a赋值为“1”。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>也就是正常的调用等等操作，包括访问、修改和删除等等。</p>
<h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p>将类的字节码从内存中删除，这样就不能继续使用这个类了，需要时可以重新加载到内存中。平时使用场景非常少。</p>
<h2 id="Java程序对类的使用方式"><a href="#Java程序对类的使用方式" class="headerlink" title="Java程序对类的使用方式"></a>Java程序对类的使用方式</h2><p>使用方式可以分为两种，<strong>主动使用</strong>和<strong>被动使用</strong>。</p>
<p>所有的Java虚拟机实现必须在每个类或接口被程序“<strong>首次主动使用</strong>”时才初始化他们。</p>
<p>而什么是“首次主动使用”？就是<strong>只有在第一次主动使用</strong>的时候初始化。</p>
<h3 id="主动使用"><a href="#主动使用" class="headerlink" title="主动使用"></a>主动使用</h3><ul>
<li><p>创建类的实例（<code>new</code>）</p>
</li>
<li><p>访问某个类或者接口的<strong>静态变量</strong>，或者对该静态变量赋值</p>
</li>
<li><p>调用类的静态方法</p>
</li>
<li><p>反射</p>
</li>
<li><p>初始化一个类的子类（子类被创建的时候，<strong>所有的父类</strong>都会被创建）</p>
</li>
<li><p>Java虚拟机启动时被标名为启动类的类</p>
</li>
<li><p>动态语言支持（从jdk1.7开始支持）</p>
</li>
</ul>
<h3 id="被动使用"><a href="#被动使用" class="headerlink" title="被动使用"></a>被动使用</h3><p>除了上述七种情况，其他的所有情况都是类的<strong>被动使用</strong>，也就不会导致类的初始化。</p>
<h3 id="加载-class文件的方式"><a href="#加载-class文件的方式" class="headerlink" title="加载.class文件的方式"></a>加载<code>.class</code>文件的方式</h3><p>由于JVM规范并没有规定我们一定要从哪里加载这些<code>.class</code>文件，所以我们甚至可以加载不在本地的文件。这也正是为什么我们可以往我们的项目中添加jar包，也正是<code>Spring</code>框架中的<code>Maven</code>如此好用的原因。</p>
<p>所以有很多种方法可以加载：</p>
<ul>
<li><p>从本地系统中直接加载</p>
</li>
<li><p>通过网络下载.class文件</p>
</li>
<li><p>从zip、jar等归档文件中加载.class文件</p>
</li>
<li><p>从专有数据库中提取.class文件（用的极少）</p>
</li>
<li><p><strong>将Java源文件动态编译为.class文件</strong></p>
<ul>
<li><p>动态代理</p>
</li>
<li><p>jsp在运行期间会被转换成servlet，最终会被编译成.class文件</p>
</li>
</ul>
</li>
</ul>
<h2 id="应当注意的点"><a href="#应当注意的点" class="headerlink" title="应当注意的点"></a>应当注意的点</h2><ul>
<li><p>主动使用</p>
<ul>
<li><p><strong>对于静态字段来说，只有直接定义了该字段的类才会被初始化</strong></p>
<p>也就是说子类如果是从父类继承得到了静态变量而不是直接在子类内部定义的话，调用子类继承而得的静态变量时子类不会被初始化。</p>
</li>
<li><p><strong>当一个类在初始化时，要求其父类全部都初始化完毕才开始执行初始化</strong></p>
</li>
</ul>
</li>
</ul>
<p>所以，<code>Java</code>在实际运行中将会占用非常大的内存，这对于吞吐量极大的项目来说并不是一个好的选择，这也正是为什么腾讯和<code>bilibili</code>都正在逐渐使用<code>Go</code>重写整个系统。</p>
<h2 id="2020年11月21日更新"><a href="#2020年11月21日更新" class="headerlink" title="2020年11月21日更新"></a>2020年11月21日更新</h2><p>即使<code>Java</code>依然在性能上有着无法反驳的劣势，却在生态上有着无可撼动的地位。基于<code>Spring Cloud</code>的微服务框架能够集成<code>RabbitMQ</code>、<code>Redis</code>、<code>Zuul</code>、<code>Consul</code>等一切企业级信息管理框架所需要的内容，再加上基于<code>Spring Boot</code>的模块可以使用<code>yml</code>轻松集成，如此强大的生态已经成为了<code>Java</code>立于不败之地的重要因素。不仅如此，在面对海量的并发控制和请求处理的时候，可以<strong>使用非常多的服务器并联处理</strong>，做到了物理意义上的“<strong>三个臭皮匠，顶个诸葛亮</strong>”。这也是为什么<code>Java</code>依然能够在运行内存占用非常高的情况下依然保持这么高的支持率的原因之一。也正因为高支持率，才有了强大的社区和丰富的库。这就是一个良性循环了。</p>
<p>当然，随着微服务、<code>RPC</code>协议、<code>RESTful</code>接口规范等的提出，单个模块中使用什么语言逐渐变得不再重要了。只对外暴露输入和输出接口，屏蔽了中间过程的一切实现，已经成为了现在开发的主流。每个模块是选择开发效率更高的语言，或者是选择执行效率更高的语言，就看每个公司的追求了。所以，也无所谓<code>Java</code>还是<code>Go</code>的抉择，只要适合该企业，并且该企业有足够的资金维护该系统，那么就是合适的。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM小工具简介</title>
    <url>/2020/02/06/Java/JVM/JVM%E5%B0%8F%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>这里会简单说明jdk自带的一些小工具，可以非常方便地查看当前地各种情况，比起什么都没有的黑框框还是要方便得多呐。</strong></p>
<p><strong>这里还是使用<code>jdk8</code>作为说明，<code>jdk9</code>及以上版本暂时还未在中国市场普及就暂时不作考虑了。最后我相信大家下载了jdk第一件事应该就是配置环境变量了吧？这里就默认大家的<code>Windows</code>、<code>Ubuntu</code>以及<code>MacOS</code>中都已经配好<code>jdk8</code>作为环境变量了。</strong><br><a id="more"></a></p>
<h2 id="JConsole"><a href="#JConsole" class="headerlink" title="JConsole"></a>JConsole</h2><p>首先是<strong>JConsole</strong>。</p>
<h3 id="呼出"><a href="#呼出" class="headerlink" title="呼出"></a>呼出</h3><p>那么<code>win+R</code>呼出运行窗口，输入<code>cmd</code>呼出命令行界面，在黑框框中输入<code>jconsole</code>（<em>大小写不敏感</em>），于是就弹出来了个窗口：</p>
<p><img src="https://sakebow.gitee.io/images/JVM-tools/jconsole.png" alt="JConsole界面"></p>
<p>同样的，如果你使用的是<code>Ubuntu</code>，那么就是<code>CTRL + ALT + T</code>呼出命令行，也是输入<code>jconsole</code>。</p>
<p>这里的<code>pid</code>是进程的<strong>唯一代号</strong>，也就是系统给进程<strong>随机分配的唯一指定标识</strong>。由于是随机的，所以<strong>不同的人不同时间打开的<code>pid</code>都会不一样</strong>。</p>
<p>然后双击链接，会弹出这个提示：</p>
<p><img src="https://sakebow.gitee.io/images/JVM-tools/安全连接失败.png" alt="安全连接失败"></p>
<h3 id="一点点拓展"><a href="#一点点拓展" class="headerlink" title="一点点拓展"></a>一点点拓展</h3><p>在这里不得不提一下<code>SSL</code>链接、<code>HTTP</code>、<code>HTTPS</code>的关系。</p>
<p>首先是<code>HTTP</code>，它<strong>只有三个步骤</strong>。</p>
<blockquote>
<ul>
<li>封装数据</li>
<li>使用TCP/IP传输</li>
<li>服务器接收</li>
</ul>
</blockquote>
<p>这三个步骤就可以正常访问一个超文本链接，也就是我们所说的网页。</p>
<p>然后是<code>HTTPS</code>，它比<code>HTTP</code>多一个<strong>S</strong>，也就是<strong>SSL安全认证</strong>，它包含了四个步骤：</p>
<blockquote>
<ul>
<li>封装数据</li>
<li><strong>使用<code>SSL</code>加密</strong></li>
<li>使用<code>TCP/IP</code>加密</li>
<li>服务器接收</li>
</ul>
</blockquote>
<p>其中由于<code>SSL</code>加密不可避免地加长了每一段数据帧的字长，所以也无可避免的<strong>增加了传输消耗</strong>，<strong>延长了响应时间</strong>。但是这些消耗带来了<strong>较为安全</strong>的传输方式，在可接受范围内。</p>
<h3 id="运行界面"><a href="#运行界面" class="headerlink" title="运行界面"></a>运行界面</h3><p>不安全连接后，则会出现四张图表：</p>
<p><img src="https://sakebow.gitee.io/images/JVM-tools/运行界面.png" alt="JConsole应用运行中"></p>
<p>在其中我们可以看几乎所有资源的使用，从这些就可以大概看出来程序的运行情况。但是信息非常笼统，所以也不太能定位，就只能看出程序好不好。</p>
<h2 id="jvisualvm"><a href="#jvisualvm" class="headerlink" title="jvisualvm"></a>jvisualvm</h2><h3 id="呼出-1"><a href="#呼出-1" class="headerlink" title="呼出"></a>呼出</h3><p>同样是在黑黑的命令行工具中输入<code>jvisualvm</code>，但是他会占用一个命令行窗口，关闭了窗口，应用也跟着关了。</p>
<p><img src="https://sakebow.gitee.io/images/JVM-tools/jvisualvm.png" alt="占用一个窗口的JVisualVM"></p>
<p>不过还好你可以加上参数让命令行不占用窗口：<br><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">jvisualvm --console suppress</span><br></pre></td></tr></table></figure><br><img src="https://sakebow.gitee.io/images/JVM-tools/suppress.png" alt="不占用窗口的JVisualVM"></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>如果你使用的是<code>eclipse</code>作为开发工具，无论是官方原版还是自己公司的魔改版，你可以使用<code>eclipse</code>公司自己开发的<strong>应用程序</strong>：<code>Memory Analyser Tools</code>，即<a href="http://www.eclipse.org/mat/downloads.php" target="_blank" rel="noopener">MAT</a>。他不是插件，而是一个外表非常像<code>eclipse</code>的数据可视化应用。</p>
<p><strong>由于博主使用的是IDEA所以就不贴图了。</strong></p>
<p>当然还有其它工具，比如<code>jmap</code>等等。这里就不一一列举了。总有一款工具是你用起来最顺手的。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>学习JVM之前的一些准备</title>
    <url>/2020/02/06/Java/JVM/JVM%E5%AD%A6%E4%B9%A0%E5%89%8D%E7%9A%84%E5%87%86%E5%A4%87/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>这里是学习JVM视频的一些笔记，版本是<a href="https://pan.baidu.com/s/1nYrw9fie-ZvHTReqD6hdLA" target="_blank" rel="noopener">jdk8u144</a>（提取码：s3xf）。我在这里使用的是<a href="https://bilibili.com/BV1PJ411n7xZ" target="_blank" rel="noopener">JVM教程</a></strong></p>
<p><strong>2020年6月转<code>ubuntu</code>系统了，用的<a href="https://pan.baidu.com/s/1ldwYHZh0fcIhmSG_POIUtQ" target="_blank" rel="noopener">jdk8u221</a>（提取码：r5vi）。</strong><br><a id="more"></a></p>
<h2 id="学习之前的唠嗑"><a href="#学习之前的唠嗑" class="headerlink" title="学习之前的唠嗑"></a>学习之前的唠嗑</h2><p>在学习之前，个人还是觉得方法非常重要。博主自己的高数老师曾说过：<strong>理解是肤浅的，记忆是深刻的。</strong></p>
<p>在学习的时候，往往查了“为什么”之后，看了，然后忘了。所以，个人觉得，学习的时候“为什么”往往不是那么重要，因为目前的你并没有建立起系统的知识架构，整个大脑就是一团浆糊，问不出什么实质性的东西。需要先将“是什么”落实到实处，再开始问“为什么”，这样你的思维才更加系统，也会在慢慢填补“是什么”的时候慢慢地理解到“为什么”。</p>
<h2 id="为什么学JVM"><a href="#为什么学JVM" class="headerlink" title="为什么学JVM"></a>为什么学JVM</h2><p>很多人在学习的过程中或者学习之前都会问这个问题。这里针对学习过程中的人提出一些看法，因为我也是，我多少还是有点资格回答这个问题。</p>
<p>如果你有经验，了解<code>SSM</code>、<code>SSH</code>乃至<code>Springoot</code>甚至<code>SpringCloud</code>的用法，你们可能非常希望能够快速投身行业中，用自己“<strong>高超</strong>”的技术马上在公司中获得一席之地。那还是太天真了。现在不管是大学计算机专业，还是培训班速成小班，还是关系户师徒学堂，都在<strong>大批量</strong>地产出<strong>熟悉框架</strong>、<strong>知晓基本规范</strong>的码农，都是随处可见的<strong>富士康工人</strong>，<strong>没有感情的<code>API</code>调用工程师</strong>。尤其是学的还不错但是从未接触过<code>JVM</code>的人，往往走入了能够胜任的误区。因为往往现实生活中并不像大学一样<strong>1000封顶的访问量</strong>、<strong>10左右的并发量</strong>，而是直接上千万上亿的并发控制、海量数据字段的查询和修改。这不是一个普通应届毕业生能够接触到的项目，更不是一个普通培训班出身的人能够担负的任务（<em>如果是在大厂有师傅带就另说</em>）。</p>
<p>所以，当我们真正面对如此凶猛的并发和访问的时候，往往需要了解最底层的执行原理，深刻地明白每一步真正的操作，明确哪些是我能够优化得更好的，哪些是系统定死了没有办法的。<strong>一点点避开没有办法的，一点点优化能够优化的</strong>，从而完成一定的优化。当然，这种优化肯定是有极限的，也就是<strong>硬件的极限</strong>。这些都是后话了。由于硬件更新换代在写这篇文章的一年达到了一个瓶颈，始终无法得到质的提升，所以软件优化也就变得尤为重要。</p>
<p>如果说的更真实一点，那就是因为所有的<code>Java</code>岗位都是会在面试的时候文问很多有关<code>JVM</code>的问题，不光是<code>BATJ</code>，还有其他中小企业。如果没有准备，被面试官灵魂拷问锤得心态爆炸还是很难受的。</p>
<h2 id="JVM难点"><a href="#JVM难点" class="headerlink" title="JVM难点"></a>JVM难点</h2><h3 id="JVM确实是非常枯燥非常无聊的"><a href="#JVM确实是非常枯燥非常无聊的" class="headerlink" title="JVM确实是非常枯燥非常无聊的"></a>JVM确实是非常枯燥非常无聊的</h3><p>其中大多都是一些名词之间相互推导，相互解释。更让人摸不着头脑的是，JVM并不像应用框架一样随便写一写就有一个很有反馈性的结果，而是一大堆原理性的内容，比如内存地址等等，眼睛看不见，手也摸不到，<strong>深渊一样黑暗的DOS框简直让人绝望</strong>。</p>
<h3 id="JVM学习难以有立竿见影的效果"><a href="#JVM学习难以有立竿见影的效果" class="headerlink" title="JVM学习难以有立竿见影的效果"></a>JVM学习难以有立竿见影的效果</h3><p>JVM的学习往往是潜移默化的，因为不会立即应用到实践中去。但在原理慢慢搭建起来的时候，编码习惯也会<strong>随之而改变</strong>。</p>
<p>举个很简单的例子：<strong>理解JVM垃圾回收机制之前，变量初始化看心情写</strong>。这个写null，那个new一个，再来个静态变量；但是<strong>理解了垃圾回收机制之后，立马就规范了变量初始化的编码习惯</strong>。当然，这也可能和<strong>设计模式</strong>与<strong>框架原理</strong>的学习有关，但是<code>JVM</code>依然是众中之重。正所谓<strong>基础不牢，地动山摇</strong>。</p>
<h3 id="英文原文文献更有效果，但是看起来非常吃力"><a href="#英文原文文献更有效果，但是看起来非常吃力" class="headerlink" title="英文原文文献更有效果，但是看起来非常吃力"></a>英文原文文献更有效果，但是看起来非常吃力</h3><p>国内并没有一款非常优秀的教材，虽然目前已经相对于以前非常丰富了，已经有很多人踩了坑，但还是推荐更为权威的英文文档。更恐怖的是，英文学习没有捷径，是一条充满了血与泪的道路。</p>
<p>当然，作为母语是中文的我，阅读正儿八经的外文学术文章还是非常吃力的。各种各样神奇的语法都是见都没见过的，明明单词都认识，但就是翻译不出来那种味道。可能还是语文功底不够吧……以后得多看看书了。</p>
<h3 id="源码的阅读简直是一场噩梦"><a href="#源码的阅读简直是一场噩梦" class="headerlink" title="源码的阅读简直是一场噩梦"></a>源码的阅读简直是一场噩梦</h3><p><code>HashMap</code>、<code>ConcurrentHashMap</code>、<code>Spring</code>、<code>MyBatis</code>等等常用框架的源码是非常重要的，不仅是了解其中的<code>API</code>的调用，更是其中原理的掌握。比如，<code>HashMap</code>的<strong>长度拓展原理</strong>和<code>Spring</code>框架的<strong>循环依赖</strong>处理，都是非常重要的。如何通过<code>HashMap</code>优化、如何通过<code>Spring</code>解决变量和依赖，都是在实际工作中非常细节但是非常重要的知识点，也是面试重点。</p>
<p>另外，在学习过程中当你遇到查都查不到的问题时，<strong>源码是最好的参考书</strong>。举个简单的例子，当你需要明白<code>Thread</code>和<code>Runnable</code>两者对线程的控制谁更贴合需求的时候，源码里面对应类的各种方法中的注释是最好的说明。<code>Thread</code>类中的<code>start</code>方法的注释明确说明了：<strong>当线程结束后，由<code>Thread</code>类及其子类创建的线程将不会允许被第二次调用</strong>。而<code>Runnable</code>类并没有这一项说明，并且线程之间可以使用<code>notify</code>或者<code>notifyAll</code>方法反复相互调用，达到无限循环的效果。</p>
<h2 id="不怎么重要的重点"><a href="#不怎么重要的重点" class="headerlink" title="不怎么重要的重点"></a>不怎么重要的重点</h2><p><code>JVM</code>不是只有<code>Oracle甲骨文公司</code>特有，有些公司也有自己的<code>JVM</code>。当然，每个<code>JVM</code>都有自己独特的特点，都是由世界级大佬根据需求设计的适应极端环境的虚拟机。由于企业并不是研究所，所以这些<code>JVM</code>设计出来后也将不会再重构，即是说原理将保持不变。现在中国市场使用最多的主要还是<code>Oracle</code>的<code>jdk</code>，其他的<code>open-jdk</code>之类用的比例实在太少，这里就不一一详细说明了。</p>
<p>希望大家学有所成！</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>大学生活总结</title>
    <url>/2020/02/02/diary/my-college-life/</url>
    <content><![CDATA[<script src="/crypto-js.js"></script><script src="/mcommon.js"></script><h3 id="encrypt-message">如果你坚持要看，请联系我。</h3><link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.min.css"> <link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap-theme.min.css"> <script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script> <script src="//cdn.bootcss.com/bootstrap/3.3.5/js/bootstrap.min.js"></script> <div id="security"> <div> <div class="input-group"> <input type="text" class="form-control" aria-label="Enter the password." id="pass"/> <div class="input-group-btn"> <button type="button" class="btn btn-default" onclick="decryptAES()">Decrypt</button> </div> </div> </div> </div> <div id="encrypt-blog" style="display:none"> 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 </div>]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>大学生活的各种吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo设置背景图片轮播效果</title>
    <url>/2020/01/29/hexo/hexo%E4%BF%AE%E6%94%B9%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>Next主题确实是好用，但是中间还是有太多太多的坑，差点没把自己摔死。这个博客记录了完成背景图片轮播的博客，喜欢折腾的同学可以看看，这方面对CSS3的要求略微有点高。</strong><br><a id="more"></a></p>
<p><a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a>的<a href="https://github.com/theme-next" target="_blank" rel="noopener">NexT</a>主题非常简约，个性化调整也非常方便。在这里就给大家介绍Hexo的背景图片轮播的制作方法。</p>
<h2 id="尴尬的开发条件"><a href="#尴尬的开发条件" class="headerlink" title="尴尬的开发条件"></a>尴尬的开发条件</h2><p>由于我还很菜，再加上电脑卡顿严重，有时候所有方法全部试了一遍都没有效果，重新创建一个工程就好了，也有时候重启就好了。这个背景图片轮播就是<strong>除了吃饭连续调了36个小时</strong>，<strong>最后重新新建一个项目就好了</strong>。这样的情况下调bug简直就是折磨。所以我基本上就用最小幅度的修改来保证需求的实现。</p>
<p>好了，来看看从入门到入土的全过程吧。我使用的是<code>WebStorm</code>作为<code>IDE</code>，其中内置的终端是可以操作的。如果没有<code>WebStorm</code>的话，可以使用<code>git</code>的<code>Windows</code>桌面版客户端自带的终端，即<code>Git Bash</code>，是个非常不错的终端，个人非常喜欢<code>Vim</code>风格。但是<code>Windows</code><strong>自带的终端是不可以操作</strong><code>Hexo</code>的，连<code>PowerShell</code><strong>的管理员模式也不可以</strong>，这一点还请注意。</p>
<h2 id="开发条件更新（2020年6月27日）"><a href="#开发条件更新（2020年6月27日）" class="headerlink" title="开发条件更新（2020年6月27日）"></a>开发条件更新（2020年6月27日）</h2><p>弱弱电脑泡水了，光荣牺牲。现在换了强强电脑，也就是现在的台式机，并且改用内存占用更少的<code>VScode</code>配合<code>Git Bash</code>分别完成<strong>编辑</strong>和<strong>部署</strong>。<code>VScode</code>中安装的插件就是<code>markdown-all-in-one</code>、<code>GitLens</code>和<code>Language-Stylus</code>，分别完成<code>markdown编辑</code>、<code>GitHub部署</code>和<code>Stylus样式表</code>三个部分。很可惜的是<code>VScode</code>自带的终端不能代替<code>Git Bash</code>，就有点不太方便。其他的都还可以。</p>
<h2 id="确定背景图片"><a href="#确定背景图片" class="headerlink" title="确定背景图片"></a>确定背景图片</h2><p>我们先找好一个背景图片，就你啦。<em><del>没错，博主是个不折不扣的死肥宅</del></em></p>
<p><img src="https://sakebow.gitee.io/images/background/poi.png" alt="夕立"></p>
<p>然后把他放在背景图片中。由于夕立的图片从左到右对比度差异比较大，我准备加上透明度。透明度确实有很多种方法，我选了个对模板改动最小的方法：<code>after伪类</code>。于是，<strong>噩梦开始了</strong>。</p>
<h2 id="写入样式表"><a href="#写入样式表" class="headerlink" title="写入样式表"></a>写入样式表</h2><p>在NexT模板里面，样式表大多是用styl文件存储的，简单地说，它是一种新语言，叫Stylus语言，基于nodejs，非常强大，补足了CSS3的许多缺点。</p>
<p>接着我们找到NexT模板中给我们预留的自定义样式文件中，也就是根目录下的：<code>/themes/next/source/css/_custom/custom.styl</code>，打开发现是个空的。</p>
<p>好了，写下我们的代码：（<em>由于里面包含keyframe，就直接用CSS3全部写完了，没用上stylus</em>）</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 在上层的body什么都不要写，因为body加上透明度opacity后文字也变得透明了</span></span><br><span class="line"><span class="comment"> * 于是所有的东西全部写在伪类，这里只保留最低限度的：层数（防遮盖）、位置（相对伪类的位置）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">position </span>: relative;</span><br><span class="line">  <span class="attribute">z-index </span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 在伪类中加上所有的属性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="selector-tag">body</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">content </span>: <span class="string">''</span>;                 <span class="comment">/* 伪类需要有内容，否则会变成0*0，无法显示效果 */</span></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;                  <span class="comment">/* 宽度拉满 */</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;                 <span class="comment">/* 高度拉满 */</span></span><br><span class="line">  <span class="attribute">background-size</span>: cover;       <span class="comment">/* 背景图片铺满整个容器 */</span></span><br><span class="line">  <span class="attribute">background-repeat</span>: no-repeat; <span class="comment">/* 不要重复 */</span></span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.5</span>;                 <span class="comment">/* 透明度为50% */</span></span><br><span class="line">  <span class="attribute">-moz-opacity</span>: <span class="number">0.5</span>;            <span class="comment">/* 火狐浏览器的透明度设置 */</span></span><br><span class="line">  <span class="attribute">-khtml-opacity</span>: <span class="number">0.5</span>;          <span class="comment">/* safari浏览器的透明度设置，它使用了KDE的KHTML作为内核 */</span></span><br><span class="line">  <span class="attribute">position</span>: fixed;              <span class="comment">/* 位置设为固定，否则往下滑背景图片就滑没了 */</span></span><br><span class="line">  <span class="attribute">z-index</span>: -<span class="number">1</span>;                  <span class="comment">/* 防遮罩 */</span></span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;                       <span class="comment">/* y坐标抵到浏览器顶部 */</span></span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;                      <span class="comment">/* x坐标抵到浏览器左侧 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>于是，就有了这样的效果：</p>
<p><img src="https://sakebow.gitee.io/images/hexo-change-background-image/screenshots/1.png" alt="演示效果图1"></p>
<p>看着好像还行？</p>
<h2 id="编写js脚本"><a href="#编写js脚本" class="headerlink" title="编写js脚本"></a>编写js脚本</h2><p>找到根目录下的<code>/themes/next/source/js/src</code>，在其中<strong>新建</strong>一个<code>js</code>文件。这里并没有给我们预留一个空文件，那就自己新建好了。我新建了<code>custom.js</code>文件。</p>
<p><strong>严重警告</strong>：下面这个例子是我第一次的尝试，是<strong>错误的</strong>！</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将所有的路径写下来</span></span><br><span class="line"><span class="keyword">let</span> imgUrl = [</span><br><span class="line">  <span class="string">'/images/background/poi.png'</span>, <span class="comment">// 舰娘夕立</span></span><br><span class="line">  <span class="string">'/images/background/touhou-red.jpg'</span> <span class="comment">// 东方红魔馆</span></span><br><span class="line">];</span><br><span class="line"><span class="comment">// 这里let类型是ECMA script6的特性</span></span><br><span class="line"><span class="comment">// 可以让我们把这个变量仅限于大括号内，可以组织非法访问带来的莫名其妙的问题</span></span><br><span class="line"><span class="keyword">let</span> imgIndex = <span class="number">0</span>; <span class="comment">// 设置imgIndex来选择imgUrl中的字符串</span></span><br><span class="line"><span class="comment">// 设置计时器，每8秒换一次图片</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里用setInterval函数</span></span><br><span class="line"><span class="comment"> * 传递2个参数</span></span><br><span class="line"><span class="comment"> *   一个是执行的事件，也就是函数对象</span></span><br><span class="line"><span class="comment"> *       可以写好了再把方法名传进来，也可以直接在这里定义</span></span><br><span class="line"><span class="comment"> *   还有一个是中间等待的时间，也就是多长时间执行一次</span></span><br><span class="line"><span class="comment"> * 返回一个定时器对象，方便在需要删除该定时器的时候直接引用</span></span><br><span class="line"><span class="comment"> * 如果不删除定时器，这个定时器就会一直进行下去</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> interval = setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1、获取需要变更的元素</span></span><br><span class="line">  <span class="comment">// 2、变更url</span></span><br><span class="line">  $(<span class="string">'body:after'</span>).css(<span class="string">"background-image"</span>, <span class="string">"url('"</span> + imgUrl[imgIndex] + <span class="string">"')"</span>);</span><br><span class="line">  <span class="comment">// 3、imgIndex自增，越界归零，也就是循环播放效果</span></span><br><span class="line">  (imgIndex === imgUrl.length) ? (imgIndex = <span class="number">0</span>) : (imgIndex++)</span><br><span class="line">  <span class="comment">// 这个是唯一的三元运算符，可以叫做冒号运算符</span></span><br><span class="line">  <span class="comment">// 如果满足问号前的条件，就执行第二个括号里面的语句，否则执行第三个括号里面的语句。</span></span><br><span class="line">  <span class="comment">// 由于运算符有规定的优先顺序，所以这里不加括号也是完全OK的，只是为了让大家看得清楚才加上的</span></span><br><span class="line">&#125;, <span class="number">8000</span>);</span><br></pre></td></tr></table></figure>
<p>最后，找到根目录下的<code>/themes/next/layout/_custom/header.swig</code>，这是个空文件。在里面引入jQuery和我们刚刚完成的js文件。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这里是用的bootcdn中的jQuery镜像，可以加载得稍微快一点点，这一点点差别人类感觉不到就是了。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 同样的，由于实在next模板内做的修改，src="/"访问的其实是根目录下的/themes/next，所以从/js/开始 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/js/src/custom.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>科普：</strong><code>swig</code>简单的说就是一种超级强大的工具，基本上很多语言都支持，甚至可以用于汇编开发中。</p>
</blockquote>
<p>好的！到这里就结束了！在WebStorm下方的Terminal（汉化了的同学这里叫做“终端”）输入hexo server，敲下回车就可以运行了。终端会弹出一大堆东西，其中有一句话是：”localhost:4000/“，点击就会自动呼出浏览器运行结果。</p>
<blockquote>
<p><strong>P.S.</strong> 会玩的同学可以在淘宝上购买一个超大号的回车键，每当这个时候就可以郑重地像按起爆器一样按下去，非常有仪式感。</p>
</blockquote>
<h3 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h3><p>然后，什么效果都没有。</p>
<p><strong>我慌了</strong>。</p>
<p>一开始我以为是url拼接的问题，调了很久很久，一直没成功。直到最后，我才明白：<strong>伪类after不可以被选中</strong>。</p>
<p><strong>全部木大啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊(╯‵□′)╯︵┻━┻</strong></p>
<p>上网一查，发现有一些方法，比如append一个新的style标签，这样子很难看清楚，也不容易编写。最后还是决定：<strong>把每一个图片定义成一个单独的CSS样式的类，然后每隔一段时间让body换个类</strong>。听着不难？试试吧。</p>
<h3 id="再次修改"><a href="#再次修改" class="headerlink" title="再次修改"></a>再次修改</h3><p><strong>还是严重警告</strong>：下面的<code>CSS</code>部分是第二次尝试，还是略微有一点点问题，<strong>下方注释会标记有问题的地方</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span>, <span class="selector-class">.pekora</span>, <span class="selector-class">.beaten</span>, <span class="selector-class">.collection</span>, <span class="selector-class">.touhou-red</span>, <span class="selector-class">.bang</span>, <span class="selector-class">.succubus</span>, <span class="selector-class">.poi</span> &#123;</span><br><span class="line">  <span class="attribute">position </span>: relative;</span><br><span class="line">  <span class="attribute">z-index </span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span><span class="selector-pseudo">:after</span>,</span><br><span class="line"><span class="selector-class">.pekora</span><span class="selector-pseudo">:after</span>, <span class="selector-class">.touhou-red</span><span class="selector-pseudo">:after</span>, <span class="selector-class">.beaten</span><span class="selector-pseudo">:after</span>, <span class="selector-class">.collection</span><span class="selector-pseudo">:after</span>, <span class="selector-class">.bang</span><span class="selector-pseudo">:after</span>, <span class="selector-class">.succubus</span><span class="selector-pseudo">:after</span>, <span class="selector-class">.poi</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">content </span>: <span class="string">''</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background-size</span>: cover;</span><br><span class="line">  <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">-moz-opacity</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">-khtml-opacity</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">position</span>: fixed;</span><br><span class="line">  <span class="attribute">z-index</span>: -<span class="number">1</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* 加上动画 */</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 我给animation传入的3个值分别是：</span></span><br><span class="line"><span class="comment">   *   - 动画名称 - bg-scale</span></span><br><span class="line"><span class="comment">   *   - 延迟时间 - 动画会持续8秒</span></span><br><span class="line"><span class="comment">   *   - 执行次数 - 无限执行：infinite</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="attribute">animation </span>: bg-scale <span class="number">8s</span> infinite;</span><br><span class="line">  <span class="attribute">-webkit-animation </span>: bg-scale <span class="number">8s</span> infinite;</span><br><span class="line">  <span class="attribute">-moz-animation </span>: bg-scale <span class="number">8s</span> infinite;</span><br><span class="line">  <span class="attribute">-o-animation </span>: bg-scale <span class="number">8s</span> infinite;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 大家完全可以复制粘贴，注意这下面的url要换成自己的图片路径。</span></span><br><span class="line"><span class="comment"> * 例如我将图片存在了根目录下的/themes/next/source/images/background/里面，所有的url就都这样配置了</span></span><br><span class="line"><span class="comment"> * 需要说明的是：这是在next模板中配置的，所以url("/")所访问的根目录是/themes/next/source/</span></span><br><span class="line"><span class="comment"> * 所以url就直接是省略了前面的，从/images/开始</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* hololive所属vtuber三期生：pekora，嚣张的兔子 */</span></span><br><span class="line"><span class="selector-class">.pekora</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">background-image </span>: <span class="built_in">url</span>(<span class="string">"/images/background/pekora.jpg"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 东方红魔馆 */</span></span><br><span class="line"><span class="comment">/* 把body:after也设置了就是为了初始化</span></span><br><span class="line"><span class="comment"> * 这样一开始就是这个图片作为背景，</span></span><br><span class="line"><span class="comment"> * 也算是不动用重要模板文件的最小程度修改</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="selector-tag">body</span><span class="selector-pseudo">:after</span>, <span class="selector-class">.touhou-red</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">background-image </span>: <span class="built_in">url</span>(<span class="string">"/images/background/touhou-red.jpg"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 将R16的百合图片中，攻的一方配上“现实”，受的一方配上“我”。看到这张图片的时候我的心情非常复杂 */</span></span><br><span class="line"><span class="selector-class">.beaten</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">background-image </span>: <span class="built_in">url</span>(<span class="string">"/images/background/beaten.jpg"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 澡堂中的舰娘们 */</span></span><br><span class="line"><span class="selector-class">.collection</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">background-image </span>: <span class="built_in">url</span>(<span class="string">"/images/background/collection.jpg"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 偶像大师（圣诞限定版） */</span></span><br><span class="line"><span class="selector-class">.bang</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">background-image </span>: <span class="built_in">url</span>(<span class="string">"/images/background/bang.jpg"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 四只比基尼魅魔，是《魅魔和社畜》的作者所作，没有下海（一直在反复横跳就是了），不过老师的狗粮真的很美味 */</span></span><br><span class="line"><span class="selector-class">.succubus</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">background-image </span>: <span class="built_in">url</span>(<span class="string">"/images/background/succubus.jpg"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 舰娘夕立 */</span></span><br><span class="line"><span class="selector-class">.poi</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">background-image </span>: <span class="built_in">url</span>(<span class="string">"/images/background/poi.png"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 最后再加上切换的动画 */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这是一个叫做bg-scale的动画</span></span><br><span class="line"><span class="comment"> * 其实原本是有scale这个缩放的动作的</span></span><br><span class="line"><span class="comment"> * 但是违和感太强烈了删掉了</span></span><br><span class="line"><span class="comment"> * 结果这个莫名其妙的名字没改</span></span><br><span class="line"><span class="comment"> * 因为影响不大就算了吧！诶嘿~⭐</span></span><br><span class="line"><span class="comment"> * 大家可以在这其中加入自定义的动作</span></span><br><span class="line"><span class="comment"> * 尤其注意scale（缩放）和translate（平移）混用的时候scale应当在前面</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  注意：这个动画设置略微有一点点误差。</span></span><br><span class="line"><span class="comment"> *       后面有修改版本，请不要复制这里的动画设置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@keyframes</span> bg-scale &#123;</span><br><span class="line">  <span class="comment">/* 最开始的状态 */</span></span><br><span class="line">  0% &#123;</span><br><span class="line">    <span class="attribute">opacity </span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">transform </span>: <span class="built_in">translateY</span>(-<span class="number">3%</span>) ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 经历1/5的时间到这一步</span></span><br><span class="line"><span class="comment">   * 完成的事件：</span></span><br><span class="line"><span class="comment">   *   - 透明度增加到50%</span></span><br><span class="line"><span class="comment">   *   - 从上方3%的地方移到了正中间（浏览器y轴朝下）</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  20% &#123;</span><br><span class="line">    <span class="attribute">opacity </span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateY</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 经历3/5的时间到这一步</span></span><br><span class="line"><span class="comment">     * 完成的事件：</span></span><br><span class="line"><span class="comment">     *   - 什么都没变</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  80% &#123;</span><br><span class="line">    <span class="attribute">opacity </span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateY</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 最后1/5的时间到这一步</span></span><br><span class="line"><span class="comment">   * 完成的事件：</span></span><br><span class="line"><span class="comment">   *   - 透明度变为0%（完全看不见）</span></span><br><span class="line"><span class="comment">   *   - 从正中间平移到下方3%的地方</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  100% &#123;</span><br><span class="line">    <span class="attribute">opacity </span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateY</span>(<span class="number">3%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 下面都是针对各种浏览器的特化，意义是一样的 */</span></span><br><span class="line"><span class="keyword">@-webkit-keyframes</span> bg-scale&#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    <span class="attribute">opacity </span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">-webkit-transform </span>: <span class="built_in">translateY</span>(-<span class="number">3%</span>) ;</span><br><span class="line">  &#125;</span><br><span class="line">  20% &#123;</span><br><span class="line">    <span class="attribute">opacity </span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">-webkit-transform</span>: <span class="built_in">translateY</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  80% &#123;</span><br><span class="line">    <span class="attribute">opacity </span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">-webkit-transform</span>: <span class="built_in">translateY</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    <span class="attribute">opacity </span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">-webkit-transform</span>: <span class="built_in">translateY</span>(<span class="number">3%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@-moz-keyframes</span> bg-scale&#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    <span class="attribute">-moz-opacity </span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">-moz-transform </span>: <span class="built_in">translateY</span>(-<span class="number">3%</span>) ;</span><br><span class="line">  &#125;</span><br><span class="line">  20% &#123;</span><br><span class="line">    <span class="attribute">-moz-opacity </span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">-moz-transform</span>: <span class="built_in">translateY</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  80% &#123;</span><br><span class="line">    <span class="attribute">-moz-opacity </span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">-moz-transform</span>: <span class="built_in">translateY</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    <span class="attribute">-moz-opacity </span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">-moz-transform</span>: <span class="built_in">translateY</span>(<span class="number">3%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@-o-keyframes</span> bg-scale&#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    <span class="attribute">opacity </span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">-o-transform </span>: <span class="built_in">translateY</span>(-<span class="number">3%</span>) ;</span><br><span class="line">  &#125;</span><br><span class="line">  20% &#123;</span><br><span class="line">    <span class="attribute">opacity </span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">-o-transform</span>: <span class="built_in">translateY</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  80% &#123;</span><br><span class="line">    <span class="attribute">opacity </span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">-o-transform</span>: <span class="built_in">translateY</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    <span class="attribute">opacity </span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">-o-transform</span>: <span class="built_in">translateY</span>(<span class="number">3%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>终于，<strong>背景动了</strong>。虽然只是不停的重复同一张图片，但是那种感动、懊悔和愤慨，久久地回荡在胸腔中。最终，爆发了出来：<strong>wdnmd</strong>！</p>
<h3 id="最后加上js脚本（custom-js）"><a href="#最后加上js脚本（custom-js）" class="headerlink" title="最后加上js脚本（custom.js）"></a>最后加上js脚本（custom.js）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是jQuery的写法，意思是一打开这页面就这么做</span></span><br><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 先准备好和类名一样的字符串数组</span></span><br><span class="line">  <span class="keyword">let</span> IMG_CLASS = [<span class="string">"touhou-red"</span>, <span class="string">"poi"</span>, <span class="string">"beaten"</span>, <span class="string">"collection"</span>, <span class="string">"pekora"</span>, <span class="string">"succubus"</span>, <span class="string">"bang"</span>];</span><br><span class="line">  <span class="comment">// 再准备一个索引</span></span><br><span class="line">  <span class="keyword">let</span> imgIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/** 还需要一个计时器</span></span><br><span class="line"><span class="comment">   * 这个计时器传入了两个参数</span></span><br><span class="line"><span class="comment">   *   - 第一个表示需要重复的动作</span></span><br><span class="line"><span class="comment">   *   - 第二个表示下一次动作的延迟时间</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">let</span> interval = setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 删除上一个类名（如果本身就没有这个类名也不会报错）</span></span><br><span class="line">    $(<span class="string">"body"</span>).removeClass(IMG_CLASS[imgIndex]);</span><br><span class="line">    <span class="comment">// 索引 + 1</span></span><br><span class="line">    imgIndex++;</span><br><span class="line">    <span class="comment">// 当越界的时候归零，变成循环展示图片</span></span><br><span class="line">    <span class="keyword">if</span> (imgIndex == IMG_CLASS.length) &#123;</span><br><span class="line">      imgIndex = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加上当前索引所指向的类名</span></span><br><span class="line">    $(<span class="string">"body"</span>).addClass(IMG_CLASS[imgIndex]);</span><br><span class="line">  &#125;, <span class="number">8000</span>); <span class="comment">// 每8000毫秒，也就是8秒执行一次</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="希望之花"><a href="#希望之花" class="headerlink" title="希望之花"></a>希望之花</h3><p>知道这个梗的人应该都明白，“不要停下来啊！”代表的是什么意思。没错，还远远没有结束。<strong>心态崩坏第二弹</strong>：<strong>js代码本身存在的bug</strong></p>
<p>JavaScript代码是运行在客户端的。所以它代表了一个问题：客户的电脑情况很大程度上决定了代码的成果。比如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入代码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"//cdn.bootcss.com/highlight.js/9.6.0/styles/github.min.css"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>乍一看没什么问题。<strong>可是这天你断网了</strong>。码农好好的坐在公司里调bug，一口大锅就这么扣在了他头上。</p>
<p>我所遇到的情况正是如此。js里写好了8000ms的延迟，CSS样式文件里也清清楚楚写了8s，但是就是有误差，这个误差不是别的原因，就是由每个人的电脑性能不同决定的。新的图片展示之前，旧的图片会很明显的闪一下。就这么一点点的误差展现了这么刺眼的效果。</p>
<p>求求你让我下班吧……orz</p>
<h3 id="暴力解决"><a href="#暴力解决" class="headerlink" title="暴力解决"></a>暴力解决</h3><p>我放弃了思考，如果会闪的话，那就是说，在js执行之前，keyframe动画就已经开始了执行下一个动画。那么，眼不见为净，就让这短暂的几帧动画看不到就好了！</p>
<p>于是，keyframe的最终版：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用这一段代码替换之前提到的的keyframe</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@keyframes</span> bg-scale &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    <span class="attribute">opacity </span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">transform </span>: <span class="built_in">translateY</span>(-<span class="number">3%</span>) ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 在这1/20的时间里什么都不做</span></span><br><span class="line"><span class="comment">   * 保持透明度为0（什么都看不见的白板）</span></span><br><span class="line"><span class="comment">   * 于是造成了小于1秒的空白背景</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  5% &#123;</span><br><span class="line">    <span class="attribute">opacity </span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">transform </span>: <span class="built_in">translateY</span>(-<span class="number">3%</span>) ;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 紧接着，这1/5的时间里完成了：</span></span><br><span class="line"><span class="comment">   *   - 透明度从0变为50</span></span><br><span class="line"><span class="comment">   *   - 从上方3%的位置移到正中间</span></span><br><span class="line"><span class="comment">   * 所以，之前小于1秒的空白背景就在忍受范围内了！</span></span><br><span class="line"><span class="comment">   * 我可真是个靓仔</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  25% &#123;</span><br><span class="line">    <span class="attribute">opacity </span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateY</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  80% &#123;</span><br><span class="line">    <span class="attribute">opacity </span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateY</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    <span class="attribute">opacity </span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateY</span>(<span class="number">3%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@-webkit-keyframes</span> bg-scale&#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    <span class="attribute">opacity </span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">-webkit-transform </span>: <span class="built_in">translateY</span>(-<span class="number">3%</span>) ;</span><br><span class="line">  &#125;</span><br><span class="line">  5% &#123;</span><br><span class="line">    <span class="attribute">opacity </span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">-webkit-transform </span>: <span class="built_in">translateY</span>(-<span class="number">3%</span>) ;</span><br><span class="line">  &#125;</span><br><span class="line">  25% &#123;</span><br><span class="line">    <span class="attribute">opacity </span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">-webkit-transform</span>: <span class="built_in">translateY</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  80% &#123;</span><br><span class="line">    <span class="attribute">opacity </span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">-webkit-transform</span>: <span class="built_in">translateY</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    <span class="attribute">opacity </span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">-webkit-transform</span>: <span class="built_in">translateY</span>(<span class="number">3%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@-moz-keyframes</span> bg-scale&#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    <span class="attribute">-moz-opacity </span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">-moz-transform </span>: <span class="built_in">translateY</span>(-<span class="number">3%</span>) ;</span><br><span class="line">  &#125;</span><br><span class="line">  5% &#123;</span><br><span class="line">    <span class="attribute">-moz-opacity </span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">-moz-transform </span>: <span class="built_in">translateY</span>(-<span class="number">3%</span>) ;</span><br><span class="line">  &#125;</span><br><span class="line">  25% &#123;</span><br><span class="line">    <span class="attribute">-moz-opacity </span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">-moz-transform</span>: <span class="built_in">translateY</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  80% &#123;</span><br><span class="line">    <span class="attribute">-moz-opacity </span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">-moz-transform</span>: <span class="built_in">translateY</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    <span class="attribute">-moz-opacity </span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">-moz-transform</span>: <span class="built_in">translateY</span>(<span class="number">3%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@-o-keyframes</span> bg-scale&#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    <span class="attribute">opacity </span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">-o-transform </span>: <span class="built_in">translateY</span>(-<span class="number">3%</span>) ;</span><br><span class="line">  &#125;</span><br><span class="line">  5% &#123;</span><br><span class="line">    <span class="attribute">opacity </span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">-o-transform </span>: <span class="built_in">translateY</span>(-<span class="number">3%</span>) ;</span><br><span class="line">  &#125;</span><br><span class="line">  25% &#123;</span><br><span class="line">    <span class="attribute">opacity </span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">-o-transform</span>: <span class="built_in">translateY</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  80% &#123;</span><br><span class="line">    <span class="attribute">opacity </span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">-o-transform</span>: <span class="built_in">translateY</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    <span class="attribute">opacity </span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">-o-transform</span>: <span class="built_in">translateY</span>(<span class="number">3%</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>nice！<strong>下班啦</strong>！</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当然这个方法是有点问题的，比如<strong>网速慢的时候只能第一张图片无限循环</strong>；<strong>后期添加图片的时候非常的麻烦</strong>等等非常无奈的问题。但是总体效果还是非常不错的呐！</p>
<p>虽然路途坎坷，但是确实可以看出，<code>Hexo</code>的美化要是认真从前端入手一点点深入，一点点修改，就能够做出你认为最好的。正因为方法多样，所以才有如此广阔的创意模板和二次魔改，这就是<code>Hexo</code>的魅力不是吗？</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>NexT主题踩坑</tag>
      </tags>
  </entry>
</search>
