<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sakebow的小博客</title>
  
  <subtitle>一条苦苦挣扎的废柴大学狗</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sakebow.gitee.io/"/>
  <updated>2020-12-04T07:32:07.279Z</updated>
  <id>https://sakebow.gitee.io/</id>
  
  <author>
    <name>Sakebow</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>VScode侧边栏字体调整</title>
    <link href="https://sakebow.gitee.io/2020/12/04/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/VScode%E4%BE%A7%E8%BE%B9%E6%A0%8F%E5%AD%97%E4%BD%93%E8%B0%83%E6%95%B4/"/>
    <id>https://sakebow.gitee.io/2020/12/04/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/VScode%E4%BE%A7%E8%BE%B9%E6%A0%8F%E5%AD%97%E4%BD%93%E8%B0%83%E6%95%B4/</id>
    <published>2020-12-04T07:30:00.000Z</published>
    <updated>2020-12-04T07:32:07.279Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>现在全网都只有关于<code>Windows</code>系统中修改<code>VScode</code>侧边栏字体大小的方法，在这里介绍<code>Ubuntu</code>系统的修改方法。<code>VScode</code>虽然好用，但是</strong>默认字体实在是太小了<strong>，侧边栏默认$13$号字体，编辑器默认$14$号字体，对于我来说完全<code>hold</code>不住。所以，我去改一改。</strong></p><h2 id="寻找侧边栏配置文件"><a href="#寻找侧边栏配置文件" class="headerlink" title="寻找侧边栏配置文件"></a>寻找侧边栏配置文件</h2><h3 id="和Windows不太一样的安装目录和存储文件"><a href="#和Windows不太一样的安装目录和存储文件" class="headerlink" title="和Windows不太一样的安装目录和存储文件"></a>和<code>Windows</code>不太一样的安装目录和存储文件</h3><p>首先就是<strong>用户自己可以设置的</strong>配置文件，也就是<code>settings.json</code>。但是，发现<code>sideBar</code>只有左边还是右边的设置。</p><p><img src="https://sakebow.gitee.io/images/经验分享/sidebar-setting.png" alt="只有左右设置"></p><p><strong>这显然不是我们想要的结果</strong>。</p><h3 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h3><p>于是，在<a href="http://www.zxmseed.com/blog/208537" target="_blank" rel="noopener"><code>Zxmseed</code>写的Visual Studio Code 左侧资源管理器字体设置</a>中找到了配置所在，也就是<code>${installation-location}\Microsoft VS Code\resources\app\out\vs\workbench\</code>里面的<code>workbench.main.css</code>文件中。<strong>但是很不幸</strong>，在<code>Ubuntu</code>系统和<code>Windows</code>系统还是很有些<strong>不一样</strong>的。</p><h3 id="使用Linux特有的手段查找文件"><a href="#使用Linux特有的手段查找文件" class="headerlink" title="使用Linux特有的手段查找文件"></a>使用<code>Linux</code>特有的手段查找文件</h3><p>所以，我们使用<code>Linux</code>的<code>find</code>命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> find <span class="variable">$&#123;folder name&#125;</span> -name <span class="variable">$&#123;part of target folder or file name&#125;</span></span></span><br><span class="line">find /usr -name 'code'</span><br></pre></td></tr></table></figure><p>这行命令的意思是：<strong>在<code>/usr</code>文件夹下寻找包含<code>code</code>这个单词的子文件夹或者文件</strong>。</p><p>当然，你也可以使用第三方包，比如<code>mlocate</code>，需要使用安装命令进行安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install mlocate</span><br></pre></td></tr></table></figure><p>然后使用<code>mlocate</code>包中的<code>locate</code>命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locate code</span><br></pre></td></tr></table></figure><p>这种方法<strong>不需要指定查找位置</strong>，直接输入名称就给你匹配出来。</p><h3 id="找到了！"><a href="#找到了！" class="headerlink" title="找到了！"></a>找到了！</h3><p>不管用什么方法，最终也很幸运，我们找到了：</p><p><img src="https://sakebow.gitee.io/images/经验分享/folder-finding.png" alt="寻找VScode"></p><p>于是我们一个个试，发现<code>/usr/share/code</code>就是我们要找的文件夹，也就是<code>Microsoft VScode</code>的安装目录。</p><p>接着对照<code>Zxmseed</code>的博客中所指的位置，<strong>锁定了<code>/usr/share/code/resources/app/out/vs/workbench</code></strong>，里面有个文件是<code>workbench.desktop.main.css</code>。</p><p><img src="https://sakebow.gitee.io/images/经验分享/lock-folder.png" alt="锁定文件夹"></p><p>是不是和<code>Windows</code><strong>有些不同</strong>？也可能是版本更新之后才有所不同的吧。</p><h2 id="修改侧边栏配置文件"><a href="#修改侧边栏配置文件" class="headerlink" title="修改侧边栏配置文件"></a>修改侧边栏配置文件</h2><h3 id="没什么做不到的Vim编辑器"><a href="#没什么做不到的Vim编辑器" class="headerlink" title="没什么做不到的Vim编辑器"></a>没什么做不到的<code>Vim</code>编辑器</h3><p>一般<code>Linux</code>系统（<em>不包含<code>Deepin</code>等国产魔改系统</em>）都会内置<code>vi</code>命令来修改文件，<strong>但是非常难用</strong>。所以这里我们改用<code>Vim</code>，需要使用命令安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install vim</span><br></pre></td></tr></table></figure><p>安装完就<strong>已经没什么好怕的了</strong>。</p><p>找到目标之后，我们<strong>使用<code>Vim</code>打开</strong>这个文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /usr/share/code/resources/app/out/vs/workbench/workbench.desktop.main.css</span><br></pre></td></tr></table></figure><p>你会发现很大一批文字。<strong>千万不要妄图使用<code>gedit</code>命令打开超级大的文本文件</strong>，<strong>会卡得不行</strong>。</p><p>进入之后，我们使用<code>Vim</code>的<strong>字符串匹配功能</strong>一个个找下去，也就是在界面直接输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> /是匹配命令，后面是匹配字符串</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 直接输入不必回车，就只设置这么多字符串就能找到了</span></span><br><span class="line">/.content&#123;font</span><br></pre></td></tr></table></figure><p><img src="https://sakebow.gitee.io/images/经验分享/font-setting.png" alt="找到位置"></p><p>立马就锁定了这个位置。按下回车，光标就会停在<code>.content</code>这儿。默认字体大小是$13$号，我们稍微增大一些，改为$15$号，就按下<code>i</code>键，进入编辑模式，左下角会出现“<strong>—插入—</strong>”的字样，就能修改了。修改完按下<code>Esc</code>键退出编辑模式，再输入<code>:x</code>保存修改并退出。</p><h2 id="重启VScode应用，成功修改侧边栏字体"><a href="#重启VScode应用，成功修改侧边栏字体" class="headerlink" title="重启VScode应用，成功修改侧边栏字体"></a>重启<code>VScode</code>应用，成功修改侧边栏字体</h2><p>最后，就修改成功了。将<code>VScode</code>全部关掉，然后重新打开，我们就能看到左边的字体稍微有些大了。</p><h2 id="编辑器字体修改"><a href="#编辑器字体修改" class="headerlink" title="编辑器字体修改"></a>编辑器字体修改</h2><p>相对的，编辑器的修改就方便很多。直接在上方的<code>File</code>菜单栏里找到<code>Preferences</code>的<code>settings</code>。当然，你也可以使用快捷键：<code>Ctrl</code>+<code>，</code>，在里面搜索<code>font</code>，就能够修改编辑器的字体大小。</p><p><img src="https://img-blog.csdnimg.cn/20201204143634557.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29yZGluYXJ5X2Jyb255,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>是不是有点能理解了呢？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;现在全网都只有关于&lt;code&gt;Windows&lt;/code&gt;系统中修改&lt;code&gt;VScode&lt;/code&gt;侧边栏字体大小的方
      
    
    </summary>
    
    
      <category term="经验分享" scheme="https://sakebow.gitee.io/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="VScode魔改" scheme="https://sakebow.gitee.io/tags/VScode%E9%AD%94%E6%94%B9/"/>
    
  </entry>
  
  <entry>
    <title>参天树：决策树的操作</title>
    <link href="https://sakebow.gitee.io/2020/12/03/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E5%86%B3%E7%AD%96%E6%A0%91%E7%AE%97%E6%B3%95/%E5%8F%82%E5%A4%A9%E6%A0%91%EF%BC%9A%E5%86%B3%E7%AD%96%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
    <id>https://sakebow.gitee.io/2020/12/03/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E5%86%B3%E7%AD%96%E6%A0%91%E7%AE%97%E6%B3%95/%E5%8F%82%E5%A4%A9%E6%A0%91%EF%BC%9A%E5%86%B3%E7%AD%96%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C/</id>
    <published>2020-12-03T02:53:00.000Z</published>
    <updated>2020-12-04T02:49:15.859Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>既然已经了解了决策树的定义和原理，那么现在就更进一步，对树进行描述和修剪，就像是园艺师一样。</strong></p><a id="more"></a><h2 id="知识点复习：哈夫曼树"><a href="#知识点复习：哈夫曼树" class="headerlink" title="知识点复习：哈夫曼树"></a>知识点复习：哈夫曼树</h2><p>如果说大学稍微努了一点力，那么应该会了解一点哈夫曼树。</p><p>在哈夫曼树创建的时候，我们会优先计算所有元素的频率，然后将频率最高的几个元素放在最前面。为什么要这样做？因为</p><h2 id="决策树创建的基本步骤"><a href="#决策树创建的基本步骤" class="headerlink" title="决策树创建的基本步骤"></a>决策树创建的基本步骤</h2><p>既然我们明白了决策树是在树的基础上进行划分。至于改进在哪？那自然是作为<strong>权重</strong>出现在决策树中间的<strong>信息增益</strong>。</p><p>还是搬出<a href="https://blog.csdn.net/ordinary_brony/article/details/110498273" target="_blank" rel="noopener">上一篇文章</a>中出现的一张大图：</p><p><img src="https://sakebow.gitee.io/images/决策树/决策流程图.png" alt="决策流程图"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;既然已经了解了决策树的定义和原理，那么现在就更进一步，对树进行描述和修剪，就像是园艺师一样。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="人工智能" scheme="https://sakebow.gitee.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
      <category term="算法模型" scheme="https://sakebow.gitee.io/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>大树荫：决策树的算法原理</title>
    <link href="https://sakebow.gitee.io/2020/12/01/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E5%86%B3%E7%AD%96%E6%A0%91%E7%AE%97%E6%B3%95/%E5%A4%A7%E6%A0%91%E8%8D%AB%EF%BC%9A%E5%86%B3%E7%AD%96%E6%A0%91%E7%9A%84%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/"/>
    <id>https://sakebow.gitee.io/2020/12/01/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E5%86%B3%E7%AD%96%E6%A0%91%E7%AE%97%E6%B3%95/%E5%A4%A7%E6%A0%91%E8%8D%AB%EF%BC%9A%E5%86%B3%E7%AD%96%E6%A0%91%E7%9A%84%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/</id>
    <published>2020-12-01T07:06:00.000Z</published>
    <updated>2020-12-02T14:06:08.715Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>我们理解了决策树的定义与目的之后，我们便可以开始了解决策树背后的意义了。</strong></p><a id="more"></a><h2 id="信息熵和信息量化"><a href="#信息熵和信息量化" class="headerlink" title="信息熵和信息量化"></a>信息熵和信息量化</h2><p><strong>“等下，信息量有点大……”</strong></p><p>当我们面对有点难以接受和一时间反应不过来的信息时，我们经常说这句话。</p><p>你家的猫娘听到了特朗普败选的消息，一定是一脸不明所以地盯着眼前这个又跳又叫的奇怪生物；而如果是你和你的室友，那么就会相视一笑。为什么会有这样的差别？因为你的室友和你的猫娘<strong>所接收的信息量是不相同的</strong>。</p><p>信息量<strong>越是不足</strong>，那么这件事情就<strong>越不确定</strong>，要<strong>把这件事情搞清楚所需要的信息就越多</strong>；反之，信息量<strong>越足</strong>，各种局势也<strong>愈发明朗</strong>，要<strong>把这件事情搞清楚所需要的信息就越少</strong>。</p><p>那么，信息量怎么衡量？单纯的通过人的接受能力和反应时间实在是太主观了，也太武断了。更何况，如果不是使用数学方法衡量的话，现在也很难直接使用机器学习的方法帮助我们<strong>充分挖掘信息中的潜在价值</strong>。</p><blockquote><p>1948年，像农在他著名的《通信的数学原理》中提出了<strong>信息熵</strong>的概念，从而解决了信息量化的问题。</p><p>——摘自《scikit-learn机器学习常用算法原理与编程实战》 [著]黄永昌</p></blockquote><p>如果你的脑海里还残存了一点点高中化学的知识，你应该知道，<strong>熵是一种不稳定状态的度量方式</strong>。<strong>熵越大</strong>，<strong>空间内越混乱</strong>。那么信息熵也应当类似。如果说对这件事<strong>完全弄明白了</strong>，那么就是一种<strong>稳定状态</strong>；而<strong>半懂不懂</strong>则是一种<strong>不稳定的状态</strong>。信息熵描述的就是对这个信息来说从不稳定（<em>也就是没有完全理解</em>）到稳定（<em>也就是彻底理解</em>）之间的差距。</p><p>信息熵的量化公式就是：</p><script type="math/tex; mode=display">H(X) = -\sum_{x\in X}P(x)log_2P(x)</script><p>其中，$X$指所研究的事件集合，$x$指事件集合中所出现的其中一个事件，$P(x)$则是事件$x$所出现的概率。</p><p>如果在我面前有一个宝箱，出货率如下表所示：</p><div class="table-container"><table><thead><tr><th>物品</th><th>概率</th></tr></thead><tbody><tr><td>一次性湿纸巾一包</td><td>$25\%$</td></tr><tr><td>一次性纸手帕一包</td><td>$25\%$</td></tr><tr><td>一次性塑料碗一个</td><td>$25\%$</td></tr><tr><td>一次性木筷子一双</td><td>$25\%$</td></tr></tbody></table></div><p>既然每一种一次性用品抽中的概率都是$25\%$，那么任意抽一次，也就只有这些结果：</p><ul><li>一次性湿纸巾一包</li><li>一次性纸手帕一包</li><li>一次性塑料碗一个</li><li>一次性木筷子一双</li></ul><p>所以，信息熵也就是：</p><script type="math/tex; mode=display">H(抽奖结果)=-(\frac{1}{4}\log_2\frac{1}{4})*4=2(bit)</script><p>没错，结果的单位实际上是<strong>比特</strong>。要确认我这次抽到的是4种一次性用具的哪一种，只需要<strong>两个比特</strong>就能解决，也就是一个字节的$\frac{1}{4}$就可以了，大概就是<code>00000000</code>到<code>00000011</code>，或者是<code>0x00</code>到<code>0x03</code>。</p><p>很神奇不是么？</p><h2 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h2><p>什么是信息增益？<strong>就是信息量的差值</strong>。<strong>信息增益只是一个值</strong>，<strong>没有正负的矢量意义</strong>。还记得之前提到的权重么？<strong>这个权重就是信息增益</strong>。如果增益非常大，那么权重就会非常大。在决策树彻底长成古老的巨树之后，信息增益就会帮我们从根出发，一直上升到对应的叶子。</p><p>好的，到了这一步，我们换个场景：</p><p>现在你刚拿到你的小蛋糕店，也装修完了，现在剩下一地的箱子，共$100$只。$8$个装了垃圾，$16$个是日用品，$16$个是对蛋糕店来说有用的，$4$个是极其重要的，还有$8$个被你的猫娘们占用了，剩下$48$个是空箱子。现在不再是抽奖了，而是你要逐一分类。当然，这个时候你完全可以看看里面是什么。</p><p>渐渐地，在分类的过程中，你也找到了诀窍：</p><ul><li>空箱子非常轻，踢一脚就会滚两圈；</li><li>装了垃圾的箱子会看起来脏一点，蒙着一层灰；</li><li>装了日用品的箱子中，有的会伸出来衣架，有的会散发出沐浴露的香味等等；</li><li>装了蛋糕店相关的箱子和极其重要的箱子会有很明显的警告标志；</li><li>被猫娘们霸占的箱子则会伸出来一只猫尾巴或者猫爪爪</li></ul><p>看起来很有规律了嘛。那么就开始分类吧：</p><p>首先，我们先分析一下，对于这$100$个箱子里面，随便选一个打开看的话，就会有这些事件：</p><script type="math/tex; mode=display">X=\{空箱子(x_1),垃圾箱(x_2),日用品箱(x_3),蛋糕箱(x_4),重要箱子(x_5),猫娘箱(x_6)\}</script><p>概率分布就是这样：</p><div class="table-container"><table><thead><tr><th>$X$</th><th>$x_1$</th><th>$x_2$</th><th>$x_3$</th><th>$x_4$</th><th>$x_5$</th><th>$x_6$</th></tr></thead><tbody><tr><td>$P(x)$</td><td>$0.48$</td><td>$0.08$</td><td>$0.16$</td><td>$0.16$</td><td>$0.04$</td><td>$0.08$</td></tr></tbody></table></div><p>好的，接下来就是信息熵了。</p><h3 id="根"><a href="#根" class="headerlink" title="根"></a>根</h3><p>一开始就是一片混沌的6种箱子混在一起，$H(X)=-\sum_{x\in X}P(x)*\log_xP(x)=2.1231$。</p><h3 id="猫枝叶、部分日用品枝叶"><a href="#猫枝叶、部分日用品枝叶" class="headerlink" title="猫枝叶、部分日用品枝叶"></a>猫枝叶、部分日用品枝叶</h3><p>为了先照顾你心目中最重要的几只小猫娘，你决定<strong>先看看有没有猫</strong>。于是，你看看箱子里伸出来了啥，然后发现了4个伸出来猫爪爪的箱子和4个伸出来猫尾巴的箱子，还发现了8个伸出来衣架的日用品箱子。于是，$H(x_6)=-P(x_6)<em>\log_2P(x_6)=3.64</em>0.08=0.2912$，这就是找到猫娘所需要的信息增益。对于突然发现的日用品箱$(x_7)$我们也计算一下，$H(x_7)=-P(x_7)*\log_2P(x_7)=0.2915$</p><h3 id="分枝"><a href="#分枝" class="headerlink" title="分枝"></a>分枝</h3><p>那么，然后<strong>剩下来空箱子</strong>、<strong>垃圾箱</strong>、<strong>蛋糕箱和剩下的日用品箱</strong>，记为$Y$，$H(Y)=-\sum_{x\in Y}P(x)*\log_2P(x)=1.5143$</p><p>然后看看<strong>有没有警告标记</strong>。找到警告标记之后，会找到蛋糕箱和对自己非常重要的箱子，记为$Z$，$H(Z)=-\sum_{x\in Z}P(x)*\log_2P(x)=0.6088$。</p><p>而剩下一些空箱子、垃圾箱和剩下的日用品箱，记为$A$，$H(x)=-\sum_{x\in A}P(x)*\log_2P(x)=1.0913$</p><h3 id="重要箱子枝叶"><a href="#重要箱子枝叶" class="headerlink" title="重要箱子枝叶"></a>重要箱子枝叶</h3><p>找出了蛋糕箱和重要箱子之后，我们再<strong>打开看看</strong>箱子里是个啥。打开之后如果发现了相册和笔记本，那就是重要箱子，$H(x_5)=-P(x_5)*\log_2P(x_5)=0.1858$。</p><h3 id="蛋糕箱枝叶"><a href="#蛋糕箱枝叶" class="headerlink" title="蛋糕箱枝叶"></a>蛋糕箱枝叶</h3><p>同时，我们也找到了蛋糕箱，$H(x_4)=-P(x_4)*\log_2P(x_4)=0.423$。</p><h3 id="空箱子枝叶"><a href="#空箱子枝叶" class="headerlink" title="空箱子枝叶"></a>空箱子枝叶</h3><p>我们刚刚通过有没有警示标志找出了空箱子、垃圾箱和剩下的日用品箱，我们接下来就<strong>随便踢一脚试试</strong>，如果瞬间就飞出去翻滚两圈，那就是空箱子。于是，$H(x_1)=-P(x_1)*\log_2P(x_1)=0.5803$</p><h3 id="分枝-1"><a href="#分枝-1" class="headerlink" title="分枝"></a>分枝</h3><p>那么，踢不动的就是垃圾箱和日用品箱了，记为$B$，$H(B)=-\sum_{x\in B}P(x)*\log_2P(x)=0.583$</p><h3 id="垃圾箱枝叶、剩余日用品箱枝叶"><a href="#垃圾箱枝叶、剩余日用品箱枝叶" class="headerlink" title="垃圾箱枝叶、剩余日用品箱枝叶"></a>垃圾箱枝叶、剩余日用品箱枝叶</h3><p>最后，我们在最后剩下的<strong>箱子里间闻一闻</strong>，就能够通过有没有沐浴露的清香来分辨最后的两种箱子。没有香味那就应该是充满了灰尘味道的垃圾箱了。于是，$H(x_2)=-P(x_2)<em>\log_xP(x_2)=2.915$。最后就是剩下的$8$个日用品箱了，也就是$H(x_3)=-P(x_3)</em>\log_2P(x_3)=2.915$。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这下整颗树就明了了呢。画张图总结一下吧：</p><p><img src="https://sakebow.gitee.io/images/决策树/决策流程图.png" alt="决策流程图"></p><p>看起来非常不错啊！</p><h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><p><strong>在这里插句嘴</strong>，我们一直在计算熵值，也就是这个函数$H(x)=-P(x)*\log_2P(x)$。如果我们吧这个函数画出来：</p><p><img src="https://sakebow.gitee.io/images/决策树/函数图像.png" alt="决策流程图"></p><p>这也正好说明了：<strong>若是对于这件事发生的概率越大</strong>、<strong>对这件事越确定</strong>，<strong>熵值越低</strong>，<strong>也就越稳定</strong>、<strong>越可靠</strong>。</p><p>当然，<strong>还有一个小小的问题</strong>。在化学里面，只要一个独立的系统放在这里，熵值只会变大，只是时间快慢的问题了。也就是说，要是就把这一堆箱子放在这里，箱子只会越来越乱。当然，对于用电脑比较多的办公人士、码农等等，一段时间只往电脑里塞文件而不分类，电脑里面的文件也只会越来越乱。<strong>为什么要分类</strong>？一方面让自己更好地找到自己想要的东西，另一方面，学术一点的表达就是：<strong>让熵值减少</strong>，<strong>从而该事件更稳定</strong>。如果是表述得更哲学一点，那就是像书中说的一样：</p><blockquote><p>如果没有外力的作用，这个世界将会是越来越无序的。人活着，再与尽量让熵变低，即让世界变得更有序，降低不确定性。</p><p>希望笔者在暮年之时，回首往事，能自信地说，我给这个世界带来的信息增益是正数，且已经尽力做到最大了。</p><p>——摘自《scikit-learn机器学习常用算法原理及编程实战》 [著]黄永昌</p></blockquote><p>是不是有点能理解了呢？</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;我们理解了决策树的定义与目的之后，我们便可以开始了解决策树背后的意义了。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="人工智能" scheme="https://sakebow.gitee.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
      <category term="算法模型" scheme="https://sakebow.gitee.io/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>开工：数据集的特征理解</title>
    <link href="https://sakebow.gitee.io/2020/11/22/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87%EF%BC%9ADataFrame%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://sakebow.gitee.io/2020/11/22/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87%EF%BC%9ADataFrame%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2020-11-22T14:51:00.000Z</published>
    <updated>2020-11-22T15:32:28.038Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>由于特征分析中包含了很多有关<code>Python</code>中数据分析的方法，这里单独创建一篇文章进行说明。本篇文章会持续更新，收集各种各样非常多不同的、方便的库。</strong></p><a id="more"></a><h2 id="最常用库"><a href="#最常用库" class="headerlink" title="最常用库"></a>最常用库</h2><h3 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a><code>DataFrame</code></h3><p>如果是图表形式，<code>DataFrame</code>将会是最理想的库。包含了多维度合并分析、多维度降维分析、图像等非常方便的库。</p><h3 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a><code>Numpy</code></h3><p>而如果有什么<code>DataFrame</code>做不到的一些事情，就和<code>numpy</code>一起使用，通过矩阵来计算高维度的分析和计算。</p><h3 id="Pandas"><a href="#Pandas" class="headerlink" title="Pandas"></a><code>Pandas</code></h3><p>接着就是读取文件的<code>pandas</code>库。确实，现在有着非常多的代码库，也有非常多的形式读取不同形式的文件。但是<code>pandas</code>库能够将任何形式的文件转变为<code>DataFrame</code>格式，对接起来非常方便。</p><h3 id="matplotlib"><a href="#matplotlib" class="headerlink" title="matplotlib"></a><code>matplotlib</code></h3><p>如果你觉得数据还是太抽象，你可以使用<code>matplotlib</code>库进行图像的绘制，这样能够让数据更为直观，能够协助看清什么数据有着什么样的趋势，哪些数据占比更多而哪些数据占比更少等等。这些直观的表达更能够为我们下一步的决策和分析提供更细致的参考。</p><h2 id="获得数据"><a href="#获得数据" class="headerlink" title="获得数据"></a>获得数据</h2><p>对于数学分析，其实<strong>更推荐文件的形式</strong>，而<strong>不是数据库</strong>。因为数据库的<strong>读取速度非常有限</strong>，在分析大量的数据时需要花费一些时间等待网络请求和数据传输的时间。虽然<code>MongoDB</code>数据库相比<code>Oracle</code>、<code>MySQL</code>、<code>SQL Server</code>等数据库有着非关系型的特点，以<code>JSON</code>的形式保存所有的数据，却还是不能够<strong>在很短的时间内获得大量对象中的同一个属性的属性值进行分析</strong>。所以这里推荐的形式有<code>csv</code>、<code>xls</code>、<code>json</code>和<code>xml</code>等的<strong>本地文件</strong>。</p><ul><li>如果是<code>csv</code>文件，<code>pandas</code>库提供了<code>read_csv(&lt;str&gt; csv_path)</code>方法；</li><li>如果是<code>excel</code>文件，<code>pandas</code>库提供了<code>read_excel(&lt;str&gt; excel_path)</code>方法；</li><li>如果是<code>json</code>文件，<code>pandas</code>库提供了<code>read_json(&lt;str&gt; json_path)</code>方法；</li><li>如果是剪贴板，<code>pandas</code>库提供了<code>read_clipboard()</code>方法；</li><li>……</li></ul><p>基本上涵盖了目前所有的主流格式。</p><h2 id="图表绘制"><a href="#图表绘制" class="headerlink" title="图表绘制"></a>图表绘制</h2><p><code>matplotlib</code>库提供了非常丰富的绘图库，横纵坐标都能够使用<code>numpy</code>的数组。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;由于特征分析中包含了很多有关&lt;code&gt;Python&lt;/code&gt;中数据分析的方法，这里单独创建一篇文章进行说明。本篇文章会持续更新，收集各种各样非常多不同的、方便的库。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="人工智能" scheme="https://sakebow.gitee.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
      <category term="Python" scheme="https://sakebow.gitee.io/tags/Python/"/>
    
      <category term="特征工程" scheme="https://sakebow.gitee.io/tags/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>开工：数据集的特征理解</title>
    <link href="https://sakebow.gitee.io/2020/11/22/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/%E5%BC%80%E5%B7%A5%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%9B%86%E7%9A%84%E7%89%B9%E5%BE%81%E7%90%86%E8%A7%A3/"/>
    <id>https://sakebow.gitee.io/2020/11/22/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/%E5%BC%80%E5%B7%A5%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%9B%86%E7%9A%84%E7%89%B9%E5%BE%81%E7%90%86%E8%A7%A3/</id>
    <published>2020-11-22T00:54:00.000Z</published>
    <updated>2020-11-22T14:38:48.593Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>本篇将详细解释数据集的处理方式。我相信肯定是有小伙伴读过《特征工程入门与实践》，所以这里就拿一些不一样的数据集说明特征理解的过程。</strong></p><a id="more"></a><h2 id="数据集的准备"><a href="#数据集的准备" class="headerlink" title="数据集的准备"></a>数据集的准备</h2><p>在这里我们使用的是德国的能源消耗信息，是一个结构化的报表。由于数据在外网，所以这里下载下来给大家：<a href="https://sakebow.gitee.io/images/数据集/germany_energy.csv">点击查看并全文复制保存在本地</a>。</p><p>如果你使用<code>Chrome</code>浏览器打开，那么你打开的时候应该是这样：</p><p><img src="https://sakebow.gitee.io/images/特征工程/德国能源数据集.png" alt="数据集"></p><p>我们可以看到，这个数据中包含了从$2006/1/1$开始的所有耗电数据、风力发电数据、太阳能发电数据和风力太阳能混合发电。在准备理解特征之前，我们还是把之前的流程图放在下面供参考：</p><p><img src="https://sakebow.gitee.io/images/特征工程/特征理解流程.png" alt="特征工程流程"></p><p>好的，开搞！</p><h2 id="数据读取"><a href="#数据读取" class="headerlink" title="数据读取"></a>数据读取</h2><p>在这里，我们使用<code>pandas</code>库进行数据的读取。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取数据集文件</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_data</span><span class="params">(path)</span>:</span></span><br><span class="line">  datas = pd.read_csv(path)</span><br><span class="line">  <span class="comment"># 选取耗电作为研究对象</span></span><br><span class="line">  data = datas[[<span class="string">'Date'</span>, <span class="string">'Consumption'</span>]]</span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>封装了这个方法之后，我们调用就是这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我的文件保存在了/home/sakebow/python/data/germany_energy.csv</span></span><br><span class="line">data = get_data(<span class="string">'/home/sakebow/python/data/germany_energy.csv'</span>)</span><br></pre></td></tr></table></figure><p>由于数据本身是用<code>csv</code>存储的，所以具有一定的结构性。<strong>第一步</strong>：<strong>结构化直接完成</strong>$\sqrt{}$</p><p>紧接着，我们来看看每一列的情况：</p><ul><li>日期是定序等级，虽然数值有实际的意义，本质上还是类别；</li><li>能耗是定量数据，在研究的时候还是会觉得数值非常大，所以将所有的能耗数据和$2006/01/01$的相减，得到定距等级；</li><li>风力发电和混合发电也是使用定距等级进行分析。</li></ul><p><strong>第二步</strong>：<strong>每一列的类别分析</strong>，<strong>完成</strong>$\sqrt{}$</p><p>然后我们就对照<a href="/2020/11/21/人工智能/特征工程/准备：特征理解/">准备：特征理解</a>中提供的参照表进行图表的绘制。</p><p>那么对着表一个个看，发现应当这么操作：</p><div class="table-container"><table><thead><tr><th>对象</th><th>使用图表</th></tr></thead><tbody><tr><td>日期</td><td>直方图</td></tr><tr><td>能耗</td><td>折线图、散点图、直方图</td></tr><tr><td>风力</td><td>折线图、散点图、直方图</td></tr><tr><td>太阳能</td><td>折线图、散点图、直方图</td></tr><tr><td>混合</td><td>折线图、散点图、直方图</td></tr></tbody></table></div><p>看起来还不错。不过我们还是想研究<strong>能耗</strong>、<strong>风力</strong>、<strong>太阳能</strong>和<strong>混合发电量</strong>随着时间的推移而变化的趋势，所以，重新规划一下：</p><div class="table-container"><table><thead><tr><th>对象</th><th>变量类型</th></tr></thead><tbody><tr><td>日期</td><td>自变量（作为$x$轴）</td></tr><tr><td>能耗</td><td>因变量（作为$y$轴之一）</td></tr><tr><td>风力</td><td>因变量（作为$y$轴之一）</td></tr><tr><td>太阳能</td><td>因变量（作为$y$轴之一）</td></tr><tr><td>混合</td><td>因变量（作为$y$轴之一）</td></tr></tbody></table></div><p>好了，图表确认了，我们直接开始吧。</p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>首先，我们先拉出数据集里面的日期和耗电量。刚刚我们拿到了一共四列数据的<code>DataFrame</code>对象<code>data</code>现在我们需要提取其中的几列作为研究对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用两个中括号能够同时提取多列作为研究对象</span></span><br><span class="line">consumptions = data[[<span class="string">'Date'</span>, <span class="string">'Consumption'</span>]]</span><br><span class="line"><span class="comment"># 使用DataFrame封装的plot方法能够非常方便的画出图像</span></span><br><span class="line">consumptions.plot()</span><br></pre></td></tr></table></figure><p><strong>执行</strong>！</p><p>好嘛，啥都没发生。纠其原因，就是没有显示图像。画归画，显示又是另一回事。所以我们引入<code>matplotlib</code>作为绘图包。接下来就是完整的代码：</p><p><strong>严重警告</strong>：这部分代码虽然<strong>没问题</strong>，但是得出来的<strong>结果很奇葩</strong>。<strong>复制请慎重</strong>！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> pyplot</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_data</span><span class="params">(path, x, y)</span>:</span></span><br><span class="line">  datas = pd.read_csv(path)</span><br><span class="line">  data = datas[[x, y]]</span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  data = get_data(<span class="string">'/home/sakebow/python/data/germany_energy.csv'</span>, <span class="string">'Date'</span>, <span class="string">'Consumption'</span>)</span><br><span class="line">  data.plot()</span><br><span class="line">  pyplot.xlabel(<span class="string">'date'</span>)</span><br><span class="line">  pyplot.ylabel(<span class="string">'consumption'</span>)</span><br><span class="line">  pyplot.show()</span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p><strong>看起来非常完美</strong>！<strong>运行</strong>！</p><p><img src="https://sakebow.gitee.io/images/特征工程/德国能源数据可视化图表_1.png" alt="德国能源数据"></p><p>嗯……虽然线条没什么问题，但是这个横坐标也太奇葩了吧？直接将<code>DataFrame</code>的索引变成了横坐标。这显然不是什么好图表。</p><p>所以，我们稍加修改：</p><p><strong>注意</strong>：下面这个方法是<strong>正确的</strong>，<strong>请放心复制</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> pyplot</span><br><span class="line"><span class="comment"># 封装读取数据的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_data</span><span class="params">(path, x, y)</span>:</span></span><br><span class="line">  datas = pd.read_csv(path)</span><br><span class="line">  data = datas[[x, y]]</span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  <span class="comment"># 获取数据</span></span><br><span class="line">  data = get_data(<span class="string">'/home/sakebow/python/data/germany_energy.csv'</span>, <span class="string">'Date'</span>, <span class="string">'Consumption'</span>)</span><br><span class="line">  <span class="comment"># 确认索引，并且替换掉原先的索引</span></span><br><span class="line">  data.set_index(<span class="string">'Date'</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">  <span class="comment"># 内置函数绘图</span></span><br><span class="line">  data.plot()</span><br><span class="line">  <span class="comment"># 横坐标备注</span></span><br><span class="line">  pyplot.xlabel(<span class="string">'date'</span>)</span><br><span class="line">  <span class="comment"># 纵坐标备注</span></span><br><span class="line">  pyplot.ylabel(<span class="string">'consumption'</span>)</span><br><span class="line">  <span class="comment"># 显示图表</span></span><br><span class="line">  pyplot.show()</span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p><img src="https://sakebow.gitee.io/images/特征工程/德国能源数据可视化图表_2.png" alt="德国能源数据"></p><p><strong>这就好多了</strong>。</p><p>能够很明显地看出来，没有什么非常明显的规律，甚至还有一定的周期性。</p><p>这也就是特征理解一直在做的事情。通过图表分析数据地走向。如果数据量非常多，我们也可以使用这样的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> pyplot</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  <span class="comment"># 获取数据</span></span><br><span class="line">  datas = pd.read_csv(<span class="string">'/home/sakebow/python/data/germany_energy.csv'</span>)</span><br><span class="line">  <span class="comment"># 确认索引，并且替换掉原先的索引</span></span><br><span class="line">  datas.set_index(<span class="string">'Date'</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">  <span class="comment"># 内置函数绘图</span></span><br><span class="line">  data.plot()</span><br><span class="line">  <span class="comment"># 横坐标备注</span></span><br><span class="line">  pyplot.xlabel(<span class="string">'date'</span>)</span><br><span class="line">  <span class="comment"># 显示图表</span></span><br><span class="line">  pyplot.show()</span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p><img src="https://sakebow.gitee.io/images/特征工程/德国能源数据可视化图表_3.png" alt="德国能源数据"></p><p>像这样就非常明显地表明：<strong>从2006年开始德国的耗电有着周期性的</strong>、<strong>稳定的变化</strong>；<strong>风力发电和太阳能发电一直都在增长</strong>。<strong>但是混合发电量依然远远达不到耗电量</strong>。</p><p>这就是特征理解了。在这个阶段，我们所做的就是<strong>使用图表来理解什么数据是什么趋势</strong>、<strong>通过肉眼大致预测什么数据和什么有关</strong>。接下来就是剩下的步骤了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本篇将详细解释数据集的处理方式。我相信肯定是有小伙伴读过《特征工程入门与实践》，所以这里就拿一些不一样的数据集说明特征理解的过程。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="人工智能" scheme="https://sakebow.gitee.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
      <category term="特征工程" scheme="https://sakebow.gitee.io/tags/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>准备：特征理解</title>
    <link href="https://sakebow.gitee.io/2020/11/21/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/%E5%87%86%E5%A4%87%EF%BC%9A%E7%89%B9%E5%BE%81%E7%90%86%E8%A7%A3/"/>
    <id>https://sakebow.gitee.io/2020/11/21/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/%E5%87%86%E5%A4%87%EF%BC%9A%E7%89%B9%E5%BE%81%E7%90%86%E8%A7%A3/</id>
    <published>2020-11-21T02:39:00.000Z</published>
    <updated>2020-11-22T00:53:48.739Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>虽然我们介绍了数据的无量纲化，但是在实际编码之前我们还是需要多做一些准备工作。</strong></p><a id="more"></a><p>在20多年的考试生涯中，老师都不断的提醒我们<strong>多读题</strong>。而在机器学习中，多读题也就变成了<strong>多了解数据的特点</strong>。也就是接下来要介绍的几个特点。</p><h2 id="数据是否具有统一的格式"><a href="#数据是否具有统一的格式" class="headerlink" title="数据是否具有统一的格式"></a>数据是否具有统一的格式</h2><p>现在数据飞速膨胀，单一的数字已经没办法满足现在的高标准严要求了。所以，这里使用一些高维度的数据进行说明。</p><p>还是收集了20万猫娘数据的你，还是分析各种疾病。但是呢，病情记录却不全是报表形式的数据，而是一大堆毫不相关的症状堆叠在一起。这种数据被称为<strong>非结构化数据</strong>，或者是<strong>无组织数据</strong>。就像是：</p><div class="table-container"><table><thead><tr><th>序号</th><th>账号</th><th>情况</th></tr></thead><tbody><tr><td>1</td><td>12301231823</td><td>眼球血丝较多，眼睛经常痒，咽喉处疼痛，鼻涕多</td></tr><tr><td>2</td><td>31287936661</td><td>呼吸不畅，喷嚏非常多，四肢无力</td></tr><tr><td>3</td><td>54174139414</td><td>胃胀痛，干呕，恶心</td></tr><tr><td>…</td><td>…</td><td>…</td></tr></tbody></table></div><p>当我们分析情况的时候，就会人和机器一起一头雾水，不知道从哪开始。</p><p>另外，分析疾病并不能一杆子打死，而是各有不同，需要每只猫娘的个人信息。这个时候，由于医院系统的数字化管理，猫娘的信息都是以非常标准的报表形式给出，非常方便。这些数据就是<strong>结构化数据</strong>，或者是<strong>有组织数据</strong>。就像是：</p><div class="table-container"><table><thead><tr><th>编号</th><th>姓名</th><th>年龄</th><th>性别</th><th>种族</th><th>持有铃铛</th><th>铃铛登记时间</th></tr></thead><tbody><tr><td>123831643</td><td>香子兰</td><td>14</td><td>女</td><td>猫</td><td>是</td><td>2018-12-25</td></tr><tr><td>123862173</td><td>巧克力</td><td>14</td><td>女</td><td>猫</td><td>是</td><td>2019/5/30</td></tr><tr><td>412371383</td><td>铃仙</td><td>16</td><td>女</td><td>兔</td><td>否</td><td>$\times$</td></tr><tr><td>…</td><td>…</td><td>…</td><td>…</td><td>…</td><td>…</td></tr></tbody></table></div><p>收集这些信息的时候，由于非常严格的格式和非常好理解的表格形式，所以读取非常方便。</p><h2 id="数值是指代类别还是具体数值"><a href="#数值是指代类别还是具体数值" class="headerlink" title="数值是指代类别还是具体数值"></a>数值是指代类别还是具体数值</h2><p>还是刚刚的个人信息的例子。</p><p>香子兰是女猫娘，这就是<strong>指代类别</strong>的数据。而年龄是14，这又是<strong>具体数值</strong>。虽然都是每一位用户的属性，却相当明确地给出了完全不一样的参考。</p><p>类别用于给用户分类，比如女性猫娘更适合比较精细的工作，而男性牛头人更适合力量型的工作等等；数值则用于定量表示用户的各种参数信息。比如握力、跳远距离等等。</p><h2 id="数据的四个等级"><a href="#数据的四个等级" class="headerlink" title="数据的四个等级"></a>数据的四个等级</h2><p>刚刚我们把数据分为定性和定量两种，接下来我们继续分类：</p><ul><li>定类等级</li><li>定序等级</li><li>定距等级</li><li>定比等级</li></ul><p>刚刚提到的<strong>指代类别</strong>就是<strong>定类等级</strong>数据，这个比较好理解，就不再赘述。</p><p>而<strong>定序等级</strong>，则是<strong>在同一种前提下对所有的类别进行排序</strong>所得到的类别集合。打个比方，我们需要在地下城寻找更适合当裁缝的种族，所以收集大量的数据，并按照所有种族的平均表现进行排序。最后我们发现，蚕和毛毛虫这两个种族不相上下，并列第一，其次是蜘蛛，然后是人类。于是，我们就得到了一个有序的集合，这个集合就是含有<strong>定序等级</strong>的数据。虽然说这组数据中包含一些使用数据精确说明的定量数据，但是本身代表的实际上是一个类，哪怕这个数字是一个像$25\%$之类的确切数值数。</p><p><strong>定距等级</strong>，顾名思义，就是设置参照并使用差值进行绘图。还是<a href="/2020/11/15/人工智能/特征工程/知识储备：数据的无量纲化/">知识储备：数据的无量纲化</a>中跳远数据的例子。比起全部使用$1.537$上下不等的共20万琐碎数据，还是将$1.537$作为新的参照重新计算这些数据反而效果会更好。其中，这个由差值组成的新的数据集就是包含<strong>定距等级</strong>的数据集。当然，毕竟是20万条数据，画图将会是密密麻麻的一片，毫无参考价值。所以，这里可以以年龄为$x$轴，每个年龄段都计算均值，这样就能得出<strong>年龄-跳远距离</strong>曲线。这个年龄又是<strong>定序等级</strong>。就变成了<strong>不同类别下的定量分析</strong>。全都联系起来了，不是么？</p><p><strong>定比等级</strong>同样也是定量的描述，只不过和<strong>定距等级</strong>不一样的是，<strong>定距等级使用的是差值</strong>，而<strong>定比等级使用的是比值</strong>。同样需要参照物，研究的时候也是研究比值而不是源数据。<code>CPU</code>、<code>GPU</code>等电子产品的性能分析就是最好的例子。往往在新款<code>CPU</code>、<code>GPU</code>等电子产品推出的时候，都会和一个参照物进行比较。比如，<code>intel</code>新款<code>CPU</code>会和历代<code>CPU</code>产品进行比较，频率提升了多少比率、各种测试环境下的表现提升了多少比率等等；小米会和华为比较，打开应用的速度提升了百分之多少，游戏延迟降低了百分之多少等等。这些都是<strong>定比等级</strong>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后就用《特征工程入门与实践》中的表格作总结吧。</p><p>下面这个表格总结了本篇的核心内容，也就是<strong>四大数据特点的比较</strong>。</p><div class="table-container"><table><thead><tr><th>等级</th><th>属性</th><th>例子</th><th>描述性统计</th><th>图表</th></tr></thead><tbody><tr><td>定类</td><td>离散、无序</td><td>颜色、真或假</td><td>频率/占比、众数</td><td>条形图、饼状图</td></tr><tr><td>定序</td><td>有序</td><td>考试等级、年龄分段</td><td>频率、众数、中位数、百分数</td><td>条形图、饼图、茎叶图</td></tr><tr><td>定距</td><td>数据差有真实意义</td><td>温度、跳远</td><td>频率、众数、中位数、均值、标准差</td><td>条形图、饼图、茎叶图、箱线图、直方图</td></tr><tr><td>定比</td><td>连续、存在有真实意义的绝对零点，可以做除法</td><td>性能指标、金钱、重量</td><td>均值、标准差</td><td>直方图、箱线图</td></tr></tbody></table></div><p>如果你不知道<strong>什么等级应该用什么样的统计量表示</strong>，那就对照下面这张表：</p><div class="table-container"><table><thead><tr><th>统计量</th><th>定类</th><th>定序</th><th>定距</th><th>定比</th></tr></thead><tbody><tr><td>众数</td><td>$\sqrt{}$</td><td>$\sqrt{}$</td><td>$\sqrt{}$</td><td>有时可行</td></tr><tr><td>中位数</td><td>$\times$</td><td>$\sqrt{}$</td><td>$\sqrt{}$</td><td>$\sqrt{}$</td></tr><tr><td>差值、最小最大值</td><td>$\times$</td><td>$\sqrt{}$</td><td>$\sqrt{}$</td><td>$\sqrt{}$</td></tr><tr><td>均值</td><td>$\times$</td><td>$\times$</td><td>$\sqrt{}$</td><td>$\sqrt{}$</td></tr><tr><td>标准差</td><td>$\times$</td><td>$\times$</td><td>$\sqrt{}$</td><td>$\sqrt{}$</td></tr></tbody></table></div><p>现在，相信你对一大堆不知所云甚至毫无关联的数据的时候，不会像以前那么害怕了，不是么？最后还是提醒一下，特征工程的特征理解，最最核心的操作步骤，就是下面这张图所示的：</p><p><img src="https://sakebow.gitee.io/images/特征工程/特征理解流程.png" alt="特征工程流程"></p><p>是不是有点能理解了？</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;虽然我们介绍了数据的无量纲化，但是在实际编码之前我们还是需要多做一些准备工作。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="人工智能" scheme="https://sakebow.gitee.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
      <category term="特征工程" scheme="https://sakebow.gitee.io/tags/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>方向：特征工程的定义与目的</title>
    <link href="https://sakebow.gitee.io/2020/11/19/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/%E6%96%B9%E5%90%91%EF%BC%9A%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E7%9B%AE%E7%9A%84/"/>
    <id>https://sakebow.gitee.io/2020/11/19/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/%E6%96%B9%E5%90%91%EF%BC%9A%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E7%9B%AE%E7%9A%84/</id>
    <published>2020-11-19T03:26:00.000Z</published>
    <updated>2020-11-19T15:21:49.778Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>本文主要是<a href="https://www.bilibili.com/video/BV1rp4y197fo" target="_blank" rel="noopener">B站视频：【机器学习】特征工程</a>的学习笔记，里面包含了视频内容和自己的理解。</strong></p><a id="more"></a><h2 id="特征工程的定义"><a href="#特征工程的定义" class="headerlink" title="特征工程的定义"></a>特征工程的定义</h2><blockquote><p>特征工程是将<strong>原始数据转化为更好地代表预测模型的潜在问题的特征</strong>的过程，从而<strong>提高了对未知数据的预测准确性</strong>。</p><p>——摘自视频中展示的PPT</p></blockquote><p>也就是说，特征工程不过就是从大量的原始中选出确确实实对需要研究的数据产生了影响的个别数据。听起来和我之前描述的机器学习过程没有什么区别？确实没有什么区别，换了个专业的名词而已。</p><h2 id="特征工程的目标"><a href="#特征工程的目标" class="headerlink" title="特征工程的目标"></a>特征工程的目标</h2><p>在大学毕业以前，题目都会明确指定自变量和因变量，然后使用固定的模式来匹配这些自变量和因变量，最终得出结论。</p><p>在研究生生活开始以后，就再也没有固定的套路了。一大堆数据里面，确定一个研究对象并设置为因变量，将其他的变量全部设定为自变量，最后分析哪些变量对因变量的变化产生了决定性的作用，哪些变量对因变量产生了重要作用，而哪些变量是与因变量完全无关的。</p><p>所以，特征工程的目标则是针对因变量的变化，<strong>通过排除并没有什么作用的变量而降低问题的复杂度</strong>，<strong>让所研究的问题更加清晰</strong>。</p><p>这也是机器学习中最需要做的事情。拿到数据之后，选定其中一个数据作为我们需要研究的对象；剩下的便是使用各种各样的机器学习算法对剩余的数据进行降维、降噪和建模分析。</p><p>所以，特征工程就是为了机器学习的进一步分析服务的。是不是有点能理解了呢？</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本文主要是&lt;a href=&quot;https://www.bilibili.com/video/BV1rp4y197fo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;B站视频：【机器学习】特征工程&lt;/a&gt;的学习笔记，里面包含了视频内容和自己的理解。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="人工智能" scheme="https://sakebow.gitee.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
      <category term="特征工程" scheme="https://sakebow.gitee.io/tags/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>知识储备：数据的无量纲化</title>
    <link href="https://sakebow.gitee.io/2020/11/15/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%9A%84%E6%97%A0%E9%87%8F%E7%BA%B2%E5%8C%96/"/>
    <id>https://sakebow.gitee.io/2020/11/15/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%9A%84%E6%97%A0%E9%87%8F%E7%BA%B2%E5%8C%96/</id>
    <published>2020-11-15T11:42:00.000Z</published>
    <updated>2020-11-21T11:02:23.398Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>你现在拿到了许多数据，顺序是完全随机的。这已经不是单凭肉眼和逻辑推导就能分析出来的规律，只能通过机器学习来计算。那么，应该从哪一步开始？</strong></p><a id="more"></a><h2 id="数据无量纲化"><a href="#数据无量纲化" class="headerlink" title="数据无量纲化"></a>数据无量纲化</h2><p>放心，无论是谁只要是第一次听到这个名词都会蒙圈一会。其的定义就是：“<strong>将不同规格的数据转换到同一规格</strong>，<strong>或者不同分布的数据转换为同一分布</strong>”。听起来不是很好理解？</p><p>还是那个时候收集了20万猫娘数据的你。这个时候你甚至收集到了猫娘们跳远、跳高的数据。可是这些数据都集中在$1.537$米左右，想要分析的话实在是<strong>计算量非常大</strong>。所以，你修改了一下计算参照，不再是将所有的数据和$0$米相比，而是和平均值$1.537$米相比。于是大量的数据都集中在$0$到$0.262$，少部分分布在$0.262$到$0.501$。这个计算量就好多了，不是么？</p><p>这就是<strong>数据规格化</strong>。</p><blockquote><p>数据规格化指对数据的规范化处理。有些情况下，为了能正确地真正反映实际情况，必须对原始数据进行加工处理，使之规范化。数据经过规格化后其计算结果与未经规格化的计算结果差别较大。这是由于相似系数取决于坐标原点的位置。在规格化后，坐标原点移动了，使样品之间的夹角改变很大。</p><p>——摘自<a href="https://baike.baidu.com/item/数据规格化/610954" target="_blank" rel="noopener">百度百科【数据规格化】</a></p></blockquote><p>听到这里，你的<code>DNA</code>应该有反应了。没错，就是</p><script type="math/tex; mode=display">若X\sim N(\mu,\sigma^2),那么Y=\frac{X-\mu}{\sigma}\sim N(0,1)</script><p>之前我们在做题的时候都是二话不说先化为标准正态分布，实际上这么做就是为了<strong>数据规格化</strong>。</p><p>而对于不同分布的数据我们则是尽可能地转化为统一的分布，这个分布多半选择<strong>正态分布</strong>，因为正态分布有非常多便于统计运算的性质。</p><p>正因为数据的无量纲化之后能够将数据变为更为规范的、标准的数据集，所以往往在进行机器学习的时候为了能够更快地收敛、在更短的时间内给出更精确的结果，无量纲化也是重要的一步。当然，也可以跳过，这都看原数据的质量了。</p><h2 id="无量纲化的意义"><a href="#无量纲化的意义" class="headerlink" title="无量纲化的意义"></a>无量纲化的意义</h2><blockquote><p>机器学习和数据挖掘中所使用的数据，永远不可能是完美的。很多特征，对于分析和建模来说意义非凡，但对于实际收集数据的人却不是如此，因此数据挖掘之中，常常会有重要的字段缺失值很多，但又不能舍弃字段的情况。因此，数据预处理中非常重要的一项就是处理缺失值。</p><p>——摘自<a href="https://blog.csdn.net/weixin_36325602/article/details/104134462" target="_blank" rel="noopener">CSDN用户AI_Engine：数据无量纲化</a></p></blockquote><p>听起来像极了对账的时候各种奇葩漏账、错别字的样子，不是么？机器面对这样一大批乱七八糟的东西也是一样的。“这TM是啥？”“那TM又是啥？”然后稀里糊涂给了个让你情不自禁说出“这TM什么鬼”的结果。</p><p>听起来还是有点不太明白？举个例子。</p><p>你想给你的小猫娘科普中国四大名著。但是很可惜，在使用电脑准备文案的时候，你把<strong>水浒传</strong>打成了<strong>水许传</strong>。最绝望的是，你的小猫娘学会了。可以想象，你的小猫娘蹦蹦跳跳的跑到别人面前大声喊出“水许传”的时候，你会有多尴尬。</p><p>机器学习也是一样的，要是有个错误的数据，完全不会自己思考的机器就会把这个当作正确答案进行进一步的运算，然后得出一个错误的结果。像极了<strong>计算出老奶奶的速度是60km/h</strong>的小学生。</p><p><img src="https://sakebow.gitee.io/images/emoji/60码的老奶奶.jpg" alt="计算错误就只好以60码的速度行走的老奶奶" height="350"></p><p>当然，除了纠错补全，无量纲化还能够使用正态分布的许多种特性进行新的分析。例如：</p><script type="math/tex; mode=display">若X\sim N(0,1),则\left\{\begin{matrix}  EX&=&0\\  DX&=&1\\\end{matrix}\right.</script><p>不仅如此，我们还能够通过查表的方式确定当前服从正态分布的变量对应了多少概率，就像我们高中非常熟悉的$P(-\sigma+\mu&lt;X&lt;+\sigma+\mu)=0.6826$等等。更进一步，我们还能够使用正态分布所引出的其他分布来进行更多的数学分析，就像是考研过程中被折磨了无数遍的$F(m,n)=\frac{n\sum^m_{i=1}x^2}{m\sum^n_{i=1}y^2}$等。</p><p>是不是有点能理解了？</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;你现在拿到了许多数据，顺序是完全随机的。这已经不是单凭肉眼和逻辑推导就能分析出来的规律，只能通过机器学习来计算。那么，应该从哪一步开始？&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="人工智能" scheme="https://sakebow.gitee.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
      <category term="特征工程" scheme="https://sakebow.gitee.io/tags/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>滑动窗口在机器学习中的运用</title>
    <link href="https://sakebow.gitee.io/2020/11/13/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E8%BF%90%E7%94%A8/"/>
    <id>https://sakebow.gitee.io/2020/11/13/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E8%BF%90%E7%94%A8/</id>
    <published>2020-11-13T07:50:00.000Z</published>
    <updated>2020-11-15T11:37:40.847Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>如果接触过计算机网络中的<code>TCP/IP</code>协议的话，你可能会对滑动窗口比较熟悉。那么滑动窗口到底是什么原理？在机器学习中又是如何运用？</strong></p><a id="more"></a><h2 id="计算机网络的滑动窗口复习"><a href="#计算机网络的滑动窗口复习" class="headerlink" title="计算机网络的滑动窗口复习"></a>计算机网络的滑动窗口复习</h2><p>在计算机网络中，滑动窗口的主要目的是<strong>流量控制</strong>，也就是为了处理网络拥塞的情况。对于拥塞，有三种不同策略的滑动窗口，分别是：<strong>停止等待</strong>、<strong>后退N帧</strong>、<strong>选择重传</strong>。这些就不一一展开了，因为我们主要介绍的不是这个，详情请回忆本科时候学习的计算机网络。</p><h2 id="滑动窗口的原理"><a href="#滑动窗口的原理" class="headerlink" title="滑动窗口的原理"></a>滑动窗口的原理</h2><p>滑动窗口就像是一张解密卡，中间的可以透光的部分可以让我们看到卡片的后面。</p><p><img src="https://sakebow.gitee.io/images/机器学习/解密卡.jpeg" alt="解密卡"></p><p><del>嗯……是不是暴露年龄了？</del></p><p>如果你恰好有很大一堆需要解密的数据，你就会用这张解密卡从左到右移动，逐渐解开所有的谜题。</p><p>这就是滑动窗口的原理。因为是每走一步分析一次，所以滑动窗口对时序数据的分析有着非常大的作用。如果只是单纯的分段分析，有可能会刚刚好忽略了转折点，最终就没能得到较好的结果。</p><h2 id="滑动窗口的应用"><a href="#滑动窗口的应用" class="headerlink" title="滑动窗口的应用"></a>滑动窗口的应用</h2><p>正因为滑动窗口对于时序数据的优势，所以滑动窗口将来会更多的应用在涉及时序数据的分析中，比如股票随着时间的变化、脑网络中随时间变化的活动情况、电网中各类传感器数据随时间变化的情况等等。</p><p>到了现在这个“充分挖掘数据价值”的时代中，单一时间片的数据已经远远不够价值地体现了，需要大量的、多个时间维度的分析与评价，最终联系多个时间段的实际情况对实验结果的影响最终得出可能的结论。</p><p>听不懂没关系，还是一如既往的小例子。</p><p>你的小猫娘<strong>并不是一成不变的</strong>。她再怎么说也是有懵懂期、好动期、叛逆期<del>和发情期</del>等等，每个阶段都有不同的心理和生理活动，所以想要理解你的小猫娘的话，要是一直将你的小猫娘固定在让你最快乐的那个时段中，最终对小猫娘的理解<strong>一定是片面的</strong>。而若是动态地分析，不停地按照一定的步长分析每个时段的小猫娘，在保证考虑新时段和旧时段的联系的同时，还要使用相对较长的步长来避免你对过去的小猫娘的不舍。这样最终对小猫娘的理解也会<strong>相对来说更为全面</strong>。</p><p>这也就是滑动窗口想要解决的问题。一次只看一小部分，但是每个部分都有相关联的地方，不至于完全隔断，也不至于过度分析。</p><h2 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h2><p>滑动窗口虽然是能够让我们看到相对来说更为连续的数据，但是窗口毕竟是窗口，<strong>并不能帮助分析</strong>。窗口的实质只不过是使用狭窄的边框<strong>屏蔽掉</strong>整个数据的其他部分，从而让我们更<strong>好地专注</strong>于整个数据中的一小部分连续的数据。真正的分析还是得使用能够分析数据的机器学习算法，比如<strong>降维</strong>的<code>TSNE</code>、<strong>分类</strong>的随机森林、<strong>预测</strong>的回归分析等等。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;如果接触过计算机网络中的&lt;code&gt;TCP/IP&lt;/code&gt;协议的话，你可能会对滑动窗口比较熟悉。那么滑动窗口到底是什么原理？在机器学习中又是如何运用？&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="人工智能" scheme="https://sakebow.gitee.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
      <category term="算法模型" scheme="https://sakebow.gitee.io/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Windows下使用Docker搭建GitLab服务器</title>
    <link href="https://sakebow.gitee.io/2020/11/10/%E8%BF%90%E7%BB%B4/docker/Windows%E4%B8%8B%E4%BD%BF%E7%94%A8Docker%E6%90%AD%E5%BB%BAGitLab%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://sakebow.gitee.io/2020/11/10/%E8%BF%90%E7%BB%B4/docker/Windows%E4%B8%8B%E4%BD%BF%E7%94%A8Docker%E6%90%AD%E5%BB%BAGitLab%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2020-11-10T09:22:00.000Z</published>
    <updated>2020-11-15T11:37:17.735Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>也不是所有的公司都崇尚<code>Linux</code>哲学，也有非常多的公司热衷于使用<code>Windows</code>当作服务器。所以这里介绍一下在如何在<code>Windows</code>下使用<code>Docker</code>搭建<code>GitLab</code>。</strong></p><a id="more"></a><h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装<code>Docker</code></h2><p>安装包：<a href="https://pan.baidu.com/s/1Ek_Z4LOAV80Pf2V4FKFs2Q" target="_blank" rel="noopener">提取码：ary4</a></p><p>在<code>Windows</code>下安装<code>Docker</code>就非常难受了，需要解决非常多的约束。</p><h3 id="系统更新"><a href="#系统更新" class="headerlink" title="系统更新"></a>系统更新</h3><p>有些人非常讨厌更新所以使用一些脚本把更新关掉了。但是人家<code>Docker</code>必须要更新才能安装，你气不气嘛。</p><p>如果你是<code>Windows10</code>，在“更新和安全”$\rightarrow$“<code>Windows</code>更新”，在里面找到“检查更新”按钮，点击即可。到最后，会提示你重启以应用更新。当然，你可以选择现在重启，但是我们推荐把下面的步骤做完之后再更新。</p><h3 id="添加“适用于Linux的Windows子系统”"><a href="#添加“适用于Linux的Windows子系统”" class="headerlink" title="添加“适用于Linux的Windows子系统”"></a>添加“适用于<code>Linux</code>的<code>Windows</code>子系统”</h3><p>在编辑这篇博客的时候，<code>Docker</code>已经出道了2.5.0，所以需要这样的设置。</p><p>打开“控制面板”$\rightarrow$“程序”$\rightarrow$“程序和功能”$\rightarrow$“启用或关闭<code>Windows</code>功能”$\rightarrow$“适用于<code>Linux</code>的<code>Windows</code>子系统”（最下方倒数第三个），勾选，然后点击“确定”。</p><p><img src="https://sakebow.gitee.io/images/SpringCloud/安装WSL.png" alt="操作截图"></p><p>接着<code>Windows</code>就能够帮你下载这些东西。等待完成之后，系统会提示需要重启，重启之后就应用了更改。这个时候重启吧，但是别忘了，在开机之前还有一点点事情要做。</p><h3 id="VT开启"><a href="#VT开启" class="headerlink" title="VT开启"></a><code>VT</code>开启</h3><p>你的<code>Windows</code>需要开启<code>virtual technology</code>，也就是<strong>虚拟化</strong>，打游戏的时候经常要开启的那个。有些主板可能比较难找，但一定会有，实在找不到去问问度娘吧，主办版本太多了也没办法一一说明。</p><h3 id="结束？"><a href="#结束？" class="headerlink" title="结束？"></a>结束？</h3><p><strong>试着打开<code>Docker Desktop</code>的安装包吧！</strong></p><p>看到这里是不是以为马上就要结束了？<strong>当然没有</strong>。只不过往后的步骤有提示而已，别担心啦。</p><p>打开安装包之后，他会提示：需要安装<code>Linux</code>内核以支持<code>Docker</code>的运行。这里她也非常贴心的给出了链接，点进去下载就好了。</p><p>这里我也给出我自己已经下载好的吧：<a href="https://pan.baidu.com/s/1TALJ76QmVgm0VrumzDkUQw" target="_blank" rel="noopener">提取码：14m1</a></p><p>下载好了之后安装，这个过程是不会让你选择路径的。因为安装包不大，所以也没什么影响，放心安装。</p><p>等全部安装完之后，就可以真正意义上打开<code>Docker Desktop</code>的安装包了。</p><p>之后便是等待安装结束。<code>Docker</code>安装文件给的提示是注销用户再重新登录即可，可能使用<code>Linux</code>的人比较习惯这种操作。不过呢，既然是傻瓜式的<code>Windows</code>，直接重启计算机就好了。（<em>仅限开机较快的同学</em>）</p><p>到这里，就能够打开<code>Docker Desktop</code>正常使用了。</p><h2 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h2><p>在<code>Linux</code>系统中，直接修改<code>/etc/docker/daemon.json</code>就够了。但是<code>Windows</code>系统中可没有这个。所以直接打开任务栏中的<code>Docker</code>，按照下图步骤进行设置</p><p><img src="https://sakebow.gitee.io/images/SpringCloud/Windows的docker换源.png" alt="Docker界面"></p><p>其中国内源可以选择：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Docker国内镜像源</span></span><br><span class="line">https://registry.docker-cn.com</span><br><span class="line"><span class="meta">#</span><span class="bash"> 网易Docker源</span></span><br><span class="line">http://hub-mirror.c.163.com</span><br></pre></td></tr></table></figure><p>当然你还可以选择阿里云的私人镜像站，都是非常不错的。这里就不一一介绍了。</p><p>最后，安装一下<code>Git</code>客户端吧。在<code>Windows</code>上如果不进行任何配置的话，只能使用<code>Git Bash</code>。但是考虑到<code>GitLab</code>一定要用到<code>Git</code>客户端，所以也就安装了算了吧。</p><p>国内的话更推荐使用<a href="http://npm.taobao.org/mirrors/git-for-windows/v2.29.2.windows.2/" target="_blank" rel="noopener">淘宝的Git-2.29.2.2镜像</a>。</p><p>就是这样啦。接下来我们开始搭建<code>GitLab</code>。</p><p>打开命令行（实际上是<code>Git</code>客户端），输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">docker pull twang2218/gitlab-ce-zh # 拉取镜像</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">下载时间很长，我们趁下载的时间准备`docker-compose.yml`：</span><br><span class="line"></span><br><span class="line">```yml</span><br><span class="line">version: '3' # 版本号</span><br><span class="line">services: # 开启服务</span><br><span class="line">  gitlab: # 服务名称</span><br><span class="line">    image: 'twang2218/gitlab-ce-zh:latest' # 使用镜像</span><br><span class="line">    restart: always</span><br><span class="line">    hostname: 'GitLab' # 主机名称（自定义）</span><br><span class="line">    environment: # 环境配置</span><br><span class="line">      TZ: 'Asia/Shanghai'</span><br><span class="line">      GITLAB_OMNIBUS_CONFIG: |</span><br><span class="line">        external_url 'http://192.168.1.112:8080'</span><br><span class="line">        gitlab_rails['gitlab_shell_ssh_port'] = 4022</span><br><span class="line">        unicorn['port'] = 8888</span><br><span class="line">        nginx['listen_port'] = 8080</span><br><span class="line">    ports: # 端口映射，格式为“本机IP：Docker镜像内部IP”</span><br><span class="line">      - '1080:8080'</span><br><span class="line">      - '1043:8443'</span><br><span class="line">      - '1022:22'</span><br><span class="line">    volumes: # 挂载卷</span><br><span class="line">      # 前面是Windows的地址所以斜杠向右；后面是Linux的地址所以向左</span><br><span class="line">      - D:\codes\docker\gitlab\config:/etc/gitlab</span><br><span class="line">      - D:\codes\docker\gitlab\data:/var/opt/gitlab</span><br><span class="line">      - D:\codes\docker\gitlab\logs:/var/log/gitlab</span><br></pre></td></tr></table></figure><p>粘贴后记得保存哦。</p><p>等拉取完毕后，运行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d # 以后台进程的方式运行容器</span><br></pre></td></tr></table></figure><p>于是，<code>GitLab</code>就能够跑起来了。短暂地等待之后，使用“本机IP：端口号”的形式访问网站就好了。比如说我设置之后就可以使用：<code>http://10.33.76.59:1080</code>进入<code>GitLab</code>网站。</p><p>如果你有看过我之前写的<a href="/2020/07/08/Java/SpringCloud/版本控制的另一种打开方式/">版本控制的另一种打开方式</a>，那么你对上述的过程应该很熟悉。但是在<code>Windows</code>下有所不同的是，在进入容器内的时候并不能使用<code>/bin/bash</code>，因为<code>Windows</code>系统压根就没有这个地址。</p><p>所以只能使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it $&#123;docker-container-id&#125; bash</span><br></pre></td></tr></table></figure><p>也就是将<code>/bin/bash</code>更换为<code>bash</code>。</p><p>这下就能进去了。剩下的改密码、创建什么的都和之前<a href="/2020/07/08/Java/SpringCloud/版本控制的另一种打开方式/">版本控制的另一种打开方式</a>一模一样了。</p><p>是不是有点懂了呢？</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;也不是所有的公司都崇尚&lt;code&gt;Linux&lt;/code&gt;哲学，也有非常多的公司热衷于使用&lt;code&gt;Windows&lt;/code&gt;当作服务器。所以这里介绍一下在如何在&lt;code&gt;Windows&lt;/code&gt;下使用&lt;code&gt;Docker&lt;/code&gt;搭建&lt;code&gt;GitLab&lt;/code&gt;。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="运维" scheme="https://sakebow.gitee.io/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="docker" scheme="https://sakebow.gitee.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>从面向对象来看静态绑定和动态绑定</title>
    <link href="https://sakebow.gitee.io/2020/11/02/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E4%BB%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%9D%A5%E7%9C%8B%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E5%92%8C%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A/"/>
    <id>https://sakebow.gitee.io/2020/11/02/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E4%BB%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%9D%A5%E7%9C%8B%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E5%92%8C%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A/</id>
    <published>2020-11-02T07:00:00.000Z</published>
    <updated>2020-11-03T10:50:51.535Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>这个部分是相当底层的知识，不涉及实际编程，可能会有些枯燥。</strong></p><a id="more"></a><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>所谓<strong>绑定</strong>，就是<strong>将方法与其所在的对象或者类关联起</strong>来。</p><p><strong>静态绑定</strong>，或者有人比较喜欢称为<strong>前期绑定</strong>，意思是<strong>在执行之前就已经明确了什么方法属于什么类或者对象</strong>。</p><p><strong>动态绑定</strong>，或者有人比较喜欢称为<strong>后期绑定</strong>，意思是<strong>在执行的时候根据具体的实例化对象绑定对应的方法</strong>。</p><p>听起来很绕？来看看这些个例子。</p><h2 id="类比说明静态绑定和动态绑定"><a href="#类比说明静态绑定和动态绑定" class="headerlink" title="类比说明静态绑定和动态绑定"></a>类比说明静态绑定和动态绑定</h2><p>有一天，你家里多了一只猫娘。先不管你是怎么得到的吧，总之就在你家了。于是，在这个时候，这只猫娘就和你<strong>绑定</strong>了。</p><p>由于家里人就你天天陪着她，她也就每天粘着你。不久之后，你就和这只猫娘<strong>静态绑定</strong>了。有人来看看你和你的猫娘的时候，一看到那只怯生生的猫娘躲在你背后，就知道：啊，这只小猫娘粘上你了呐。</p><p>但是呢，眼看着小猫娘一天天长大，总不能一直都在家里吧？。你的猫娘也凭自己的努力得到了一个小铃铛（<del><em>串戏了啊喂</em></del>），你就带着她出去转转了。路上碰到了一个警察，警察看到你的猫娘上有一只铃铛，就把猫娘和你一起<strong>动态绑定</strong>了。只有在你出门之后，警察才会将你和你的小猫娘通过一只铃铛进行绑定。</p><h2 id="从面向对象来看静态绑定和动态绑定"><a href="#从面向对象来看静态绑定和动态绑定" class="headerlink" title="从面向对象来看静态绑定和动态绑定"></a>从面向对象来看静态绑定和动态绑定</h2><p>辣么，在面向对象编程中，动态绑定和静态绑定又是什么呢？拿<code>Java</code>来说吧。</p><p>我们在创建<code>utils</code>包的时候会封装一些静态类作为项目必须的工具类。其中必定会使用<code>private</code>、<code>final</code>、<code>static</code>等来修饰字段或者方法。这些就是<strong>静态绑定</strong>，在一开始就直接知道了这些个方法和字段就是这个工具类的一部分。</p><p>另外，在声明<code>entity</code>包中的各种映射实体类的时候，我们会使用<code>public</code>来修饰，其中的各种方法也是<code>public</code>方法。这种在运行之中<code>JVM</code>也并不清楚这到底是谁的方法，而是在产生各种中间件的时候发现这些个方法是属于这个类的。这就是<strong>动态绑定</strong>。</p><p><strong>动态绑定</strong>实际上是将<strong>可执行的方法</strong>和<strong>生成的对象</strong>进行绑定，所以仅发生在程序执行过程中；<strong>静态绑定</strong>则是将<strong>不可被继承</strong>或者<strong>不可被覆盖</strong>的方法和原类进行版绑定。</p><h2 id="给实际编程所带来的影响"><a href="#给实际编程所带来的影响" class="headerlink" title="给实际编程所带来的影响"></a>给实际编程所带来的影响</h2><p>可以肯定的是，无论是什么语言，动态绑定永远都比静态绑定耗时较长。拿<code>Java</code>来看，<code>JVM</code>需要消耗一点时间将创建过后的对象和方法对应起来实现动态绑定，而静态绑定则是已经确认了谁和谁本来就应该在一起。所以，如果是使用非常频繁的工具类，我们可以考虑使用静态方法，这样就能够进行静态绑定，这样运行起来会稍微快一点点。（<del><em>虽然一直做<code>CRUD</code>的<code>API</code>调用工程师也接触不到这些内容啦</em></del>）</p><p>是不是有点能理解了呢？</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;这个部分是相当底层的知识，不涉及实际编程，可能会有些枯燥。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="软件开发建模" scheme="https://sakebow.gitee.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%BB%BA%E6%A8%A1/"/>
    
    
      <category term="软件项目管理" scheme="https://sakebow.gitee.io/tags/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>用例图：不是面向对象的面向对象设计概念图</title>
    <link href="https://sakebow.gitee.io/2020/11/02/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E7%94%A8%E4%BE%8B%E5%9B%BE%EF%BC%9A%E4%B8%8D%E6%98%AF%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E6%A6%82%E5%BF%B5%E5%9B%BE/"/>
    <id>https://sakebow.gitee.io/2020/11/02/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E7%94%A8%E4%BE%8B%E5%9B%BE%EF%BC%9A%E4%B8%8D%E6%98%AF%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E6%A6%82%E5%BF%B5%E5%9B%BE/</id>
    <published>2020-11-02T06:38:00.000Z</published>
    <updated>2020-11-15T11:36:38.611Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>相信经历软考的人都应当对最后的几个大题的图傻傻分不清楚。别害怕，还有更猛的，把你锤在地上爬都爬不起来。</strong></p><a id="more"></a><h2 id="用例图简介"><a href="#用例图简介" class="headerlink" title="用例图简介"></a>用例图简介</h2><p>用例图是什么？这个只能通过死记硬背来对应起来。这玩意怎么记呢？既然是用例图，那肯定就是在说<strong>什么对象在使用什么操作</strong>。听起来很有面向对象的那味儿了，不是么？</p><blockquote><p><img src="https://sakebow.gitee.io/images/软件工程/用例图.png" alt="这是一个用例图的例子"></p><p>——摘自<a href="https://baike.baidu.com/item/用例图/9531932" target="_blank" rel="noopener">百度百科【用例图】</a></p></blockquote><p>来看看上面这张图，这种就是用例图（<del>虽然并不标准</del>）。</p><p>可以看到，教师拥有“录入成绩”、“修改成绩”、“查询成绩”、“删除成绩”、“登录”五大功能，同时附赠一个“找回密码”的小功能，而且“录入成绩”、“修改成绩”这两个大功能共用一个“保存成绩”的小功能；学生就只有“查询成绩”、“登录”和附赠的“找回密码”。</p><p>可以看到，这张用例图清晰地表示了<strong>哪个角色能够使用哪些功能</strong>，而<strong>哪些功能中包含或者拓展哪些小功能</strong>。</p><p>是不是觉得这个系统应该怎么规划都想得很清楚了？是不是觉得现在开始编码随便写写就能出来了？没错，用例图就是这么简单直接所以才能够普及。</p><p>顺便说明一下，用例图时需要明确标明系统边界的，所以标准的画法应当是在所有功能外画一个大边框，表示这是系统的边界；与此同时还需要在边框旁边标明这个是什么系统。</p><h2 id="面向对象？很可惜不是"><a href="#面向对象？很可惜不是" class="headerlink" title="面向对象？很可惜不是"></a>面向对象？很可惜不是</h2><p>什么是<strong>面向对象</strong>？<strong>每一个类所实例化的对象都有与之对应的属性来描述对象的特征，并且还有成员函数来描述对象的行为</strong>。<strong>类</strong>又是什么？是<strong>属性和操作的封装体</strong>；<strong>对象</strong>是什么？是<strong>类的实例</strong>。</p><p>可是用例图有吗？<strong>当然没有</strong>。</p><p>回看我们刚刚的例子，用例图<strong>只包含若干个执行者和执行者所对应的操作</strong>。这算哪门子面向对象嘛。</p><p>但是也正因为用例图屏蔽了面向对象中很多的细节，删去了属性、不必要的成员函数乃至对象之间的关系，所以反而<strong>传达了更精确的面向对象概念</strong>。</p><p>挺可笑的不是嘛。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;相信经历软考的人都应当对最后的几个大题的图傻傻分不清楚。别害怕，还有更猛的，把你锤在地上爬都爬不起来。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="软件开发建模" scheme="https://sakebow.gitee.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%BB%BA%E6%A8%A1/"/>
    
    
      <category term="软件项目管理" scheme="https://sakebow.gitee.io/tags/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Python的最火框架：Django</title>
    <link href="https://sakebow.gitee.io/2020/11/01/python/Django/Python%E7%9A%84%E6%9C%80%E7%81%AB%E6%A1%86%E6%9E%B6%EF%BC%9ADjango/"/>
    <id>https://sakebow.gitee.io/2020/11/01/python/Django/Python%E7%9A%84%E6%9C%80%E7%81%AB%E6%A1%86%E6%9E%B6%EF%BC%9ADjango/</id>
    <published>2020-11-01T15:45:00.000Z</published>
    <updated>2020-11-03T09:05:20.608Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>你可能是一个<code>Java</code>工程师，你还可能想和<code>SpringBoot</code>比划比划。但是呢，<code>Django</code>在<code>SSM</code>时代确实是配置少、功能强。</strong></p><a id="more"></a><h2 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h2><p>虽然说有人觉得<code>Python</code>比<code>Java</code>更强，但现在<code>SpringBoot</code>框架发展起来了之后，<code>Django</code>的少配置就不怎么少了；<code>SpringCloud</code>框架发展起来之后，<code>Java</code>现在的生态就已经超过<code>Python</code>了。期待<code>Python</code>的后期发力吧。如果你希望在<code>Web</code>开发上有所建树，现在的企业级开发框架基本上已经统一为<code>SpringCloud</code>了。如果你的研究方向就是<code>PythonWeb</code>，那么这篇文章应该会对你有一点点小小的帮助。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>当还在<code>SSM</code>时代，<code>JavaWeb</code>编程依然是一大堆的<code>xml</code>配置文件和很多的<code>properties</code>配置的时候，<code>Django</code>作为一种配置少，而且是<strong>传说中</strong>的“垃圾回收机制比<code>Java</code>强几倍”而且“运行速度快几倍”的<code>Python</code>语言构造的<code>Web</code>框架，并且生态和集成度都比<code>Flask</code>好，所以广受好评。</p><p>广受好评了之后，就必然是社区的大力支持。现在<code>Django</code>的社区提供的各种方便的、易集成的库已经远超<code>Flask</code>了。而且，<strong>据说</strong>，<code>SpringBoot</code>往往在编写的时候一不小心就会从小型练手项目升级为中小型企业及解决方案，因为包括权限管理、安全认证和防火墙等等生态已经非常完善了，而且集成还非常容易；而<code>Django</code>并不会，练手就是练手，不会突然升级为中小型企业级解决方案。</p><p>不过呢，既然是<code>Web</code>开发，所以很多内容实际上和<code>Java</code>是相通的。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><code>Python</code>安装库和<code>NodeJS</code>类似，直接使用命令安装：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用Python3自带的Pip3工具安装工具库</span></span><br><span class="line">pip3 install django <span class="comment"># 使用pip安装django</span></span><br><span class="line">python3 -m django --version <span class="comment"># 查看django版本</span></span><br><span class="line"><span class="comment"># 显示版本就是安装成功</span></span><br><span class="line"><span class="comment"># 在写这篇博客的时候最新的版本是3.1.3，所以理应在执行后显示“3.1.3”</span></span><br></pre></td></tr></table></figure><p>方便吧？</p><p>辣么，我们直接开始吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;你可能是一个&lt;code&gt;Java&lt;/code&gt;工程师，你还可能想和&lt;code&gt;SpringBoot&lt;/code&gt;比划比划。但是呢，&lt;code&gt;Django&lt;/code&gt;在&lt;code&gt;SSM&lt;/code&gt;时代确实是配置少、功能强。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="PythonWeb" scheme="https://sakebow.gitee.io/categories/PythonWeb/"/>
    
    
      <category term="Python" scheme="https://sakebow.gitee.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>证据理论：真相永远只有一个</title>
    <link href="https://sakebow.gitee.io/2020/11/01/%E7%94%B5%E7%BD%91%E7%A0%94%E7%A9%B6/%E8%AF%81%E6%8D%AE%E7%90%86%E8%AE%BA%EF%BC%9A%E7%9C%9F%E7%9B%B8%E6%B0%B8%E8%BF%9C%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA/"/>
    <id>https://sakebow.gitee.io/2020/11/01/%E7%94%B5%E7%BD%91%E7%A0%94%E7%A9%B6/%E8%AF%81%E6%8D%AE%E7%90%86%E8%AE%BA%EF%BC%9A%E7%9C%9F%E7%9B%B8%E6%B0%B8%E8%BF%9C%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA/</id>
    <published>2020-11-01T03:32:00.000Z</published>
    <updated>2020-11-01T03:54:20.265Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>本教程主要参考来自<a href="https://www.bilibili.com/video/BV1hV41117ca/" target="_blank" rel="noopener">B站的【人工智能教程】5.4 - 证据理论</a>视频，在这之上还加入了其他的博客、论文以及针对个人研究方向的见解。</strong></p><a id="more"></a><h2 id="侦探剧？不，是统计学！"><a href="#侦探剧？不，是统计学！" class="headerlink" title="侦探剧？不，是统计学！"></a>侦探剧？不，是统计学！</h2><p>证据理论，英文全拼其实不重要，反正也很少人说。但是他还有个别称，叫做“<strong><code>DS</code>理论</strong>”。这个名称在各种论文中出现的频率非常的高，因为是新单词，所以被当作高端词汇滥用了（<em>捂脸</em>）</p><p>那么，为什么说这个是<strong>统计学</strong>？</p><p>我们先来假设这样一个场景：</p><p>有一天，你带着你的小猫娘上街去玩。本来走着好好的，突然小猫娘在一家冰淇淋车面前停下来了。你看着她那期待的眼神和流口水的小嘴巴，实在不忍心拉着她快速离开，于是你顺着她的眼神瞟过去，发现了很大一张菜单，不仅有不知所云的名字，还有非常诱人的效果图。菜单上有三样：仰望星空、蓝海默默和冰の爱恋。</p><p>好嘛，买嘛。那么她看中的是哪一个呢？名字完全不知所云，估计直接问也不会有结果。那就猜吧！于是，你的脑海中有这么些个结果：（<em>结果以集合形式呈现</em>）</p><ul><li>{仰望星空}</li><li>{蓝海默默}</li><li>{冰の爱恋}</li><li>{仰望星空，蓝海默默}</li><li>{仰望星空，冰の爱恋}</li><li>{蓝海默默，冰の爱恋}</li><li>{仰望星空，蓝海默默，冰の爱恋}</li><li>{不想吃，被五颜六色的图片吸引了}</li></ul><p>嗯……接下来就是该选什么了。我作为她的主人，多少还是了解她的喜好的。于是我又开始对每个选项赋予一定的概率：</p><ul><li>{仰望星空} - 25%</li><li>{蓝海默默} - 20%</li><li>{冰の爱恋} - 15%</li><li>{仰望星空，蓝海默默} - 18%</li><li>{仰望星空，冰の爱恋} - 13%</li><li>{蓝海默默，冰の爱恋} - 8%</li><li>{仰望星空，蓝海默默，冰の爱恋} - 1%</li><li>{不想吃，被五颜六色的图片吸引了} - 0%</li></ul><p>你知道，小猫娘对很神秘的名字是没有任何抵抗力的。所以你觉得“仰望星空”应该是分数最高的；另外，小猫娘还吃不完两个冰淇淋，所以不太可能买两个。难道是今天突然懂事了想给你也买一个？三个那就更离谱了，不想吃是绝对不可能的……呜哇，口水都滴到地上了啊……</p><p>怎么办，好像“仰望星空”这一款是最有希望的。算了，点了。你的小猫看起来很开心。</p><h2 id="背后的统计学原理"><a href="#背后的统计学原理" class="headerlink" title="背后的统计学原理"></a>背后的统计学原理</h2><p>那么我们来分析一下，我们这么选的真正原因。</p><p>小猫娘看到了三个冰淇淋，那就是三个选项。对于这三个选项，我们能够生成一共$2^3=8$种子集，分别是空集$1$个、单元素集合$3$个、双元素集合$3$个、三元素集合$1个$。</p><p>为了方便说明，我们记这$8$个选项为$\Omega$，每一个选项都有一个概率值，我们可以将这个选项和概率之间的关系称作一种“映射”，也就是将它视为函数：$p_i = f(x_i)\in(0, 1), x_i\in\Omega$。这个可以说是根据周边什么信息推理出来的或主观或客观的评价概率。在冰淇淋这个情境中，你心中的$8$个选项对应的概率值就是你的<strong>主观</strong>考虑，如果说是像娃娃机一样设定好的概率那就是<strong>客观</strong>的了。当然，这个概率不是说我们想怎么定义就怎么定义的，而是遵循这些条件：</p><script type="math/tex; mode=display">\left\{\begin{matrix}  f(\phi) &= &0 &\cdots &❶\\  \sum_{x_i\in\Omega}f(x_i) &= &1 &\cdots &❷\end{matrix}\right.</script><p>其实总接下来就是两项：</p><ul><li>空集无概率</li><li>其余和为$1$</li></ul><p>如果同时满足这两个条件，$f(x)$才能够被称作<strong>概率分配函数</strong>，因为恰好完全分配了。</p><p>当然，我们这里的$x$实际上表示一个对象，也就是说，$x$包含了这个对象所有的条件集。有时候我们也写为矩阵形式$\sum_{A\subseteq\Omega}f(A)=1$。而其中的$f(A)$也就是当前环境下对假设集$A$的信任程度。也就是你认为$A$中的条件是不是真的能够成立，成立的概率应该是多少。</p><h2 id="证据成立概率的上限和下限"><a href="#证据成立概率的上限和下限" class="headerlink" title="证据成立概率的上限和下限"></a>证据成立概率的上限和下限</h2><p>到这里，相信大家应该对<code>DS</code>理论有一定的了解了。那么接下来就是纯数学了。</p><p>我们刚刚提到$x\in\Omega$，其中如果还加上一个条件：$x$的取值相互独立，那么$\Omega$的所有子集就可以称作幂集，记为$2^\Omega$。也就是像给小猫娘麦冰淇淋一样，只能是$8$种相互独立的可能；而如果说是两只双胞胎猫娘，姐姐选了之后妹妹选同样的冰淇淋概率非常高，这就是对另一种可能产生了影响，也就不相互独立。</p><p>如果说，$A$代表单元素集合，那么$f(A)$就是对于假设条件$A$的精确信任度；如果$A$代表多元素集合，$f(A)$则仅代表整体信任度，每个假设条件的信任度并不精确，若$A=\Omega$也是同样的。对于这一点，我们用数学语言表示就是：</p><script type="math/tex; mode=display">对于任意的A\subseteq\Omega，记B\subseteq{A}，有Bel(A)=\sum_{B\subseteq A}f(B)</script><p>听起来绕口？无所谓啦。总之这句话的意思就是：当$A$为多元素集合的时候，记$Bel(A)$为$A$中<strong>所有子集</strong>的精确信任度之和。这个$Bel(A)$也可以称作<strong>下限函数</strong>。</p><p>除了这些，还有<strong>似然函数</strong>，同样是在集合$A$是幂集的前提下，具体表示为：</p><script type="math/tex; mode=display">对于\forall A\subseteq\Omega，s.t.\rightarrow Pl(A)=1-Bel(\bar{A})，其中\bar{A}=\Omega-A</script><p>可以看到，这里多了一个<strong>取反</strong>的操作，所以这里讨论的也就不是集合$A$的精确信任度，而是$A$的<strong>非假信任度</strong>。同样的，相对于被称为<strong>下限函数</strong>的$Bel(A)$，$Pl(A)$也就被称为<strong>上限函数</strong>或者<strong>不可驳斥函数</strong>。听起来很让人摸不着头脑不是么？明明都有了真实的精确信任度，偏偏还要弄个非假的信任度，这不是折腾？</p><p>只能说，这是另一种求法，可以用在完全没有办法或者说靠人计算实在太麻烦的情况下。比如，你想带着你家里的所有猫娘出去逛街，但是每只猫娘的性格都不太一样，所以需要确定一个地点<strong>至少有一只猫娘愿意去</strong>。估计算到一半你就觉得太难了。所以改变思路：<strong>没有猫娘愿意去</strong>。听起来很不错？但是，还是有一个小小的弊端。因为我们用这个方法求出来的是<strong>非假信任度</strong>，也就是肯定为真的部分加上只能保证不假的部分的和。虽然绝对可以保证不是假的，但是有多少能确定是真的呢？如果精确部分很难算的话，这就真的一点都不知道了，完全决定不了该带猫娘们去哪。</p><p>那么<strong>上下限和现实感觉有什么联系</strong>？只能这么说：当上限$Pl(A)=1$，下限$Bel(A)=0$的时候，我们就会在现实生活中觉得：<strong>我们对这件事一无所知</strong>，因为<strong>任何事</strong>发生的概率都是$[0,1]$。</p><p>那么上限和下限有什么关系吗？从<strong>数学</strong>上来说，有的。信任函数和似然函数有以下几点性质：</p><script type="math/tex; mode=display">\left\{\begin{matrix}  Bel(\phi) &= &Pl(\phi) &= &0 \\  Bel(\Omega) &= &Pl(\Omega) &= &1\\\end{matrix}\right.</script><script type="math/tex; mode=display">若有A\subseteq B，则有\left\{\begin{matrix}  Bel(A) &\leq &Bel(B)\\  Pl(A) &\leq &Pl(B)\end{matrix}\right.</script><script type="math/tex; mode=display">对于\forall A\subseteq\Omega，s.t.：\left\{\begin{matrix}  Pl(A) &\ge &Bel(A)\\  Pl(A)+Pl(\bar{A}) &\ge &1\\  Bel(A)+Bel(\bar{A}) &\le &1\end{matrix}\right.</script><h2 id="证据组合"><a href="#证据组合" class="headerlink" title="证据组合"></a>证据组合</h2><p>单个证据基本上就是这些了。接下来难度升级：多个证据组合。</p><p>对于两个不同的概率分配函数$f(x)$和$g(x)$，正交和$h(x)=f(x)\bigoplus g(x)$满足：</p><script type="math/tex; mode=display">\left\{\begin{matrix}  h(\phi) &= &0\\  h(A) &= &\frac{\sum_{x\cap y=A}f(x)\times g(y)}{1-\sum_{x\cap y=\phi}f(x)\times g(y)} &= &\frac{\sum_{x\cap y=A}f(x)\times g(y)}{\sum_{x\cap y\neq\phi}f(x)\times g(x)}\end{matrix}\right.</script><p>看起来头大？只能死记硬背了。我们唯一能做的就是把$h(A)$的分母提取出来：</p><script type="math/tex; mode=display">K=1-\sum_{x\cap y=\phi}f(x)\times g(y)=\sum_{x\cap y\neq\phi}f(x)\times g(x)</script><p>对于这个$K$，我们还有一个小小的判定：</p><script type="math/tex; mode=display">\left\{\begin{matrix}  if &K &\neq &0，then：&正交和h(x)也是概率分布函数\\  if &K &= &0，then：&h(x)不存在，f(x)与g(x)矛盾\end{matrix}\right.</script><p>这个在多个条件下的混合判定更有用。</p><p>拿视频中的例子说明吧。你现在正流鼻涕，眼睛还有点点红。于是你问了你的医生朋友，说道：</p><ul><li>如果流鼻涕，九成会是感冒但不是过敏性鼻炎；</li><li>如果眼睛红了，八成会是过敏性鼻炎而不是感冒。</li></ul><p>这就是<strong>规则</strong>。那么你的情况就是这样的，也就是<strong>样本空间</strong>：</p><ul><li>{没病} - 也就是我们所说的空集$\phi$</li><li>{感冒}</li><li>{过敏性鼻炎}</li><li>{又是感冒又是过敏性鼻炎}</li></ul><p>于是，你将每一块都拉出来分析，最终发现你<strong>就是感冒</strong>，<strong>不是过敏性鼻炎</strong>。</p><h2 id="证据理论在电网中的应用"><a href="#证据理论在电网中的应用" class="headerlink" title="证据理论在电网中的应用"></a>证据理论在电网中的应用</h2><p>说了这么多，就该说说实际中的应用了吧。</p><p>说白了，证据理论依然是使用非常多的机器学习算法对海量的用户数据进行分析，并作出分类与预测这两个动作，本质上依然是一种机器学习。</p><p>实际中，我们可以使用证据理论预判哪条路在什么时候容易堵车、哪些设备在经过怎么样的使用之后会在什么时候损毁，甚至还能够进行心理预测、军事战场动向、信息安全主动防御等等。如果你曾经看过我的<a href="/2020/10/28/电网研究/态势感知：我预判了你的预判！">态势感知</a>，你会发现这些应用方向和态势感知的内容<strong>重复率相当高</strong>。实际上态势感知只是一个方向，而<code>DS</code>理论则是一个<strong>相对比较实际的方法</strong>来感知事物的态势。</p><p>那么在电网中呢？我们可以使用证据理论来预判在什么季节哪个小区的用电非常高、哪个片区的故障概率非常高。<strong>在发生停电之前</strong>，我们就能够使用这些预测信息来给用户发送预警，防止用户在洗热水澡、写文档、电压力锅煲羊肉汤的时候突然断电。当然，在信息推送的时候还是要保证<strong>概率下限都足够高</strong>的时候才推送，否则很多误报就会像狼来了一样，让用户丧失信心。</p><p>是不是有点能理解了呢？</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本教程主要参考来自&lt;a href=&quot;https://www.bilibili.com/video/BV1hV41117ca/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;B站的【人工智能教程】5.4 - 证据理论&lt;/a&gt;视频，在这之上还加入了其他的博客、论文以及针对个人研究方向的见解。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="人工智能" scheme="https://sakebow.gitee.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
      <category term="论文研究" scheme="https://sakebow.gitee.io/tags/%E8%AE%BA%E6%96%87%E7%A0%94%E7%A9%B6/"/>
    
  </entry>
  
  <entry>
    <title>态势感知：我预判了你的预判！</title>
    <link href="https://sakebow.gitee.io/2020/10/28/%E7%94%B5%E7%BD%91%E7%A0%94%E7%A9%B6/%E6%80%81%E5%8A%BF%E6%84%9F%E7%9F%A5%EF%BC%9A%E6%88%91%E9%A2%84%E5%88%A4%E4%BA%86%E4%BD%A0%E7%9A%84%E9%A2%84%E5%88%A4%EF%BC%81/"/>
    <id>https://sakebow.gitee.io/2020/10/28/%E7%94%B5%E7%BD%91%E7%A0%94%E7%A9%B6/%E6%80%81%E5%8A%BF%E6%84%9F%E7%9F%A5%EF%BC%9A%E6%88%91%E9%A2%84%E5%88%A4%E4%BA%86%E4%BD%A0%E7%9A%84%E9%A2%84%E5%88%A4%EF%BC%81/</id>
    <published>2020-10-28T00:43:00.000Z</published>
    <updated>2020-11-01T03:33:56.094Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>态势感知的英文是<code>Situation Awareness</code>，所以有些情况下也会被简写为<code>SA</code></strong></p><a id="more"></a><h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>“态势感知”，单单分析这个名词，大概就是“使用某种方法感知态势”。</p><blockquote><p>态势，即事物发展的形势及状态。</p><p>——<a href="https://baike.baidu.com/item/态势/11045952" target="_blank" rel="noopener">百度百科【态势】</a></p><p>态势感知是感知大量的时间和空间中的环境要素，理解他们的意义，并预测他们在不久将来的状态</p><p>——<a href="https://blog.csdn.net/wyqwilliam/article/details/82596594" target="_blank" rel="noopener">对网络安全态势感知的理解和认识</a></p><p>一种不可预测的、多方面情况的不断更新的、有意义的知识，操作人员在参与实时多任务时可以用该知识来指导选择和行动。</p><p>——摘自：石乐义,刘佳,朱红强,段鹏飞.网络安全态势感知研究综述[J].计算机工程与应用.2019,55(24):1-9.</p></blockquote><p>那么也就是说，我们需要<strong>运用某种方法感知事物的发展形势以及状态，而其目的就是预测，并为最终的决策提供参考</strong>。</p><p>当然，凭借常人的理解，如果是“<strong>感知</strong>”，那么目的绝对就是<strong>预测</strong>了，也就必然在最后做决定的时候提供参考。但是呢，既然是高端的学术，我们不能这么简单地概括为“<strong>预测</strong>”，我们还应当把周边的其它东西也介绍一下。因为这个<strong>感知</strong>同样是一个小型生态，包括了提取信息、理解信息和预测未来三个方向。接下来我们就开始详细展开这个“<strong>感知</strong>”了。</p><blockquote><p><img src="https://sakebow.gitee.io/images/电网/JSGG201924002_02800.jpg" alt="态势感知"></p><p>——摘自：石乐义,刘佳,朱红强,段鹏飞.网络安全态势感知研究综述[J].计算机工程与应用.2019,55(24):1-9.</p></blockquote><h2 id="态势感知的子类展开"><a href="#态势感知的子类展开" class="headerlink" title="态势感知的子类展开"></a>态势感知的子类展开</h2><p>态势要素提取，实际上就是收集电网中海量的传感器数据，并使用特定的机器学习算法处理这些数据。在这个部分主要是收集数据，使用报表、日志、第三方数据存储系统等各种各样的方法保存真实数据。这个时候你拿到的无非就是一大堆杂七杂八的文件，还有各式各样的报表，以及乱七八糟的日志。是不是觉得还没开始就头大了？万事开头难嘛（虽然后面也不简单）</p><p>态势理解，听起来像是只有人脑才可以做到的数据理解，就像是军事里面的态势理解一样让人琢磨不透。实际上，所谓理解不过是解读数据背后的含义，实际上就是使用机器学习算法对特定的业务数据分析。刚刚我们在要素提取的时候拿到了非常多杂七杂八的数据不是嘛，我们的任务就是在杂七杂八的数据中筛选出和当前研究方向契合度最高的几个变量，然后筛除一些偏差值很大的数据，最终开始使用机器学习算法针对我们研究的方向进行拟合。这个估计就是整个环节中最繁琐的地方了，相当于秘书一样，要把开完会拿到的所有文件整理分类上报。</p><p>态势预测，这个词在理解上就相对较容易。顾名思义，态势预测就是预测事物的发展形势。那么，我们在经过了态势要素提取（或者说整体数据的分类）、态势理解（或者说专项数据的进一步分析）之后，我们应该做到了降维、降噪、建模三件事。然后则是套用模型来预测特定条件下的特殊结果，并对以后的决策提供参考。这一步也有人愿意称作“对未来状态的映射”。</p><h2 id="举例说明态势感知"><a href="#举例说明态势感知" class="headerlink" title="举例说明态势感知"></a>举例说明态势感知</h2><p>举个简单的例子来说明这整个态势感知的过程吧。</p><p>首先，还是你的收集的20万猫娘的数据，给你家的那只小猫娘提供一点点参考。</p><p>你凭借着你的热爱，成功找出了20万只猫娘的健康状态和身体情况。在这里，你发现了一些特点，比如健康状况良好的猫娘会有各种各样的表现，无一例外的表现出粘人的特点和对主人的浓厚兴趣；而还有感冒等小病的猫娘则有各种各样的反映，并没有统一的共性。一整套流程下来，我们就得出了一份份文件记录这些猫娘的很多信息。这个过程就是态势要素提取。</p><p>当然，你并不满足。于是你针对各种各样的病症开始了各种各样的分析，比方说眼睛红、有气无力、呼吸声音很重等等。虽然这可不是人能够完成的事情，但你还是凭着你的热情，一半人力一半计算机辅助地筛除了一只活到现在都没有得过病的猫娘数据，并得出了关于猫娘生病的一些普适性的公式，也就是症状与病症的映射。这个过程就是态势理解。</p><p>最后，你在和你家的小猫娘生活的时候，你发现了小猫娘出现了很类似你之前收集过的某种特征，于是你立马把对照表拿了出来，一一比对。最后，你发现你的小猫娘很可能是患了感冒，于是喂她吃了些对症的药，好好地陪了她一整天。这个过程就是态势预测。</p><p>第二天她又生龙活虎的了，粘着你不放。</p><h2 id="态势感知的应用"><a href="#态势感知的应用" class="headerlink" title="态势感知的应用"></a>态势感知的应用</h2><p>由于态势感知是从提取，到理解，最后是预测的系统级应用，从过程上来看似乎是“<strong>自上而下</strong>”、“<strong>自顶向下</strong>”的架构。所以，这种技术现阶段往往是规模非常庞大的系统或者是不计成本的系统中才会使用的数据中台，比如大型企业数据中台或者政府平台以及军事平台。</p><p>既然是最终目的为预测和决策的中台，那么可以很肯定的说，这个玩意就是为了将来的<strong>战场动向预测</strong>而作准备，其次便是为<strong>异常状况预警</strong>、可以预测的<strong>数据的预报</strong>等等辅助预测而作的准备，再进一步准备就是<strong>自动化生态的建设</strong>，最后就是像是<strong>股市的预测</strong>一样辅助决策。</p><p>最开始态势感知是用于军事领域的，然后逐渐在网络安全上铺开，因为是预测攻击对象和攻击手段然后进行预警和自动防御。之后便在多种多样的小细节上加以细化，也就变成了现在的一些自动化系统，也就是现在的电网系统，通过海量的数据来预测未发生故障、定位已发生故障等等方面。</p><h2 id="态势感知研究现状"><a href="#态势感知研究现状" class="headerlink" title="态势感知研究现状"></a>态势感知研究现状</h2><p>根据中国知网的数据，有关态势感知的论文在<strong>2019</strong>年一共<strong>886</strong>篇，而自然语言处理相关论文在2019年已经达到了<strong>1522篇</strong>的，是态势感知的<strong>2</strong>倍。其中主要是有关网络安全的态势感知的论文共<strong>286</strong>篇，其次是有关电网的态势感知的论文共67篇，再就是有关军事的战场动向的论文<strong>49</strong>篇。可以看出，态势感知相对来说现在正在研究的人并不是非常多，有关电网的研究更是少之又少。</p><p>国外对于态势感知则是从<strong>1999</strong>年首次提出，到现在已经有了20年的发展，相对来说非常成熟。而国内则是从<strong>2009</strong>年首次提出，发展少10年而且发展方向非常受限，直到现在态势感知的主力军也只是局限于网络安全方面的研究。</p><p>是不是有点能理解了呢？</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;态势感知的英文是&lt;code&gt;Situation Awareness&lt;/code&gt;，所以有些情况下也会被简写为&lt;code&gt;SA&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="人工智能" scheme="https://sakebow.gitee.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
      <category term="论文研究" scheme="https://sakebow.gitee.io/tags/%E8%AE%BA%E6%96%87%E7%A0%94%E7%A9%B6/"/>
    
  </entry>
  
  <entry>
    <title>智能微电网</title>
    <link href="https://sakebow.gitee.io/2020/10/11/%E7%94%B5%E7%BD%91%E7%A0%94%E7%A9%B6/%E6%99%BA%E8%83%BD%E5%BE%AE%E7%94%B5%E7%BD%91/"/>
    <id>https://sakebow.gitee.io/2020/10/11/%E7%94%B5%E7%BD%91%E7%A0%94%E7%A9%B6/%E6%99%BA%E8%83%BD%E5%BE%AE%E7%94%B5%E7%BD%91/</id>
    <published>2020-10-11T00:43:00.000Z</published>
    <updated>2020-11-01T03:32:36.315Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>微电网，听起来就像是微服务一样，总觉得和<code>SpringCloud</code>、模块化、可插拔的灵活架构有关。</strong></p><a id="more"></a><h2 id="微电网"><a href="#微电网" class="headerlink" title="微电网"></a>微电网</h2><p><strong>微电网</strong>和<strong>电网</strong>有一定的区别。</p><blockquote><p>电力系统中各种电压的变电所及输配电线路组成的整体，称为<strong>电力网</strong>。它包含<strong>变电</strong>、<strong>输电</strong>、<strong>配电</strong>三个单元。电力网的任务是输送与分配电能，改变电压。</p><p>——百度百科【<a href="https://baike.baidu.com/item/电网/1250763" target="_blank" rel="noopener">电网</a>】</p></blockquote><p>也就是说，电网只是单纯的一张<strong>网</strong>，电厂、工厂、公司、家庭等等就像是网中的一个<strong>节点</strong>，节点之间依靠各种电线、变电器、配电器等等<strong>相互连接</strong>。这就是日常生活最普遍的基本电力网络，<strong>单纯供电用网络</strong>。但也正是这个电力网络，是中国现今<strong>特高压坚强电网</strong>的基石，也是“基建狂魔”背后的重要支撑。</p><p>那么<strong>微电网</strong>又是什么呢？</p><blockquote><p>微电网（Micro-Grid）也译为微网，是指由<strong>分布式电源</strong>、<strong>储能装置</strong>、<strong>能量转换装置</strong>、<strong>负荷</strong>、<strong>监控</strong>和<strong>保护装置</strong>等组成的<strong>小型发配电系统</strong>。</p><p>——百度百科【<a href="https://baike.baidu.com/item/微电网/568036" target="_blank" rel="noopener">微电网</a>】</p></blockquote><p>看起来这个说明相较于电网更高端？但是我们来提取关键字：“<strong>小型发配电系统</strong>”，也就是说微电网只是单纯的体量小一些，<strong>本质还是电网</strong>。</p><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><p>如果你以前是Java工程师，那么你应该对<strong>微服务</strong>有所了解。</p><p>由于一台机器的负载能力和处理能力是非常有限的，所以将一整个项目拆分成多个模块，每个模块使用一台机器发布服务，这样整个项目的处理能力和负载能力就明显提高了。而<strong>微服务</strong>的核心，就是<strong>分布式</strong>。</p><p>打个比方，你一直照顾你们家好多只猫娘的一日三餐。但是你的钱再怎么也不够花一年，所以除了一日三餐你还得工作。虽然非常累的时候有猫娘能治愈你的内心，但这也不是办法。</p><p>于是你决定让一些听话懂事的猫娘帮你做饭。比如，大姐帮你剁肉、二姐帮你择菜、最有活力的几个出去购物等等。每只猫娘都在整个做饭过程中都帮了一小部分忙，这样你每天也轻松多了。</p><p>这就是微服务，分解、解耦、各司其职，<strong>分布式</strong>就是最核心的部分。</p><h2 id="微电网和微服务"><a href="#微电网和微服务" class="headerlink" title="微电网和微服务"></a>微电网和微服务</h2><p>同样的，<strong>微电网</strong>也适用于这样的解释。</p><p>微电网由各种分布式的装置，将各个<strong>小规模</strong>的储能装置联合起来形成<strong>大容量</strong>的储能厂；同时保护装置、负荷装置、能量转换装置以及监控保护装置都能够使用<strong>较小型</strong>的设备，减小了开支；同时分布式的架构也能够轻松实现模块的新增和删除，即分布式设备的<strong>即插即用</strong>；不仅如此，分布式的电源能够使得<strong>多种完全不同的发电装置</strong>有了合并的可能，比如风能、太阳能、潮汐能等新兴的新能源发电技术；再加上，地形复杂的西部地区，发电装置难以互联、用电之处远在东南，分布式更适合这种<strong>复杂的地理环境</strong>，更不用说像南海诸岛这样甚至无法架设地面缆线的<strong>极端地形</strong>……可以说是具有相当多的便利了。</p><p>当然，有方便之处当然也就有麻烦之处。</p><blockquote><p>在高并发分布式的场景下，故障经常是突然间就<strong>雪崩式爆发</strong>。所以必须建立完善的监控体系，尽可能发现故障的征兆。</p><p>——知乎<strong>老刘</strong>对<a href="https://www.zhihu.com/question/65502802" target="_blank" rel="noopener"><strong>什么是微服务架构</strong></a>的回答（一楼）</p></blockquote><p>由于<strong>微服务</strong>是由各个模块相互之间交流构成的，所以往往出现错误之后虽然能够补救，却难定位。错误在开发过程中很难预测，往往在开发中就只是用一个统一错误处理草率解决；不仅如此，一旦微服务架构中某个模块出错甚至可能导致整个系统雪崩。所以定位错误有些困难，处理和解决错误也难。<strong>微电网也不例外</strong>。分布式的微电网在故障检测的时候往往要消耗更大的代价。大量的传输线、变压器、配电器，使得监测代价提升了不止一倍；更何况，雪崩之后不知道会发生什么事故，甚至会有工作人员伤亡的可能。</p><p>万事万物都是矛盾的，微电网也是。但是，考虑到将来带来的方便，这些缺点无论如何都是要硬着头皮克服了。</p><h2 id="现存的微电网标准"><a href="#现存的微电网标准" class="headerlink" title="现存的微电网标准"></a>现存的微电网标准</h2><h3 id="美国"><a href="#美国" class="headerlink" title="美国"></a>美国</h3><p>对于美国地广人稀的特点，部分远郊地区供电成本过大，分布式电网确实比较适合；而华盛顿、曼哈顿等大城市却又是用电量超越想象，分布式电网也拥有较大的负载和能量储存系统，也是不错的选择。</p><blockquote><p>而美国CERTS定义的微电网要设计成当主电网发生故障时微电网与主电网无缝解列或成孤岛运行，一旦故障去除后便可与主电网重新连接。这种微电网的优点是它在与之相连的配电系统中被视为一个自控型实体，保证重要用户电力供应的不间断，提高供电的可靠性，减少馈线损耗，对当地电压起支持和校正作用。</p><p>——百度百科【<a href="https://baike.baidu.com/item/微电网/568036" target="_blank" rel="noopener">微电网</a>】</p></blockquote><p>可以看到美国对于微电网的要求是具有高灵活度的“热插拔”，也就是分布式模块中的某一个模块坏掉了之后能够立马像火箭一样脱离整体，保证其他地区用电的同时将故障区域隔离开，方便之后的检修。这也是体现了美国使用科技解放人力的主旨。</p><h3 id="欧盟"><a href="#欧盟" class="headerlink" title="欧盟"></a>欧盟</h3><p>而欧洲因为起步较早，已经有了相应的气候，整个电网生态的诸多理论已有苗头。另外，相应的，欧盟国家的多个地区为了更好的发展，也一直在互相帮助，高度工业化的欧洲国家也就在互相帮助中有了完全不同的技术与规范。</p><blockquote><p>欧洲提出要充分利用分布式能源、智能技术、先进电力电子技术等实现集中供电与分布式发电的高效紧密结合，并积极鼓励社会各界广泛参与电力市场，共同推进电网发展。微电网以其智能性、能量利用多元化等特点也成为欧洲未来电网的重要组成。欧洲已初步形成了微电网的运行、控制、保护、安全及通信等理论，并在实验室微电网平台上对这些理论进行了验证。其后续任务将集中于研究更加先进的控制策略、制定相应的标准、建立示范工程等。即，为分布式电源与可再生能源的大规模接入以及传统电网向智能电网的初步过渡做积极准备。</p><p>——百度百科【<a href="https://baike.baidu.com/item/微电网/568036" target="_blank" rel="noopener">微电网</a>】</p></blockquote><p>可以看出，欧洲对于电网的主旨便是像以前的苏联一样，各司其职、物尽其用。另外，已经高度工业化、甚至开始去工业化的欧洲地区，对于电网的另一个考虑就是可再生的清洁能源。</p><h3 id="日本"><a href="#日本" class="headerlink" title="日本"></a>日本</h3><p>了解世界地图的人应该都知道，日本这个弹丸之地资源非常有限，需求却始终随着时代的发展不停上涨。所以日本的主题更偏向能源多样化。</p><blockquote><p>微电网是指在一定区域内利用可控的分布式电源，根据用户需求提供电能的小型系统。</p><p>东京大学给出的定义：微电网是一种由分布式电源组成的独立系统，一般通过联络线与大系统相连，由于供电与需求的不平衡关系，微电网可选择与主网之间互供或者独立运行。</p><p>三菱公司给出的定义：微电网是一种包含电源和热能设备以及负荷的小型可控系统，对外表现为一整体单元并可以接入主网运行；并且将以传统电源供电的独立电力系统也归入为微电网研究范畴，大大扩展了美国CERTS对微电网的定义范围。</p><p>——百度百科【<a href="https://baike.baidu.com/item/微电网/568036" target="_blank" rel="noopener">微电网</a>】</p><p>日本微电网的架构允许燃气轮机等旋转发电设备直接接入到微电网同步运行，目前，日本的微电网研究集中在负荷跟踪能力、电能质量监控、电力供需平衡、经济调度以及孤岛稳定运行等方面。</p><p>——中国储能网【<a href="http://www.escn.com.cn/news/show-187504.html" target="_blank" rel="noopener">日本微电网项目介绍</a>】</p><p>在Hachinohe的微电网展示项目中，目标主要集中在研究间歇的可再生能源发电对微电网控制的影响，分布式电源包括：PV、小型风力机和生物质能发电。</p><p>——中国储能网【<a href="http://www.escn.com.cn/news/show-187504.html" target="_blank" rel="noopener">日本微电网项目介绍</a>】</p></blockquote><p>可以看到，因为资源非常有限，能源来源非常多样，分布式储能系统正好应对了多种能源来源；同时，多样的能源转化、灵活的配电系统，能够让日本针对各种各样的场景进行灵活的升降配。但是，日本却<strong>没有</strong>将设备的<strong>即插即用</strong>考虑进电网之中，具体原因无可考证。但是分布式电源的多样化却做的非常认真，也算是在具有日本特色的发展时代中有所偏重。</p><h2 id="我国的微电网现状"><a href="#我国的微电网现状" class="headerlink" title="我国的微电网现状"></a>我国的微电网现状</h2><p>一些发达国家已经先走一步了，现在已经有了略高于我们的成就。但是，毕竟我们有着大量的测试用户（<em>14亿人</em>）、大量的复杂地形（<em>从高原到盆地一应俱全</em>）和大量的刁钻使用方式（<em>从日常使用到工业控制，甚至从军事用电到黑市挖矿</em>），我们若是一一攻克，说不定还有再重大技术上超越发达国家的可能，就比如现如今的音媒体和电子支付已经是远远超过任何一个国家了。当然这也只是我单纯的猜想和内心的希望。</p><p>说点实际的吧。</p><blockquote><p>从2017年开始，国家标准和能源局的文件里已经开始正式把这个定义明确，上升到国家标准层面或者是上升到国家政策层面，在标准里面规定微电网是指由分布式发电、用电负荷、监控、保护和自动化装置等组成的，是一个能够基本实现内部电力电量平衡的小型供电系统，微电网分为并网型微电网和独立型微电网。在2017年能源局发的文件里面，对这个定义也做了进一步的明确，基本上也是比较类似的表述。</p><p>——搜狐网：<strong>国电阳光</strong>【<a href="https://www.sohu.com/a/236529823_100005941" target="_blank" rel="noopener">微电网技术当前现状及未来发展趋势</a>】</p></blockquote><p>可以看到，2017年国家开始重视微电网，并制定了国家层面的标准与规范。事实上，中国在最近5年间已经几近完成了“坚强电网”，所以对于普通民众来说普通电网和微电网并没有什么特别大的差别。但是在石油无法自给自足、甚至还被其他国家左右命运的时代中，可再生的新能源迫在眉睫；同时为了弥补新能源供能尚且不足以超过石油的缺点，多个发电厂联合功能、统一管理也是为了整个电网的安全和稳定不得不作出的考虑。</p><p>当然，高层还做出了更远的考虑。</p><blockquote><p>两大电网公司在今年初都相继提出要向综合能源供应上转变，怎么将电力、燃气、水务、热力等多种资源捆绑成一种资源，实现彼此耦合，解决有关能源的有效利用和调峰的问题，这是微网要解决的问题，当然这也是我们电网公司发展的一个重要的机遇。</p><p>——搜狐网：<strong>国电阳光</strong>【<a href="https://www.sohu.com/a/236529823_100005941" target="_blank" rel="noopener">微电网技术当前现状及未来发展趋势</a>】</p></blockquote><p>可以想象，未来肯定是将会统一管理的。若是发展到了足够优秀的地步，也是能够一切按照各种仪器设备和各类管理系统进行统一的管理，“一条龙服务”的方便未来似乎近在眼前了，不再因为石油危机担忧的未来也不远了，甚至就连一带一路沿线的所有经营点、合作国都将用上这样方便的微电网，逐步走向合作共赢、实现人类命运共同体。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;微电网，听起来就像是微服务一样，总觉得和&lt;code&gt;SpringCloud&lt;/code&gt;、模块化、可插拔的灵活架构有关。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="电网" scheme="https://sakebow.gitee.io/categories/%E7%94%B5%E7%BD%91/"/>
    
    
      <category term="论文研究" scheme="https://sakebow.gitee.io/tags/%E8%AE%BA%E6%96%87%E7%A0%94%E7%A9%B6/"/>
    
  </entry>
  
  <entry>
    <title>数据中台是什么</title>
    <link href="https://sakebow.gitee.io/2020/10/11/%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0/%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>https://sakebow.gitee.io/2020/10/11/%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0/%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0%E6%98%AF%E4%BB%80%E4%B9%88/</id>
    <published>2020-10-11T00:43:00.000Z</published>
    <updated>2020-11-01T03:32:31.123Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>现在，“数据中台”这个概念越来越火，但是数据中台到底是什么，服务对象是谁，目标又是什么？</strong></p><a id="more"></a><h2 id="数据中台的概念"><a href="#数据中台的概念" class="headerlink" title="数据中台的概念"></a>数据中台的概念</h2><blockquote><p>数据中台被誉为大数据的下一站，由阿里兴起，核心思想是数据共享，并在 2018 年因为“腾讯数据中台论”再度成为了人们谈论的焦点。</p><p>——CSDN：<strong>VIP_CQCRE</strong>：【<a href="https://blog.csdn.net/cqcre/article/details/96935800" target="_blank" rel="noopener">到底什么是数据中台？</a>】</p><p>数据中台是对既有/新建信息化系统业务与数据的沉淀，是实现数据赋能新业务、新应用的中间、支撑性平台。</p><p>——百度百科【<a href="https://baike.baidu.com/item/数据中台/53067001" target="_blank" rel="noopener">数据中台</a>】</p></blockquote><p>确实，数据中台只是近些年火起来的名词。而且“数据中台”这个词语，听起来就像是和“<strong>数据</strong>”和“<strong>中</strong>”有很大的关系，似乎就是<strong>中间件</strong>+<strong>大数据</strong>。虽然目前还没有一个定义来确定这个词语到底是指代什么，但是很明显的是，这个词语就是为了<strong>数据</strong>和<strong>中间处理</strong>而存在的。</p><p>既然这个技术涉及数据，那么这个技术将不可能外包给其他的什么公司或者个人。虽然非常无奈，但是物理隔绝确实能保证秘密不会被传播。所以，比起<code>SpringCloud</code>、<code>Odoo</code>、<code>GoodERP</code>等这些个框架，还是不能够随意售卖、转让或者开源。</p><p>那么数据中台到底是什么？</p><blockquote><p><strong>数据中台是一套可持续“让企业的数据用起来”的机制，一种战略选择和组织形式，是依据企业特有的业务模式和组织架构，通过有形的产品和实施方法论支撑，构建一套持续不断把数据变成资产并服务于业务的机制。</strong></p><p>——知乎：<strong>Alan</strong>：【<a href="https://zhuanlan.zhihu.com/p/99591075" target="_blank" rel="noopener">数据中台（一）什么是数据中台</a>】</p><p><strong>数据中台是在政企数字化转型过程中，对各业务单元业务与数据的沉淀，构建包括数据技术、数据治理、数据运营等数据建设、管理、使用体系，实现数据赋能。数据中台，是新型信息化应用框架体系中的核心。</strong></p><p>——百度百科【<a href="https://baike.baidu.com/item/数据中台/53067001" target="_blank" rel="noopener">数据中台</a>】</p><p>中台是一种经营理念；中台是一种组织形式；中台是“平台思维”的自然演进</p><p>——节选自<a href="https://bilibili.com/BV1F741177R9" target="_blank" rel="noopener">第十届全球软件开发大会：菜鸟数据中台的演讲</a></p></blockquote><p>看起来还是有点深奥。而且越来越多的专业词汇让你感觉到更摸不着头脑了！</p><p>让我们来看看知乎：<strong>Alan</strong>：【<a href="https://zhuanlan.zhihu.com/p/99591075" target="_blank" rel="noopener">数据中台（一）什么是数据中台</a>】中附上的图片：</p><p><img src="https://pic4.zhimg.com/80/v2-62e4ca86b5cc1ca51e99bd115d460e6f_720w.jpg" alt="数据中台的架构图"></p><p>到这里，基本上就对数据中台有一个概念了：</p><p><strong>数据中台实际上是企业在对用户行为进行分析时，为了将用户数据最大化利用的平台。</strong></p><p>那么，什么是最大化利用？（<em>注：因为科技能力限制，所以每个时代都有每个特定的最大化限制</em>）</p><p>举个例子，在很早之前，甚至电商还没有起步的时候，你的小蛋糕店（<del><em>La Soleil</em></del>）都是<strong>通过你自己的大脑记住常客的偏好</strong>来选取顾客最喜欢的口味。</p><p>但是，你的猫娘女仆们实在太可爱了，为你吸了大量的粉，生意很快做起来了，不光是为了蛋糕，还有为了猫娘慕名前来的顾客，甚至还有预定的顾客，你越来越忙不过来了。所以，你用你超强的代码能力，做了个<strong>推荐系统</strong>出来。用户注册之后，系统便会记录每一次下单的偏好特点，并<strong>制作适当的模型进行预测</strong>。用户再次下单时，就能看到自己的偏好摆在首页上，非常方便。</p><p>这时，你的妹妹（<del><em>这即视感太强烈了啊喂</em></del>）当起了你的蛋糕店的公关，开始推广、联动，甚至积极出周边，很快做出了蛋糕店以上的很多服务。你的小蛋糕店规模现在已经不得了了，甚至歪果仁都慕名而来，推荐系统的日活甚至超过了10万。于是，<strong>你决定将小作坊升级为大企业</strong>。这个转变并不容易，所以你想到了数据中台。你希望数据中台为你完成这些任务：</p><ul><li>你一个人再也没有那么多精力制作那么多的蛋糕了，所以你雇用了很多特级厨师，不仅要做蛋糕，还要做出法式、意式、英式、中式、日式等等特色；别忘了雇佣采购员和外送员，你们家的猫娘忙着照顾客人，才没有时间出去跑腿呢。数据中台就帮助你完成企业中各角色的上下班打卡、每日食品产出、请假、评级等等的人员管理。<strong>这是企业员工管理</strong>；</li><li>你的蛋糕店的各种原材料库存得严格把关了。糖每天都有多少、奶油每天还有多少、各种水果罐头每天还有多少……低于某一个阈值的时候发短信、发邮箱进行预警。这是企业库存管理；</li><li>你的蛋糕店的各种用户数据都应当记录，并且针对客户的各种订单进行偏好预测；同时，还要能够接收客户对于各种地方的吐槽，并且积极回复、处理、反馈。<strong>这是企业客户管理</strong>；</li><li>为了高效制作蛋糕，机器肯定不能少。搅拌机、烘烤机等等全部都要有一个管理，比如哪个设备正在运作、经过了多长时间的连续运转、下次损坏是多久之后等等；不仅如此，部分简单劳动可以使用机器集群完成，一旦集群中某一个坏掉了便需要紧急绕开损毁机器并选择其他运行方案。<strong>这是企业设备管理</strong>；</li><li>在完成基本的用餐之后，你的妹妹还需要处理各种联动企划、手办设计和各大平台的推广，于是需要记录各种各样的合作安排与合作绩效，并从中选出最有前景的几家进行长期合作。<strong>这是企业合作管理</strong>；</li><li>……</li></ul><p>听起来这完全就像是一个很普通的<code>ERP</code>系统？不不不，<strong>远没有这么简单</strong>。细心的你应该能注意到这些事情：</p><ul><li>在<strong>人员管理</strong>中，你可以使用<strong>大数据</strong>对现在的员工进行分析，他们是有什么样的特殊属性才能够成为企业中最优秀的几个员工，下次招聘的时候就按照这个标准进行招聘，从而让自己的员工逐年精进；</li><li>在<strong>库存管理</strong>中，你可以使用<strong>大数据</strong>分析前些日子中的售卖数据，然后发现每年的特定时间段有着特定的销售规律，库存也会按照这个规律逐渐耗尽，有时速度非常快，有时速度非常慢。针对不一样的处境，系统会选择不同的时机提出警告，让采购尽快购回；</li><li>在<strong>客户管理</strong>中，你可以使用<strong>大数据</strong>分析客户行为数据，将一个个用户逐渐<strong>标签化</strong>，使用权重最大的一个或者很多个标签对用户的偏好进行分析和定义，以便能够更好地推销新旧产品；</li><li>在<strong>设备管理</strong>中，你可以使用<strong>大数据</strong>分析机器在什么样的工作环境下工作能够坚持多久，并预测在什么样的环境下这个设备将会被损毁，从而尽快维护翻新更换；同时在机器集群损毁其中一台的时候，你的整个系统能够寻找不影响其他机器运转的其他线路，进行<strong>智能调度</strong>；</li><li>在<strong>合作管理</strong>中，你可以使用<strong>大数据</strong>分析在什么样的平台做推广能够得到最大回报，也可以分析手办穿着什么服装、摆出什么动作能够得到买家最大的呼声，并使用<strong>数据可视化</strong>做出日活、周活等折线图、柱状图、饼状图等进一步辅助分析；</li><li>……</li></ul><p>通过<code>ERP</code>和大数据的结合，也就是具有灵魂的业务加上能力超强的工具，就成了。听起来这个普通得不能再普通的<code>ERP</code>系统瞬间就变成了<strong>一整个生态</strong>，包括了企业员工、企业设备、企业自己、合作企业、蛋糕客户、手办客户等等在内所有的数据整合在一起，通过数据挖掘、数据分析、标签化、智能调度、可视化、监控告警等等技术，完成企业方方面面的管理和经营；作为总经理的你面对每一个问题时都能够从数据中台中找出对应的源数据和经过分析后的数据来进行决策。<strong>这听起来就像是世界500强的作风啊</strong>！</p><h2 id="数据中台的目的"><a href="#数据中台的目的" class="headerlink" title="数据中台的目的"></a>数据中台的目的</h2><p>看了以上很长一段对于数据中台运行生态和运行机制，我们接下来再讨论数据中台的能力和目的。</p><p>数据中台应当具备三个能力：</p><blockquote><p>1、在中台能力及资源充足的情况下（包括业务知识、技术能力、人才积累），提供数据产品、数据服务。</p><p>2、在中台业务能力及人力资源不充分、但体系相对成熟的情况下（包括数据体系、技术体系），提供平台级别的能力，包括数据平台能力、技术平台能力、建模平台能力等，甚至是数据本身。</p><p>3、在中台人力资源和对业务领域知识理解不充分，平台级别能力也无法满足要求的情况下，作为算力基础平台提供服务。</p><p>——知乎：<strong>帆软</strong>：【<a href="https://zhuanlan.zhihu.com/p/121047371" target="_blank" rel="noopener">一文详解数据中台，别再跟数据平台搞混了！</a>】</p></blockquote><p>说白了，这三个目的旨在应对三个不同的场景：</p><ul><li>在企业<strong>已经做到足够大</strong>的情况下，能够为自己的企业、其他的企业提供服务。比如，现在的高德地图提供地图接口、阿里巴巴提供快递查询接口和阿里云服务；</li><li>在企业<strong>沿用已有的制度和技术</strong>的情况下，能够给别人提供服务。比如，现在的<code>GoodERP</code>对<code>Odoo</code>进行二次封装之后卖其他的中小型企业，并根据需求进行二次开发和部署；</li><li>在企业<strong>完全没有形成气候</strong>的情况下，给其他企业做最简单的事情。比如，现在的各大高校实验室中，技术力较为低下、硬件水平明显不足、工作时间明显较少，但还是在接很多的横向项目，通过外包和承包等等手段介入并为他们根据原型进行代码实现、根据需求进行数据清洗等等。</li></ul><p>简直就像游戏的难度分级一样：从简单到困难，再就是噩梦难度；从不需要太苦思冥想的简单重复劳动，到需要动点脑子针对特殊的业务进行特殊的编码实现，最后到时时刻刻都需要认真思考，针对每一个细节进行最大的优化。如果真的要做到这一步，我们将会更详细地要求：</p><blockquote><p><strong>决策支持类</strong>：主题报表（月度/季度/年度/专题）的大屏数据可视化展示</p><p><strong>数据分析类</strong>：<code>BI</code>、商业智能、<code>OLAP</code>分析、数据挖掘、数据驱动的机器学习</p><p><strong>数据检索类</strong>：全文检索、日志分析、数据血缘分析、数据地图</p><p><strong>数据共享开放类</strong>：实时数据订阅、离线数据接触、数据<code>API</code>接出</p><p>——知乎：<strong>帆软</strong>：【<a href="https://zhuanlan.zhihu.com/p/121047371" target="_blank" rel="noopener">一文详解数据中台，别再跟数据平台搞混了！</a>】</p></blockquote><p>这些就都是只有具有超强算力的大型公司才能够完成的任务了。</p><p>不难发现，数据中台甚至都包含一定的<strong>业务能力</strong>，如果我们放入鸡蛋、面粉和糖（<em>代指<strong>源数据</strong></em>），出来的可就是蛋糕（<em>代指<strong>最终成果</strong></em>）了；而普通的大数据平台只不过是<strong>分析数据的工具</strong>而已，如果单纯的放入鸡蛋、面粉和糖，可能就只有一团白色的浆糊（<em>代指<strong>半成品</strong>、<strong>中间变量</strong></em>），剩下的烘焙、成型、涂奶油还得我们另外寻找其他办法；再深挖一些，大数据平台中使用的Hadoop集群，就更是完全没有任何其他功能的数学分析工具而已，放入鸡蛋、面粉和糖，它甚至只能在你混在一起之后巧妙地重新分为三类（<em>Hadoop真的是物理意义上毫无感情的机器</em>）。</p><p>是不是有点能理解了？</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;现在，“数据中台”这个概念越来越火，但是数据中台到底是什么，服务对象是谁，目标又是什么？&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="大数据" scheme="https://sakebow.gitee.io/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="数据中台" scheme="https://sakebow.gitee.io/tags/%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>电网现状和未来</title>
    <link href="https://sakebow.gitee.io/2020/10/05/%E7%94%B5%E7%BD%91%E7%A0%94%E7%A9%B6/%E7%94%B5%E7%BD%91%E7%8E%B0%E7%8A%B6%E5%92%8C%E6%9C%AA%E6%9D%A5/"/>
    <id>https://sakebow.gitee.io/2020/10/05/%E7%94%B5%E7%BD%91%E7%A0%94%E7%A9%B6/%E7%94%B5%E7%BD%91%E7%8E%B0%E7%8A%B6%E5%92%8C%E6%9C%AA%E6%9D%A5/</id>
    <published>2020-10-05T00:43:00.000Z</published>
    <updated>2020-11-01T03:32:39.543Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>由于用电问题困扰了中国这个人口大国很久，于是也开始筹备智慧电网了。</strong></p><a id="more"></a><h2 id="什么是电网？"><a href="#什么是电网？" class="headerlink" title="什么是电网？"></a>什么是电网？</h2><p>现如今，我们的日常生活、游戏娱乐、工作生产等等非常依赖电力，甚至无法想象没有电会给人们带来怎样的空虚与恐慌。而在中国这样一个人口大国，14亿人的用电问题将是一个很严峻的挑战。取电已经到了一定的瓶颈，所以如何<strong>减少浪费</strong>将是另一个很重要的课题。</p><p><img src="https://sakebow.gitee.io/images/emoji/nopower.jpg" alt="没电了"></p><p><strong>电网</strong>正是处理这样一个问题的解决方案。电网将所有的用户<strong>织成了一张大网</strong>，每个人都在这张网上享有一定的电力。用这个电力，你可以维持你这个节点的正常运作。这正是传统电网的所有功能（<del><em>其实就一个功能</em></del>）。但是，随着需求越来越复杂、实际情况越来越多样，传统电网逐渐暴露出了越来越多的缺点。每当出现意外停电之后，我们除了一脸蒙圈地看着黑黑的屋子发呆，就只能对着电力热线乱发脾气，然后就只能空等着不知道什么时候才能回来的电力。如果你现在正在用电脑写文档，没有保存的你只能在停电之后思考人生。</p><p><img src="https://sakebow.gitee.io/images/emoji/down.jpg" alt="难受" width=350 /></p><p>所以，为了迎合变化多端的电力需求，就推出了智能电网。用户可以像购买云服务器一样按需升降配，也能够随时启动随时关闭。其中除了完成传统电网的所有功能外，还要加上对用户电力的动态管理、分析用户用电习惯并智能调节、快速定位故障位置并告知检修员和用户等等。</p><p><strong>举个简单的例子：</strong></p><p>你和几只猫娘住在一个<strong>有些年代</strong>的小区了，<strong>传统电网</strong>将每一家每一户都关联了起来。这里电路、网路都能满足需求。但是，这几年夏天明显热了好几个度，整个小区空调用电<strong>急剧升高</strong>。不是夏天的时候还凑合，结果一到夏天是不是就因为<strong>电路过载就大范围停电了</strong>。你、你的猫娘们和你的邻居们都热得没有办法。</p><p><img src = "https://sakebow.gitee.io/images/emoji/annoy.jpg" width=350 alt="生气" /></p><p>有一天，你攒够钱了，去了一个高档小区，架设了<strong>智能电网</strong>。虽然有些偏，但是非常宜居。你们经常开着四人座电驱动小汽车出门、开浴霸洗澡、电吹风、电饭煲、电压力锅……<strong>因为人多</strong>，所以你们的电压也明显比原来屋子里的<strong>电压大</strong>，而且电压非常稳定。即使是空调大开的夏天，猫娘和你们的房间也都能稳定制冷，你们每晚睡得都很安稳。</p><p><img src="https://sakebow.gitee.io/images/emoji/sigoi.jpg" alt="厉害了" width=350 /></p><p>由于你运气非常不错，营收额多了一倍，于是你带着猫娘出去大玩特玩了一周。在这一周内，你们家<strong>所有的用电都停了</strong>，于是你们被分配的<strong>电压也降低了</strong>，多余的电压就<strong>分配给其他的住户了</strong>。可能是你的邻居，也可能是城市另一端的某个陌生人。管他呢，总之你们家的电压因为长时间不用而被减少了。</p><p><img src="https://sakebow.gitee.io/images/emoji/np.jpg" alt="牛批的很"></p><p>这就是<strong>传统电网</strong>和<strong>智能电网</strong>之间的区别。</p><h2 id="电网的生态"><a href="#电网的生态" class="headerlink" title="电网的生态"></a>电网的生态</h2><p>别忘了，电网可是相当底层的技术，所以在这个项目之上理应有<strong>许多小项目</strong>来构成整个生态。就像你<strong>不能光有猫娘</strong>，这样不足以让她生活；还的有对应的猫粮、梳毛器、小鱼干、毛绒玩具、猫爬架等等，才是一个美好的生活环境。</p><p>所以，现在就衍生出了多个子项目：客户报障系统（<em>TCT</em>）、地理信息系统（<em>GIS</em>）、营销系统（<em>CMS</em>）、计量系统（<em>AMI</em>）、生产管理系统（<em>PMS</em>）、设计规划（<em>DCS</em>）等等，每个子项目都代表了一个服务，每个服务提供不同的功能。</p><p><img src="https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=1976883394,2771927944&amp;fm=173&amp;app=25&amp;f=JPEG?w=640&amp;h=425&amp;s=510366B852C072E7DE94C9480300F0E3" alt="智能电网"></p><p>这个图来自<strong>我爱阳光明媚</strong>的<a href="https://baijiahao.baidu.com/s?id=1613397434596286148&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">什么是智能电网？智能电网有哪些特征？</a>，其中智能电网的每一个小模块都代表一个小服务，对应了一个小方向。由上而下的多级管理制度更方便了用电的调度和调节，具体的管理细节就是<strong>工程管理</strong>的知识了。每个调节的地方需要实时监测保障安全和正常使用，这就是仪器仪表的<strong>知识</strong>；调度时考虑每个节点的安全和线路的消耗和规划，这又是电气的知识了；发电能源再从核能发电、火力发电逐渐过渡到风力、水力、地热等等清洁能源，这也是化工的知识；因为是生态，所以在原理上有非常多的内容是相互交叉的，所以在子项目之间如何解耦却又高聚合又是一大问题。这又开始了<strong>软件工程</strong>的知识……</p><p>就这么简简单单地一列举，是不是觉得这个电网项目简直就是一项体量超级大的项目？</p><h2 id="全球的电网现状"><a href="#全球的电网现状" class="headerlink" title="全球的电网现状"></a>全球的电网现状</h2><p>现在中国的<strong>大部分</strong>城市依然还是使用传统电网，智能电网<strong>起步非常晚</strong>，政策少、标准少。但是面对<strong>14亿人的超大量用电</strong>问题，智能电网的升降配等操作都有很大的困难等待我们的挑战。另外，之前的传统电网都是单纯的电路连接，并不具备智能。如果全部修改成智能，需要大量的传感器、收发器、探测器等等，改造难度不亚于全部拆掉重新建。</p><p>国外起步较早，但因为各国发展现状和发展理念不一样，各有侧重。</p><p>欧洲电力行业更倾向于清洁能源和环保，毕竟是全球首先发达的几个地区之一，正在慢慢去工业化并更侧重环保；日本由于国土面积小、资源有限，能源可再生、节能降耗则是日本电网的基调；英国国家电网将整个国家分成11个区，每个区设置3到7个变电站和一个经理，每个变电站都有一名工程师和一队操作队。由于系统较中国成熟，所以已经实现了无人值班，并且工程师定期维修检查的制度。在美国，虽然全国被分为完全独立的几个州，电网不能够完全全球联网统一调度，但是美国依然完成了输电线路监测和和输电统通信网，还有配电系统、智能电表和用户侧系统，其中用户侧还包含家庭显示器、可编程恒温器、动态电价计量器等等。</p><p>当然，正因为电网是一整个生态，所以这些国家在建设的时候花费了不小的代价。首先是每家每户的传统电表改造成智能电表，并且政府、煤气电力市场等多方面提供了巨额科研经费以供智慧电网的架设和铺开。</p><h2 id="我国电网所面临的挑战"><a href="#我国电网所面临的挑战" class="headerlink" title="我国电网所面临的挑战"></a>我国电网所面临的挑战</h2><p>虽然电网建设了一整个包括营销、计量等的完整生态，但建设智能电网的最终目的还是回到了能源。以前的传统电网使用了煤炭、核能等不可再生而且污染严重的能源，而现如今的电网已经大量投入使用清洁能源，比如西南的太阳能、西北的风能等等。</p><p>但是正如刚刚所说，太阳能、风能等等分布并不是非常紧凑，反而非常分散；同时绝大部分的用电却又在我国东南部，造成了供电和用电的地理位置上的割裂。所以对于大容量储能还是有所不足，能源出现和能源使用的地方随机性太大。</p><p>不过也不用太担心，在电网中我们可以建立虚拟电厂，也就是VPP，全称<em>Virtual Power Plant</em>。虚拟电厂能够将一个片区的电力集中在一起，然后使用智能调控系统进行统一的管理。简单地概括，就是国家有电，你也要电，所以虚拟电厂就充当中介的作用，收集电、发配电。</p><p><img src="https://sakebow.gitee.io/images/电网/VPP.png" alt="VPP架构图"></p><p>理论上，不管片区多大都是可以集中的，但是考虑到成本问题，一般不会这么无谋。至于智能调控系统，就是刚刚提到的整个生态的系统了。传统电网的面向群体是一个小团体，可能是一个小区，也可能是一个别墅群，也可能是一栋筒子楼，剩下进入家家户户的还是得自行预估、设计、测算、牵线等等，麻烦但是无奈。而智能电网面向的群体则是个体用户，用得多得的多，用的少得的少。</p><p>听起来非常不错？但是挑战依然还有很多。如果是面向群体，那么一整个群体就能够共享、调节，最终达到一个稳定的用电标准。既然已经决定面向个体，那么就没有调节的余地了，这也就意味着电网将要面对无数完全不同的复杂需求进行严苛的调整。一户人家只有他一个大龄单身<del>死肥</del>宅，所以用电除了大量的空调就是全天候的电脑用电；你们家有很多只猫娘，从微波炉、电饭煲，到浴霸、热水器，再有空调、地暖，以及电脑和电视甚至电动小汽车等等应有尽有的电器用电，所以需要更多、更稳定、更复杂的管理；还有一家只有一只小小的猫娘，用电水平较低，所以分配较为轻松，但是也不能因为较为轻松所以完全放弃了这一家的正常用电；最后一家是一个到处寻找商机的商人，常年不在家，所以还需要给这位商人一个随时关停家庭用电的远程开关……</p><h2 id="我国电网未来的展望"><a href="#我国电网未来的展望" class="headerlink" title="我国电网未来的展望"></a>我国电网未来的展望</h2><p>在智能电网中，最大的方便之处估计就是自愈系统了。传统电力中，你只能等电网公司慢慢报故障、检查工人慢慢找故障、修理工人慢慢慢慢修故障；而在智能电网中，通过类似<code>SpringCloud</code>分布式集群中的熔断机制，能够暂时缓解小范围的断路故障，也能通过对各种各样的探测器传回总部的各种数值的大数据分析得出故障最可能发生的地点，然后让检修工人第一时间赶往现场，并通过<code>GIS</code>系统实时报告故障地址和检修工人的地址与进度。</p><p>是不是听起来就很方便？当然，到这里还不算结束。</p><p>中国高层已经安排了计划，要求建设运营好“两网”，分别是“<strong>坚强智能电网</strong>”和“<strong>泛在电力物联网</strong>”。</p><p>听起来就是两个新鲜的高端词汇？然而“坚强智能电网”即将完成了，就是：</p><blockquote><p><strong>以特高压为主干网架</strong>，核心使用<strong>传感技术</strong>，利用传感器对<strong>温度在线监测装置</strong>、<strong>断路器在先监测装置</strong>、<strong>避雷器在先监测装置</strong>、<strong>容性设备在线监测装置</strong>等关键设备进行实时监控，通过网络系统整合所有传感数据，通过<strong>数据分析</strong>和<strong>数据挖掘</strong>，协助电力系统的<strong>优化管理</strong>。</p><p>——摘自百度百科【<a href="https://baike.baidu.com/item/坚强智能电网" target="_blank" rel="noopener">坚强电网</a>】</p></blockquote><p>什么？你让我说人话？就是说从电厂出发的电是最强的，然后在运输线沿线各个地方放些传感器，然后让专门的人看看这些传感器的数据又没有问题、要不要修；同时，普通用户也能够看到一些他们自己非常关心的数据，譬如账户余额、家庭用电量什么的，来满足日常生活和突发事故排查以及报障。</p><p>这就是“坚强智能电网”，首先是“<strong>坚强</strong>”，然后是“<strong>智能</strong>”。优先保障电力的稳定，然后在这个的基础上保持一定的智能。</p><p>那么“泛在电力物联网”又是什么？先从字面上理解，“泛在”一词，顾名思义，意为“<strong>广泛存在的</strong>”，就像是我们现在人手一部手机一样，见怪不怪了。“电力物联网”应当放在一起，因为是<strong>由电力作为媒介传递信息的万物互联而构成的网</strong>。只要是用电的，无论是工厂、办公室还是小商店，都能够实时监控；每个人都像一个行走的结构体，各个字段信息像血肉一样丰富了信息时代的你。</p><p>接下来我们看看官方怎么解释：</p><blockquote><p>国网公司做出两个阶段的战略安排：</p><p>到2021年初步建成泛在电力物联网，基本实现业务协同和数据贯通，初步实现统一物联管理，各级智慧能源综合服务平台具备基本功能，支撑电网业务与新兴业务发展。<br>到2024年建成泛在电力物联网，全面实现业务协同、数据贯通和统一物联管理，公司级智慧能源综合服务平台具备强大功能，全面形成共建共治共享的能源互联网生态圈。</p><p>——摘自百度百科【<a href="https://baike.baidu.com/item/泛在电力物联网" target="_blank" rel="noopener">泛在电力物联网</a>】</p></blockquote><p>百度百科的这一条可以说是基本上阐述了泛在电力物联网的目的，挖掘核心价值，就是“万物互联”、“能源服务”和“生态建设”。</p><p>万物互联是一个很庞大的图景。有多庞大？就像是单凭一个人画出清明上河图那么庞大。不是完不成，而是需要面对很多挑战。图景里有些什么呢？大到港口运了几千万吨货物，小到今天生产了多少罐猫粮；重要到今天印了多少钞票，普通到你今天看了多少<del>R18</del>图片……是不是不由得默默咽了一口唾沫？</p><blockquote><p>2018年，国往信通工作会议上就提出了“打造全业务泛在电力物联网，建设指挥企业，引领具有卓越竞争力的世界一流能源互联网企业建设”的工作目标，并提出了建设“国网-电力物联网”，简称<code>SG-eIoT</code>，即<code>electric Internet of Things</code>。</p><p>——摘自搜狐新闻【<a href="https://sohu.com/a/299805908_99947185" target="_blank" rel="noopener">什么是“泛在电力物联网”？要建立一个什么样的泛在电力物联网？</a>】</p></blockquote><p>大力发展智能电网的目的，主要就是为了能够打通终端、网络、平台、运维和安全五大体系，构建一个非常完整的生态，同时打通输电、变电、配电、用电、卖电五大场景，统一管理、统一协调，并实现各类终端设备的热插拔。到了那个时候，不管你是工厂添置设备，还是数据中心追加服务器集群，还是街边添加自助售货机，都是插上电立马给你一条龙服务。</p><p>当然，有大项目就得用大技术。预计这次会用到“大云物移智”，即大数据、云计算、物联网、移动互联网和人工智能。不过，感觉像是留了一手一样的，国家电网一点口号都没有喊，甚至都没有大肆宣传任何一点小成就，突然“坚强智能电网”就要建好了，突然就声明2024年需要建好智能电网，突然就声明2030年能够接入<code>SG-IoT</code>网络的设备达到20亿台。可以看到国家电网已经有相当的实力了。</p><p>未来肯定是美好的，我也相信学术界和商业圈都已经做好准备了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;由于用电问题困扰了中国这个人口大国很久，于是也开始筹备智慧电网了。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="电网" scheme="https://sakebow.gitee.io/categories/%E7%94%B5%E7%BD%91/"/>
    
    
      <category term="论文研究" scheme="https://sakebow.gitee.io/tags/%E8%AE%BA%E6%96%87%E7%A0%94%E7%A9%B6/"/>
    
  </entry>
  
  <entry>
    <title>自定义module的导入</title>
    <link href="https://sakebow.gitee.io/2020/09/27/JavaScript/Vue/%E8%87%AA%E5%AE%9A%E4%B9%89module%E7%9A%84%E5%AF%BC%E5%85%A5/"/>
    <id>https://sakebow.gitee.io/2020/09/27/JavaScript/Vue/%E8%87%AA%E5%AE%9A%E4%B9%89module%E7%9A%84%E5%AF%BC%E5%85%A5/</id>
    <published>2020-09-27T12:40:00.000Z</published>
    <updated>2020-09-27T13:05:40.572Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>对于前端小白来说，ES5、ES6两套完全不一样的标准放在一起是很头疼的事。导入的时候同时使用两套不同的标准将会在<code>ESLint</code>存在的时候报错。</strong></p><a id="more"></a><h2 id="ES5的写法"><a href="#ES5的写法" class="headerlink" title="ES5的写法"></a>ES5的写法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义neko.js并作为模块导出</span></span><br><span class="line"><span class="keyword">var</span> Neko = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Neko</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">  Neko.prototype.grow = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age += <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Neko</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  neko: Neko</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Neko模块</span></span><br><span class="line"><span class="keyword">import</span> Neko <span class="keyword">from</span> <span class="string">'./neko'</span></span><br></pre></td></tr></table></figure><p>可以看到，在定义这个<code>Neko</code>类的时候非常冗赘，而且多种多样的闭包让人眼花撩乱、不知所措。</p><h2 id="ES6的写法"><a href="#ES6的写法" class="headerlink" title="ES6的写法"></a>ES6的写法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义neko.js并作为模块导出</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Neko</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (name, age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">  grow () &#123;</span><br><span class="line">    <span class="keyword">this</span>.age += <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Neko</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Neko.js模块</span></span><br><span class="line"><span class="keyword">const</span> Neko = <span class="built_in">require</span>(<span class="string">'./neko.js'</span>)</span><br></pre></td></tr></table></figure><p>在导入和导出的时候都出现了明显的不同。但是在不同之处又有些相同，这就在初学的时候容易弄混。</p><p>如果你使用了<code>ESLint</code>，你的语言将非常严格，于是在编辑的时候你只允许使用<code>ES5</code>、<code>ES6</code>的其中一种。</p><p>当你混用的时候：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> $ = <span class="built_in">require</span>(<span class="string">'jquery'</span>)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Neko</span><br></pre></td></tr></table></figure><p>这个时候你的程序就会报错。你的程序在其他位置一点问题都没有，大量复杂的继承、闭包只会让你更加心烦意乱。所以，我们还是尽可能统一风格、统一标准。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;对于前端小白来说，ES5、ES6两套完全不一样的标准放在一起是很头疼的事。导入的时候同时使用两套不同的标准将会在&lt;code&gt;ESLint&lt;/code&gt;存在的时候报错。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://sakebow.gitee.io/categories/JavaScript/"/>
    
    
      <category term="Vue" scheme="https://sakebow.gitee.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>读论文的方法论</title>
    <link href="https://sakebow.gitee.io/2020/09/25/%E7%94%B5%E7%BD%91%E7%A0%94%E7%A9%B6/%E8%AF%BB%E8%AE%BA%E6%96%87%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    <id>https://sakebow.gitee.io/2020/09/25/%E7%94%B5%E7%BD%91%E7%A0%94%E7%A9%B6/%E8%AF%BB%E8%AE%BA%E6%96%87%E7%9A%84%E6%96%B9%E6%B3%95%E8%AE%BA/</id>
    <published>2020-09-25T06:44:00.000Z</published>
    <updated>2020-09-26T10:57:12.235Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>研究生生活开始了，学术上可不能有所怠慢，尤其是作为学硕的我。</strong></p><a id="more"></a><p><strong>一般的，我们会把一篇论文阅读很多次。</strong></p><h2 id="第一遍"><a href="#第一遍" class="headerlink" title="第一遍"></a>第一遍</h2><p>首先，我们会关注论文的<strong>摘要</strong>、<strong>引文</strong>。因为这会让我们对开题的各种说明有些了解。</p><p>同时，正因为我们正处于寻找课题的阶段，所以我们现在需要做的就是理解研究思路、掌握分析方法。当然也别忘了语言的雕琢，<strong>审稿人最喜欢那些听起来非常拗口的东西了</strong>。</p><h2 id="第二遍"><a href="#第二遍" class="headerlink" title="第二遍"></a>第二遍</h2><p>第二遍大概会<strong>在我们稍有基础之后</strong>，这时我们会对一定的数据格式有一定的敏感性。也正是这个时候，我们会仔细了解论文的<strong>图表信息</strong>，包括图表中所包含的<strong>数字</strong>、<strong>文字说明</strong>和<strong>得出结论</strong>。在这时，需要从作者所提供的数据，在作者所站在的角度上通过什么样的标准才能够的出论文中所阐述的结论。如果你觉得恰当，是为什么？如果你觉得欠妥，又是为什么？</p><p><em>在这里插播一句话：你能检索的论文都不会有所误解，只会有所欠缺，因为能够在这上面发表的论文起码在因果关系上是没有问题的，数据造假问题不再考虑范围内。</em></p><p>当然，这时正因为你有了一些基础，所以你可以<strong>略读摘要和引言</strong>，<strong>直接找图表进行深入讨论</strong>，其他的细枝末节干脆屏蔽掉也是可以的。</p><h2 id="第三遍"><a href="#第三遍" class="headerlink" title="第三遍"></a>第三遍</h2><p>第三遍自然也是第二遍的升级。这个时候我们已经具备了阅读实际问题的能力了，<strong>即使面对几十个数据文档的轮番轰炸也能够应对自如</strong>。那么，这个时候就应该联系<strong>摘要</strong>、<strong>引文</strong>和<strong>图表</strong>，看图表是不是对应着这些摘要和引文。如果不是，那么图表又在说明什么问题？如果是对应的，那么图表又为什么样的结论提供了强有力的证据？作者对这样的证据是如何讨论的？</p><p>这个时候就需要对应你了解的引言和摘要，开始对图表进行分析了。就想象你是一名小学语文老师一样，板着一副臭脸，拍着桌子喊着：“你的主题呢？！”那种高高在上的姿态估计很多人都会欲罢不能。这就是坚持到找到乐趣的时候了，相信你也离成功不远了。</p><h2 id="第四遍"><a href="#第四遍" class="headerlink" title="第四遍"></a>第四遍</h2><p>这个时候相信你已经入门了。最起码，你能够自己模仿了。这个时候，就开始读一些高级论文吧，因为一篇文章的高级可不是因为一个句子而高级，而是一整篇全程高能才叫高级。从字里行间学习他们行文的规范和规律，再从一字一句中扣出思想和论证方法。</p><p>这个阶段更考验的是我们的综合能力了，除了文档的格式规范、图表分析，更是字里行间透露出你对学科的严谨、认真。</p><h2 id="第五遍"><a href="#第五遍" class="headerlink" title="第五遍"></a>第五遍</h2><p>能够读第五遍的文章应该只有英文论文了。因为这是我们中文母语的学生所不熟悉的领域，于是对于我们来说相当于又回到了第一遍。但是，学习正是这样一种“<strong>螺旋上升</strong>”的变化过程，不是么？</p><h2 id="后面的文章行文规律"><a href="#后面的文章行文规律" class="headerlink" title="后面的文章行文规律"></a>后面的文章行文规律</h2><p>上面我们介绍了读五遍论文的时候每一遍都应当做些什么，所以在写论文的读后感的时候，我们会将文章分成<strong>至少四个部分</strong>，每个部分将会侧重不同的地方，每个地方针对每个不同的阶段都会有不同的侧重点。相信针对每个不同阶段的人都会有不同的收获吧。</p><p>祝各位都变得巨牛批！</p><p><img src="https://sakebow.gitee.io/images/emoji/牛批.jpg" width="400" /></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;研究生生活开始了，学术上可不能有所怠慢，尤其是作为学硕的我。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="电网" scheme="https://sakebow.gitee.io/categories/%E7%94%B5%E7%BD%91/"/>
    
    
      <category term="论文研究" scheme="https://sakebow.gitee.io/tags/%E8%AE%BA%E6%96%87%E7%A0%94%E7%A9%B6/"/>
    
  </entry>
  
</feed>
