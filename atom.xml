<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>我的笔记本</title>
  
  <subtitle>一只干什么都会失败但是很不想放弃的科研狗</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sakebow.github.io/"/>
  <updated>2021-01-01T08:40:31.276Z</updated>
  <id>https://sakebow.github.io/</id>
  
  <author>
    <name>sakebow</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>用Qt做个建议的数据分析界面</title>
    <link href="https://sakebow.github.io/2020/12/30/python/PyQt5/%E7%94%A8Qt%E5%81%9A%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%95%8C%E9%9D%A2/"/>
    <id>https://sakebow.github.io/2020/12/30/python/PyQt5/%E7%94%A8Qt%E5%81%9A%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%95%8C%E9%9D%A2/</id>
    <published>2020-12-30T15:28:00.000Z</published>
    <updated>2021-01-01T08:40:31.276Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p>既然我们了解到了基本的<code>GUI</code>搭建方法，那就让我们结合研究生的数据分析日常，让我们来看看一个简单的数据分析界面应该怎么做。主要的分析步骤是根据数据酷客的博客的基础上加以改编。在这里感谢作者。</p><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p>这里我还是和之前的<a href="">用<code>Qt</code>学着做个界面</a>一样的准备：</p><ul><li><code>Ubuntu</code> $20.04$</li><li><code>Python</code> $3.8.5$</li><li><code>Microsoft Visual Studio Code</code> $1.52.1$</li><li><code>Microsoft</code>官方提供的适用于<code>Microsoft Visual Studio Code</code>的<code>Python</code>拓展包（名字就是<code>Python</code>）</li></ul><p>数据还是使用的<a href="https://sakebow.gitee.io/images/数据集/germany_energy.csv" target="_blank" rel="noopener">德国能源数据</a>，和之前的<a href="">开工：数据集的特征理解</a>一样。</p><h2 id="优先确认界面（概要设计）"><a href="#优先确认界面（概要设计）" class="headerlink" title="优先确认界面（概要设计）"></a>优先确认界面（概要设计）</h2><p>由于这个界面是一个小项目，所以我们得有些规划。</p><p>首先确认一个大致的界面规划：</p><p><img src="https://sakebow.gitee.io/images/研一小项目/软件界面.png" alt="确认界面长什么样"></p><p>首先，一个很普通的<strong>关于</strong>按钮和<strong>退出</strong>按钮在上面。</p><p>退出按钮就是单纯的结束程序，而关于按钮则是弹窗说明作者（我）的一点点信息。</p><p>就像这样：</p><p><img src="https://sakebow.gitee.io/images/研一小项目/错误提示.png" alt="弹窗样式"></p><p><del>虽然这张图完全不像是在介绍信息，但大致上也是这个样子。</del></p><p>在下面就是有关<strong>能耗</strong>、<strong>太阳能发电量</strong>、<strong>风力发电量</strong>、<strong>综合发电量</strong>的<strong>所有数据</strong>、<strong>年度数据</strong>、<strong>季度数据</strong>和<strong>周度数据</strong>，最后再来个<strong>预测</strong>，看看多少年后混合发电量能够满足能耗均值。</p><p>这些按钮点开都能显示一张数据可视化表，在预测部分还会有个弹窗说明预测结果。</p><p>当然，这个图只是示意图，并不代表最终成果。我们还可以稍加修改。</p><h2 id="确认复用关系（详细设计）"><a href="#确认复用关系（详细设计）" class="headerlink" title="确认复用关系（详细设计）"></a>确认复用关系（详细设计）</h2><p>首先，我们需要确定，窗体可以使用<code>QWidget</code>创建，只不过我们为了加一些属性就继承了这个类进行复写。所以，我们会定义一个有很多基础属性的自定义窗体，并把一些基础字段封装在构造函数中。</p><p>有了基础父类，接下来就是主界面了。主界面作为独立的一个界面，继承了基础父类之后不会再往下继承。</p><p>其次，还有弹窗。这个弹窗同样也得继承自基础父类，但是和主界面有所不同。对于<strong>关于按钮的弹窗</strong>和<strong>预测图表的弹窗</strong>可以使用相同的样式，也就是上面我们显示的<code>Error</code>样式。弹窗中可以使用一个大标题、一个小标题，这两个字段都可以封装在构造函数中。</p><p>之后便是绘图了。为了让这个小项目看起来没有那么复杂，我们就使用<code>matplotlib</code>库好了。</p><h2 id="开始编码"><a href="#开始编码" class="headerlink" title="开始编码"></a>开始编码</h2><p>既然已经明白该怎么做了，就直接开始吧，剩下的一边做一边想，因为项目本身不大，也没有什么技术难点。</p><h3 id="不怎么需要注意的注意事项"><a href="#不怎么需要注意的注意事项" class="headerlink" title="不怎么需要注意的注意事项"></a>不怎么需要注意的注意事项</h3><p>当然，如果项目的体量再大些的话，没有详细的文档还是不建议开始。</p><h3 id="最初的父类"><a href="#最初的父类" class="headerlink" title="最初的父类"></a>最初的父类</h3><p>对于最开始的父类，我们可以这么写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QWindow</span><span class="params">(QWidget)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, parent=None, flags=Qt.WindowFlags<span class="params">()</span>)</span>:</span></span><br><span class="line">    super().__init__(parent=parent, flags=flags)</span><br><span class="line">    <span class="comment"># 获取屏幕宽高作为任何窗口的最大宽高</span></span><br><span class="line">    QWindow.WINDOW_MAX_WIDTH = QApplication.desktop().width()</span><br><span class="line">    QWindow.WINDOW_MAX_HEIGHT = QApplication.desktop().height()</span><br><span class="line">    <span class="comment"># 给定主窗口默认宽高</span></span><br><span class="line">    QWindow.WINDOW_INIT_HEIGHT = int(self.WINDOW_MAX_HEIGHT / <span class="number">2</span>)</span><br><span class="line">    QWindow.WINDOW_INIT_WIDTH = int(self.WINDOW_MAX_WIDTH / <span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 给定主窗口默认位置</span></span><br><span class="line">    QWindow.X = int(self.WINDOW_MAX_WIDTH / <span class="number">4</span>)</span><br><span class="line">    QWindow.Y = int(self.WINDOW_MAX_HEIGHT / <span class="number">4</span>)</span><br><span class="line">    <span class="comment"># 给定弹窗的默认宽高</span></span><br><span class="line">    QWindow.BOX_WIDTH = int(self.WINDOW_INIT_WIDTH / <span class="number">2</span>)</span><br><span class="line">    QWindow.BOX_HEIGHT = int(self.WINDOW_INIT_HEIGHT / <span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 给定弹窗的默认位置</span></span><br><span class="line">    QWindow.BOX_X = int(self.WINDOW_MAX_WIDTH *<span class="number">3</span> / <span class="number">8</span>)</span><br><span class="line">    QWindow.BOX_Y = int(self.WINDOW_MAX_HEIGHT * <span class="number">3</span> / <span class="number">8</span>)</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>在这里，这些字段都不是使用<code>self</code>定义的，而是使用<strong>类名</strong>定义。因为这样表示这个类的<strong>静态变量</strong>。子类在被创建的时候，这些字段就不会作为对象的一部分<strong>重复占用</strong>空间。</p><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;既然我们了解到了基本的&lt;code&gt;GUI&lt;/code&gt;搭建方法，那就让我们结合研究生的数据分析日常，让我们来看看一个简单的数据分析界面应该怎
      
    
    </summary>
    
    
      <category term="UI界面" scheme="https://sakebow.github.io/categories/UI%E7%95%8C%E9%9D%A2/"/>
    
    
      <category term="Python" scheme="https://sakebow.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>用Qt学着做个界面</title>
    <link href="https://sakebow.github.io/2020/12/28/python/PyQt5/%E7%94%A8Qt%E5%AD%A6%E7%9D%80%E5%81%9A%E4%B8%AA%E7%95%8C%E9%9D%A2/"/>
    <id>https://sakebow.github.io/2020/12/28/python/PyQt5/%E7%94%A8Qt%E5%AD%A6%E7%9D%80%E5%81%9A%E4%B8%AA%E7%95%8C%E9%9D%A2/</id>
    <published>2020-12-28T14:10:00.000Z</published>
    <updated>2020-12-30T15:15:44.906Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><a id="more"></a><h2 id="使用环境"><a href="#使用环境" class="headerlink" title="使用环境"></a>使用环境</h2><p>首先说一下我所使用的环境：</p><ul><li><code>Ubuntu</code> $20.04$</li><li><code>Python</code> $3.8.5$</li><li><code>Microsoft Visual Studio Code</code> $1.52.1$</li><li><code>Microsoft</code>官方提供的适用于<code>Microsoft Visual Studio Code</code>的<code>Python</code>拓展包（名字就是<code>Python</code>）</li></ul><p>由于是<code>Ubuntu</code>系统，可能和<code>Windows</code>有一些出入，但是<strong>不需要配环境</strong>确实方便。</p><h2 id="一个窗体"><a href="#一个窗体" class="headerlink" title="一个窗体"></a>一个窗体</h2><p>好的，我们来根据<a href="http://code.py40.com/pyqt5/16.html" target="_blank" rel="noopener">这个不确定是不是官方文档的教程</a>来试一个简单的窗体程序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># version 1</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> PyQt5.Qt <span class="keyword">import</span> Qt</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QApplication, QWidget</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过继承，构造一个自定义的窗体</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QWindow</span><span class="params">(QWidget)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, parent = None, flags = Qt.WindowFlags<span class="params">()</span>)</span>:</span></span><br><span class="line">    super().__init__(parent = parent, flags = flags)</span><br><span class="line">    <span class="comment"># 规定窗体宽度、高度</span></span><br><span class="line">    <span class="comment"># 同时规定屏幕宽度、高度，便于中心定位</span></span><br><span class="line">    self.WINDOW_WIDTH = <span class="number">500</span></span><br><span class="line">    self.WINDOW_HEIGHT = <span class="number">300</span></span><br><span class="line">    self.SCREEN_WIDTH = <span class="number">1920</span></span><br><span class="line">    self.SCREEN_HEIGHT = <span class="number">1080</span></span><br><span class="line">    self.x = int((window.SCREEN_WIDTH - window.WINDOW_WIDTH) / <span class="number">2</span>)</span><br><span class="line">    self.y = int((window.SCREEN_HEIGHT - window.WINDOW_HEIGHT) / <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  <span class="comment"># 创建应用主线程，其中sys.argv是从命令行传入的参数（一般应用不常用）</span></span><br><span class="line">  app = QApplication(sys.argv)</span><br><span class="line">  <span class="comment"># 创建主窗体</span></span><br><span class="line">  window = QWindow()</span><br><span class="line">  <span class="comment"># 尺寸设置</span></span><br><span class="line">  window.resize(window.WINDOW_WIDTH, window.WINDOW_HEIGHT)</span><br><span class="line">  <span class="comment"># 移动到指定的位置</span></span><br><span class="line">  window.move(window.x, window.y)</span><br><span class="line">  <span class="comment"># 设置窗体标题</span></span><br><span class="line">  window.setWindowTitle(<span class="string">'example'</span>)</span><br><span class="line">  <span class="comment"># 显示窗体</span></span><br><span class="line">  window.show()</span><br><span class="line">  <span class="comment"># 限制整个程序只能在主线程结束后结束，否则窗体会闪退</span></span><br><span class="line">  sys.exit(app.exec_())</span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>真实的效果就像这样：</p><p><img src="https://sakebow.gitee.io/images/研一小项目/一个简单的窗体.png" alt="窗体效果"></p><p>看起来还不错。在<code>Ubuntu</code>系统中的默认主题就是这样的样式，和<code>Windows</code>稍稍有些区别。</p><h2 id="加上按钮"><a href="#加上按钮" class="headerlink" title="加上按钮"></a>加上按钮</h2><p>既然结果还行，那让我们来加点东西。就先加个<strong>按钮</strong>吧，等之后再把事件绑上去。</p><p><em>注：以下代码<code>version 2</code>和上面<code>version 1</code>有区别的地方就在于添加注释的地方</em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># version 2</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> PyQt5.Qt <span class="keyword">import</span> Qt</span><br><span class="line"><span class="comment"># 增加QGridLayout库</span></span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QApplication, QPushButton, QWidget, QGridLayout</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QWindow</span><span class="params">(QWidget)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, parent = None, flags = Qt.WindowFlags<span class="params">()</span>)</span>:</span></span><br><span class="line">    super().__init__(parent = parent, flags = flags)</span><br><span class="line">    self.WINDOW_WIDTH = <span class="number">500</span></span><br><span class="line">    self.WINDOW_HEIGHT = <span class="number">300</span></span><br><span class="line">    self.SCREEN_WIDTH = <span class="number">1920</span></span><br><span class="line">    self.SCREEN_HEIGHT = <span class="number">1080</span></span><br><span class="line">    self.x = int((self.SCREEN_WIDTH - self.WINDOW_WIDTH) / <span class="number">2</span>)</span><br><span class="line">    self.y = int((self.SCREEN_HEIGHT - self.WINDOW_HEIGHT) / <span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 定义一个按钮的实例</span></span><br><span class="line">    self.btn = QPushButton(<span class="string">'test button'</span>)</span><br><span class="line">    <span class="comment"># 定义容纳按钮的布局</span></span><br><span class="line">    self.window_grid_layout = QGridLayout()</span><br><span class="line">    <span class="comment"># 设置这个布局的位置和大小</span></span><br><span class="line">    self.window_grid_layout.setContentsMargins(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="comment"># 将定义的按钮塞进布局</span></span><br><span class="line">    self.window_grid_layout.addWidget(self.btn, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 将窗体布局设为构建的布局</span></span><br><span class="line">    self.setLayout(self.window_grid_layout)</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  app = QApplication(sys.argv)</span><br><span class="line">  window = QWindow()</span><br><span class="line">  window.resize(window.WINDOW_WIDTH, window.WINDOW_HEIGHT)</span><br><span class="line">  window.move(window.x, window.y)</span><br><span class="line">  window.setWindowTitle(<span class="string">'example'</span>)</span><br><span class="line">  window.show()</span><br><span class="line">  sys.exit(app.exec_())</span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>于是，就有了这样的效果：</p><p><img src="https://sakebow.gitee.io/images/研一小项目/添加按钮.png" alt="窗体效果"></p><p>看上去还行。</p><h2 id="方法封装"><a href="#方法封装" class="headerlink" title="方法封装"></a>方法封装</h2><p>但是窗体不能只有一个按钮，还得有标签、按钮、下拉框等等。</p><p>于是我们再回头看看我们代码中设置控件的地方：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个按钮的实例</span></span><br><span class="line">self.btn = QPushButton(<span class="string">'test button'</span>)</span><br><span class="line"><span class="comment"># 定义容纳按钮的布局</span></span><br><span class="line">self.window_grid_layout = QGridLayout()</span><br><span class="line"><span class="comment"># 设置这个布局的位置和大小</span></span><br><span class="line">self.window_grid_layout.setContentsMargins(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment"># 将定义的按钮塞进布局</span></span><br><span class="line">self.window_grid_layout.addWidget(self.btn, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment"># 将窗体布局设为构建的布局</span></span><br><span class="line">self.setLayout(self.window_grid_layout)</span><br></pre></td></tr></table></figure><p>设置控件，一行；将控件添加进布局，一行。这样两行不停的交替，也许会有人喜欢，但是我是<strong>坚决不会允许</strong>的，我会将控件设置专门放在一起，将布局设置专门放在一起，最后再设置个布局，就像下面这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># version 3</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> PyQt5.Qt <span class="keyword">import</span> Qt</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QApplication, QPushButton, QWidget, QGridLayout</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QWindow</span><span class="params">(QWidget)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, parent = None, flags = Qt.WindowFlags<span class="params">()</span>)</span>:</span></span><br><span class="line">    super().__init__(parent = parent, flags = flags)</span><br><span class="line">    self.WINDOW_WIDTH = <span class="number">500</span></span><br><span class="line">    self.WINDOW_HEIGHT = <span class="number">300</span></span><br><span class="line">    self.SCREEN_WIDTH = <span class="number">1920</span></span><br><span class="line">    self.SCREEN_HEIGHT = <span class="number">1080</span></span><br><span class="line">    self.x = int((self.SCREEN_WIDTH - self.WINDOW_WIDTH) / <span class="number">2</span>)</span><br><span class="line">    self.y = int((self.SCREEN_HEIGHT - self.WINDOW_HEIGHT) / <span class="number">2</span>)</span><br><span class="line">    self.window_grid_layout = QGridLayout()</span><br><span class="line">    self.window_grid_layout.setContentsMargins(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="comment"># 按照顺序执行三个方法</span></span><br><span class="line">    self.init_layout()</span><br><span class="line">    self.set_layout()</span><br><span class="line">    self.finish_layout()</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  <span class="comment"># 定义控件</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">init_layout</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.btn = QPushButton(<span class="string">'test button'</span>)</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  <span class="comment"># 设置控件的位置</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">set_layout</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.window_grid_layout.addWidget(self.btn, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  <span class="comment"># 结束控件设置</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">finish_layout</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.setLayout(self.window_grid_layout)</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  app = QApplication(sys.argv)</span><br><span class="line">  window = QWindow()</span><br><span class="line">  window.resize(window.WINDOW_WIDTH, window.WINDOW_HEIGHT)</span><br><span class="line">  window.move(window.x, window.y)</span><br><span class="line">  window.setWindowTitle(<span class="string">'example'</span>)</span><br><span class="line">  window.show()</span><br><span class="line">  sys.exit(app.exec_())</span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>这样就看起来更简洁了！如果出现了问题，也能够<strong>快速定位</strong>出现问题的方法。</p><h2 id="QSS样式美化"><a href="#QSS样式美化" class="headerlink" title="QSS样式美化"></a>QSS样式美化</h2><p>如果你对<code>Web</code>前端比较熟悉，那么你一定知道<code>CSS3</code>。强大的样式表让我们能够做到很多事。同样的，<code>PyQt5</code>也有类似的<code>QSS</code>，但是却相对<code>CSS3</code>缺少很多强大的效果。</p><p>我们可以类比<code>CSS3</code>写一点点样式表，命名为<code>style.qss</code>，和窗体文件一起放在<code>pyqt5</code>文件夹里：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">QPushButton</span> &#123;</span><br><span class="line">  # 边框</span><br><span class="line">  <span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-tag">black</span>;</span><br><span class="line">  # 背景</span><br><span class="line">  <span class="selector-tag">background</span>: <span class="selector-tag">white</span>;</span><br><span class="line">  <span class="selector-tag">color</span>: <span class="selector-tag">olive</span>;</span><br><span class="line">  <span class="selector-tag">font-size</span>: 20<span class="selector-tag">px</span>;</span><br><span class="line">  <span class="selector-tag">height</span>: 40<span class="selector-tag">px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>Python3</code>在<code>Ubuntu</code>系统中不支持相对路径，所以我们需要使用其他的库：<code>os</code>，其中的<code>getcwd()</code>方法能够获得当前<strong>工作区的绝对路径</strong>。注意，是工作区，而不是当前文件。也就是说，<code>os.getcwd()</code>方法只能够获得该文件所在文件夹的绝对路径，获取的地址还得加上当前文件夹名字。</p><p>于是，加上<code>QSS</code>美化的代码就像是这样：</p><p>注：<em>以下代码段<code>version 4</code>和上面<code>version 3</code>仅在于添加注释的地方有区别</em>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># version 4</span></span><br><span class="line"><span class="comment"># 获取路径的库</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> PyQt5.Qt <span class="keyword">import</span> Qt</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QApplication, QPushButton, QWidget, QGridLayout</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QWindow</span><span class="params">(QWidget)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, parent = None, flags = Qt.WindowFlags<span class="params">()</span>)</span>:</span></span><br><span class="line">    super().__init__(parent = parent, flags = flags)</span><br><span class="line">    self.WINDOW_WIDTH = <span class="number">500</span></span><br><span class="line">    self.WINDOW_HEIGHT = <span class="number">300</span></span><br><span class="line">    self.SCREEN_WIDTH = <span class="number">1920</span></span><br><span class="line">    self.SCREEN_HEIGHT = <span class="number">1080</span></span><br><span class="line">    self.x = int((self.SCREEN_WIDTH - self.WINDOW_WIDTH) / <span class="number">2</span>)</span><br><span class="line">    self.y = int((self.SCREEN_HEIGHT - self.WINDOW_HEIGHT) / <span class="number">2</span>)</span><br><span class="line">    self.window_grid_layout = QGridLayout()</span><br><span class="line">    self.window_grid_layout.setContentsMargins(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    self.init_layout()</span><br><span class="line">    self.set_layout()</span><br><span class="line">    self.finish_layout()</span><br><span class="line">    <span class="comment"># 将读取的内容作为样式表美化控件</span></span><br><span class="line">    self.setStyleSheet(self.load_qss())</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">init_layout</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.btn = QPushButton(<span class="string">'test button'</span>)</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">set_layout</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.window_grid_layout.addWidget(self.btn, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">finish_layout</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.setLayout(self.window_grid_layout)</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">load_qss</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="comment"># 获取路径并读取文件</span></span><br><span class="line">    <span class="keyword">with</span> open(os.getcwd() + <span class="string">'/pyqt5/style.qss'</span>) <span class="keyword">as</span> q:</span><br><span class="line">      <span class="keyword">return</span> q.read()</span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  app = QApplication(sys.argv)</span><br><span class="line">  window = QWindow()</span><br><span class="line">  window.resize(window.WINDOW_WIDTH, window.WINDOW_HEIGHT)</span><br><span class="line">  window.move(window.x, window.y)</span><br><span class="line">  window.setWindowTitle(<span class="string">'example'</span>)</span><br><span class="line">  window.show()</span><br><span class="line">  sys.exit(app.exec_())</span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>于是效果就像是这样：</p><p><img src="https://sakebow.gitee.io/images/研一小项目/qss.png" alt="窗体样式"></p><p>看着没毛病。</p><h2 id="第三方美化插件"><a href="#第三方美化插件" class="headerlink" title="第三方美化插件"></a>第三方美化插件</h2><p>但是这样的界面稍微有点单调，再加一点小图标怎么样？</p><p>如果你做过<code>Web</code>项目，那么你应该知道<code>font-awesome</code>。这是个非常不错的字体库。当然，也有大佬把这些字体库放在了<code>PyQt</code>中，就是<code>qtawesome</code>。</p><p>当然，这个是第三方库，所以我们需要另外使用<code>pip</code>安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install qtawesome</span><br></pre></td></tr></table></figure><p>然后就开始写代码。注：<em>以下代码<code>version 5</code>修改的地方和上面<code>version 3</code>相比只有导包和注释处有改动</em>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># version 5</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> PyQt5.Qt <span class="keyword">import</span> Qt</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QApplication, QPushButton, QWidget, QGridLayout</span><br><span class="line"><span class="comment"># 添加代码库</span></span><br><span class="line"><span class="keyword">import</span> qtawesome <span class="keyword">as</span> qta</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QWindow</span><span class="params">(QWidget)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, parent = None, flags = Qt.WindowFlags<span class="params">()</span>)</span>:</span></span><br><span class="line">    super().__init__(parent = parent, flags = flags)</span><br><span class="line">    self.WINDOW_WIDTH = <span class="number">500</span></span><br><span class="line">    self.WINDOW_HEIGHT = <span class="number">300</span></span><br><span class="line">    self.SCREEN_WIDTH = <span class="number">1920</span></span><br><span class="line">    self.SCREEN_HEIGHT = <span class="number">1080</span></span><br><span class="line">    self.x = int((self.SCREEN_WIDTH - self.WINDOW_WIDTH) / <span class="number">2</span>)</span><br><span class="line">    self.y = int((self.SCREEN_HEIGHT - self.WINDOW_HEIGHT) / <span class="number">2</span>)</span><br><span class="line">    self.window_grid_layout = QGridLayout()</span><br><span class="line">    self.window_grid_layout.setContentsMargins(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    self.init_layout()</span><br><span class="line">    self.set_layout()</span><br><span class="line">    self.finish_layout()</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">init_layout</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="comment"># 在构建按钮的时候添加QIcon</span></span><br><span class="line">    <span class="comment"># 这个意思是：使用fa5库中的实心图标（Solid），并且涂上橄榄色（olive）</span></span><br><span class="line">    self.btn = QPushButton(qta.icon(<span class="string">'fa5s.cannabis'</span>, color=<span class="string">'olive'</span>), <span class="string">'test button'</span>)</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">set_layout</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.window_grid_layout.addWidget(self.btn, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">finish_layout</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.setLayout(self.window_grid_layout)</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  app = QApplication(sys.argv)</span><br><span class="line">  window = QWindow()</span><br><span class="line">  window.resize(window.WINDOW_WIDTH, window.WINDOW_HEIGHT)</span><br><span class="line">  window.move(window.x, window.y)</span><br><span class="line">  window.setWindowTitle(<span class="string">'example'</span>)</span><br><span class="line">  window.show()</span><br><span class="line">  sys.exit(app.exec_())</span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>于是就变成了这样：</p><p><img src="https://sakebow.gitee.io/images/研一小项目/qtawesome.png" alt="窗体样式"></p><p>看着还行。</p><p>是不是有点能理解了呢？</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;
    
    </summary>
    
    
      <category term="UI界面" scheme="https://sakebow.github.io/categories/UI%E7%95%8C%E9%9D%A2/"/>
    
    
      <category term="Python" scheme="https://sakebow.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>进程代数是什么？</title>
    <link href="https://sakebow.github.io/2020/12/22/%E8%BF%9B%E7%A8%8B%E4%BB%A3%E6%95%B0/%E8%BF%9B%E7%A8%8B%E4%BB%A3%E6%95%B0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <id>https://sakebow.github.io/2020/12/22/%E8%BF%9B%E7%A8%8B%E4%BB%A3%E6%95%B0/%E8%BF%9B%E7%A8%8B%E4%BB%A3%E6%95%B0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</id>
    <published>2020-12-22T02:10:00.000Z</published>
    <updated>2020-12-22T02:38:55.120Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>进程代数，估计有些人听到这个词就开始头疼了，其实我也是。这次尽可能地讲得爸妈都能听懂。</strong></p><a id="more"></a><h2 id="第一印象"><a href="#第一印象" class="headerlink" title="第一印象"></a>第一印象</h2><p>我们都知道，在计算机的<strong>并发控制</strong>中，是有<strong>进程</strong>这个概念的。也就是说，每有一个人接入服务器，就有专门一个<strong>进程</strong>来处理你的请求。就像是在酒店聚餐一样，你带着一大队人进入酒店之后，就会专门派一个服务员来接待你。</p><p>那么，<strong>进程代数</strong>又是什么滴干活？顾名思义，进程代数也就是对进程</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;进程代数，估计有些人听到这个词就开始头疼了，其实我也是。这次尽可能地讲得爸妈都能听懂。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数学" scheme="https://sakebow.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="进程代数" scheme="https://sakebow.github.io/tags/%E8%BF%9B%E7%A8%8B%E4%BB%A3%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>k-means简介</title>
    <link href="https://sakebow.github.io/2020/12/16/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/k%E5%9D%87%E5%80%BC%E7%AE%97%E6%B3%95/k-means%E7%AE%80%E4%BB%8B/"/>
    <id>https://sakebow.github.io/2020/12/16/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/k%E5%9D%87%E5%80%BC%E7%AE%97%E6%B3%95/k-means%E7%AE%80%E4%BB%8B/</id>
    <published>2020-12-16T10:20:00.000Z</published>
    <updated>2020-12-16T10:21:14.428Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><a id="more"></a><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;
    
    </summary>
    
    
      <category term="人工智能" scheme="https://sakebow.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
      <category term="算法模型" scheme="https://sakebow.github.io/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>深空探测：我们的目标是星辰大海！</title>
    <link href="https://sakebow.github.io/2020/12/13/%E6%B7%B1%E7%A9%BA%E6%8E%A2%E6%B5%8B/%E6%B7%B1%E7%A9%BA%E6%8E%A2%E6%B5%8B%EF%BC%9A%E6%88%91%E4%BB%AC%E7%9A%84%E7%9B%AE%E6%A0%87%E6%98%AF%E6%98%9F%E8%BE%B0%E5%A4%A7%E6%B5%B7%EF%BC%81/"/>
    <id>https://sakebow.github.io/2020/12/13/%E6%B7%B1%E7%A9%BA%E6%8E%A2%E6%B5%8B/%E6%B7%B1%E7%A9%BA%E6%8E%A2%E6%B5%8B%EF%BC%9A%E6%88%91%E4%BB%AC%E7%9A%84%E7%9B%AE%E6%A0%87%E6%98%AF%E6%98%9F%E8%BE%B0%E5%A4%A7%E6%B5%B7%EF%BC%81/</id>
    <published>2020-12-13T10:30:00.000Z</published>
    <updated>2020-12-22T01:52:22.969Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>深空探测，听起来遥不可及。不过呢，嫦娥五号的发射，给我们带了点月球上的土壤回来，仔细想想离我们似乎也不远，只是术业有专攻，目前所掌握的只是对这个项目有没有作用罢了。</strong></p><a id="more"></a><h2 id="深空探测的定义"><a href="#深空探测的定义" class="headerlink" title="深空探测的定义"></a>深空探测的定义</h2><blockquote><p>深空探测是指脱离地球引力场，进入太阳系空间和宇宙空间的探测。根据2000年发布的《中国的航天》白皮书中的定义，国内目前将对地球以外天体开展的空间探测活动称为深空探测。</p><p>——摘自<a href="https://baike.baidu.com/item/深空探测/1716601" target="_blank" rel="noopener">百度百科【深空探测】</a></p></blockquote><p>当然，这个是$2000$年给出的定义。到现在，已经许多国家把火箭射到月球上，似乎人们认为除了地月之外的星球才叫<strong>深空探测</strong>。</p><p>这都无所谓了。总之就是到我们看不到的、不知道的宇宙中去，看看环境、取点土、走动走动试试引力、插面小旗子啥的。这就是深空探测的<strong>最终目的</strong>。</p><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>不如说刚刚说的事情应该怎么做就是个大问题。这些个事情分接下来就是：</p><ul><li>怎么上天？</li><li>怎么导航？</li><li>怎么停靠？</li><li>怎么通信？</li><li>怎么返航？</li><li>怎么分析？</li><li>……</li></ul><p>真是一大堆问题等着我们解决。不过可以放心的是，这些个问题都是由国家<strong>不计成本</strong>也要完成的项目，一定会能解决的；更可靠的是，大部分都<strong>已经探索出了一套解决方案</strong>，不管是<strong>我们自己探索的</strong>，还是<strong>照搬别人的</strong>经验。</p><ul><li>$1970$年<strong>东方红一号</strong>被送上去了</li><li>$2003$年<strong>神舟五号</strong>把杨利伟送上天了</li><li>$2007$年<strong>嫦娥一号</strong>飞到了月球上</li><li>$2013$年<strong>嫦娥三号</strong>在月球正面着陆了</li><li>$2014$年<strong>嫦娥五号试验器</strong>“打水漂”式返航保证舱内温度</li><li>$2016$年<strong>神州十一号</strong>和<strong>天宫二号</strong>自动交会对接了</li><li>$2019$年<strong>嫦娥四号</strong>在月球背面着陆了</li><li>……</li></ul><p><strong>看起来完成度已经相当高了</strong>！</p><p>不知道刚刚上天的<strong>嫦娥五号</strong>有什么新突破呢！</p><h2 id="国内外研究现状"><a href="#国内外研究现状" class="headerlink" title="国内外研究现状"></a>国内外研究现状</h2><p>不过呢，还是有人喜欢把中国和外国放一起碰一碰，像看斗鸡一样，不过还是看到一些非常有意思的言论。</p><blockquote><p>总结一下，别去和日本比航天，我们靠着体量优势搞别人心态不太好。我们国家现在的航天业是一颗粗壮但是不够高的大树，而日本我愿称他为挂在美国身上的爬山虎，你要去和爬山虎比高度，最好先超过他爬的那个东西。</p><p>——摘自<a href="https://www.zhihu.com/question/427321294/answer/1605958247" target="_blank" rel="noopener">知乎<strong>No.99的师兄</strong>对于<strong>中国嫦娥五号和日本隼鸟二号在综合技术水准上相比较来看孰强孰弱？</strong>的回答</a></p></blockquote><p>言语犀利，一语中的。</p><p>不过仔细想想，我国和外国到底有什么差距？</p><blockquote><p>美俄处于运载<strong>火箭霸主地位</strong>，主级动力采用大推力高能量的液体火箭发动机。运载火箭末级有仪器舱，内装制导与控制系统、遥测系统和发射场安全系统。有效载荷装在仪器舱的上面，外面套有整流罩。它每一级都包括箭体结构、推进系统和飞行控制系统，级与级之间靠级间段连接。各运载火箭主级动力方案大多采用成熟的液体火箭发动机，可以降低火箭总体的总质量、提高可靠性和保证研制进度。</p><p>——摘自<a href="https://www.chyxx.com/industry/201710/571603.html" target="_blank" rel="noopener">中国产业信息网【2017年全球运载火箭发展现状分析】</a></p></blockquote><p>除了这些笼统的技术，最核心的部分还是运载火箭的<strong>上面级</strong>。什么是上面级？我们曾多次在发射火箭的时候会听到类似<strong>三级运载火箭</strong>之类的字样，而<strong>上面级</strong>就是说运载火箭的第一级，即<strong>运载火箭头部附近的一级</strong>，包括<strong>推进器</strong>和<strong>火箭头部的卫星</strong>。</p><blockquote><p>20世纪50年代末，美国就开始了<strong>上面级</strong>的研制。美国在研制上面级的过程中,非常注重上面级的通用性,其研制的上面级大多数既可用于一次性运载火箭,又可用于航天飞机,并且新研制的上面级都强调自主式,有独立的制导、控制和导航系统以及电源、遥测、跟踪和指令系统。</p><p>俄罗斯继承了前苏联在上面级领域的研究成果，在上面级的研制应用使火箭不但能满足俄罗斯联邦政府的发射任务需求，而且可以为商业用户提供强大的发射服务能力。从$2001$年的和风$M$火箭是那一系列中运载能力的巅峰，到配合<code>KVRB</code>的20%运输能力增幅，可以看出俄罗斯在运载能力方面下了不少功夫。</p><p>目前国际商业发射服务市场中，欧洲的阿里安$5$火箭占有一半以上的份额，且绝大部分发射任务使用一箭双星发射方式。可贮存液体的<code>EPS</code>就是为了增强阿里安火箭的适应性而发明的，使得上面级在注入推进剂$45$天后仍然能够正常运行。可以看出，欧盟更突出的是火箭的适应性。</p><p>而中国的上面级在很多方面还是由所欠缺，主要表现在：</p><ul><li><p>起步晚。我国和美俄相比大概相差30年左右，所以现在国内的航天技术也就能力有限；</p></li><li><p>投入不足，技术也相对较为落后。除了资金以外，还缺少对这方面较为熟悉的人才。 </p></li></ul><p>——<em>总结自<strong>唐军刚</strong> <strong>陈塞崎</strong> <strong>陈益</strong> <strong>刘欣</strong>，<strong>国内外运载火箭上面级发展现状分析</strong></em></p></blockquote><h2 id="大行星到小行星"><a href="#大行星到小行星" class="headerlink" title="大行星到小行星"></a>大行星到小行星</h2><p>当然啦，到了$2020$年的今天，我们已经向地球以外的地方发射了很多卫星和空间站，也就是说，在<strong>地月系统</strong>中乃至<strong>银河系</strong>中的<strong>大行星</strong>我们所能做到的已经非常之多了。虽然像<strong>冥王星</strong>、<strong>海王星</strong>之类的太远的行星可能还没能到达，但是也八九不离十了，<strong>照搬</strong>我们过去的探索经验就能正常登陆再返航。</p><p>但是呢，小行星依然是一片空白。相比我们之前的探索，由于大行星强大的吸引力，登陆都是很普通的<strong>砸下去</strong>，<strong>减震</strong>和<strong>保护</strong>是重中之重。而小行星呢？极端一点的情况，带上人的卫星可能就<strong>刚好</strong>一个小行星那么大，于是<strong>两者之间出现了引力</strong>，这就相对来说比较棘手。有没有更极端的？当然有，小行星甚至有一个鹅卵石大小。不过这些都无所谓了，宇航员努力<strong>亿</strong>把，出门一把抓下来就是了。但是想要靠近与卫星相近的小行星，也是一大难题。这个有人喜欢把这个过程称为“<strong>附着</strong>”，因为有可能碰一下就撞飞了，也有可能撞碎了。总之硬碰硬并不值得提倡。</p><p>当然啦，除了这些个困难，还有个很要命的，就是<strong>控制</strong>。在足够远的地方，甚至没办法由地球控制，要控制也是极大的延迟，远远大于我们玩游戏时候的延迟。这也正是<strong>深空探测</strong>的重点之一。比起能够随着环境改变而自由发挥、自行决策的智能生命体而言，机器只是个笨头笨脑的大块头而已。如何让卫星<strong>自行决策</strong>、<strong>自发控制</strong>就成了一大难题。</p><p>但是很可惜的是，智能算法似乎在软件中非常多，尤其是以<code>Python</code>为首的各类机器学习库；而在硬件却少得可怜，目前能够在控制中使用的依然是<strong>传统算法</strong>，包括遗传算法等经典算法。（<del><em>或者是有其他好的方法却并没有开源？</em></del>）</p><h2 id="怎么让机器带有智能"><a href="#怎么让机器带有智能" class="headerlink" title="怎么让机器带有智能"></a>怎么让机器带有智能</h2><p>既然明白了现在最重要的问题是什么，我们就要开始思考怎么去做了。</p><p>在做之前，不如问问自己：“什么叫做<strong>拥有智能</strong>”？我们看到鹦鹉在和人对话，我们说是“<strong>聪明</strong>”；我们看到狗狗叼着树枝却进不来门，我们说是“<strong>不聪明</strong>”。这之间有什么区别吗？重要的地方就是在<strong>对于当前现状的随机应变能力</strong>。</p><p>同样的，这样一颗没办法由我们控制的卫星要拥有足够的智能的话，也是应当<strong>在面对不同环境的时候有不同的应变方式</strong>。</p><ul><li>在小行星附着的时候，如果说下方是一大块弹坑，掉进去就出不来了，那就不能随便附着；</li><li>在小行星附着的时候，如果说那只是一团水而已，那就没办法触碰，也就只能尽可能停在比较靠近的表面上空；</li><li>在小行星附着的时候，如果说突然就进入了暗面失去了太阳光，那就需要权衡当前任务是否值得不顾电力的消耗持续进行；</li><li>……</li></ul><p>如此多的复杂情况，在面对的时候展现了不一样的应对方式。让机器完全独立自主地在我们所不知道的深空自由探索，这就是机器学习一直以来想要做的事情。大疆无人机、智能扫地机器人等等一系列的智能解决方案就是非常典型的智能机器。</p><p>当然，有些人会觉得使用<strong>脑科学</strong>来给机器提供智能是非常不错的解决方案。但是，脑科学现在谁也说不清楚，深空探测却又刻不容缓，目前唯一能够想到的解决方案就是使用机器学习来尽可能地去实现人脑这个黑匣子的一些功能。</p><h2 id="柔性任务"><a href="#柔性任务" class="headerlink" title="柔性任务"></a>柔性任务</h2><p>需要在面对不同的情况使用不同的应对方式，作为一个天生拥有智能的中国国籍生命体，最普通的方法就是“<strong>具体问题具体分析</strong>”（<del><em>虽然这句话出自马克思主义哲学，但是无所谓啦！</em></del>）。</p><p><strong>但是这就意味着一个问题</strong>。如果说我是按照固定模式作息的，也就是说使用<strong>刚性任务</strong>作息，该什么时候做什么事。早上$9$点上班，中午$12$点吃午餐，下午$6$点吃晚餐，晚上$9$点下班，一周工作$7$天。那么，突如其来的疾病、车祸、疫情等等突发情况，<strong>一切就乱了套了</strong>。就拿最近的疫情说事。早上$9$点，公交不敢坐，小车不让跑；工作的时候另一边合作公司因为疫情关门了，工作直接做不下去；配送资源紧张，不仅没货，配送的人都没有。$9$点不能打卡，$12$点吃不了午餐，$9$点也没办法下班。</p><p>于是，面对这些个情况，你做出了一些改变。$9$点不能坐公交，就骑个小电驴，顶着刺骨的冷风往公司赶；$12$点不能吃午饭，要么早点点外卖，要么准备便当中午热一下；工作做不了，那就找点别的工作，总之把堆在一起的订单一个个解决……</p><p>这就是<strong>柔性任务</strong>。</p><blockquote><p>“<strong>柔性</strong>”是指生产组织形式和自动化制造设备对加工任务（工件）的<strong>适应性</strong>。</p><p>——摘自<a href="https://baike.baidu.com/item/柔性/300024" target="_blank" rel="noopener">百度百科【柔性】</a></p></blockquote><p>在这里，强调的就是<strong>适应性</strong>，也就是对各种突发状况的容错能力。当然，机器本身是没有任何适应能力的。所以，目前的解决办法就是<strong>将多个能够独立进行决策的智能芯片放在一起进行最终的决策</strong>。听起来就像<strong>随机森林</strong>一样呢！使用多个独立分类的决策树，并将所有的分类整合在一起进行投票，最终得出一个决策。</p><p>这下，我们又回到了最初的<a href="/2020/12/01/决策树算法/大树荫：决策树的算法原理">决策树</a>了。</p><h2 id="柔性任务的应用"><a href="#柔性任务的应用" class="headerlink" title="柔性任务的应用"></a>柔性任务的应用</h2><p>不难想，如果是一个先进的技术，那么一定是从<strong>军事</strong>开始。也就是无人机的自主攻击、躲避、侦察和防御，甚至还要进行多无人机的协同作业。觉得离自己太远了？那就举一个非常近的例子：<strong>游戏<code>AI</code></strong>。尤其是王者荣耀中钻石段位以上的人机<code>AI</code>，甚至能够进行团队协作。</p><p>单个游戏人物有可能并不能对玩家造成什么影响，但是能够团队协作的游戏人物可能就相当棘手了。面对你的火力输出，会有防御足够强的人站在面前；面对你的游走消耗，会展开阵型并使用特殊技能限制你的行动；面对你必胜的一击，甚至需要抉择牺牲哪一只才可以最大止损……同样在多无人机协同中也是如此。</p><p>这样的任务规划，如果应用在非载人航天器上，是不是也能成立呢？<strong>是的</strong>。如果说，我们只送上去<strong>一只卫星</strong>，那么就是<strong>单一个体的任务规划</strong>；如果我们送上去了<strong>一群卫星</strong>，分别负责行星的多个部分的采样和探索，或者说要去宇宙中某个战争爆发了的危险之地执行任务，那就是<strong>多无人机协同</strong>。</p><p>是不是有点能理解了呢？</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;深空探测，听起来遥不可及。不过呢，嫦娥五号的发射，给我们带了点月球上的土壤回来，仔细想想离我们似乎也不远，只是术业有专攻，目前所掌握的只是对这个项目有没有作用罢了。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="人工智能" scheme="https://sakebow.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
      <category term="论文研究" scheme="https://sakebow.github.io/tags/%E8%AE%BA%E6%96%87%E7%A0%94%E7%A9%B6/"/>
    
  </entry>
  
  <entry>
    <title>人到底多贵？</title>
    <link href="https://sakebow.github.io/2020/12/10/diary/%E4%BA%BA%E5%88%B0%E5%BA%95%E5%A4%9A%E8%B4%B5%EF%BC%9F/"/>
    <id>https://sakebow.github.io/2020/12/10/diary/%E4%BA%BA%E5%88%B0%E5%BA%95%E5%A4%9A%E8%B4%B5%EF%BC%9F/</id>
    <published>2020-12-10T14:51:00.000Z</published>
    <updated>2020-12-11T08:11:06.885Z</updated>
    
    <content type="html"><![CDATA[<script src="/crypto-js.js"></script><script src="/mcommon.js"></script><h3 id="encrypt-message">如果你坚持要看，请联系我。</h3><link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.min.css"> <link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap-theme.min.css"> <script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script> <script src="//cdn.bootcss.com/bootstrap/3.3.5/js/bootstrap.min.js"></script> <div id="security"> <div> <div class="input-group"> <input type="text" class="form-control" aria-label="Enter the password." id="pass"/> <div class="input-group-btn"> <button type="button" class="btn btn-default" onclick="decryptAES()">Decrypt</button> </div> </div> </div> </div> <div id="encrypt-blog" style="display:none"> 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 </div>]]></content>
    
    <summary type="html">
    
      本文包含了非常多的“内心宣泄”与“偏见”，因此不开放。
    
    </summary>
    
    
      <category term="日记" scheme="https://sakebow.github.io/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="随笔" scheme="https://sakebow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>VScode侧边栏字体调整</title>
    <link href="https://sakebow.github.io/2020/12/04/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/VScode%E4%BE%A7%E8%BE%B9%E6%A0%8F%E5%AD%97%E4%BD%93%E8%B0%83%E6%95%B4/"/>
    <id>https://sakebow.github.io/2020/12/04/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/VScode%E4%BE%A7%E8%BE%B9%E6%A0%8F%E5%AD%97%E4%BD%93%E8%B0%83%E6%95%B4/</id>
    <published>2020-12-04T07:30:00.000Z</published>
    <updated>2020-12-06T05:33:24.303Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>现在全网都只有关于<code>Windows</code>系统中修改<code>VScode</code>侧边栏字体大小的方法，在这里介绍<code>Ubuntu</code>系统的修改方法。<code>VScode</code>虽然好用，但是</strong>默认字体实在是太小了<strong>，侧边栏默认$13$号字体，编辑器默认$14$号字体，对于我来说完全<code>hold</code>不住。所以，我去改一改。</strong></p><a id="more"></a><h2 id="寻找侧边栏配置文件"><a href="#寻找侧边栏配置文件" class="headerlink" title="寻找侧边栏配置文件"></a>寻找侧边栏配置文件</h2><h3 id="和Windows不太一样的安装目录和存储文件"><a href="#和Windows不太一样的安装目录和存储文件" class="headerlink" title="和Windows不太一样的安装目录和存储文件"></a>和<code>Windows</code>不太一样的安装目录和存储文件</h3><p>首先就是<strong>用户自己可以设置的</strong>配置文件，也就是<code>settings.json</code>。但是，发现<code>sideBar</code>只有左边还是右边的设置。</p><p><img src="https://sakebow.gitee.io/images/经验分享/sidebar-setting.png" alt="只有左右设置"></p><p><strong>这显然不是我们想要的结果</strong>。</p><h3 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h3><p>于是，在<a href="http://www.zxmseed.com/blog/208537" target="_blank" rel="noopener"><code>Zxmseed</code>写的Visual Studio Code 左侧资源管理器字体设置</a>中找到了配置所在，也就是<code>${installation-location}\Microsoft VS Code\resources\app\out\vs\workbench\</code>里面的<code>workbench.main.css</code>文件中。<strong>但是很不幸</strong>，在<code>Ubuntu</code>系统和<code>Windows</code>系统还是很有些<strong>不一样</strong>的。</p><h3 id="使用Linux特有的手段查找文件"><a href="#使用Linux特有的手段查找文件" class="headerlink" title="使用Linux特有的手段查找文件"></a>使用<code>Linux</code>特有的手段查找文件</h3><p>所以，我们使用<code>Linux</code>的<code>find</code>命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> find <span class="variable">$&#123;folder name&#125;</span> -name <span class="variable">$&#123;part of target folder or file name&#125;</span></span></span><br><span class="line">find /usr -name 'code'</span><br></pre></td></tr></table></figure><p>这行命令的意思是：<strong>在<code>/usr</code>文件夹下寻找包含<code>code</code>这个单词的子文件夹或者文件</strong>。</p><p>当然，你也可以使用第三方包，比如<code>mlocate</code>，需要使用安装命令进行安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install mlocate</span><br></pre></td></tr></table></figure><p>然后使用<code>mlocate</code>包中的<code>locate</code>命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locate code</span><br></pre></td></tr></table></figure><p>这种方法<strong>不需要指定查找位置</strong>，直接输入名称就给你匹配出来。</p><h3 id="找到了！"><a href="#找到了！" class="headerlink" title="找到了！"></a>找到了！</h3><p>不管用什么方法，最终也很幸运，我们找到了：</p><p><img src="https://sakebow.gitee.io/images/经验分享/folder-finding.png" alt="寻找VScode"></p><p>于是我们一个个试，发现<code>/usr/share/code</code>就是我们要找的文件夹，也就是<code>Microsoft VScode</code>的安装目录。</p><p>接着对照<code>Zxmseed</code>的博客中所指的位置，<strong>锁定了<code>/usr/share/code/resources/app/out/vs/workbench</code></strong>，里面有个文件是<code>workbench.desktop.main.css</code>。</p><p><img src="https://sakebow.gitee.io/images/经验分享/lock-folder.png" alt="锁定文件夹"></p><p>是不是和<code>Windows</code><strong>有些不同</strong>？也可能是版本更新之后才有所不同的吧。</p><h2 id="修改侧边栏配置文件"><a href="#修改侧边栏配置文件" class="headerlink" title="修改侧边栏配置文件"></a>修改侧边栏配置文件</h2><h3 id="没什么做不到的Vim编辑器"><a href="#没什么做不到的Vim编辑器" class="headerlink" title="没什么做不到的Vim编辑器"></a>没什么做不到的<code>Vim</code>编辑器</h3><p>一般<code>Linux</code>系统（<em>不包含<code>Deepin</code>等国产魔改系统</em>）都会内置<code>vi</code>命令来修改文件，<strong>但是非常难用</strong>。所以这里我们改用<code>Vim</code>，需要使用命令安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install vim</span><br></pre></td></tr></table></figure><p>安装完就<strong>已经没什么好怕的了</strong>。</p><p>找到目标之后，我们<strong>使用<code>Vim</code>打开</strong>这个文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /usr/share/code/resources/app/out/vs/workbench/workbench.desktop.main.css</span><br></pre></td></tr></table></figure><p>你会发现很大一批文字。<strong>千万不要妄图使用<code>gedit</code>命令打开超级大的文本文件</strong>，<strong>会卡得不行</strong>。</p><p>进入之后，我们使用<code>Vim</code>的<strong>字符串匹配功能</strong>一个个找下去，也就是在界面直接输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> /是匹配命令，后面是匹配字符串</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 直接输入不必回车，就只设置这么多字符串就能找到了</span></span><br><span class="line">/.content&#123;font</span><br></pre></td></tr></table></figure><p><img src="https://sakebow.gitee.io/images/经验分享/font-setting.png" alt="找到位置"></p><p>立马就锁定了这个位置。按下回车，光标就会停在<code>.content</code>这儿。默认字体大小是$13$号，我们稍微增大一些，改为$15$号，就按下<code>i</code>键，进入编辑模式，左下角会出现“<strong>—插入—</strong>”的字样，就能修改了。修改完按下<code>Esc</code>键退出编辑模式，再输入<code>:x</code>保存修改并退出。</p><h2 id="重启VScode应用，成功修改侧边栏字体"><a href="#重启VScode应用，成功修改侧边栏字体" class="headerlink" title="重启VScode应用，成功修改侧边栏字体"></a>重启<code>VScode</code>应用，成功修改侧边栏字体</h2><p>最后，就修改成功了。将<code>VScode</code>全部关掉，然后重新打开，我们就能看到左边的字体稍微有些大了。</p><h2 id="编辑器字体修改"><a href="#编辑器字体修改" class="headerlink" title="编辑器字体修改"></a>编辑器字体修改</h2><p>相对的，编辑器的修改就方便很多。直接在上方的<code>File</code>菜单栏里找到<code>Preferences</code>的<code>settings</code>。当然，你也可以使用快捷键：<code>Ctrl</code>+<code>，</code>，在里面搜索<code>font</code>，就能够修改编辑器的字体大小。</p><p><img src="https://img-blog.csdnimg.cn/20201204143634557.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29yZGluYXJ5X2Jyb255,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>是不是有点能理解了呢？</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;现在全网都只有关于&lt;code&gt;Windows&lt;/code&gt;系统中修改&lt;code&gt;VScode&lt;/code&gt;侧边栏字体大小的方法，在这里介绍&lt;code&gt;Ubuntu&lt;/code&gt;系统的修改方法。&lt;code&gt;VScode&lt;/code&gt;虽然好用，但是&lt;/strong&gt;默认字体实在是太小了&lt;strong&gt;，侧边栏默认$13$号字体，编辑器默认$14$号字体，对于我来说完全&lt;code&gt;hold&lt;/code&gt;不住。所以，我去改一改。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="经验分享" scheme="https://sakebow.github.io/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="VScode魔改" scheme="https://sakebow.github.io/tags/VScode%E9%AD%94%E6%94%B9/"/>
    
  </entry>
  
  <entry>
    <title>什么是支持向量机</title>
    <link href="https://sakebow.github.io/2020/12/03/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/%E4%BB%80%E4%B9%88%E6%98%AF%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"/>
    <id>https://sakebow.github.io/2020/12/03/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/%E4%BB%80%E4%B9%88%E6%98%AF%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/</id>
    <published>2020-12-03T02:53:00.000Z</published>
    <updated>2020-12-06T05:27:25.913Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>支持向量机是什么？什么支持？什么向量？什么机？</strong></p><a id="more"></a><h2 id="支持向量机的定义"><a href="#支持向量机的定义" class="headerlink" title="支持向量机的定义"></a>支持向量机的定义</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;支持向量机是什么？什么支持？什么向量？什么机？&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="人工智能" scheme="https://sakebow.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
      <category term="算法模型" scheme="https://sakebow.github.io/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>参天树：决策树的操作</title>
    <link href="https://sakebow.github.io/2020/12/03/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E5%86%B3%E7%AD%96%E6%A0%91%E7%AE%97%E6%B3%95/%E5%8F%82%E5%A4%A9%E6%A0%91%EF%BC%9A%E5%86%B3%E7%AD%96%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
    <id>https://sakebow.github.io/2020/12/03/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E5%86%B3%E7%AD%96%E6%A0%91%E7%AE%97%E6%B3%95/%E5%8F%82%E5%A4%A9%E6%A0%91%EF%BC%9A%E5%86%B3%E7%AD%96%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C/</id>
    <published>2020-12-03T02:53:00.000Z</published>
    <updated>2020-12-19T07:37:15.950Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>既然已经了解了决策树的定义和原理，那么现在就更进一步，对树进行描述和修剪，就像是园艺师一样。</strong></p><a id="more"></a><h2 id="知识点复习：哈夫曼树"><a href="#知识点复习：哈夫曼树" class="headerlink" title="知识点复习：哈夫曼树"></a>知识点复习：哈夫曼树</h2><p>如果说大学稍微努了一点力，那么应该会了解一点<strong>哈夫曼树</strong>。</p><p>在哈夫曼树创建的时候，我们会优先计算所有元素的<strong>频率</strong>，然后将频率<strong>最高</strong>的几个元素放在最靠近树的根部的地方。每一次迭代中使用的元素的永远是<strong>当前元素集合</strong>里使用频率<strong>最低</strong>的，在树的构建过程中所使用的编码也会一次次加长。最终形成的树就是哈夫曼树。</p><p>为什么要这样做？实际上，哈夫曼树是根据<strong>贪心算法</strong>得来的。<strong>每一次都剔除一个最差的情况</strong>，<strong>反过来则是每一次添加一个最好的情况</strong>。也正是我们所需要寻求得最好的结果。</p><blockquote><p><img src="https://images2015.cnblogs.com/blog/947994/201605/947994-20160516090649248-600249851.png" alt="哈夫曼树"></p><p>——摘自【<code>wxdjss</code>的博客园】(<a href="https://www.cnblogs.com/wxdjss/p/5496937.html" target="_blank" rel="noopener">https://www.cnblogs.com/wxdjss/p/5496937.html</a>)</p></blockquote><p>同样的，<strong>决策树也是类似</strong>，当然也会有所改进。至于改进在哪？那自然是作为<strong>权重</strong>出现在决策树中间的<strong>信息增益</strong>。</p><p>我们得到了每一个节点的<strong>信息增益</strong>，其实也就相当于哈夫曼树中每个节点中的频率。</p><p>既然我们明白了决策树的创建这<strong>换汤不换药</strong>的操作，那就开始看看这些“药”到底换了什么<strong>汤</strong>。</p><h2 id="ID3算法"><a href="#ID3算法" class="headerlink" title="ID3算法"></a><code>ID3</code>算法</h2><p>在这个算法中，使用的概念也是<strong>信息熵</strong>，当然你也可以叫他<strong>权重</strong>，或者“<strong>纯度</strong>”。</p><p>什么是纯度？<strong>实际上也不过是取和熵值完全相反的意义而已</strong>。<strong>纯度越高</strong>，<strong>熵值越低</strong>。举个例子，还是<a href="/2020/12/01/人工智能/决策树算法/大树荫：决策树的算法原理/">上一个决策树的文章</a>中的箱子分类问题。如果我们并<strong>不按照</strong>相应的方法进行分类，而是直接将箱子里的每一件<strong>都单独作为一类</strong>，那么这个类的信息熵就是：$H(x)=-P(x)<em>\log_2P(x)=-1</em>\log_21=0$，即，<strong>没有熵</strong>。这个类的纯度就相当的高。只不过，这样划分的代价很明显。</p><ul><li>从现实情况来讲，这样就没办法分类，面对现在放在房间里的物品就只能使用大量的箱子占用大量的空间。</li><li>从算法角度来讲，这样就没办法决策，如果又来一箱，你所做的也不过是把所有的东西倒出来而已，在将来只能花费更多的时间进行决策。</li></ul><p>所以，如何选择合适的<strong>纯度</strong>就是一个重点问题了。但是呢，根据不同的数据，也会构造出不同的树，也会有不同的纯度计量方法。究其根源，既然是不纯度，那就和<strong>高信息熵</strong>有关，也就是这个数据集<strong>相当的混乱</strong>，也就是<strong>概率分布非常杂乱无章</strong>。</p><p>拿到一大堆数据之后，我们直接按照列划分，每一列都有自己的<strong>信息熵</strong>。这里，我们为了能够更快地得出我们想要的决策树，我们就可以使用贪心算法，直接选择<strong>信息熵最小</strong>的一列作为根节点。因为这个节点<strong>信息的混乱程度</strong>相当低，可以在尽可能短的时间找到一个分类，这样对于之后的分类也会比较方便。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;既然已经了解了决策树的定义和原理，那么现在就更进一步，对树进行描述和修剪，就像是园艺师一样。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="人工智能" scheme="https://sakebow.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
      <category term="算法模型" scheme="https://sakebow.github.io/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>大树荫：决策树的算法原理</title>
    <link href="https://sakebow.github.io/2020/12/01/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E5%86%B3%E7%AD%96%E6%A0%91%E7%AE%97%E6%B3%95/%E5%A4%A7%E6%A0%91%E8%8D%AB%EF%BC%9A%E5%86%B3%E7%AD%96%E6%A0%91%E7%9A%84%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/"/>
    <id>https://sakebow.github.io/2020/12/01/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E5%86%B3%E7%AD%96%E6%A0%91%E7%AE%97%E6%B3%95/%E5%A4%A7%E6%A0%91%E8%8D%AB%EF%BC%9A%E5%86%B3%E7%AD%96%E6%A0%91%E7%9A%84%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/</id>
    <published>2020-12-01T07:06:00.000Z</published>
    <updated>2020-12-02T14:06:08.715Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>我们理解了决策树的定义与目的之后，我们便可以开始了解决策树背后的意义了。</strong></p><a id="more"></a><h2 id="信息熵和信息量化"><a href="#信息熵和信息量化" class="headerlink" title="信息熵和信息量化"></a>信息熵和信息量化</h2><p><strong>“等下，信息量有点大……”</strong></p><p>当我们面对有点难以接受和一时间反应不过来的信息时，我们经常说这句话。</p><p>你家的猫娘听到了特朗普败选的消息，一定是一脸不明所以地盯着眼前这个又跳又叫的奇怪生物；而如果是你和你的室友，那么就会相视一笑。为什么会有这样的差别？因为你的室友和你的猫娘<strong>所接收的信息量是不相同的</strong>。</p><p>信息量<strong>越是不足</strong>，那么这件事情就<strong>越不确定</strong>，要<strong>把这件事情搞清楚所需要的信息就越多</strong>；反之，信息量<strong>越足</strong>，各种局势也<strong>愈发明朗</strong>，要<strong>把这件事情搞清楚所需要的信息就越少</strong>。</p><p>那么，信息量怎么衡量？单纯的通过人的接受能力和反应时间实在是太主观了，也太武断了。更何况，如果不是使用数学方法衡量的话，现在也很难直接使用机器学习的方法帮助我们<strong>充分挖掘信息中的潜在价值</strong>。</p><blockquote><p>1948年，像农在他著名的《通信的数学原理》中提出了<strong>信息熵</strong>的概念，从而解决了信息量化的问题。</p><p>——摘自《scikit-learn机器学习常用算法原理与编程实战》 [著]黄永昌</p></blockquote><p>如果你的脑海里还残存了一点点高中化学的知识，你应该知道，<strong>熵是一种不稳定状态的度量方式</strong>。<strong>熵越大</strong>，<strong>空间内越混乱</strong>。那么信息熵也应当类似。如果说对这件事<strong>完全弄明白了</strong>，那么就是一种<strong>稳定状态</strong>；而<strong>半懂不懂</strong>则是一种<strong>不稳定的状态</strong>。信息熵描述的就是对这个信息来说从不稳定（<em>也就是没有完全理解</em>）到稳定（<em>也就是彻底理解</em>）之间的差距。</p><p>信息熵的量化公式就是：</p><script type="math/tex; mode=display">H(X) = -\sum_{x\in X}P(x)log_2P(x)</script><p>其中，$X$指所研究的事件集合，$x$指事件集合中所出现的其中一个事件，$P(x)$则是事件$x$所出现的概率。</p><p>如果在我面前有一个宝箱，出货率如下表所示：</p><div class="table-container"><table><thead><tr><th>物品</th><th>概率</th></tr></thead><tbody><tr><td>一次性湿纸巾一包</td><td>$25\%$</td></tr><tr><td>一次性纸手帕一包</td><td>$25\%$</td></tr><tr><td>一次性塑料碗一个</td><td>$25\%$</td></tr><tr><td>一次性木筷子一双</td><td>$25\%$</td></tr></tbody></table></div><p>既然每一种一次性用品抽中的概率都是$25\%$，那么任意抽一次，也就只有这些结果：</p><ul><li>一次性湿纸巾一包</li><li>一次性纸手帕一包</li><li>一次性塑料碗一个</li><li>一次性木筷子一双</li></ul><p>所以，信息熵也就是：</p><script type="math/tex; mode=display">H(抽奖结果)=-(\frac{1}{4}\log_2\frac{1}{4})*4=2(bit)</script><p>没错，结果的单位实际上是<strong>比特</strong>。要确认我这次抽到的是4种一次性用具的哪一种，只需要<strong>两个比特</strong>就能解决，也就是一个字节的$\frac{1}{4}$就可以了，大概就是<code>00000000</code>到<code>00000011</code>，或者是<code>0x00</code>到<code>0x03</code>。</p><p>很神奇不是么？</p><h2 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h2><p>什么是信息增益？<strong>就是信息量的差值</strong>。<strong>信息增益只是一个值</strong>，<strong>没有正负的矢量意义</strong>。还记得之前提到的权重么？<strong>这个权重就是信息增益</strong>。如果增益非常大，那么权重就会非常大。在决策树彻底长成古老的巨树之后，信息增益就会帮我们从根出发，一直上升到对应的叶子。</p><p>好的，到了这一步，我们换个场景：</p><p>现在你刚拿到你的小蛋糕店，也装修完了，现在剩下一地的箱子，共$100$只。$8$个装了垃圾，$16$个是日用品，$16$个是对蛋糕店来说有用的，$4$个是极其重要的，还有$8$个被你的猫娘们占用了，剩下$48$个是空箱子。现在不再是抽奖了，而是你要逐一分类。当然，这个时候你完全可以看看里面是什么。</p><p>渐渐地，在分类的过程中，你也找到了诀窍：</p><ul><li>空箱子非常轻，踢一脚就会滚两圈；</li><li>装了垃圾的箱子会看起来脏一点，蒙着一层灰；</li><li>装了日用品的箱子中，有的会伸出来衣架，有的会散发出沐浴露的香味等等；</li><li>装了蛋糕店相关的箱子和极其重要的箱子会有很明显的警告标志；</li><li>被猫娘们霸占的箱子则会伸出来一只猫尾巴或者猫爪爪</li></ul><p>看起来很有规律了嘛。那么就开始分类吧：</p><p>首先，我们先分析一下，对于这$100$个箱子里面，随便选一个打开看的话，就会有这些事件：</p><script type="math/tex; mode=display">X=\{空箱子(x_1),垃圾箱(x_2),日用品箱(x_3),蛋糕箱(x_4),重要箱子(x_5),猫娘箱(x_6)\}</script><p>概率分布就是这样：</p><div class="table-container"><table><thead><tr><th>$X$</th><th>$x_1$</th><th>$x_2$</th><th>$x_3$</th><th>$x_4$</th><th>$x_5$</th><th>$x_6$</th></tr></thead><tbody><tr><td>$P(x)$</td><td>$0.48$</td><td>$0.08$</td><td>$0.16$</td><td>$0.16$</td><td>$0.04$</td><td>$0.08$</td></tr></tbody></table></div><p>好的，接下来就是信息熵了。</p><h3 id="根"><a href="#根" class="headerlink" title="根"></a>根</h3><p>一开始就是一片混沌的6种箱子混在一起，$H(X)=-\sum_{x\in X}P(x)*\log_xP(x)=2.1231$。</p><h3 id="猫枝叶、部分日用品枝叶"><a href="#猫枝叶、部分日用品枝叶" class="headerlink" title="猫枝叶、部分日用品枝叶"></a>猫枝叶、部分日用品枝叶</h3><p>为了先照顾你心目中最重要的几只小猫娘，你决定<strong>先看看有没有猫</strong>。于是，你看看箱子里伸出来了啥，然后发现了4个伸出来猫爪爪的箱子和4个伸出来猫尾巴的箱子，还发现了8个伸出来衣架的日用品箱子。于是，$H(x_6)=-P(x_6)<em>\log_2P(x_6)=3.64</em>0.08=0.2912$，这就是找到猫娘所需要的信息增益。对于突然发现的日用品箱$(x_7)$我们也计算一下，$H(x_7)=-P(x_7)*\log_2P(x_7)=0.2915$</p><h3 id="分枝"><a href="#分枝" class="headerlink" title="分枝"></a>分枝</h3><p>那么，然后<strong>剩下来空箱子</strong>、<strong>垃圾箱</strong>、<strong>蛋糕箱和剩下的日用品箱</strong>，记为$Y$，$H(Y)=-\sum_{x\in Y}P(x)*\log_2P(x)=1.5143$</p><p>然后看看<strong>有没有警告标记</strong>。找到警告标记之后，会找到蛋糕箱和对自己非常重要的箱子，记为$Z$，$H(Z)=-\sum_{x\in Z}P(x)*\log_2P(x)=0.6088$。</p><p>而剩下一些空箱子、垃圾箱和剩下的日用品箱，记为$A$，$H(x)=-\sum_{x\in A}P(x)*\log_2P(x)=1.0913$</p><h3 id="重要箱子枝叶"><a href="#重要箱子枝叶" class="headerlink" title="重要箱子枝叶"></a>重要箱子枝叶</h3><p>找出了蛋糕箱和重要箱子之后，我们再<strong>打开看看</strong>箱子里是个啥。打开之后如果发现了相册和笔记本，那就是重要箱子，$H(x_5)=-P(x_5)*\log_2P(x_5)=0.1858$。</p><h3 id="蛋糕箱枝叶"><a href="#蛋糕箱枝叶" class="headerlink" title="蛋糕箱枝叶"></a>蛋糕箱枝叶</h3><p>同时，我们也找到了蛋糕箱，$H(x_4)=-P(x_4)*\log_2P(x_4)=0.423$。</p><h3 id="空箱子枝叶"><a href="#空箱子枝叶" class="headerlink" title="空箱子枝叶"></a>空箱子枝叶</h3><p>我们刚刚通过有没有警示标志找出了空箱子、垃圾箱和剩下的日用品箱，我们接下来就<strong>随便踢一脚试试</strong>，如果瞬间就飞出去翻滚两圈，那就是空箱子。于是，$H(x_1)=-P(x_1)*\log_2P(x_1)=0.5803$</p><h3 id="分枝-1"><a href="#分枝-1" class="headerlink" title="分枝"></a>分枝</h3><p>那么，踢不动的就是垃圾箱和日用品箱了，记为$B$，$H(B)=-\sum_{x\in B}P(x)*\log_2P(x)=0.583$</p><h3 id="垃圾箱枝叶、剩余日用品箱枝叶"><a href="#垃圾箱枝叶、剩余日用品箱枝叶" class="headerlink" title="垃圾箱枝叶、剩余日用品箱枝叶"></a>垃圾箱枝叶、剩余日用品箱枝叶</h3><p>最后，我们在最后剩下的<strong>箱子里间闻一闻</strong>，就能够通过有没有沐浴露的清香来分辨最后的两种箱子。没有香味那就应该是充满了灰尘味道的垃圾箱了。于是，$H(x_2)=-P(x_2)<em>\log_xP(x_2)=2.915$。最后就是剩下的$8$个日用品箱了，也就是$H(x_3)=-P(x_3)</em>\log_2P(x_3)=2.915$。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这下整颗树就明了了呢。画张图总结一下吧：</p><p><img src="https://sakebow.gitee.io/images/决策树/决策流程图.png" alt="决策流程图"></p><p>看起来非常不错啊！</p><h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><p><strong>在这里插句嘴</strong>，我们一直在计算熵值，也就是这个函数$H(x)=-P(x)*\log_2P(x)$。如果我们吧这个函数画出来：</p><p><img src="https://sakebow.gitee.io/images/决策树/函数图像.png" alt="决策流程图"></p><p>这也正好说明了：<strong>若是对于这件事发生的概率越大</strong>、<strong>对这件事越确定</strong>，<strong>熵值越低</strong>，<strong>也就越稳定</strong>、<strong>越可靠</strong>。</p><p>当然，<strong>还有一个小小的问题</strong>。在化学里面，只要一个独立的系统放在这里，熵值只会变大，只是时间快慢的问题了。也就是说，要是就把这一堆箱子放在这里，箱子只会越来越乱。当然，对于用电脑比较多的办公人士、码农等等，一段时间只往电脑里塞文件而不分类，电脑里面的文件也只会越来越乱。<strong>为什么要分类</strong>？一方面让自己更好地找到自己想要的东西，另一方面，学术一点的表达就是：<strong>让熵值减少</strong>，<strong>从而该事件更稳定</strong>。如果是表述得更哲学一点，那就是像书中说的一样：</p><blockquote><p>如果没有外力的作用，这个世界将会是越来越无序的。人活着，再与尽量让熵变低，即让世界变得更有序，降低不确定性。</p><p>希望笔者在暮年之时，回首往事，能自信地说，我给这个世界带来的信息增益是正数，且已经尽力做到最大了。</p><p>——摘自《scikit-learn机器学习常用算法原理及编程实战》 [著]黄永昌</p></blockquote><p>是不是有点能理解了呢？</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;我们理解了决策树的定义与目的之后，我们便可以开始了解决策树背后的意义了。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="人工智能" scheme="https://sakebow.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
      <category term="算法模型" scheme="https://sakebow.github.io/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>知识储备：DataFrame的使用</title>
    <link href="https://sakebow.github.io/2020/11/22/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87%EF%BC%9ADataFrame%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://sakebow.github.io/2020/11/22/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87%EF%BC%9ADataFrame%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2020-11-22T14:51:00.000Z</published>
    <updated>2020-12-06T05:33:57.939Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>由于特征分析中包含了很多有关<code>Python</code>中数据分析的方法，这里单独创建一篇文章进行说明。本篇文章会持续更新，收集各种各样非常多不同的、方便的库。</strong></p><a id="more"></a><h2 id="最常用库"><a href="#最常用库" class="headerlink" title="最常用库"></a>最常用库</h2><h3 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a><code>DataFrame</code></h3><p>如果是图表形式，<code>DataFrame</code>将会是最理想的库。包含了多维度合并分析、多维度降维分析、图像等非常方便的库。</p><h3 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a><code>Numpy</code></h3><p>而如果有什么<code>DataFrame</code>做不到的一些事情，就和<code>numpy</code>一起使用，通过矩阵来计算高维度的分析和计算。</p><h3 id="Pandas"><a href="#Pandas" class="headerlink" title="Pandas"></a><code>Pandas</code></h3><p>接着就是读取文件的<code>pandas</code>库。确实，现在有着非常多的代码库，也有非常多的形式读取不同形式的文件。但是<code>pandas</code>库能够将任何形式的文件转变为<code>DataFrame</code>格式，对接起来非常方便。</p><h3 id="matplotlib"><a href="#matplotlib" class="headerlink" title="matplotlib"></a><code>matplotlib</code></h3><p>如果你觉得数据还是太抽象，你可以使用<code>matplotlib</code>库进行图像的绘制，这样能够让数据更为直观，能够协助看清什么数据有着什么样的趋势，哪些数据占比更多而哪些数据占比更少等等。这些直观的表达更能够为我们下一步的决策和分析提供更细致的参考。</p><h2 id="获得数据"><a href="#获得数据" class="headerlink" title="获得数据"></a>获得数据</h2><p>对于数学分析，其实<strong>更推荐文件的形式</strong>，而<strong>不是数据库</strong>。因为数据库的<strong>读取速度非常有限</strong>，在分析大量的数据时需要花费一些时间等待网络请求和数据传输的时间。虽然<code>MongoDB</code>数据库相比<code>Oracle</code>、<code>MySQL</code>、<code>SQL Server</code>等数据库有着非关系型的特点，以<code>JSON</code>的形式保存所有的数据，却还是不能够<strong>在很短的时间内获得大量对象中的同一个属性的属性值进行分析</strong>。所以这里推荐的形式有<code>csv</code>、<code>xls</code>、<code>json</code>和<code>xml</code>等的<strong>本地文件</strong>。</p><ul><li>如果是<code>csv</code>文件，<code>pandas</code>库提供了<code>read_csv(&lt;str&gt; csv_path)</code>方法；</li><li>如果是<code>excel</code>文件，<code>pandas</code>库提供了<code>read_excel(&lt;str&gt; excel_path)</code>方法；</li><li>如果是<code>json</code>文件，<code>pandas</code>库提供了<code>read_json(&lt;str&gt; json_path)</code>方法；</li><li>如果是剪贴板，<code>pandas</code>库提供了<code>read_clipboard()</code>方法；</li><li>……</li></ul><p>基本上涵盖了目前所有的主流格式。</p><h2 id="图表绘制"><a href="#图表绘制" class="headerlink" title="图表绘制"></a>图表绘制</h2><p><code>matplotlib</code>库提供了非常丰富的绘图库，横纵坐标都能够使用<code>numpy</code>的数组。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;由于特征分析中包含了很多有关&lt;code&gt;Python&lt;/code&gt;中数据分析的方法，这里单独创建一篇文章进行说明。本篇文章会持续更新，收集各种各样非常多不同的、方便的库。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="人工智能" scheme="https://sakebow.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
      <category term="Python" scheme="https://sakebow.github.io/tags/Python/"/>
    
      <category term="特征工程" scheme="https://sakebow.github.io/tags/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>开工：数据集的特征理解</title>
    <link href="https://sakebow.github.io/2020/11/22/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/%E5%BC%80%E5%B7%A5%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%9B%86%E7%9A%84%E7%89%B9%E5%BE%81%E7%90%86%E8%A7%A3/"/>
    <id>https://sakebow.github.io/2020/11/22/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/%E5%BC%80%E5%B7%A5%EF%BC%9A%E6%95%B0%E6%8D%AE%E9%9B%86%E7%9A%84%E7%89%B9%E5%BE%81%E7%90%86%E8%A7%A3/</id>
    <published>2020-11-22T00:54:00.000Z</published>
    <updated>2020-11-22T14:38:48.593Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>本篇将详细解释数据集的处理方式。我相信肯定是有小伙伴读过《特征工程入门与实践》，所以这里就拿一些不一样的数据集说明特征理解的过程。</strong></p><a id="more"></a><h2 id="数据集的准备"><a href="#数据集的准备" class="headerlink" title="数据集的准备"></a>数据集的准备</h2><p>在这里我们使用的是德国的能源消耗信息，是一个结构化的报表。由于数据在外网，所以这里下载下来给大家：<a href="https://sakebow.gitee.io/images/数据集/germany_energy.csv" target="_blank" rel="noopener">点击查看并全文复制保存在本地</a>。</p><p>如果你使用<code>Chrome</code>浏览器打开，那么你打开的时候应该是这样：</p><p><img src="https://sakebow.gitee.io/images/特征工程/德国能源数据集.png" alt="数据集"></p><p>我们可以看到，这个数据中包含了从$2006/1/1$开始的所有耗电数据、风力发电数据、太阳能发电数据和风力太阳能混合发电。在准备理解特征之前，我们还是把之前的流程图放在下面供参考：</p><p><img src="https://sakebow.gitee.io/images/特征工程/特征理解流程.png" alt="特征工程流程"></p><p>好的，开搞！</p><h2 id="数据读取"><a href="#数据读取" class="headerlink" title="数据读取"></a>数据读取</h2><p>在这里，我们使用<code>pandas</code>库进行数据的读取。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取数据集文件</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_data</span><span class="params">(path)</span>:</span></span><br><span class="line">  datas = pd.read_csv(path)</span><br><span class="line">  <span class="comment"># 选取耗电作为研究对象</span></span><br><span class="line">  data = datas[[<span class="string">'Date'</span>, <span class="string">'Consumption'</span>]]</span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>封装了这个方法之后，我们调用就是这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我的文件保存在了/home/sakebow/python/data/germany_energy.csv</span></span><br><span class="line">data = get_data(<span class="string">'/home/sakebow/python/data/germany_energy.csv'</span>)</span><br></pre></td></tr></table></figure><p>由于数据本身是用<code>csv</code>存储的，所以具有一定的结构性。<strong>第一步</strong>：<strong>结构化直接完成</strong>$\sqrt{}$</p><p>紧接着，我们来看看每一列的情况：</p><ul><li>日期是定序等级，虽然数值有实际的意义，本质上还是类别；</li><li>能耗是定量数据，在研究的时候还是会觉得数值非常大，所以将所有的能耗数据和$2006/01/01$的相减，得到定距等级；</li><li>风力发电和混合发电也是使用定距等级进行分析。</li></ul><p><strong>第二步</strong>：<strong>每一列的类别分析</strong>，<strong>完成</strong>$\sqrt{}$</p><p>然后我们就对照<a href="/2020/11/21/人工智能/特征工程/准备：特征理解/">准备：特征理解</a>中提供的参照表进行图表的绘制。</p><p>那么对着表一个个看，发现应当这么操作：</p><div class="table-container"><table><thead><tr><th>对象</th><th>使用图表</th></tr></thead><tbody><tr><td>日期</td><td>直方图</td></tr><tr><td>能耗</td><td>折线图、散点图、直方图</td></tr><tr><td>风力</td><td>折线图、散点图、直方图</td></tr><tr><td>太阳能</td><td>折线图、散点图、直方图</td></tr><tr><td>混合</td><td>折线图、散点图、直方图</td></tr></tbody></table></div><p>看起来还不错。不过我们还是想研究<strong>能耗</strong>、<strong>风力</strong>、<strong>太阳能</strong>和<strong>混合发电量</strong>随着时间的推移而变化的趋势，所以，重新规划一下：</p><div class="table-container"><table><thead><tr><th>对象</th><th>变量类型</th></tr></thead><tbody><tr><td>日期</td><td>自变量（作为$x$轴）</td></tr><tr><td>能耗</td><td>因变量（作为$y$轴之一）</td></tr><tr><td>风力</td><td>因变量（作为$y$轴之一）</td></tr><tr><td>太阳能</td><td>因变量（作为$y$轴之一）</td></tr><tr><td>混合</td><td>因变量（作为$y$轴之一）</td></tr></tbody></table></div><p>好了，图表确认了，我们直接开始吧。</p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>首先，我们先拉出数据集里面的日期和耗电量。刚刚我们拿到了一共四列数据的<code>DataFrame</code>对象<code>data</code>现在我们需要提取其中的几列作为研究对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用两个中括号能够同时提取多列作为研究对象</span></span><br><span class="line">consumptions = data[[<span class="string">'Date'</span>, <span class="string">'Consumption'</span>]]</span><br><span class="line"><span class="comment"># 使用DataFrame封装的plot方法能够非常方便的画出图像</span></span><br><span class="line">consumptions.plot()</span><br></pre></td></tr></table></figure><p><strong>执行</strong>！</p><p>好嘛，啥都没发生。纠其原因，就是没有显示图像。画归画，显示又是另一回事。所以我们引入<code>matplotlib</code>作为绘图包。接下来就是完整的代码：</p><p><strong>严重警告</strong>：这部分代码虽然<strong>没问题</strong>，但是得出来的<strong>结果很奇葩</strong>。<strong>复制请慎重</strong>！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> pyplot</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_data</span><span class="params">(path, x, y)</span>:</span></span><br><span class="line">  datas = pd.read_csv(path)</span><br><span class="line">  data = datas[[x, y]]</span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  data = get_data(<span class="string">'/home/sakebow/python/data/germany_energy.csv'</span>, <span class="string">'Date'</span>, <span class="string">'Consumption'</span>)</span><br><span class="line">  data.plot()</span><br><span class="line">  pyplot.xlabel(<span class="string">'date'</span>)</span><br><span class="line">  pyplot.ylabel(<span class="string">'consumption'</span>)</span><br><span class="line">  pyplot.show()</span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p><strong>看起来非常完美</strong>！<strong>运行</strong>！</p><p><img src="https://sakebow.gitee.io/images/特征工程/德国能源数据可视化图表_1.png" alt="德国能源数据"></p><p>嗯……虽然线条没什么问题，但是这个横坐标也太奇葩了吧？直接将<code>DataFrame</code>的索引变成了横坐标。这显然不是什么好图表。</p><p>所以，我们稍加修改：</p><p><strong>注意</strong>：下面这个方法是<strong>正确的</strong>，<strong>请放心复制</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> pyplot</span><br><span class="line"><span class="comment"># 封装读取数据的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_data</span><span class="params">(path, x, y)</span>:</span></span><br><span class="line">  datas = pd.read_csv(path)</span><br><span class="line">  data = datas[[x, y]]</span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  <span class="comment"># 获取数据</span></span><br><span class="line">  data = get_data(<span class="string">'/home/sakebow/python/data/germany_energy.csv'</span>, <span class="string">'Date'</span>, <span class="string">'Consumption'</span>)</span><br><span class="line">  <span class="comment"># 确认索引，并且替换掉原先的索引</span></span><br><span class="line">  data.set_index(<span class="string">'Date'</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">  <span class="comment"># 内置函数绘图</span></span><br><span class="line">  data.plot()</span><br><span class="line">  <span class="comment"># 横坐标备注</span></span><br><span class="line">  pyplot.xlabel(<span class="string">'date'</span>)</span><br><span class="line">  <span class="comment"># 纵坐标备注</span></span><br><span class="line">  pyplot.ylabel(<span class="string">'consumption'</span>)</span><br><span class="line">  <span class="comment"># 显示图表</span></span><br><span class="line">  pyplot.show()</span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p><img src="https://sakebow.gitee.io/images/特征工程/德国能源数据可视化图表_2.png" alt="德国能源数据"></p><p><strong>这就好多了</strong>。</p><p>能够很明显地看出来，没有什么非常明显的规律，甚至还有一定的周期性。</p><p>这也就是特征理解一直在做的事情。通过图表分析数据地走向。如果数据量非常多，我们也可以使用这样的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> pyplot</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  <span class="comment"># 获取数据</span></span><br><span class="line">  datas = pd.read_csv(<span class="string">'/home/sakebow/python/data/germany_energy.csv'</span>)</span><br><span class="line">  <span class="comment"># 确认索引，并且替换掉原先的索引</span></span><br><span class="line">  datas.set_index(<span class="string">'Date'</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">  <span class="comment"># 内置函数绘图</span></span><br><span class="line">  data.plot()</span><br><span class="line">  <span class="comment"># 横坐标备注</span></span><br><span class="line">  pyplot.xlabel(<span class="string">'date'</span>)</span><br><span class="line">  <span class="comment"># 显示图表</span></span><br><span class="line">  pyplot.show()</span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p><img src="https://sakebow.gitee.io/images/特征工程/德国能源数据可视化图表_3.png" alt="德国能源数据"></p><p>像这样就非常明显地表明：<strong>从2006年开始德国的耗电有着周期性的</strong>、<strong>稳定的变化</strong>；<strong>风力发电和太阳能发电一直都在增长</strong>。<strong>但是混合发电量依然远远达不到耗电量</strong>。</p><p>这就是特征理解了。在这个阶段，我们所做的就是<strong>使用图表来理解什么数据是什么趋势</strong>、<strong>通过肉眼大致预测什么数据和什么有关</strong>。接下来就是剩下的步骤了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本篇将详细解释数据集的处理方式。我相信肯定是有小伙伴读过《特征工程入门与实践》，所以这里就拿一些不一样的数据集说明特征理解的过程。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="人工智能" scheme="https://sakebow.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
      <category term="特征工程" scheme="https://sakebow.github.io/tags/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>准备：特征理解</title>
    <link href="https://sakebow.github.io/2020/11/21/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/%E5%87%86%E5%A4%87%EF%BC%9A%E7%89%B9%E5%BE%81%E7%90%86%E8%A7%A3/"/>
    <id>https://sakebow.github.io/2020/11/21/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/%E5%87%86%E5%A4%87%EF%BC%9A%E7%89%B9%E5%BE%81%E7%90%86%E8%A7%A3/</id>
    <published>2020-11-21T02:39:00.000Z</published>
    <updated>2020-11-22T00:53:48.739Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>虽然我们介绍了数据的无量纲化，但是在实际编码之前我们还是需要多做一些准备工作。</strong></p><a id="more"></a><p>在20多年的考试生涯中，老师都不断的提醒我们<strong>多读题</strong>。而在机器学习中，多读题也就变成了<strong>多了解数据的特点</strong>。也就是接下来要介绍的几个特点。</p><h2 id="数据是否具有统一的格式"><a href="#数据是否具有统一的格式" class="headerlink" title="数据是否具有统一的格式"></a>数据是否具有统一的格式</h2><p>现在数据飞速膨胀，单一的数字已经没办法满足现在的高标准严要求了。所以，这里使用一些高维度的数据进行说明。</p><p>还是收集了20万猫娘数据的你，还是分析各种疾病。但是呢，病情记录却不全是报表形式的数据，而是一大堆毫不相关的症状堆叠在一起。这种数据被称为<strong>非结构化数据</strong>，或者是<strong>无组织数据</strong>。就像是：</p><div class="table-container"><table><thead><tr><th>序号</th><th>账号</th><th>情况</th></tr></thead><tbody><tr><td>1</td><td>12301231823</td><td>眼球血丝较多，眼睛经常痒，咽喉处疼痛，鼻涕多</td></tr><tr><td>2</td><td>31287936661</td><td>呼吸不畅，喷嚏非常多，四肢无力</td></tr><tr><td>3</td><td>54174139414</td><td>胃胀痛，干呕，恶心</td></tr><tr><td>…</td><td>…</td><td>…</td></tr></tbody></table></div><p>当我们分析情况的时候，就会人和机器一起一头雾水，不知道从哪开始。</p><p>另外，分析疾病并不能一杆子打死，而是各有不同，需要每只猫娘的个人信息。这个时候，由于医院系统的数字化管理，猫娘的信息都是以非常标准的报表形式给出，非常方便。这些数据就是<strong>结构化数据</strong>，或者是<strong>有组织数据</strong>。就像是：</p><div class="table-container"><table><thead><tr><th>编号</th><th>姓名</th><th>年龄</th><th>性别</th><th>种族</th><th>持有铃铛</th><th>铃铛登记时间</th></tr></thead><tbody><tr><td>123831643</td><td>香子兰</td><td>14</td><td>女</td><td>猫</td><td>是</td><td>2018-12-25</td></tr><tr><td>123862173</td><td>巧克力</td><td>14</td><td>女</td><td>猫</td><td>是</td><td>2019/5/30</td></tr><tr><td>412371383</td><td>铃仙</td><td>16</td><td>女</td><td>兔</td><td>否</td><td>$\times$</td></tr><tr><td>…</td><td>…</td><td>…</td><td>…</td><td>…</td><td>…</td></tr></tbody></table></div><p>收集这些信息的时候，由于非常严格的格式和非常好理解的表格形式，所以读取非常方便。</p><h2 id="数值是指代类别还是具体数值"><a href="#数值是指代类别还是具体数值" class="headerlink" title="数值是指代类别还是具体数值"></a>数值是指代类别还是具体数值</h2><p>还是刚刚的个人信息的例子。</p><p>香子兰是女猫娘，这就是<strong>指代类别</strong>的数据。而年龄是14，这又是<strong>具体数值</strong>。虽然都是每一位用户的属性，却相当明确地给出了完全不一样的参考。</p><p>类别用于给用户分类，比如女性猫娘更适合比较精细的工作，而男性牛头人更适合力量型的工作等等；数值则用于定量表示用户的各种参数信息。比如握力、跳远距离等等。</p><h2 id="数据的四个等级"><a href="#数据的四个等级" class="headerlink" title="数据的四个等级"></a>数据的四个等级</h2><p>刚刚我们把数据分为定性和定量两种，接下来我们继续分类：</p><ul><li>定类等级</li><li>定序等级</li><li>定距等级</li><li>定比等级</li></ul><p>刚刚提到的<strong>指代类别</strong>就是<strong>定类等级</strong>数据，这个比较好理解，就不再赘述。</p><p>而<strong>定序等级</strong>，则是<strong>在同一种前提下对所有的类别进行排序</strong>所得到的类别集合。打个比方，我们需要在地下城寻找更适合当裁缝的种族，所以收集大量的数据，并按照所有种族的平均表现进行排序。最后我们发现，蚕和毛毛虫这两个种族不相上下，并列第一，其次是蜘蛛，然后是人类。于是，我们就得到了一个有序的集合，这个集合就是含有<strong>定序等级</strong>的数据。虽然说这组数据中包含一些使用数据精确说明的定量数据，但是本身代表的实际上是一个类，哪怕这个数字是一个像$25\%$之类的确切数值数。</p><p><strong>定距等级</strong>，顾名思义，就是设置参照并使用差值进行绘图。还是<a href="/2020/11/15/人工智能/特征工程/知识储备：数据的无量纲化/">知识储备：数据的无量纲化</a>中跳远数据的例子。比起全部使用$1.537$上下不等的共20万琐碎数据，还是将$1.537$作为新的参照重新计算这些数据反而效果会更好。其中，这个由差值组成的新的数据集就是包含<strong>定距等级</strong>的数据集。当然，毕竟是20万条数据，画图将会是密密麻麻的一片，毫无参考价值。所以，这里可以以年龄为$x$轴，每个年龄段都计算均值，这样就能得出<strong>年龄-跳远距离</strong>曲线。这个年龄又是<strong>定序等级</strong>。就变成了<strong>不同类别下的定量分析</strong>。全都联系起来了，不是么？</p><p><strong>定比等级</strong>同样也是定量的描述，只不过和<strong>定距等级</strong>不一样的是，<strong>定距等级使用的是差值</strong>，而<strong>定比等级使用的是比值</strong>。同样需要参照物，研究的时候也是研究比值而不是源数据。<code>CPU</code>、<code>GPU</code>等电子产品的性能分析就是最好的例子。往往在新款<code>CPU</code>、<code>GPU</code>等电子产品推出的时候，都会和一个参照物进行比较。比如，<code>intel</code>新款<code>CPU</code>会和历代<code>CPU</code>产品进行比较，频率提升了多少比率、各种测试环境下的表现提升了多少比率等等；小米会和华为比较，打开应用的速度提升了百分之多少，游戏延迟降低了百分之多少等等。这些都是<strong>定比等级</strong>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后就用《特征工程入门与实践》中的表格作总结吧。</p><p>下面这个表格总结了本篇的核心内容，也就是<strong>四大数据特点的比较</strong>。</p><div class="table-container"><table><thead><tr><th>等级</th><th>属性</th><th>例子</th><th>描述性统计</th><th>图表</th></tr></thead><tbody><tr><td>定类</td><td>离散、无序</td><td>颜色、真或假</td><td>频率/占比、众数</td><td>条形图、饼状图</td></tr><tr><td>定序</td><td>有序</td><td>考试等级、年龄分段</td><td>频率、众数、中位数、百分数</td><td>条形图、饼图、茎叶图</td></tr><tr><td>定距</td><td>数据差有真实意义</td><td>温度、跳远</td><td>频率、众数、中位数、均值、标准差</td><td>条形图、饼图、茎叶图、箱线图、直方图</td></tr><tr><td>定比</td><td>连续、存在有真实意义的绝对零点，可以做除法</td><td>性能指标、金钱、重量</td><td>均值、标准差</td><td>直方图、箱线图</td></tr></tbody></table></div><p>如果你不知道<strong>什么等级应该用什么样的统计量表示</strong>，那就对照下面这张表：</p><div class="table-container"><table><thead><tr><th>统计量</th><th>定类</th><th>定序</th><th>定距</th><th>定比</th></tr></thead><tbody><tr><td>众数</td><td>$\sqrt{}$</td><td>$\sqrt{}$</td><td>$\sqrt{}$</td><td>有时可行</td></tr><tr><td>中位数</td><td>$\times$</td><td>$\sqrt{}$</td><td>$\sqrt{}$</td><td>$\sqrt{}$</td></tr><tr><td>差值、最小最大值</td><td>$\times$</td><td>$\sqrt{}$</td><td>$\sqrt{}$</td><td>$\sqrt{}$</td></tr><tr><td>均值</td><td>$\times$</td><td>$\times$</td><td>$\sqrt{}$</td><td>$\sqrt{}$</td></tr><tr><td>标准差</td><td>$\times$</td><td>$\times$</td><td>$\sqrt{}$</td><td>$\sqrt{}$</td></tr></tbody></table></div><p>现在，相信你对一大堆不知所云甚至毫无关联的数据的时候，不会像以前那么害怕了，不是么？最后还是提醒一下，特征工程的特征理解，最最核心的操作步骤，就是下面这张图所示的：</p><p><img src="https://sakebow.gitee.io/images/特征工程/特征理解流程.png" alt="特征工程流程"></p><p>是不是有点能理解了？</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;虽然我们介绍了数据的无量纲化，但是在实际编码之前我们还是需要多做一些准备工作。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="人工智能" scheme="https://sakebow.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
      <category term="特征工程" scheme="https://sakebow.github.io/tags/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>方向：特征工程的定义与目的</title>
    <link href="https://sakebow.github.io/2020/11/19/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/%E6%96%B9%E5%90%91%EF%BC%9A%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E7%9B%AE%E7%9A%84/"/>
    <id>https://sakebow.github.io/2020/11/19/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/%E6%96%B9%E5%90%91%EF%BC%9A%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E7%9B%AE%E7%9A%84/</id>
    <published>2020-11-19T03:26:00.000Z</published>
    <updated>2020-11-19T15:21:49.778Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>本文主要是<a href="https://www.bilibili.com/video/BV1rp4y197fo" target="_blank" rel="noopener">B站视频：【机器学习】特征工程</a>的学习笔记，里面包含了视频内容和自己的理解。</strong></p><a id="more"></a><h2 id="特征工程的定义"><a href="#特征工程的定义" class="headerlink" title="特征工程的定义"></a>特征工程的定义</h2><blockquote><p>特征工程是将<strong>原始数据转化为更好地代表预测模型的潜在问题的特征</strong>的过程，从而<strong>提高了对未知数据的预测准确性</strong>。</p><p>——摘自视频中展示的PPT</p></blockquote><p>也就是说，特征工程不过就是从大量的原始中选出确确实实对需要研究的数据产生了影响的个别数据。听起来和我之前描述的机器学习过程没有什么区别？确实没有什么区别，换了个专业的名词而已。</p><h2 id="特征工程的目标"><a href="#特征工程的目标" class="headerlink" title="特征工程的目标"></a>特征工程的目标</h2><p>在大学毕业以前，题目都会明确指定自变量和因变量，然后使用固定的模式来匹配这些自变量和因变量，最终得出结论。</p><p>在研究生生活开始以后，就再也没有固定的套路了。一大堆数据里面，确定一个研究对象并设置为因变量，将其他的变量全部设定为自变量，最后分析哪些变量对因变量的变化产生了决定性的作用，哪些变量对因变量产生了重要作用，而哪些变量是与因变量完全无关的。</p><p>所以，特征工程的目标则是针对因变量的变化，<strong>通过排除并没有什么作用的变量而降低问题的复杂度</strong>，<strong>让所研究的问题更加清晰</strong>。</p><p>这也是机器学习中最需要做的事情。拿到数据之后，选定其中一个数据作为我们需要研究的对象；剩下的便是使用各种各样的机器学习算法对剩余的数据进行降维、降噪和建模分析。</p><p>所以，特征工程就是为了机器学习的进一步分析服务的。是不是有点能理解了呢？</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本文主要是&lt;a href=&quot;https://www.bilibili.com/video/BV1rp4y197fo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;B站视频：【机器学习】特征工程&lt;/a&gt;的学习笔记，里面包含了视频内容和自己的理解。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="人工智能" scheme="https://sakebow.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
      <category term="特征工程" scheme="https://sakebow.github.io/tags/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>知识储备：数据的无量纲化</title>
    <link href="https://sakebow.github.io/2020/11/15/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%9A%84%E6%97%A0%E9%87%8F%E7%BA%B2%E5%8C%96/"/>
    <id>https://sakebow.github.io/2020/11/15/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/%E7%9F%A5%E8%AF%86%E5%82%A8%E5%A4%87%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%9A%84%E6%97%A0%E9%87%8F%E7%BA%B2%E5%8C%96/</id>
    <published>2020-11-15T11:42:00.000Z</published>
    <updated>2020-11-21T11:02:23.398Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>你现在拿到了许多数据，顺序是完全随机的。这已经不是单凭肉眼和逻辑推导就能分析出来的规律，只能通过机器学习来计算。那么，应该从哪一步开始？</strong></p><a id="more"></a><h2 id="数据无量纲化"><a href="#数据无量纲化" class="headerlink" title="数据无量纲化"></a>数据无量纲化</h2><p>放心，无论是谁只要是第一次听到这个名词都会蒙圈一会。其的定义就是：“<strong>将不同规格的数据转换到同一规格</strong>，<strong>或者不同分布的数据转换为同一分布</strong>”。听起来不是很好理解？</p><p>还是那个时候收集了20万猫娘数据的你。这个时候你甚至收集到了猫娘们跳远、跳高的数据。可是这些数据都集中在$1.537$米左右，想要分析的话实在是<strong>计算量非常大</strong>。所以，你修改了一下计算参照，不再是将所有的数据和$0$米相比，而是和平均值$1.537$米相比。于是大量的数据都集中在$0$到$0.262$，少部分分布在$0.262$到$0.501$。这个计算量就好多了，不是么？</p><p>这就是<strong>数据规格化</strong>。</p><blockquote><p>数据规格化指对数据的规范化处理。有些情况下，为了能正确地真正反映实际情况，必须对原始数据进行加工处理，使之规范化。数据经过规格化后其计算结果与未经规格化的计算结果差别较大。这是由于相似系数取决于坐标原点的位置。在规格化后，坐标原点移动了，使样品之间的夹角改变很大。</p><p>——摘自<a href="https://baike.baidu.com/item/数据规格化/610954" target="_blank" rel="noopener">百度百科【数据规格化】</a></p></blockquote><p>听到这里，你的<code>DNA</code>应该有反应了。没错，就是</p><script type="math/tex; mode=display">若X\sim N(\mu,\sigma^2),那么Y=\frac{X-\mu}{\sigma}\sim N(0,1)</script><p>之前我们在做题的时候都是二话不说先化为标准正态分布，实际上这么做就是为了<strong>数据规格化</strong>。</p><p>而对于不同分布的数据我们则是尽可能地转化为统一的分布，这个分布多半选择<strong>正态分布</strong>，因为正态分布有非常多便于统计运算的性质。</p><p>正因为数据的无量纲化之后能够将数据变为更为规范的、标准的数据集，所以往往在进行机器学习的时候为了能够更快地收敛、在更短的时间内给出更精确的结果，无量纲化也是重要的一步。当然，也可以跳过，这都看原数据的质量了。</p><h2 id="无量纲化的意义"><a href="#无量纲化的意义" class="headerlink" title="无量纲化的意义"></a>无量纲化的意义</h2><blockquote><p>机器学习和数据挖掘中所使用的数据，永远不可能是完美的。很多特征，对于分析和建模来说意义非凡，但对于实际收集数据的人却不是如此，因此数据挖掘之中，常常会有重要的字段缺失值很多，但又不能舍弃字段的情况。因此，数据预处理中非常重要的一项就是处理缺失值。</p><p>——摘自<a href="https://blog.csdn.net/weixin_36325602/article/details/104134462" target="_blank" rel="noopener">CSDN用户AI_Engine：数据无量纲化</a></p></blockquote><p>听起来像极了对账的时候各种奇葩漏账、错别字的样子，不是么？机器面对这样一大批乱七八糟的东西也是一样的。“这TM是啥？”“那TM又是啥？”然后稀里糊涂给了个让你情不自禁说出“这TM什么鬼”的结果。</p><p>听起来还是有点不太明白？举个例子。</p><p>你想给你的小猫娘科普中国四大名著。但是很可惜，在使用电脑准备文案的时候，你把<strong>水浒传</strong>打成了<strong>水许传</strong>。最绝望的是，你的小猫娘学会了。可以想象，你的小猫娘蹦蹦跳跳的跑到别人面前大声喊出“水许传”的时候，你会有多尴尬。</p><p>机器学习也是一样的，要是有个错误的数据，完全不会自己思考的机器就会把这个当作正确答案进行进一步的运算，然后得出一个错误的结果。像极了<strong>计算出老奶奶的速度是60km/h</strong>的小学生。</p><p><img src="https://sakebow.gitee.io/images/emoji/60码的老奶奶.jpg" alt="计算错误就只好以60码的速度行走的老奶奶" height="350"></p><p>当然，除了纠错补全，无量纲化还能够使用正态分布的许多种特性进行新的分析。例如：</p><script type="math/tex; mode=display">若X\sim N(0,1),则\left\{\begin{matrix}  EX&=&0\\  DX&=&1\\\end{matrix}\right.</script><p>不仅如此，我们还能够通过查表的方式确定当前服从正态分布的变量对应了多少概率，就像我们高中非常熟悉的$P(-\sigma+\mu&lt;X&lt;+\sigma+\mu)=0.6826$等等。更进一步，我们还能够使用正态分布所引出的其他分布来进行更多的数学分析，就像是考研过程中被折磨了无数遍的$F(m,n)=\frac{n\sum^m_{i=1}x^2}{m\sum^n_{i=1}y^2}$等。</p><p>是不是有点能理解了？</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;你现在拿到了许多数据，顺序是完全随机的。这已经不是单凭肉眼和逻辑推导就能分析出来的规律，只能通过机器学习来计算。那么，应该从哪一步开始？&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="人工智能" scheme="https://sakebow.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
      <category term="特征工程" scheme="https://sakebow.github.io/tags/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>滑动窗口在机器学习中的运用</title>
    <link href="https://sakebow.github.io/2020/11/13/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E8%BF%90%E7%94%A8/"/>
    <id>https://sakebow.github.io/2020/11/13/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%9C%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E8%BF%90%E7%94%A8/</id>
    <published>2020-11-13T07:50:00.000Z</published>
    <updated>2020-11-15T11:37:40.847Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>如果接触过计算机网络中的<code>TCP/IP</code>协议的话，你可能会对滑动窗口比较熟悉。那么滑动窗口到底是什么原理？在机器学习中又是如何运用？</strong></p><a id="more"></a><h2 id="计算机网络的滑动窗口复习"><a href="#计算机网络的滑动窗口复习" class="headerlink" title="计算机网络的滑动窗口复习"></a>计算机网络的滑动窗口复习</h2><p>在计算机网络中，滑动窗口的主要目的是<strong>流量控制</strong>，也就是为了处理网络拥塞的情况。对于拥塞，有三种不同策略的滑动窗口，分别是：<strong>停止等待</strong>、<strong>后退N帧</strong>、<strong>选择重传</strong>。这些就不一一展开了，因为我们主要介绍的不是这个，详情请回忆本科时候学习的计算机网络。</p><h2 id="滑动窗口的原理"><a href="#滑动窗口的原理" class="headerlink" title="滑动窗口的原理"></a>滑动窗口的原理</h2><p>滑动窗口就像是一张解密卡，中间的可以透光的部分可以让我们看到卡片的后面。</p><p><img src="https://sakebow.gitee.io/images/机器学习/解密卡.jpeg" alt="解密卡"></p><p><del>嗯……是不是暴露年龄了？</del></p><p>如果你恰好有很大一堆需要解密的数据，你就会用这张解密卡从左到右移动，逐渐解开所有的谜题。</p><p>这就是滑动窗口的原理。因为是每走一步分析一次，所以滑动窗口对时序数据的分析有着非常大的作用。如果只是单纯的分段分析，有可能会刚刚好忽略了转折点，最终就没能得到较好的结果。</p><h2 id="滑动窗口的应用"><a href="#滑动窗口的应用" class="headerlink" title="滑动窗口的应用"></a>滑动窗口的应用</h2><p>正因为滑动窗口对于时序数据的优势，所以滑动窗口将来会更多的应用在涉及时序数据的分析中，比如股票随着时间的变化、脑网络中随时间变化的活动情况、电网中各类传感器数据随时间变化的情况等等。</p><p>到了现在这个“充分挖掘数据价值”的时代中，单一时间片的数据已经远远不够价值地体现了，需要大量的、多个时间维度的分析与评价，最终联系多个时间段的实际情况对实验结果的影响最终得出可能的结论。</p><p>听不懂没关系，还是一如既往的小例子。</p><p>你的小猫娘<strong>并不是一成不变的</strong>。她再怎么说也是有懵懂期、好动期、叛逆期<del>和发情期</del>等等，每个阶段都有不同的心理和生理活动，所以想要理解你的小猫娘的话，要是一直将你的小猫娘固定在让你最快乐的那个时段中，最终对小猫娘的理解<strong>一定是片面的</strong>。而若是动态地分析，不停地按照一定的步长分析每个时段的小猫娘，在保证考虑新时段和旧时段的联系的同时，还要使用相对较长的步长来避免你对过去的小猫娘的不舍。这样最终对小猫娘的理解也会<strong>相对来说更为全面</strong>。</p><p>这也就是滑动窗口想要解决的问题。一次只看一小部分，但是每个部分都有相关联的地方，不至于完全隔断，也不至于过度分析。</p><h2 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h2><p>滑动窗口虽然是能够让我们看到相对来说更为连续的数据，但是窗口毕竟是窗口，<strong>并不能帮助分析</strong>。窗口的实质只不过是使用狭窄的边框<strong>屏蔽掉</strong>整个数据的其他部分，从而让我们更<strong>好地专注</strong>于整个数据中的一小部分连续的数据。真正的分析还是得使用能够分析数据的机器学习算法，比如<strong>降维</strong>的<code>TSNE</code>、<strong>分类</strong>的随机森林、<strong>预测</strong>的回归分析等等。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;如果接触过计算机网络中的&lt;code&gt;TCP/IP&lt;/code&gt;协议的话，你可能会对滑动窗口比较熟悉。那么滑动窗口到底是什么原理？在机器学习中又是如何运用？&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="人工智能" scheme="https://sakebow.github.io/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
      <category term="算法模型" scheme="https://sakebow.github.io/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Windows下使用Docker搭建GitLab服务器</title>
    <link href="https://sakebow.github.io/2020/11/10/%E8%BF%90%E7%BB%B4/docker/Windows%E4%B8%8B%E4%BD%BF%E7%94%A8Docker%E6%90%AD%E5%BB%BAGitLab%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://sakebow.github.io/2020/11/10/%E8%BF%90%E7%BB%B4/docker/Windows%E4%B8%8B%E4%BD%BF%E7%94%A8Docker%E6%90%AD%E5%BB%BAGitLab%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2020-11-10T09:22:00.000Z</published>
    <updated>2020-11-15T11:37:17.735Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>也不是所有的公司都崇尚<code>Linux</code>哲学，也有非常多的公司热衷于使用<code>Windows</code>当作服务器。所以这里介绍一下在如何在<code>Windows</code>下使用<code>Docker</code>搭建<code>GitLab</code>。</strong></p><a id="more"></a><h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装<code>Docker</code></h2><p>安装包：<a href="https://pan.baidu.com/s/1Ek_Z4LOAV80Pf2V4FKFs2Q" target="_blank" rel="noopener">提取码：ary4</a></p><p>在<code>Windows</code>下安装<code>Docker</code>就非常难受了，需要解决非常多的约束。</p><h3 id="系统更新"><a href="#系统更新" class="headerlink" title="系统更新"></a>系统更新</h3><p>有些人非常讨厌更新所以使用一些脚本把更新关掉了。但是人家<code>Docker</code>必须要更新才能安装，你气不气嘛。</p><p>如果你是<code>Windows10</code>，在“更新和安全”$\rightarrow$“<code>Windows</code>更新”，在里面找到“检查更新”按钮，点击即可。到最后，会提示你重启以应用更新。当然，你可以选择现在重启，但是我们推荐把下面的步骤做完之后再更新。</p><h3 id="添加“适用于Linux的Windows子系统”"><a href="#添加“适用于Linux的Windows子系统”" class="headerlink" title="添加“适用于Linux的Windows子系统”"></a>添加“适用于<code>Linux</code>的<code>Windows</code>子系统”</h3><p>在编辑这篇博客的时候，<code>Docker</code>已经出道了2.5.0，所以需要这样的设置。</p><p>打开“控制面板”$\rightarrow$“程序”$\rightarrow$“程序和功能”$\rightarrow$“启用或关闭<code>Windows</code>功能”$\rightarrow$“适用于<code>Linux</code>的<code>Windows</code>子系统”（最下方倒数第三个），勾选，然后点击“确定”。</p><p><img src="https://sakebow.gitee.io/images/SpringCloud/安装WSL.png" alt="操作截图"></p><p>接着<code>Windows</code>就能够帮你下载这些东西。等待完成之后，系统会提示需要重启，重启之后就应用了更改。这个时候重启吧，但是别忘了，在开机之前还有一点点事情要做。</p><h3 id="VT开启"><a href="#VT开启" class="headerlink" title="VT开启"></a><code>VT</code>开启</h3><p>你的<code>Windows</code>需要开启<code>virtual technology</code>，也就是<strong>虚拟化</strong>，打游戏的时候经常要开启的那个。有些主板可能比较难找，但一定会有，实在找不到去问问度娘吧，主办版本太多了也没办法一一说明。</p><h3 id="结束？"><a href="#结束？" class="headerlink" title="结束？"></a>结束？</h3><p><strong>试着打开<code>Docker Desktop</code>的安装包吧！</strong></p><p>看到这里是不是以为马上就要结束了？<strong>当然没有</strong>。只不过往后的步骤有提示而已，别担心啦。</p><p>打开安装包之后，他会提示：需要安装<code>Linux</code>内核以支持<code>Docker</code>的运行。这里她也非常贴心的给出了链接，点进去下载就好了。</p><p>这里我也给出我自己已经下载好的吧：<a href="https://pan.baidu.com/s/1TALJ76QmVgm0VrumzDkUQw" target="_blank" rel="noopener">提取码：14m1</a></p><p>下载好了之后安装，这个过程是不会让你选择路径的。因为安装包不大，所以也没什么影响，放心安装。</p><p>等全部安装完之后，就可以真正意义上打开<code>Docker Desktop</code>的安装包了。</p><p>之后便是等待安装结束。<code>Docker</code>安装文件给的提示是注销用户再重新登录即可，可能使用<code>Linux</code>的人比较习惯这种操作。不过呢，既然是傻瓜式的<code>Windows</code>，直接重启计算机就好了。（<em>仅限开机较快的同学</em>）</p><p>到这里，就能够打开<code>Docker Desktop</code>正常使用了。</p><h2 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h2><p>在<code>Linux</code>系统中，直接修改<code>/etc/docker/daemon.json</code>就够了。但是<code>Windows</code>系统中可没有这个。所以直接打开任务栏中的<code>Docker</code>，按照下图步骤进行设置</p><p><img src="https://sakebow.gitee.io/images/SpringCloud/Windows的docker换源.png" alt="Docker界面"></p><p>其中国内源可以选择：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Docker国内镜像源</span></span><br><span class="line">https://registry.docker-cn.com</span><br><span class="line"><span class="meta">#</span><span class="bash"> 网易Docker源</span></span><br><span class="line">http://hub-mirror.c.163.com</span><br></pre></td></tr></table></figure><p>当然你还可以选择阿里云的私人镜像站，都是非常不错的。这里就不一一介绍了。</p><p>最后，安装一下<code>Git</code>客户端吧。在<code>Windows</code>上如果不进行任何配置的话，只能使用<code>Git Bash</code>。但是考虑到<code>GitLab</code>一定要用到<code>Git</code>客户端，所以也就安装了算了吧。</p><p>国内的话更推荐使用<a href="http://npm.taobao.org/mirrors/git-for-windows/v2.29.2.windows.2/" target="_blank" rel="noopener">淘宝的Git-2.29.2.2镜像</a>。</p><p>就是这样啦。接下来我们开始搭建<code>GitLab</code>。</p><p>打开命令行（实际上是<code>Git</code>客户端），输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">docker pull twang2218/gitlab-ce-zh # 拉取镜像</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">下载时间很长，我们趁下载的时间准备`docker-compose.yml`：</span><br><span class="line"></span><br><span class="line">```yml</span><br><span class="line">version: '3' # 版本号</span><br><span class="line">services: # 开启服务</span><br><span class="line">  gitlab: # 服务名称</span><br><span class="line">    image: 'twang2218/gitlab-ce-zh:latest' # 使用镜像</span><br><span class="line">    restart: always</span><br><span class="line">    hostname: 'GitLab' # 主机名称（自定义）</span><br><span class="line">    environment: # 环境配置</span><br><span class="line">      TZ: 'Asia/Shanghai'</span><br><span class="line">      GITLAB_OMNIBUS_CONFIG: |</span><br><span class="line">        external_url 'http://192.168.1.112:8080'</span><br><span class="line">        gitlab_rails['gitlab_shell_ssh_port'] = 4022</span><br><span class="line">        unicorn['port'] = 8888</span><br><span class="line">        nginx['listen_port'] = 8080</span><br><span class="line">    ports: # 端口映射，格式为“本机IP：Docker镜像内部IP”</span><br><span class="line">      - '1080:8080'</span><br><span class="line">      - '1043:8443'</span><br><span class="line">      - '1022:22'</span><br><span class="line">    volumes: # 挂载卷</span><br><span class="line">      # 前面是Windows的地址所以斜杠向右；后面是Linux的地址所以向左</span><br><span class="line">      - D:\codes\docker\gitlab\config:/etc/gitlab</span><br><span class="line">      - D:\codes\docker\gitlab\data:/var/opt/gitlab</span><br><span class="line">      - D:\codes\docker\gitlab\logs:/var/log/gitlab</span><br></pre></td></tr></table></figure><p>粘贴后记得保存哦。</p><p>等拉取完毕后，运行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d # 以后台进程的方式运行容器</span><br></pre></td></tr></table></figure><p>于是，<code>GitLab</code>就能够跑起来了。短暂地等待之后，使用“本机IP：端口号”的形式访问网站就好了。比如说我设置之后就可以使用：<code>http://10.33.76.59:1080</code>进入<code>GitLab</code>网站。</p><p>如果你有看过我之前写的<a href="/2020/07/08/Java/SpringCloud/版本控制的另一种打开方式/">版本控制的另一种打开方式</a>，那么你对上述的过程应该很熟悉。但是在<code>Windows</code>下有所不同的是，在进入容器内的时候并不能使用<code>/bin/bash</code>，因为<code>Windows</code>系统压根就没有这个地址。</p><p>所以只能使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it $&#123;docker-container-id&#125; bash</span><br></pre></td></tr></table></figure><p>也就是将<code>/bin/bash</code>更换为<code>bash</code>。</p><p>这下就能进去了。剩下的改密码、创建什么的都和之前<a href="/2020/07/08/Java/SpringCloud/版本控制的另一种打开方式/">版本控制的另一种打开方式</a>一模一样了。</p><p>是不是有点懂了呢？</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;也不是所有的公司都崇尚&lt;code&gt;Linux&lt;/code&gt;哲学，也有非常多的公司热衷于使用&lt;code&gt;Windows&lt;/code&gt;当作服务器。所以这里介绍一下在如何在&lt;code&gt;Windows&lt;/code&gt;下使用&lt;code&gt;Docker&lt;/code&gt;搭建&lt;code&gt;GitLab&lt;/code&gt;。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="运维" scheme="https://sakebow.github.io/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="docker" scheme="https://sakebow.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>从面向对象来看静态绑定和动态绑定</title>
    <link href="https://sakebow.github.io/2020/11/02/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E4%BB%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%9D%A5%E7%9C%8B%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E5%92%8C%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A/"/>
    <id>https://sakebow.github.io/2020/11/02/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E4%BB%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%9D%A5%E7%9C%8B%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E5%92%8C%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A/</id>
    <published>2020-11-02T07:00:00.000Z</published>
    <updated>2020-11-03T10:50:51.535Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>这个部分是相当底层的知识，不涉及实际编程，可能会有些枯燥。</strong></p><a id="more"></a><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>所谓<strong>绑定</strong>，就是<strong>将方法与其所在的对象或者类关联起</strong>来。</p><p><strong>静态绑定</strong>，或者有人比较喜欢称为<strong>前期绑定</strong>，意思是<strong>在执行之前就已经明确了什么方法属于什么类或者对象</strong>。</p><p><strong>动态绑定</strong>，或者有人比较喜欢称为<strong>后期绑定</strong>，意思是<strong>在执行的时候根据具体的实例化对象绑定对应的方法</strong>。</p><p>听起来很绕？来看看这些个例子。</p><h2 id="类比说明静态绑定和动态绑定"><a href="#类比说明静态绑定和动态绑定" class="headerlink" title="类比说明静态绑定和动态绑定"></a>类比说明静态绑定和动态绑定</h2><p>有一天，你家里多了一只猫娘。先不管你是怎么得到的吧，总之就在你家了。于是，在这个时候，这只猫娘就和你<strong>绑定</strong>了。</p><p>由于家里人就你天天陪着她，她也就每天粘着你。不久之后，你就和这只猫娘<strong>静态绑定</strong>了。有人来看看你和你的猫娘的时候，一看到那只怯生生的猫娘躲在你背后，就知道：啊，这只小猫娘粘上你了呐。</p><p>但是呢，眼看着小猫娘一天天长大，总不能一直都在家里吧？。你的猫娘也凭自己的努力得到了一个小铃铛（<del><em>串戏了啊喂</em></del>），你就带着她出去转转了。路上碰到了一个警察，警察看到你的猫娘上有一只铃铛，就把猫娘和你一起<strong>动态绑定</strong>了。只有在你出门之后，警察才会将你和你的小猫娘通过一只铃铛进行绑定。</p><h2 id="从面向对象来看静态绑定和动态绑定"><a href="#从面向对象来看静态绑定和动态绑定" class="headerlink" title="从面向对象来看静态绑定和动态绑定"></a>从面向对象来看静态绑定和动态绑定</h2><p>辣么，在面向对象编程中，动态绑定和静态绑定又是什么呢？拿<code>Java</code>来说吧。</p><p>我们在创建<code>utils</code>包的时候会封装一些静态类作为项目必须的工具类。其中必定会使用<code>private</code>、<code>final</code>、<code>static</code>等来修饰字段或者方法。这些就是<strong>静态绑定</strong>，在一开始就直接知道了这些个方法和字段就是这个工具类的一部分。</p><p>另外，在声明<code>entity</code>包中的各种映射实体类的时候，我们会使用<code>public</code>来修饰，其中的各种方法也是<code>public</code>方法。这种在运行之中<code>JVM</code>也并不清楚这到底是谁的方法，而是在产生各种中间件的时候发现这些个方法是属于这个类的。这就是<strong>动态绑定</strong>。</p><p><strong>动态绑定</strong>实际上是将<strong>可执行的方法</strong>和<strong>生成的对象</strong>进行绑定，所以仅发生在程序执行过程中；<strong>静态绑定</strong>则是将<strong>不可被继承</strong>或者<strong>不可被覆盖</strong>的方法和原类进行版绑定。</p><h2 id="给实际编程所带来的影响"><a href="#给实际编程所带来的影响" class="headerlink" title="给实际编程所带来的影响"></a>给实际编程所带来的影响</h2><p>可以肯定的是，无论是什么语言，动态绑定永远都比静态绑定耗时较长。拿<code>Java</code>来看，<code>JVM</code>需要消耗一点时间将创建过后的对象和方法对应起来实现动态绑定，而静态绑定则是已经确认了谁和谁本来就应该在一起。所以，如果是使用非常频繁的工具类，我们可以考虑使用静态方法，这样就能够进行静态绑定，这样运行起来会稍微快一点点。（<del><em>虽然一直做<code>CRUD</code>的<code>API</code>调用工程师也接触不到这些内容啦</em></del>）</p><p>是不是有点能理解了呢？</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;这个部分是相当底层的知识，不涉及实际编程，可能会有些枯燥。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="软件开发建模" scheme="https://sakebow.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%BB%BA%E6%A8%A1/"/>
    
    
      <category term="软件项目管理" scheme="https://sakebow.github.io/tags/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>时序图中容易错的地方</title>
    <link href="https://sakebow.github.io/2020/11/02/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E6%97%B6%E5%BA%8F%E5%9B%BE%E4%B8%AD%E5%AE%B9%E6%98%93%E9%94%99%E7%9A%84%E5%9C%B0%E6%96%B9/"/>
    <id>https://sakebow.github.io/2020/11/02/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E6%97%B6%E5%BA%8F%E5%9B%BE%E4%B8%AD%E5%AE%B9%E6%98%93%E9%94%99%E7%9A%84%E5%9C%B0%E6%96%B9/</id>
    <published>2020-11-02T07:00:00.000Z</published>
    <updated>2020-12-08T08:57:48.239Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>在上课的时候还是觉得时序图太容易错了，在这里记录一下。</strong></p><a id="more"></a><h2 id="时序图应当服务的阶段"><a href="#时序图应当服务的阶段" class="headerlink" title="时序图应当服务的阶段"></a>时序图应当服务的阶段</h2><p>软件开发一共分为$7$个阶段，<strong>需求分析</strong>、<strong>概要设计</strong>、<strong>详细设计</strong>、<strong>编码</strong>、<strong>测试</strong>、<strong>交付</strong>、<strong>维护</strong>。而时序图应当存在于<strong>需求分析</strong>阶段。</p><h2 id="一个错误的例子"><a href="#一个错误的例子" class="headerlink" title="一个错误的例子"></a>一个错误的例子</h2><p>首先，如果不仔细听听时序图的各种要点，只是单纯地模仿网上的各种图片，一定会出现这样教科书一般的错误：</p><p><img src="https://sakebow.gitee.io/images/软件工程/错误的时序图.png" alt="错误的时序图"></p><p>乍一看真的有时序图那种味道，从管理员开始，发送一个登录请求，然后给到服务端，服务端将<code>Token</code>验证信息发送给缓存服务器，根据缓存服务器中的字段是否存在、是否超时判断用户信息是否有效，如果无效就查询数据库，最后如果查询成功就返回管理员的用户数据，否则报错，一级级往回上报查询信息。</p><p>这个时序在逻辑上<strong>是没有问题的</strong>，步骤非常完善。<strong>但是</strong>，如果按照时序图的定义严格追溯的话，<strong>这个并不是时序图</strong>，而是按照时序排列的步骤信息。</p><h2 id="真正的时序图"><a href="#真正的时序图" class="headerlink" title="真正的时序图"></a>真正的时序图</h2><blockquote><p>它通过描述对象之间发送消息的时间顺序显示<strong>多个对象</strong>之间的<strong>动态动作</strong>。它可以表示用例的行为顺序，当执行一个用例行为时，其中的每条消息对应一个类操作或状态集中引起转换的触发事件。</p><p>——摘自<a href="https://baike.baidu.com/item/时序图" target="_blank" rel="noopener">【百度百科】时序图</a></p></blockquote><p>也就是说，时序图应当表示各个不同的对象之间的信息交互。在上方的说明中应当填入的是<strong>类的名称</strong>，而箭头应当表示<strong>消息的交互</strong>。尤其是从左向右的箭头之中，应当填入<strong>箭头所指的类中所包含的方法名称</strong>。</p><p><img src="https://sakebow.gitee.io/images/软件工程/正确的时序图.png" alt="正确的时序图"></p><h2 id="为什么最开始的那张图是“错误”的"><a href="#为什么最开始的那张图是“错误”的" class="headerlink" title="为什么最开始的那张图是“错误”的"></a>为什么最开始的那张图是“错误”的</h2><p>当然，不可否认的是，<strong>市面上有很多书会按照本篇中所述的错误方法给出一个时序图</strong>。</p><p>不可否认，那样一张图确实有一定的<strong>时序性</strong>，也确实能够说明一些对象之间的交互。但是别忘了，我们一开始就说明了，时序图是服务于<strong>需求分析阶段</strong>的。</p><p>对于一些有经验的开发工程师来说，一些需求很快就能通过以往的经验具现化为代码或者代码框架。有这个意识当然很不错，因为这样干活起来会很顺利。可是，不仅是你要懂，你还应该让其他人懂，所以实际上像最开始那样的图并不适合具现化为<strong>统一的</strong>代码。你们水平不一，有可能你想到的是使用<code>RPC</code>协议调用另一个模块的接口，而你的同事可能会就在包内再来个类，然后<code>import</code>进去。对接起来就会发现，有好多个功能重复的模块但是位置不一样、注释不一样、效率不一样等等。</p><p>所以，如果你希望这张图更好地转变为代码，请使用<strong>类</strong>作为生命线所对应的对象。</p><h2 id="最后强调一下"><a href="#最后强调一下" class="headerlink" title="最后强调一下"></a>最后强调一下</h2><p>时序图实际上并不是随便使用<strong>数据库</strong>、<strong><code>Redis</code></strong>等作为对象，而是使用实实在在参与了系统业务功能的类，在箭头上也应当贴出<strong>类中确确实实包含的方法</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;在上课的时候还是觉得时序图太容易错了，在这里记录一下。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="软件开发建模" scheme="https://sakebow.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%BB%BA%E6%A8%A1/"/>
    
    
      <category term="软件项目管理" scheme="https://sakebow.github.io/tags/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>用例图：不是面向对象的面向对象设计概念图</title>
    <link href="https://sakebow.github.io/2020/11/02/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E7%94%A8%E4%BE%8B%E5%9B%BE%EF%BC%9A%E4%B8%8D%E6%98%AF%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E6%A6%82%E5%BF%B5%E5%9B%BE/"/>
    <id>https://sakebow.github.io/2020/11/02/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E7%94%A8%E4%BE%8B%E5%9B%BE%EF%BC%9A%E4%B8%8D%E6%98%AF%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E6%A6%82%E5%BF%B5%E5%9B%BE/</id>
    <published>2020-11-02T06:38:00.000Z</published>
    <updated>2020-11-15T11:36:38.611Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>相信经历软考的人都应当对最后的几个大题的图傻傻分不清楚。别害怕，还有更猛的，把你锤在地上爬都爬不起来。</strong></p><a id="more"></a><h2 id="用例图简介"><a href="#用例图简介" class="headerlink" title="用例图简介"></a>用例图简介</h2><p>用例图是什么？这个只能通过死记硬背来对应起来。这玩意怎么记呢？既然是用例图，那肯定就是在说<strong>什么对象在使用什么操作</strong>。听起来很有面向对象的那味儿了，不是么？</p><blockquote><p><img src="https://sakebow.gitee.io/images/软件工程/用例图.png" alt="这是一个用例图的例子"></p><p>——摘自<a href="https://baike.baidu.com/item/用例图/9531932" target="_blank" rel="noopener">百度百科【用例图】</a></p></blockquote><p>来看看上面这张图，这种就是用例图（<del>虽然并不标准</del>）。</p><p>可以看到，教师拥有“录入成绩”、“修改成绩”、“查询成绩”、“删除成绩”、“登录”五大功能，同时附赠一个“找回密码”的小功能，而且“录入成绩”、“修改成绩”这两个大功能共用一个“保存成绩”的小功能；学生就只有“查询成绩”、“登录”和附赠的“找回密码”。</p><p>可以看到，这张用例图清晰地表示了<strong>哪个角色能够使用哪些功能</strong>，而<strong>哪些功能中包含或者拓展哪些小功能</strong>。</p><p>是不是觉得这个系统应该怎么规划都想得很清楚了？是不是觉得现在开始编码随便写写就能出来了？没错，用例图就是这么简单直接所以才能够普及。</p><p>顺便说明一下，用例图时需要明确标明系统边界的，所以标准的画法应当是在所有功能外画一个大边框，表示这是系统的边界；与此同时还需要在边框旁边标明这个是什么系统。</p><h2 id="面向对象？很可惜不是"><a href="#面向对象？很可惜不是" class="headerlink" title="面向对象？很可惜不是"></a>面向对象？很可惜不是</h2><p>什么是<strong>面向对象</strong>？<strong>每一个类所实例化的对象都有与之对应的属性来描述对象的特征，并且还有成员函数来描述对象的行为</strong>。<strong>类</strong>又是什么？是<strong>属性和操作的封装体</strong>；<strong>对象</strong>是什么？是<strong>类的实例</strong>。</p><p>可是用例图有吗？<strong>当然没有</strong>。</p><p>回看我们刚刚的例子，用例图<strong>只包含若干个执行者和执行者所对应的操作</strong>。这算哪门子面向对象嘛。</p><p>但是也正因为用例图屏蔽了面向对象中很多的细节，删去了属性、不必要的成员函数乃至对象之间的关系，所以反而<strong>传达了更精确的面向对象概念</strong>。</p><p>挺可笑的不是嘛。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;相信经历软考的人都应当对最后的几个大题的图傻傻分不清楚。别害怕，还有更猛的，把你锤在地上爬都爬不起来。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="软件开发建模" scheme="https://sakebow.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%BB%BA%E6%A8%A1/"/>
    
    
      <category term="软件项目管理" scheme="https://sakebow.github.io/tags/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
</feed>
