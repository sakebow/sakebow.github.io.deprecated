<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sakebow的小博客</title>
  
  <subtitle>一条苦苦挣扎的废柴大学狗</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.sakebow.cn/"/>
  <updated>2020-03-22T10:32:29.517Z</updated>
  <id>http://www.sakebow.cn/</id>
  
  <author>
    <name>Sakebow</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue钩子的一点小坑</title>
    <link href="http://www.sakebow.cn/2020/03/22/vue/Vue%E9%92%A9%E5%AD%90%E7%9A%84%E4%B8%80%E7%82%B9%E5%B0%8F%E5%9D%91/"/>
    <id>http://www.sakebow.cn/2020/03/22/vue/Vue%E9%92%A9%E5%AD%90%E7%9A%84%E4%B8%80%E7%82%B9%E5%B0%8F%E5%9D%91/</id>
    <published>2020-03-22T10:12:00.000Z</published>
    <updated>2020-03-22T10:32:29.517Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>其实严格上来说这并不是Vue的知识点，但是涉及到了Vue的知识就放在这边了。这里就只是说明一下钩子的一些很难注意到的点，生命周期什么的会单独开一篇博客进行详细阐释。</strong></p><a id="more"></a><h2 id="mounted简直不能太迷"><a href="#mounted简直不能太迷" class="headerlink" title="mounted简直不能太迷"></a>mounted简直不能太迷</h2><p>实际上这个钩子没有迷惑的地方，只是单纯的有一个小小的点没有注意到。就是这两种写法的区别：</p><ul><li><strong>lambda表达式写法</strong><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mounted: <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><strong>普通写法</strong><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mounted () &#123;&#125;</span><br></pre></td></tr></table></figure>不得不承认，这两种写法在使用上没有区别，编译器也不会报错，该运行的还是会正常运行。<strong>对于萌新来说</strong>，几乎是没有差别。也就在所谓的<code>没有差别</code>上栽了一些人，包括我。</li></ul><p>在做项目过程中，我希望在<code>mounted</code>钩子中立即加载数据，但是发现了一个<strong>致命问题</strong>：</p><p><strong>lambda表达式写法的mounted钩子无法获取当前组件的data</strong></p><p>这实际上是因为<strong>lambda表达式没有this</strong>，也就找不到指向自己的指针。</p><p>如果你了解过<code>axios</code>，你就会发现他也含有lambda表达式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">    dataType: <span class="string">'json'</span>,</span><br><span class="line">    type: <span class="string">'post'</span>,</span><br><span class="line">    url: <span class="string">'$&#123;ip&#125;:$&#123;port&#125;/$&#123;api&#125;'</span>,</span><br><span class="line">    params: &#123;</span><br><span class="line">        id: <span class="string">'123'</span>,</span><br><span class="line">        pwd: <span class="string">'321'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 获取res后的业务处理，一般数据会封装在res.data中</span></span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 获取异常的处理，必须使用err，否则ESLint环境下报错</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>对，<code>then</code>和<code>catch</code>方法中<strong>不能使用this</strong>！</p><p>这就是因为lambda表达式没有this指针。虽然是ES6标准，但也在一些方面略逊于ES5呐。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;其实严格上来说这并不是Vue的知识点，但是涉及到了Vue的知识就放在这边了。这里就只是说明一下钩子的一些很难注意到的点，生命周期什么的会单独开一篇博客进行详细阐释。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://www.sakebow.cn/categories/javascript/"/>
    
    
      <category term="vue" scheme="http://www.sakebow.cn/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>关于shiro的一点想法</title>
    <link href="http://www.sakebow.cn/2020/03/19/shiro/%E5%85%B3%E4%BA%8Eshiro%E7%9A%84%E4%B8%80%E7%82%B9%E6%83%B3%E6%B3%95/"/>
    <id>http://www.sakebow.cn/2020/03/19/shiro/%E5%85%B3%E4%BA%8Eshiro%E7%9A%84%E4%B8%80%E7%82%B9%E6%83%B3%E6%B3%95/</id>
    <published>2020-03-19T12:28:00.000Z</published>
    <updated>2020-03-19T13:49:29.789Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>Shiro是较早的时候就已经由Apache公司创造的，那个时候普遍是jsp进行前后端设计。到了现如今，Shiro是否还有自己的一席之地？</strong></p><a id="more"></a><h2 id="以前的技术"><a href="#以前的技术" class="headerlink" title="以前的技术"></a>以前的技术</h2><p>就不说很早以前<code>Servlet+jsp</code>的时代了，就从最近的<code>SSM</code>开始说吧。可能有些人最近<code>SpringBoot</code>用得忘记了<code>SSM</code>。也就当我复习了。</p><p>数据包从用户操作浏览器开始一直到用户操作浏览器结束为止我就不再赘述了，这里由于主篇幅是<code>Shiro</code>就不再复习了，况且<code>SSM</code>专栏中也反复提及，帮助读者记忆。</p><p>此处讲解Shiro的时候引入现有的图片：</p><p><img src="https://images2015.cnblogs.com/blog/846961/201605/846961-20160521131219154-1119400350.png" alt="Shiro流程走向"></p><p>原帖：<a href="https://www.cnblogs.com/sunshine-2015/p/5515429.html" target="_blank" rel="noopener">https://www.cnblogs.com/sunshine-2015/p/5515429.html</a></p><p>Shiro的原理流程总结为：</p><ul><li><p>通过ini配置文件创建<code>SecurityManager</code>对象；</p></li><li><p>调用<code>Subject</code>对象中的<code>login</code>方法发起以<code>token</code>作为参数的认证请求，提交到Subject对象的代理对象<code>DelegationSubject</code>中；</p></li><li><p>代理对象<code>DelegationSubject</code>调用<code>securityManager</code>的<code>login</code>方法。如果方法运行失败，将会抛出异常，逐步往回走，最终回到原点；如果方法运行成功，数据将提交到默认安全管理器<code>DefaultSecurityManager</code>；</p></li><li><p>默认安全管理器<code>DefaultSecurityManager</code>调用<code>authenticate</code>方法，其实也就是将锅扔给了抽象类<code>AbstractAuthenticator</code>；</p></li><li><p>抽象类<code>AbstractAuthenticator</code>接到锅以后调用<code>doAuthenticate</code>接口，于是验证信息提交到了<code>ModularRealmAuthenticator</code>。在这里<code>doMultiRealmAuthentication</code>方法将会遍历所有的<code>Realm</code>对象进行认证。此处全部失败才会抛出异常，回到起点；而成功的<code>Realm</code>将会直接送往下一个关口，也就是<code>AuthenticatingRealm</code>；</p></li><li><p><code>AuthenticatingRealm</code>调用<code>doGetAuthenticationInfo</code>方法，同样的，失败回到起点，成功送往下一关。下一站，也就是自定义的<code>Realm</code>；</p></li><li><p>自定义的<code>Realm</code>距离数据库最近，它可以进入数据库查询用户名和密码，成功之后将会创建<code>SimpleAuthenticationInfo</code>对象；同样的，不匹配就回到起点；</p></li><li><p><code>SimpleAuthenticationInfo</code>对象被回调入<code>AuthenticatingRealm</code>，然后调用<code>assertCredentialsMatch</code>，将数据传入<code>SimpleCredentialsMatcher</code>中；</p></li><li><p>在<code>SimpleCredentialsMatcher</code>中，<code>SimpleAuthenticationInfo</code>中的信息将会和最初的<code>token</code>进行比较。比较过程中二者将会被转化为比特数组。</p></li><li><p>最终成功的捷报层层返回，最终也回到了起点。</p></li></ul><p>看起来非常的麻烦。但是不得不承认，这些信息传入<code>jsp</code>中将会非常完美地完成权限管理操作，比起人工确认权限要方便得多。</p><h2 id="现在的技术"><a href="#现在的技术" class="headerlink" title="现在的技术"></a>现在的技术</h2><p>现在，<code>SpringBoot</code>基本上抢占了全部的市场，大部分坚持Java的公司改成了最新的微服务框架，因为他的热部署、高可用、高并发、快构建等等优点完美超越SSM。但是，由于jsp最终会被渲染为Servlet，也就不可避免地耦合了<code>HttpServletRequest</code>和<code>HttpServletResponse</code>，这也在前后端交互上存在一定的不便。前端需要数据测试的时候，往往后台人员连接口都没有弄出来，等也不是不等也不是。</p><p>于是，前后端分离思想爆发了。<code>React</code>、<code>Vue</code>等前端框架的出现也正推动了前后端分离的发展。于是，前端从<code>jsp</code>彻底变成了<code>html</code>。这也就是说，<code>HttpServletRequest</code>和<code>HttpServletResponse</code>将不再支持，Shiro也将不再适用。能不能用？肯定是可以的，只不过许许多多的变量不能够使用<code>HttpServletRequest</code>写入<code>Session</code>后，世界开始变得灰暗了。<code>Shiro</code>就这么被发展的浪潮冲走了。</p><h2 id="权限认证何去何从"><a href="#权限认证何去何从" class="headerlink" title="权限认证何去何从"></a>权限认证何去何从</h2><p>权限认证没有了<code>Shiro</code>将会怎么办？虽然惶惶不知所措，但是Shiro带来的Token却是一块宝。</p><p>首先，<code>Token</code>不像<code>Session</code>，占用服务器的内存，这将减少服务器的压力；</p><p>其次，<code>Token</code>可以保存到<code>localStorage</code>和<code>SessionStorage</code>，比起<code>Cookie</code>和<code>Session</code>将会方便很多，也给客户端减少了一定的压力；</p><p>再者，<code>Token</code>在请求的时候不会加入请求头一并发送，而<code>Cookie</code>将会加入请求头，跟着请求一并发送。在网络上再一次减少了压力；</p><p>最后，<code>Session</code>和<code>Cookie</code>只能同时运行在同一台服务器上，也就是我们常常说的<strong>不能跨域</strong>，而<code>Token</code>随意。</p><p>岂不美哉？</p><p>前端我拿到用户信息之后，把存在<code>localStorage</code>或者<code>sessionStorage</code>的<code>Token</code>拿出来，发到后台，再等后台的确认，就可以快速确认权限，而且并不需要考虑<strong>大小限制</strong>、<strong>跨域问题</strong>，后台也就只需要全部发送JSON数据，完全不需要考虑页面的跳转、越级访问等等问题。</p><p>所以，到<code>SpringBoot</code>横行的时代，<code>Shiro</code>已经失去了它的历史低位。</p><h2 id="我们还有没有必要学习Shiro呢？"><a href="#我们还有没有必要学习Shiro呢？" class="headerlink" title="我们还有没有必要学习Shiro呢？"></a>我们还有没有必要学习<code>Shiro</code>呢？</h2><ul><li><p>如果你是小白，希望快速成长，没有看的必要，因为已经过时了。</p></li><li><p>如果你是大佬，希望开发新东西，可以看看这些刚刚被淘汰的东西，曾经风光过的框架必有其闪光之处，发现并继承闪光点，或许也能开发出新的东西呢。</p></li><li><p>如果你想等待新技术被完全检验，那么大可认真学习。这样你接下来学习新技术的时候，将会看到满满的系统教程，对以后的学习有非常大的帮助。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Shiro是较早的时候就已经由Apache公司创造的，那个时候普遍是jsp进行前后端设计。到了现如今，Shiro是否还有自己的一席之地？&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://www.sakebow.cn/categories/java/"/>
    
    
      <category term="shiro" scheme="http://www.sakebow.cn/tags/shiro/"/>
    
  </entry>
  
  <entry>
    <title>shiro开发实战</title>
    <link href="http://www.sakebow.cn/2020/03/02/shiro/shiro%E7%AE%80%E4%BB%8B/"/>
    <id>http://www.sakebow.cn/2020/03/02/shiro/shiro%E7%AE%80%E4%BB%8B/</id>
    <published>2020-03-02T13:13:00.000Z</published>
    <updated>2020-03-04T07:09:42.570Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>Shiro并不是一个新技术，很早以前Apache公司就已经好好地做出来了，只不过一直没什么人用。现在SpringBoot开始了之后才因为整合非常方便就开始推广使用了。即使如此使用量依然不是很大。本篇将以原理为主讲述Shiro的实现原理和运作流程。</strong></p><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="http://shiro.apache.org" target="_blank" rel="noopener">shiro</a>是一款基于Java的安全权限框架，主要用于认证<strong>用户登录</strong>和<strong>操作是否符合权限</strong>，主要功能有：认证、授权、加密、会话管理、Web集成、缓存等等。你可能是在Web项目中认识到的Shiro，实际上Shiro甚至可以用在JavaSE中，非常的方便。</p><p>Shiro核心关注点是：</p><ul><li>认证</li><li>授权</li><li>Session管理</li><li>加密</li></ul><p>而其他则是附带的支持。</p><h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2><p>Shiro的设计思想并不是面向对象的，而是面向切面的。这也是为什么它和Spring的相性这么好。</p><p>首先从代码出发，也就是<code>Application</code>，然后转交到交互对象<code>Subject</code>。这个交互对象不是别的，而是当前正在操作的<strong>线程</strong>。为什么是线程而不是用户？因为谁都可以是交互对象，甚至可以是爬虫，只需要你的请求正对着我的接口。</p><p>接着，与Subject的所有交互都会委托给<code>SecurityManager</code>，也就相当于功能强大的拦截器。</p><p>最后<code>SecurityManager</code>需要验证身份时，就需要从<code>Realm</code>中获取相应的用户进行比较确认用户身份是否合法，同时确认用户相应角色权限是否能够执行当前操作。与其说是实体类，更像是<code>dataSource</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Shiro并不是一个新技术，很早以前Apache公司就已经好好地做出来了，只不过一直没什么人用。现在SpringBoot开始了之后才因为整合非常方便就开始推广使用了。即使如此使用量依然不是很大。本篇将以原理为主讲述Shiro的实现原理和运作流程。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://www.sakebow.cn/categories/java/"/>
    
    
      <category term="shiro" scheme="http://www.sakebow.cn/tags/shiro/"/>
    
  </entry>
  
  <entry>
    <title>shiro开发实战</title>
    <link href="http://www.sakebow.cn/2020/03/02/shiro/shiro%E5%AE%9E%E6%88%98/"/>
    <id>http://www.sakebow.cn/2020/03/02/shiro/shiro%E5%AE%9E%E6%88%98/</id>
    <published>2020-03-02T12:38:00.000Z</published>
    <updated>2020-03-02T13:15:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>本篇将以Shiro实战为主，原理将较少涉及。如果你对原理比较感兴趣，你可以查看我的<a href="">shiro原理</a>教程。</strong></p><a id="more"></a><h2 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h2><p>首先是加入依赖。这是Shiro和Spring的整合包，当然我们可以在<a href="https://www.webjars.org/" target="_blank" rel="noopener">webjars</a>上找到对应的资源。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;shiro-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;shiro-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;shiro-cas&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;shiro-ehcache&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>虽然Shiro是一款非常方便的框架，但也只是一具空壳，其中的血肉还是需要我们自己根据业务需求填充。下面我们依次来填充。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本篇将以Shiro实战为主，原理将较少涉及。如果你对原理比较感兴趣，你可以查看我的&lt;a href=&quot;&quot;&gt;shiro原理&lt;/a&gt;教程。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://www.sakebow.cn/categories/java/"/>
    
    
      <category term="shiro" scheme="http://www.sakebow.cn/tags/shiro/"/>
    
  </entry>
  
  <entry>
    <title>synchronized特性</title>
    <link href="http://www.sakebow.cn/2020/03/01/Java%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%80%83/synchronized%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.sakebow.cn/2020/03/01/Java%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%80%83/synchronized%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-03-01T09:33:00.000Z</published>
    <updated>2020-03-01T12:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>在JMM中，我们介绍了synchronized的工作原理，这次我们来详细介绍它的特性。这部分相对于内存模型考的概率不大，所以导读也就简略些。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;在JMM中，我们介绍了synchronized的工作原理，这次我们来详细介绍它的特性。这部分相对于内存模型考的概率不大，所以
      
    
    </summary>
    
    
      <category term="java" scheme="http://www.sakebow.cn/categories/java/"/>
    
    
      <category term="面试" scheme="http://www.sakebow.cn/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>JMM简介</title>
    <link href="http://www.sakebow.cn/2020/03/01/Java%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%80%83/JMM/"/>
    <id>http://www.sakebow.cn/2020/03/01/Java%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%80%83/JMM/</id>
    <published>2020-03-01T02:15:00.000Z</published>
    <updated>2020-03-28T12:36:02.273Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>JMM，英文全称就不说明了，将单词直译很简单地平在一起，就有了中文释义：Java内存模型。这也是Java必考基础知识。内存模型虽然是内存相关的知识，却是CPU、磁盘之间沟通的桥梁，也是程序运行的基本环境之一。所以内存模型往往和垃圾回收、线程安全等问题综合。这也是为什么内存模型更为重要的原因。</strong></p><h2 id="概念梳理"><a href="#概念梳理" class="headerlink" title="概念梳理"></a>概念梳理</h2><p>Java内存结构包含<strong>栈</strong>、<strong>堆</strong>、<strong>方法区</strong>等等，而<strong>Java内存模型</strong>则是完全不同的概念。</p><p><strong>Java内存模型</strong>是一种规范，也是一种抽象的概念，描述了Java程序中各种<strong>线程共享变量</strong>的访问规则，以及在JVM中将变量在内存中存取的底层实现细节。由于这些存取细节屏蔽了不同操作系统的底层实现细节，Java也就自然而然成为一种跨平台语言。具体分为<strong>主内存</strong>和<strong>工作内存</strong>：</p><h4 id="主内存"><a href="#主内存" class="headerlink" title="主内存"></a>主内存</h4><p>Java的共享变量全部保存在主内存中，不管是普通对象还是静态对象都保存在这。</p><h4 id="工作内存"><a href="#工作内存" class="headerlink" title="工作内存"></a>工作内存</h4><p>所有的方法对共享变量进行操作的时候都只能在工作内存中运行。运行时，会将共享变量<strong>复制</strong>到工作内存中进行处理，处理完成后返回到主内存中。</p><p>这个过程就像是GitHub代码托管一样：</p><ul><li>先从代码库中下载代码（<em>先从主存中获得共享变量的拷贝</em>）</li><li>再本地编码（<em>然后在工作内存中对共享变量的拷贝进行处理</em>）</li><li>完成后推送到代码库（<em>拷贝处理结束后，将结果返回到主内存并覆盖原有数据</em>）</li></ul><p>就这三步过程，一共包含了8个<strong>原子</strong>步骤：</p><ul><li><strong>Lock</strong>：线程访问时，给共享变量加锁</li><li><strong>Read</strong>：线程读取主内存的数据</li><li><strong>Load</strong>：线程获得主内存的拷贝，并加载到工作内存</li><li><strong>Use</strong>：线程对拷贝进行处理</li><li><strong>Assign</strong>：将处理结果返回</li><li><strong>Store</strong>：保存返回值并覆盖原有拷贝</li><li><strong>Write</strong>：使用新的拷贝覆盖主内存的对应变量</li><li><strong>Unlock</strong>：对变量解锁</li></ul><p>其中<strong>Lock</strong>和<strong>Unlock</strong>是可选的，也就是添加了<code>synchronized</code>关键字才会生效，否则不生效。其余6个步骤不管是否加锁都一定会进行。</p><p>但是对一个变量执行<strong>Lock</strong>操作的时候，将会相对应地清空工作内存中此变量的值；</p><p>而对一个变量执行<strong>Unlock</strong>操作的时候，将会首先将该变量的拷贝加载到主内存中。</p><h2 id="synchronized关键字保证三大特性的原理"><a href="#synchronized关键字保证三大特性的原理" class="headerlink" title="synchronized关键字保证三大特性的原理"></a>synchronized关键字保证三大特性的原理</h2><p>###synchronized保证原子性</p><p>复习一下，原子性是指<strong>同步语句对应的汇编指令在全部执行完之前，不能有其他线程从中插进来</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 关键字需要传入函数名或者Object类型变量</span></span><br><span class="line">    <span class="keyword">synchronized</span> ((Object) count) &#123;</span><br><span class="line">        <span class="comment">// 10条线程重复1000次累加</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// lambda表达式简化写法</span></span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="comment">// 注意这里不要写i，否则会和上层循环冲突</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 查看结果</span></span><br><span class="line">                <span class="comment">// 不要将结果写在线程外，否则会由主线程执行，最后输出10个0</span></span><br><span class="line">                System.out.println(count);</span><br><span class="line">            &#125;).start();<span class="comment">// 开启线程，否则不运行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>synchronized</code>给<code>count</code>加了锁，所以保证了仅有一条线程可以对<code>count</code>共享变量进行操作，从而保证了操作的原子性。</p><h3 id="synchronized保证可见性"><a href="#synchronized保证可见性" class="headerlink" title="synchronized保证可见性"></a>synchronized保证可见性</h3><p>复习一下，可见性是指<strong>当线程2对共享变量进行修改的时候，线程1还是拿着工作空间的变量拷贝进行操作</strong>。而<code>synchronized</code>则因为线程2无法在线程1处理过程中进入修改，所以从另外一种层面上，也就是加锁，保证了代码的可见性。</p><h3 id="synchronized保证有序性"><a href="#synchronized保证有序性" class="headerlink" title="synchronized保证有序性"></a>synchronized保证有序性</h3><p>JVM会在运行时对代码进行重排序以按照<strong>系统认为</strong>的最优解进行运作，这种重排序将遵循一定的算法，也就是<strong>as-if-serial语义</strong>，大致上就是规定了不可重排序的语句有：</p><ul><li><p><strong>写后读</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">System.out.println(a);</span><br></pre></td></tr></table></figure></li><li><p><strong>写后写</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">a = user.getAge();</span><br></pre></td></tr></table></figure></li><li><p><strong>读后写</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">User user = preparedStatement.executeQuery();</span><br><span class="line"><span class="keyword">int</span> a = user.getAge();</span><br><span class="line">user = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></li></ul><p>当然也有可以随意重排序的，比如<strong>读后读</strong>、<strong>两个完全独立的变量进行写操作</strong>等。</p><p><strong>但是这种算法只能保证单线程情况下最优，多线程情况下则无法保证。</strong></p><p>即使<code>synchronized</code>本身不能阻止JVM对代码进行重排序，也能够通过保证仅有一条线程可以执行同步代码块，从而避免了重排序带来的混乱，也算是保证了代码的有序性。</p><h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><p><code>volatile</code>关键字用于修饰共享变量，作用是当有线程将共享变量的拷贝更改了以后，便会将所有工作空间中的共享变量全部设置为<strong>失效</strong>，使得其他线程只能再次从主内存中寻找新的共享变量进行操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;JMM，英文全称就不说明了，将单词直译很简单地平在一起，就有了中文释义：Java内存模型。这也是Java必考基础知识。内存模
      
    
    </summary>
    
    
      <category term="java" scheme="http://www.sakebow.cn/categories/java/"/>
    
    
      <category term="面试" scheme="http://www.sakebow.cn/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Java的线程安全问题</title>
    <link href="http://www.sakebow.cn/2020/02/29/Java%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%80%83/Java%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"/>
    <id>http://www.sakebow.cn/2020/02/29/Java%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%80%83/Java%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/</id>
    <published>2020-02-29T05:04:00.000Z</published>
    <updated>2020-03-01T12:56:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>线程安全发生的情况非常单一，但是其中包含的技术点非常多。在这里强调一遍，这是Java面试重点考察内容，是个公司都会考。各位萌新一定要引起重视，各位大学生一定要引起重视。</strong></p><a id="more"></a><h2 id="并发编程的三个问题"><a href="#并发编程的三个问题" class="headerlink" title="并发编程的三个问题"></a>并发编程的三个问题</h2><h3 id="可见性问题"><a href="#可见性问题" class="headerlink" title="可见性问题"></a>可见性问题</h3><p>可见性是指<strong>一个线程对共享变量进行修改，另一个线程能立即得到修改后的最新值</strong>。</p><p>当另一个线程没能立即拿到修改后的新值时，就产生了<strong>线程安全问题</strong>。举个简单的例子，就是最简单的累加。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以使用JUnit工具对普通函数进行测试，用静态main函数对静态函数测试</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 由于计算机计算速度越来越快，必须使用大量的数据才可以让问题凸显，几十个都已经不算问题了。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 匿名对象新建线程</span></span><br><span class="line">        <span class="comment">// lambda表达式简化写法，函数式编程已经成为趋势</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 计算</span></span><br><span class="line">            count ++;</span><br><span class="line">            <span class="comment">// 查看结果</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">": "</span> + count);</span><br><span class="line">        <span class="comment">// 执行线程，否则不会显示</span></span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是，经过仔细比对观察，终于发现了不对劲的地方！</p><p><img src="http://47.111.252.78/images/Java%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/%E9%87%8D%E5%A4%8D%E6%95%B0%E6%8D%AE.png" alt="线程不安全的证据"></p><p>这就是<strong>没能立刻拿到修改后的数据</strong>。</p><h3 id="原子性问题"><a href="#原子性问题" class="headerlink" title="原子性问题"></a>原子性问题</h3><p>原子性是指<strong>在一次或多次执行中，要么所有的操作都会执行，并且不会受到其他因素干扰而中断；要么所有的操作都不执行</strong>。</p><p>同样的，我们使用累加的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// CPU的速度对循环次数有影响，博主的i7-7500U能够在30次的1000次累加表现优异，所以只能用50次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                count ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 每次循环完查看结果，如果大量测试都刚好是1000的整数倍，那么就是线程安全，否则线程不安全</span></span><br><span class="line">            System.out.println(count);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>终于，在第34次的1000次累加中终于出现了线程安全问题：</p><p><img src="http://47.111.252.78/images/Java%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/%E5%87%BA%E7%8E%B0%E9%9B%B6%E5%A4%B4.png" alt="原子性不能保证"></p><p>如果你足够强，你可以去查看字节码文件，也就是运行时生成的<code>.class</code>文件。然后使用反汇编程序<code>javap</code>，在管理员权限下的命令行工具，在其中输入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -p -v .\Test<span class="class">.<span class="keyword">class</span></span></span><br></pre></td></tr></table></figure><p>其中<code>-p</code>是显示私有属性，<code>-v</code>是显示详细信息，最后跟上你想要查看的字节码文件名，在这里博主就简单说一下：<code>count++</code>实际上反汇编了是四条汇编指令，分别是：<strong>取原始值</strong>、<strong>获取常量1</strong>、<strong>原始值加上常量1</strong>、<strong>将结果返回</strong>。在多线程的环境下，有可能会还没执行完，下一个线程就开始了，于是第一个线程返回了自己的结果1，第二个线程在第一个线程<strong>返回之前</strong>就已经拿到了原始数据0，那么还是返回了1，而不是2。最后，产生了1000次累加总和不是1000的倍数这种问题。</p><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>有序性是指程序中代码的执行顺序。Java在编译时和运行时会对代码进行优化，最后会导致程序最终执行顺序不一定就是我们编写代码时的顺序。</p><p><em>这里有个并发压力测试工具jcstress，在Spring框架的pom.xml文件中添加依赖，让编译器自动导包。依赖如下：</em></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.openjdk.jcstress/jcstress-core --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jcstress<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jcstress-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>、</span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>不建议</strong>使用SpringBoot框架测试，因为SpringBoot集成度过高，不一定会显示在终端上，结果也就不得而知。</p><p>我们使用这个工具编写测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> ready = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">// 标注这个方法需要新的线程</span></span><br><span class="line"><span class="meta">@Actor</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor1</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// I_Result中提供了各种各样保存数据的方法</span></span><br><span class="line">    <span class="keyword">if</span> (ready) &#123;</span><br><span class="line">        r.r1 = num + num;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r.r1 =  <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Actor</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor2</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line">    num = <span class="number">2</span>;</span><br><span class="line">    ready = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>压力测试会将上面两个方法的代码反复执行。如果出现了不同的结果，则表明JVM会将代码进行自动优化，然后代码重新排序。<strong>对于完全没有前后必然逻辑关系的两行代码更有可能会出现代码重构的情况</strong>，比如a++；b*=5；这两句没有必然联系，JVM执行时就会有一定概率变动顺序。</p><h2 id="LOCK"><a href="#LOCK" class="headerlink" title="LOCK"></a>LOCK</h2><p>相信大家一定听过了这个单词，就算没学过也应该听别人说过。对，这也是<strong>面试必考</strong>。</p><h3 id="LOCK和synchronized的区别"><a href="#LOCK和synchronized的区别" class="headerlink" title="LOCK和synchronized的区别"></a>LOCK和synchronized的区别</h3><ul><li><code>synchronized</code>是<strong>关键字</strong>，而<code>Lock</code>是一种<strong>接口</strong></li><li><code>synchronized</code>会<strong>自动释放</strong>锁，而<code>Lock</code>需要<strong>手动释放</strong>锁</li><li><code>synchronized</code>是<strong>不可中断的</strong>，而<code>Lock</code><strong>可以中断也可以不中断</strong></li><li><code>synchronized</code><strong>不能直观</strong>地观察到线程有没有拿到锁，而<code>Lock</code><strong>可以很直观</strong>的看到线程有没有拿到锁</li><li><code>synchronized</code>可以锁住<strong>方法和代码块</strong>，但是<code>Lock</code>只能锁住<strong>代码块</strong></li><li><code>Lock</code>可以使用<strong>读锁</strong>提高多线程读效率</li><li><code>synchronized</code>是<strong>非公平锁</strong>，<code>ReentrantLock</code>可以判断是不是公平锁</li></ul><blockquote><p><strong>非公平锁</strong>是指从就绪的线程中随机选择下一个运行线程，而不是遵循先来后代的原则。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;线程安全发生的情况非常单一，但是其中包含的技术点非常多。在这里强调一遍，这是Java面试重点考察内容，是个公司都会考。各位萌新一定要引起重视，各位大学生一定要引起重视。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://www.sakebow.cn/categories/java/"/>
    
    
      <category term="面试" scheme="http://www.sakebow.cn/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Session的线程安全问题</title>
    <link href="http://www.sakebow.cn/2020/02/29/Java%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%80%83/Session%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"/>
    <id>http://www.sakebow.cn/2020/02/29/Java%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%80%83/Session%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/</id>
    <published>2020-02-29T01:10:00.000Z</published>
    <updated>2020-02-29T05:04:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>服务器虽然能够为每一个会话维护一个Session，在一定程度上确保了线程安全，但是往往在一些细节上还是不能如愿地保证线程安全。这里将详细介绍线程不安全的情况。</strong></p><a id="more"></a><h2 id="HttpServletRequest源码"><a href="#HttpServletRequest源码" class="headerlink" title="HttpServletRequest源码"></a>HttpServletRequest源码</h2><p>通过<code>CTRL</code>+<code>鼠标左键</code>，你找到了源码。（<em>Tomcat相关的jar包有三个，直接找需要很久</em>）</p><p>先来看注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Extends the javax.servlet.ServletRequest <span class="class"><span class="keyword">interface</span> <span class="title">to</span> <span class="title">provide</span> <span class="title">request</span> <span class="title">information</span> <span class="title">for</span> <span class="title">HTTP</span> <span class="title">servlets</span>. <span class="title">The</span> <span class="title">servlet</span> <span class="title">container</span> <span class="title">creates</span> <span class="title">an</span> <span class="title">HttpServletRequest</span> <span class="title">object</span> <span class="title">and</span> <span class="title">passes</span> <span class="title">it</span> <span class="title">as</span> <span class="title">an</span> <span class="title">argument</span> <span class="title">to</span> <span class="title">the</span> <span class="title">servlet</span>'<span class="title">s</span> <span class="title">service</span> <span class="title">methods</span>(<span class="title">doGet</span>, <span class="title">doPost</span>, <span class="title">etc</span>).</span></span><br></pre></td></tr></table></figure><p>继承了ServletRequest类，为HTTP Servlet一共请求头信息。这个<strong>Servlet容器</strong>创建了一个<code>HttpServletRequest</code>对象并作为参数传递给Servlet的服务方法，比如doGet、doPost等。</p><p>非常清晰了吧？就算<code>HttpServletRequest</code>是一个接口，他在运行的时候还是创建了一个提供请求头信息的容器。而其中的<code>getSession</code>方法一共有两个，一个是带有<code>create</code>参数的方法，一个是无参方法。</p><p>首先是有参方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> HttpSession <span class="title">getSession</span><span class="params">(<span class="keyword">boolean</span> create)</span></span></span><br></pre></td></tr></table></figure><p>他的注释是：<em>传入true，就会在必要的时候为请求新建一个Session，返回值将会是与请求头相关联的HttpSession对象；而如果是false则会在当前没有Session的时候直接返回null，最后也会因为没有对应的有效对象直接返回null</em>。</p><p>而无参方法则是<code>getSession(true)</code>的调用。</p><h2 id="HttpSession的源码"><a href="#HttpSession的源码" class="headerlink" title="HttpSession的源码"></a>HttpSession的源码</h2><p>你似乎还是不明白这到底是怎么回事。于是，为了弄清楚getSession到底返回了个什么，你又找到了HttpSession的源码，然后发现他依然是一个接口。</p><p>老规矩，先来看看注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Provides a way to identify a user across more than one page request or visit to a Web site and to store information about that user.</span><br></pre></td></tr></table></figure><p><em>提供了在多个页面请求中确认其中一个用户身份的方法，或者说是访问Web服务器并存储用户信息的方法。</em></p><p>说白了这就是实现了Session的功能。下面更是有一句你非常熟悉的：<code>The session persists for a specified time period, across more than one connection or page request from the user.</code>。相信不翻译大家也能明白HttpSession是个啥玩意了吧。</p><p>但是接口怎么实现？继续顺藤摸瓜，你找到了<code>StandardSession</code>，这部分参考了CSDN中<a href="https://www.cnblogs.com/digdeep/p/4429098.html" target="_blank" rel="noopener">digdeep的博客</a>。</p><p>而在<code>StandardSession</code>中，第一行就使用了<code>ConcurrentHashMap</code>作为容器存储信息。这是个什么？因为这又是一个大坑所以还是另外用一个单独的版块来进行阐述，<a href="">点击这里查看ConcurrentHashMap详解</a>。这里就直接说结论了：<code>ConcurrentHashMap</code>为<code>HttpSession</code>保证了线程安全，这个是不容置疑的。</p><h2 id="Session线程不安全的真正原因"><a href="#Session线程不安全的真正原因" class="headerlink" title="Session线程不安全的真正原因"></a>Session线程不安全的真正原因</h2><p>事实上，Servlet本身不是线程安全的，就算你的Session再怎么线程安全，最后Servlet中修改变量值的时候永远都会出现问题。举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在Servlet中定义属性</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"><span class="comment">// 在Servlet中编写方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 属性修改</span></span><br><span class="line">    count++;</span><br><span class="line">    <span class="comment">// 线程暂停，放大效果</span></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">"count: "</span> + count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用tomcat自带的JMETER压力测试工具模拟五次访问，输出结果就是这样：</span></span><br><span class="line"><span class="comment"> * http-bio-8080-exec-6 count: 5</span></span><br><span class="line"><span class="comment"> * http-bio-8080-exec-9 count: 5</span></span><br><span class="line"><span class="comment"> * http-bio-8080-exec-8 count: 5</span></span><br><span class="line"><span class="comment"> * http-bio-8080-exec-5 count: 5</span></span><br><span class="line"><span class="comment"> * http-bio-8080-exec-7 count: 5</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>很明显，五次输出中四次都拿到了<strong>脏数据</strong>，这不是能够让系统中断的错误，这是逻辑错误，往往比编译器报错更让人头疼。会出现这种情况的原因有两点：</p><ul><li>容器<strong>只会创建一个</strong><code>Servlet</code>实例，也就是说，这个<code>Servlet</code>中定义的所有变量，只会出现一次。</li><li>容器收到请求之后，会启动一个线程来处理该请求。当有多个请求同时访问同一个<code>Servlet</code>值后，这只会出现一次的变量在被多个线程修改的时候就会出现线程安全问题。</li></ul><p>所以这个问题实际上有点迷惑，<strong>真正线程不安全的并不是<code>Session</code>，而是<code>Servlet</code></strong>。</p><p>那么怎么解决呢？同样的，这里涉及<strong>JVM的多线程机制</strong>，因为内容颇多，而且是面试重点，所以单独拉出来讲解。<a href="">点击这里查看JVM多线程机制</a>。这里只给出结果：加上关键字<code>synchronized</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在Servlet中定义属性</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"><span class="comment">// 在Servlet中编写方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 加锁，this是指当前类</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"count: "</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用tomcat自带的JMETER压力测试工具模拟五次访问，输出结果就是这样：</span></span><br><span class="line"><span class="comment"> * http-bio-8080-exec-5 count: 1</span></span><br><span class="line"><span class="comment"> * http-bio-8080-exec-9 count: 2</span></span><br><span class="line"><span class="comment"> * http-bio-8080-exec-7 count: 3</span></span><br><span class="line"><span class="comment"> * http-bio-8080-exec-8 count: 4</span></span><br><span class="line"><span class="comment"> * http-bio-8080-exec-6 count: 5</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>现在就正常了。</p><p>虽然加锁能够避免线程安全问题，但是加锁会<strong>牺牲性能</strong>。</p><p>所以尽量我们不要修改Servlet的属性。如果你使用了框架，相对应的就是Controller部分，尽量不要修改这些部分。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;服务器虽然能够为每一个会话维护一个Session，在一定程度上确保了线程安全，但是往往在一些细节上还是不能如愿地保证线程安全。这里将详细介绍线程不安全的情况。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://www.sakebow.cn/categories/java/"/>
    
    
      <category term="面试" scheme="http://www.sakebow.cn/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>spring-boot的Web开发简介</title>
    <link href="http://www.sakebow.cn/2020/02/25/spring-boot/spring-boot-%E5%BC%80%E5%8F%91%E5%B0%8F%E5%AE%9E%E6%88%98/"/>
    <id>http://www.sakebow.cn/2020/02/25/spring-boot/spring-boot-%E5%BC%80%E5%8F%91%E5%B0%8F%E5%AE%9E%E6%88%98/</id>
    <published>2020-02-25T14:11:00.000Z</published>
    <updated>2020-02-26T07:21:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>本篇将以一个实例来对各种各样的功能进行讲解。由于博主已经连模板都用的和教程不一样了，所以放弃治疗连例子都不用教程的。希望大家也可以融会贯通。不过别担心，由于博主也是从头开始，多少会有一些非常类似的坑一起踩过，能够作为前车之鉴。</strong></p><a id="more"></a><h2 id="实例简介"><a href="#实例简介" class="headerlink" title="实例简介"></a>实例简介</h2><p>这是博主毕业论文所研究的系统，也就是<strong>大学生竞赛外包系统</strong>。大学生可以组队、可以外包。特殊的比赛有特殊的规定，所以我们将模拟这种情况。</p><p>对于这个系统，我将给出我的分析过程：</p><blockquote><p>乍一看是大学生和委托这两个对象，发包方发起委托，承包方接收委托，听起来非常有道理，不是吗？不是的。实际上是大学生和比赛这两个对象，大学生和比赛构成了委托表。这才是这个系统的核心。</p></blockquote><p>那么问题就好说了，大致上就是这个样子的：</p><p><img src="http://47.111.252.78/images/spring-boot-example/%E7%B3%BB%E7%BB%9FUML%E6%B4%BB%E5%8A%A8%E5%9B%BE.png" alt="系统活动图"></p><p>于是也能将数据库设计好（省略属性）：</p><p><img src="http://47.111.252.78/images/spring-boot-example/%E6%95%B0%E6%8D%AE%E5%BA%93ER%E5%9B%BE.png" alt="数据库ER图"></p><p>细化就是这样（可能会有遗漏，基本上全了）：</p><p><img src="http://47.111.252.78/images/spring-boot-example/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1.png" alt="数据库设计"></p><p>最后，就开始系统开发啦！（数据库建库等跳过，因为在这里不是重点）</p><p>在数据库完成之后，我们就要开始进行SpringBoot的编码了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本篇将以一个实例来对各种各样的功能进行讲解。由于博主已经连模板都用的和教程不一样了，所以放弃治疗连例子都不用教程的。希望大家也可以融会贯通。不过别担心，由于博主也是从头开始，多少会有一些非常类似的坑一起踩过，能够作为前车之鉴。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://www.sakebow.cn/categories/java/"/>
    
    
      <category term="spring boot" scheme="http://www.sakebow.cn/tags/spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>Collection，Set和List以及Map</title>
    <link href="http://www.sakebow.cn/2020/02/24/Java%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%80%83/Java%E9%9B%86%E5%90%88%E6%A2%B3%E7%90%86/"/>
    <id>http://www.sakebow.cn/2020/02/24/Java%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%80%83/Java%E9%9B%86%E5%90%88%E6%A2%B3%E7%90%86/</id>
    <published>2020-02-24T02:44:00.000Z</published>
    <updated>2020-02-24T09:48:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>如果你是Java后台开发人员，这四个将会伴随你整个面试。而且，想要爬到更高的层次，这是谁也跑不掉的数据结构。</strong></p><a id="more"></a><h2 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h2><p>先来看一下Java所有的容器类：</p><ul><li><p>Collection：接口（不是实体类！）</p><ul><li><p>List：接口（不是实体类！）</p><ul><li><p>LinkedList：链表实体类</p></li><li><p>ArrayList：集合实体类</p></li><li><p>Vector：vector实体类（比较接近数组）</p><ul><li>Stack：链表实体类</li></ul></li></ul></li><li><p>Set：接口（不是实体类！）</p><ul><li>HashSet：哈希集合实体类</li><li>LinkedHashSet：链表哈希集合实体类</li><li>TreeSet：树状集合实体类</li></ul></li></ul></li></ul><p>但是这些有什么区别吗？弄了这么多花里胡哨的，他们都是为了什么而产生的？</p><p>我们通过源码来看看。（又双叒叕是源码）</p><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p><strong>Collection是一种接口，其下又衍生出了”Set“和”List“两种接口，而且具有不同的功能。</strong></p><p>但是Collection不支持直接实例化，而需要通过对两个子接口中的一个进行实例化才可以间接地将Collection进行实例化。</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p><strong>Set中不包含任何重复元素，就像是数学术语中的“集合”一样。</strong></p><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p><strong>HashSet在源码中使用了HashMap进行了所有功能的实现，所以本质上HashSet是HashMap的再封装，顶多是加了不重复这个功能。</strong></p><p>HashSet支持向里面添加<strong>null</strong>对象，但是<strong>会进行简单的排序</strong>。</p><h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><p>LinkedHashSet和HashSet都是继承自Set，所以也有基本的集合属性。唯一不同的就是，LinkedHashSet将会严格按照add方法的顺序进行元素的添加，而HashSet会自动排序。</p><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>TreeSet与其说是实现了Set，应该说是实现了NavigableSet接口，而NavigableSet接口又是继承自SortedSet接口。相信大家看到这个名字都知道是干嘛的吧？也就是说，TreeSet将会遍历整个集合的元素并按<strong>升序排列</strong>。</p><p>但是要强调一点，TreeSet<strong>不支持加入null元素</strong>，因为无法升序排列。</p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p><strong>List是一个有序的数据集。与Set不同的是List允许同样的值反复插入，而且List可以直接使用数据在集合中的索引位置直接访问，非常快速方便。</strong></p><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>LinkedList中是使用Node类实现的，也就是在LinkedList类中另外定义了私有的Node类进行实现，也就是说，本质上是链表。</p><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>ArrayList中使用了Object数组实现的，也就是说，ArrayList本质上就是数组。</p><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>Vector中使用了Object数组。其实由ArrayList继承而来的Vector也必定是数组实现的。</p><h4 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h4><p>Stack由Vector继承而来，本质也是数组，只不过增加了栈一样先进后出的逻辑控制。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;如果你是Java后台开发人员，这四个将会伴随你整个面试。而且，想要爬到更高的层次，这是谁也跑不掉的数据结构。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://www.sakebow.cn/categories/java/"/>
    
    
      <category term="面试" scheme="http://www.sakebow.cn/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Session工作原理</title>
    <link href="http://www.sakebow.cn/2020/02/24/Java%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%80%83/Session%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>http://www.sakebow.cn/2020/02/24/Java%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%80%83/Session%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</id>
    <published>2020-02-24T00:10:00.000Z</published>
    <updated>2020-02-29T00:28:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>在Web面试的时候，后台一定要清楚Session的工作原理，因为总有一些数据需要从后台传入前端。而在说Session的时候，不可避免地会谈到Cookies。本篇将详细阐述二者的区别。</strong></p><a id="more"></a><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="TCP-IP网络协议"><a href="#TCP-IP网络协议" class="headerlink" title="TCP/IP网络协议"></a>TCP/IP网络协议</h3><p>根据计算机网络原理，双方在通信时往往会互相发送报文，也就是把数据处理成了多个压缩包逐个发送。而在这个过程中，双方会建立一个虚拟连接通道。你问我为什么不是物理的？因为物理连接是一开始就存在的。如果是有线连接，物理连接就是网线；如果是无线连接，空气也能算介质。</p><p>那么，这个虚拟连接什么时候开始什么时候结束呢？</p><p>1、当我们要发送数据包前，快递员会先跟他提个醒：“快递到了，签收一下”</p><p>2、对面听到了之后回应：“好嘞”，然后把门打开了</p><p>3、快递员听到了回应之后，虚拟连接就成立了，搬运也就开始了</p><p>这就是我们俗称“<strong>三次握手</strong>”。</p><p>最后搬运完了之后，开始执行同样的操作。</p><p>1、快递员这边提个醒：“全部搬完了！”</p><p>2、对面听到了之后回应：“好嘞”，然后把钱递了出去</p><p>3、快递员收到钱之后，清点了一下，喊一声：“收齐啦！谢谢！”（<em>没收齐是不会进入结束阶段的</em>）</p><p>4、对面听到了，直接“砰”地就把门关上了，虚拟连接断开</p><p>你也可以叫他“<strong>四次握手</strong>”，也有人叫他“<strong>四次挥手</strong>”，这都无所谓了。</p><h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><p>会话在计算机术语中是指<strong>一个终端用用户与交互系统进行通讯的过程</strong>。“三次握手”建立了一个会话，“四次挥手”关闭了一个会话。例如，<strong>从你登录</strong>求职网<strong>一直到退出</strong>账号这整个过程都是会话。（摘自<a href="https://baike.baidu.com/item/HTTP%E4%BC%9A%E8%AF%9D/4376108?fr=aladdin" target="_blank" rel="noopener">百度百科</a>）</p><p>我们一般所说的“会话”，其实全称是“<strong>HTTP会话</strong>”。</p><h3 id="HTTP网络协议"><a href="#HTTP网络协议" class="headerlink" title="HTTP网络协议"></a>HTTP网络协议</h3><p>只要你访问了互联网，网址栏永远会显示http://或者https://，这就是HTTP协议的作用，也就是客户端和服务端之间的相互通信。但是HTTP是无状态协议，也就是说不管你去哪访问，服务器永远不会管你先前干了什么，这也就是为什么好好的填了在线简历一刷新全都没了。</p><p>这无疑是非常恐怖的。但是不用担心，我们有<strong>Session和Cookie</strong>。</p><h2 id="Session和Cookie"><a href="#Session和Cookie" class="headerlink" title="Session和Cookie"></a>Session和Cookie</h2><p>Session运行在服务端，当我们在连接中接入steam的时候，你就有了<strong>唯一一个</strong>SessionID，这样服务器就确认了是你购买了这款游戏。与此同时，运行在客户端的Cookie就帮我们保存了一小段的信息，一般是保存在内存中，用来记录各种各样的信息。正因如此，我们能<strong>免认证直接登录</strong>就是因为这段Cookie在会话结束后<strong>存在了硬盘中</strong>，在有效时间内再次访问就会使用这段Cookie；而一些做的并不是很好的网站却没有这个功能，直接关掉浏览器，甚至是关掉网页Cookie就消失了，在登录和登出之间反复横跳。</p><p>你可能会怀疑：如果一个人登录修改了Session，第二个人登进去会不会把第一个人顶出去？</p><h2 id="Session的工作原理"><a href="#Session的工作原理" class="headerlink" title="Session的工作原理"></a>Session的工作原理</h2><p>服务器系统会为<strong>每一个会话维护一个Session</strong>，<strong>不同的会话对应不同的Session</strong>。下面会详细解释为什么系统对每一个会话使用并一直保持使用<strong>完全不同</strong>的Session来处理不同的会话。</p><h3 id="写入Session列表"><a href="#写入Session列表" class="headerlink" title="写入Session列表"></a>写入Session列表</h3><p>这也是整个会话管理的第一步。</p><p>服务器对当前应用中的Session是以<strong>Map</strong>的形式进行管理的，这个Map成为Session列表。我们知道，Map是以<strong>键值对（key-value）</strong>的形式存储的，所以最终将会是一个多行两列的表格，每一行代表一个键值对。而Session里面都是些什么啊？用表格表示的话就是这样：</p><table><thead><tr><th>key</th><th>value</th></tr></thead><tbody><tr><td>D329C89C88DEC2189888FDF365961A87</td><td>org.apache.catalina.session.StandardSessionFacade@1878aab4</td></tr><tr><td>9C7B848D2CCF19DC00B80218BC181838</td><td>org.apache.catalina.session.StandardSessionFacade@78dded51</td></tr></tbody></table><p>（以上数据均为举例，并不是真实数据）</p><p>左边的<code>key</code>为32位随机串，是根据某种算法生成的字符串，被称为<code>JSessionID</code>，也就是Java类型的Session对象的ID值。右边的<code>value</code>值就是HttpSession对象的引用，存放在<strong>服务器的堆内存中</strong>。</p><p>当用户<strong>第一次提交请求</strong>的时候，<strong>服务端</strong>的Servlet执行到<code>request.getSession()</code>方法后，会自动生成一个<code>Map.Entity</code>对象，也就是键值对对象。<strong>一定要明确写明调用了getSession方法，因为只有在这种情况下服务端才会生成Session</strong></p><h3 id="服务器生成并发送Cookie客户端"><a href="#服务器生成并发送Cookie客户端" class="headerlink" title="服务器生成并发送Cookie客户端"></a>服务器生成并发送Cookie客户端</h3><p>在服务器写入Session列表后，系统还自动将<code>JSessionID</code>以<strong>Cookie</strong>的形式保存在响应报头中，并随着这个报头，传送给客户端。</p><h3 id="客户端接受并发送Cookie到服务器"><a href="#客户端接受并发送Cookie到服务器" class="headerlink" title="客户端接受并发送Cookie到服务器"></a>客户端接受并发送Cookie到服务器</h3><p>客户端接收到JSessionID后，将这个存在浏览器缓存中。只要浏览器不关闭，Cookie就不会消失。<strong>每次请求的时候，缓存中的Cookie就会被封装到响应报头中发送到服务器</strong>。</p><h3 id="服务器接收Cookie并在表中查找发送的JSessionID"><a href="#服务器接收Cookie并在表中查找发送的JSessionID" class="headerlink" title="服务器接收Cookie并在表中查找发送的JSessionID"></a>服务器接收Cookie并在表中查找发送的JSessionID</h3><p>服务端从请求中读取到客户端发送回来的Cookie，并根据Cookie中的JSessionID的值，在Map中查找相应的<code>key</code>所对应的<code>value</code>，即Session对象。然后，服务器才可以对Session对象中的对应属性进行读写操作。</p><p>这一整套流程像极了银行卡的办理和使用。</p><ul><li>你到了银行，<strong>请求</strong>办一张卡</li><li>通过银行的某种随机算法，银行给了你一个<strong>随机的字符串</strong>，这就变成了你的<strong>唯一标识</strong>了</li><li>银行<strong>只给了你一张卡</strong>，卡上有你的<strong>唯一标识</strong></li><li>你以后就可以拿着卡去找银行存取了。同样的，银行就通过你银行卡上的<strong>唯一标识</strong>来查找你的真实数据，然后修改</li></ul><h2 id="Session的线程安全问题"><a href="#Session的线程安全问题" class="headerlink" title="Session的线程安全问题"></a>Session的线程安全问题</h2><p>虽然说银行能够对每一个客户的业务处理独立进行，线程安全问题可以在一定程度上得到保证。但是开发中Session多少还是有一定的线程安全问题。这一部分由于涉及源码，将会单独拉出来一个板块进行讲解。而且这个板块涉及的内容非常多，请务必在确保你了解<code>synchronized</code>关键字、<code>ConcurrentHashMap</code>类的基础上查看<a href="">此教程</a>。</p><h2 id="附：Cookie被禁后的Session运行流程"><a href="#附：Cookie被禁后的Session运行流程" class="headerlink" title="附：Cookie被禁后的Session运行流程"></a>附：Cookie被禁后的Session运行流程</h2><p>上面我们讲了，Session的运行少不了Cookie，在一定程度上说，Cookie就是维持两边通信的基础。</p><p>但是别忘了，IE是可以<strong>禁用</strong>Cookie的。这种情况怎么办？禁用了Cookie之后，客户端中将不再保存服务端送来的JSessionID，下一次请求将是全新的请求，服务器会分配全新的JSessionID，用户已保存的信息也就不能通过正常访问方式访问了，最后随着失效时间的到来而消失。</p><p>细心的你似乎已经发现了，我说的是<strong>不能通过正常方式</strong>。非正常的访问方式是：你通过抓包抓住了JSessionID，然后使用<code>同样的网址</code>+<code>;</code>+<code>JSessionID=</code>+<code>记录下来的JSessionID</code>。这个时候你就能在请求的同时把原来的JSessionID强行送出去，然后服务器就知道了你的身份。</p><p><strong>但是，这个身份不一定是你，而是能够使用抓包工具抓到包的任何人。更可怕的是，抓包工具就集成在浏览器中，也就是我们所熟知的F12开发者选项</strong>。</p><p>这也引出了另一个问题：<strong>会话到底是什么时候结束</strong>？</p><p>答案是：<strong>Session消失了会话才会结束</strong>。我们一开始就已经强调了，<strong>服务器会为每一个会话维护一个Session</strong>。这也是为什么电商平台往往要有退出按钮。</p><p>但是我们该怎么在Cookie被禁掉之后重新找到原来的数据呢？Servlet有<strong>重定向</strong>和<strong>非重定向</strong>方法。</p><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先确定接口位置</span></span><br><span class="line">String uri = request.getContextPath() + <span class="string">"/api"</span>;</span><br><span class="line"><span class="comment">// 解决Cookie禁用后重定向时Session的跟踪问题</span></span><br><span class="line">uri = response.encodeRedirecrtURL(uri);</span><br><span class="line">response.sendRedirect(uri);</span><br></pre></td></tr></table></figure><p>这样不管是否禁止Cookie就都能找到我的用户数据啦！简直不要太完美！</p><p>可现实是：<strong>你的JSessionID明晃晃地挂在地址栏上</strong>。这可了不得，你把自己的位置都给暴露了，还不怕别人暗中狙你一枪？</p><h3 id="非重定向"><a href="#非重定向" class="headerlink" title="非重定向"></a>非重定向</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先确定接口</span></span><br><span class="line">String uri = <span class="string">"api"</span>;</span><br><span class="line"><span class="comment">// 解决Cookie禁用后非重定向时Session的跟踪问题</span></span><br><span class="line">uri = response.encodeURL(uri);</span><br><span class="line">out.println(<span class="string">"&lt;a href='"</span> + uri + <span class="string">"'&gt;跳转&lt;/a&gt;"</span>);</span><br></pre></td></tr></table></figure><p>同样的，这样不管是否禁用Cookie都可以访问到原有的JSessionID。但是别忘了，a标签可是GET请求啊！明明白白地打在地址栏上的啊！</p><p>以上，就是Session的全部内容。实际上Session还有非常多的细节问题，但是<strong>最重要的还是工作原理的部分</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;在Web面试的时候，后台一定要清楚Session的工作原理，因为总有一些数据需要从后台传入前端。而在说Session的时候，不可避免地会谈到Cookies。本篇将详细阐述二者的区别。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://www.sakebow.cn/categories/java/"/>
    
    
      <category term="面试" scheme="http://www.sakebow.cn/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>HashMap详细探究</title>
    <link href="http://www.sakebow.cn/2020/02/23/Java%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%80%83/HashMap%E8%AF%A6%E7%BB%86%E6%8E%A2%E7%A9%B6/"/>
    <id>http://www.sakebow.cn/2020/02/23/Java%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%80%83/HashMap%E8%AF%A6%E7%BB%86%E6%8E%A2%E7%A9%B6/</id>
    <published>2020-02-23T08:56:00.000Z</published>
    <updated>2020-03-09T10:21:33.911Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>本文将分为两个部分，一个是HashMap原理讲解，一个是HashMap面试常考。当然，这里没有实战内容，全都是生涩的理论知识，比较枯燥而且难懂。但是这可是非常重要的必考部分呢。</strong></p><a id="more"></a><h2 id="原理讲解"><a href="#原理讲解" class="headerlink" title="原理讲解"></a>原理讲解</h2><p>HashMap是Map接口的实现类。确实，HashMap也是一种容器，可以类比C#中的字典类型，是标准的键值对，即Key-Value存储模式。</p><p>想必大家都听说过：HashMap其实就是<strong>散列表</strong>，使用链表处理冲突。而链表长度大于8的时候，链表会被重构为红黑树。</p><p>为什么是红黑树？因为红黑树中红色节点和黑色节点在重构是会不停的旋转，从而使得整个树无论怎么增删改查时间复杂度永远只有O(log(n))。这无疑比链表的O(n)要快。</p><p>而为什么是8？因为链表平均查找长度为(1 + 2 + … + n) / 2 = (n + 1) / 2，而红黑树是log<sub>2</sub>(n)，当n取8的时候，链表和红黑树相差1个节点以上的消耗，这个时候才有了显著的提升。</p><p>但是，当n取6时，红黑树平均查找长度是2.5，链表是3.5，也是一个节点的长度，为什么偏偏要选8？这是因为如果消耗严格控制在1个节点将会在树和链表中反复横跳，这个转换的代价远远超过了增删改查的代价。</p><p><strong>当然仅仅大于8是不够的</strong>。如果散列表始终只有一个数据，转换为红黑树的代价是毁灭性的。为什么？如果你们在大学期间有幸能够接触到红黑树，应该会了解到红黑树其实是按照一定的规律将节点标记为红色和黑色，并且对红色和黑色的节点有严格地排列规律，如果不正确就需要重新修改排列顺序。那么，我将会为这唯一一个散列表的数据反复的重构、再排列，<strong>已经远远不如原来的链表了</strong>。所以源码中还另外规定了：需要<strong>散列表长度超过64</strong>。</p><p>好了，接下来我们开始看源码。</p><p>首先我们来看看注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Hash table based implementation of the Map <span class="class"><span class="keyword">interface</span>.</span></span><br><span class="line"><span class="class"><span class="title">This</span> <span class="title">implementation</span> <span class="title">provides</span> <span class="title">all</span> <span class="title">of</span> <span class="title">the</span> <span class="title">optional</span> <span class="title">map</span> <span class="title">operations</span>, <span class="title">and</span> <span class="title">permits</span> <span class="title">null</span> <span class="title">values</span> <span class="title">and</span> <span class="title">the</span> <span class="title">null</span> <span class="title">key</span>.</span></span><br><span class="line"><span class="class"><span class="title">The</span> <span class="title">HashMap</span> <span class="title">class</span> <span class="title">is</span> <span class="title">roughly</span> <span class="title">equivalent</span> <span class="title">to</span> <span class="title">Hashtable</span>,</span></span><br><span class="line"><span class="class">  <span class="title">except</span> <span class="title">that</span> <span class="title">it</span> <span class="title">is</span> <span class="title">unsynchronized</span> <span class="title">and</span> <span class="title">permits</span> <span class="title">nulls</span>.</span></span><br><span class="line"><span class="class"><span class="title">This</span> <span class="title">class</span> <span class="title">makes</span> <span class="title">no</span> <span class="title">guarantees</span> <span class="title">as</span> <span class="title">to</span> <span class="title">the</span> <span class="title">order</span> <span class="title">of</span> <span class="title">the</span> <span class="title">map</span></span>;</span><br><span class="line">in particular, it does not guarantee that the order will remain constant over time.</span><br></pre></td></tr></table></figure><p>大致意思上就是说：这个继承类提供了Map的所有操作，并且支持<strong>null:null</strong>这样的键值对。在某种程度上，HashMap和HashTable是类似的，但是HashMap是线程不安全的。同样的，HashMap不能保证顺序。</p><p>为什么不能保证顺序？我们看看添加元素的方法：put。结果put中<strong>只是调用了putVal方法</strong>，我们再转到putVal中查看详细的内容。</p><p>同样的，看方法之前先看注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.put and related methods ：实现了Map.put和其他相关方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment"> * hash字段是键的哈希值，是我们通过一定的计算产生的，常见的算法有MD5，SHA-1等等。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * key字段是需要加入的键值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment"> * value字段是键值所对应的数据，和key一起构成“键值对”</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyIfAbsent if true, don't change existing value</span></span><br><span class="line"><span class="comment"> * onlyIfAbsent翻译过来是“仅在缺省情况下生效”</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment"> * evict翻译过来是“驱逐”的意思</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment"> * 返回值是当前值，如果为空则什么都没有</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><blockquote><p>先说明一下：由于hash值是使用key值进行计算得出来的，所以只要key值相同，hash值一定相同。</p><p>这也是为什么HashMap会略微快一点，因为他的位置是根据key算出来的。</p><p>获取hash值除以特定长度后的余数，余数重复的元素将会放在同一个节点，以链表或者红黑树的形式绑在一起。这也就是数据结构的散列表处理冲突。</p><p>这个概念比较重要，马上我们就会用到。</p></blockquote><p>在开始我们的函数之前，我们要先理清一个问题：Node这个玩意为什么在那么多容器里面都有？</p><p>首先，Node这个类并不是单独拉个文件出来写的，而是在每个类中按需定制。比如LinkedList就是在自己的类里面定义了一个private class Node，而HashMap中，Node则是实现了Map的Entity接口。</p><p>而有过Web开发经验的同学们应该就非常清楚了吧，Entity就是和数据库表中字段一一对应的实体类，也就是专门用来封装数据的对象的通用名称。来看看他的解释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">A map <span class="title">entry</span> <span class="params">(key-value pair)</span></span></span><br></pre></td></tr></table></figure><p>注释第一句话都写成这样了，大家应该熟悉得不能再熟悉了吧。对，Node在HashMap中就是一对键值对。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 一开始定义了Node数组和Node变量</span></span><br><span class="line">  <span class="comment">// 需要注意的是，Node是自定义的结构体，不进行任何初始化的情况时默认为null</span></span><br><span class="line">  Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">  <span class="comment">// table是HashMap类定义之初就声明的Node数组，以transient关键字声明的变量不参与序列化过程</span></span><br><span class="line">  <span class="comment">// 将table中的值全部放到tab中，如果为空，那么就调用resize方法，将数组扩容。</span></span><br><span class="line">  <span class="comment">// 如果数组不为0，容量扩大两倍；如果为0，按照默认大小配置。这里是为0的情况，数组将以默认值进行初始化</span></span><br><span class="line">  <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">    n = (tab = resize()).length;</span><br><span class="line">  <span class="comment">// 这里使用了单个“&amp;”符号，表示两边同时满足，即i在已经获取hash值之后成为n-1</span></span><br><span class="line">  <span class="comment">// 如果这个Node节点为空，新建节点</span></span><br><span class="line">  <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">    tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">  <span class="comment">// 如果这里已经有节点占着了</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e; K k;</span><br><span class="line">    <span class="comment">// 你可能会怀疑这里的p会不会是空的</span></span><br><span class="line">    <span class="comment">// 实际上，前面p = tab[i = (n - 1) &amp; hash]的时候，这里p被强行赋值了</span></span><br><span class="line">    <span class="comment">// 所以p所指向的是当前插入节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这段有点长，我们静下心来好好分析：这些条件是：</span></span><br><span class="line">    <span class="comment">// 1、如果当前节点p的哈希值和传入哈希值（就是要插入元素的哈希值）相等</span></span><br><span class="line">    <span class="comment">// 2.1、k暂存当前节点的key值，如果当前节点的key值和传入key值相等</span></span><br><span class="line">    <span class="comment">// 2.2、如果传入key值不为空，而且key值与当前节点key值相同</span></span><br><span class="line">    <span class="comment">// 首先，2.1和2.2先判断，两者中只要有一个为真，2就为真</span></span><br><span class="line">    <span class="comment">// 其次判断1是否为真。好了，我们分析一下这么做是为什么。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、hash可以定位一组元素。hash仅用于快速定位，在数据处理中没有实际意义。</span></span><br><span class="line">    <span class="comment">// 2、hash + key可以精确定位一个元素</span></span><br><span class="line">    <span class="comment">// 重复的key无法给出唯一的value值</span></span><br><span class="line">    <span class="comment">// 所以一旦检测到有重复的key，就用新插入的value替换原有的value</span></span><br><span class="line">    <span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">      e = p; <span class="comment">// 这里只是暂存原有节点p，否则会被替换</span></span><br><span class="line">    <span class="comment">// 如果p是TreeNode类型，则加到树中。</span></span><br><span class="line">    <span class="comment">// 文章开头我们说了，8个节点以上的话将会转变成红黑树，所以当他成为树的时候，调用树的方法就好了。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">      e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 最后，既没有重复的key、也没有转变为树，即节点数小于8且无重复键</span></span><br><span class="line">      <span class="comment">// 就很平常的使用循环寻找链表尾节点</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">        <span class="comment">// 到头了</span></span><br><span class="line">        <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 插入</span></span><br><span class="line">          p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">          <span class="comment">// 但是如果你插入这个节点就到8了</span></span><br><span class="line">          <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">            <span class="comment">// 转变成红黑树</span></span><br><span class="line">            treeifyBin(tab, hash);</span><br><span class="line">          由于循环也不知道写什么条件，就干脆自己控制跳出循环好了</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先前我们看到，e是暂存了p，也就是当前节点</span></span><br><span class="line">        <span class="comment">// 1、暂存节点的hash值和插入hash值相等</span></span><br><span class="line">        <span class="comment">// 2.1、k最后变回暂存节点的key，并且判断是否和插入的key相同</span></span><br><span class="line">        <span class="comment">// 2.2、key不为空且key和k相同</span></span><br><span class="line">        <span class="comment">// 也就是说，如果键值重复了，将会直接结束</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// p还原</span></span><br><span class="line">        p = e;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后，如果暂存的e节点存在</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">      V oldValue = e.value;</span><br><span class="line">      <span class="comment">// 缺省情况下不生效 或者 旧值为空，则将暂存的e节点的value变为新的value</span></span><br><span class="line">      <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">        e.value = value;</span><br><span class="line">      afterNodeAccess(e);<span class="comment">// 这个实际上是空函数</span></span><br><span class="line">      <span class="comment">// 最后返回旧值</span></span><br><span class="line">      <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ++modCount;</span><br><span class="line">  <span class="comment">// 如果容量不够了，两倍扩容</span></span><br><span class="line">  <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">    resize();</span><br><span class="line">  afterNodeInsertion(evict);<span class="comment">// 这个实际上是空函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，不能保持原有数据的原因是：HashMap会变成<strong>红黑树</strong>，然后整个结构就<strong>转起来</strong>了，原来的链表将会被拉成树，原来的树将会被重构，再回过头来看的时候原来的顺序已经被转得不像样子了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本文将分为两个部分，一个是HashMap原理讲解，一个是HashMap面试常考。当然，这里没有实战内容，全都是生涩的理论知识，比较枯燥而且难懂。但是这可是非常重要的必考部分呢。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://www.sakebow.cn/categories/java/"/>
    
    
      <category term="面试" scheme="http://www.sakebow.cn/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>spring-boot的Web开发简介</title>
    <link href="http://www.sakebow.cn/2020/02/23/spring-boot/spring-boot-Web%E5%BC%80%E5%8F%91%E7%AE%80%E4%BB%8B/"/>
    <id>http://www.sakebow.cn/2020/02/23/spring-boot/spring-boot-Web%E5%BC%80%E5%8F%91%E7%AE%80%E4%BB%8B/</id>
    <published>2020-02-23T08:56:00.000Z</published>
    <updated>2020-03-02T12:38:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>这里将会简单介绍一下SpringBoot在Web开发中的实战部分，将会是从零开始创建的儿童学步教程，从打开IDEA开始的傻瓜式教学</strong>。（其实这个是博主创建项目的笔记，所以会从什么都没有开始）</p><a id="more"></a><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>这一部分就参照我之前的教程就好了，非常方便的。<a href="/2020/02/15/spring-boot/spring-boot-preparation/">点击这里跳转</a>。</p><h2 id="编写并启用第一个接口"><a href="#编写并启用第一个接口" class="headerlink" title="编写并启用第一个接口"></a>编写并启用第一个接口</h2><p>想必Hello World大家已经熟悉的不能再熟悉了。但是作为小白接触的第一个接口还是非常简便的，不需要考虑什么花里胡哨的，能看到成功的结果就行了不是吗？好嘛，开始吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 很普通的在java文件夹下创建cn.sakebow.study.boot.controller.HelloController类</span></span><br><span class="line"><span class="comment">// cn.sakebow.study.boot是博主为了和自己购买的域名保持一致</span></span><br><span class="line"><span class="comment">// controller.HelloController大家应该是一样的</span></span><br><span class="line"><span class="meta">@RestController</span> <span class="comment">// 标识控制层接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>) <span class="comment">// 标识这个部分是Get请求的接口，需要在网址栏中使用/hello访问</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123; <span class="comment">// 这个是接口本体</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello world!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>就这样就结束了。</strong></p><p>如果你有SSM基础，你会发现在这之前，你需要新建<code>spring-config.xml</code>文件，或者说是你们所熟知的applicationContext.xml文件。</p><p>个人比较喜欢用spring-config这个名称，因为看着就知道是spring的配置文件，不是springMVC的，也不是mybatis的。</p><p>在SSM中，你需要在里面<strong>手动</strong>添加一大堆乱七八糟的配置。没错，这么多<strong>除了第一行全部都是手打的</strong>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- spring-config.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/tx/spring-tx.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 读取db.properties --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:db.properties"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 事务管理器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSourceTransactionManager"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 开启事务注解 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:annotation-driven</span></span></span><br><span class="line"><span class="tag">            <span class="attr">transaction-manager</span>=<span class="string">"dataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:annotation-driven</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- mybatis工厂配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactoryBean"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"classpath:mybatis-config.xml"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- mapper扫描器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"com.sakebow.study.ssm.dao"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- service扫描器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span></span></span><br><span class="line"><span class="tag">            <span class="attr">base-package</span>=<span class="string">"com.sakebow.study.ssm.service"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.sakebow.study.ssm.service.impl"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>你以为这就结束了？不！还有springMVC！一样的，<strong>除了第一行全部手打</strong>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- springmvc-config.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/mvc/spring-mvc.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 加载注解驱动 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置包扫描器，即扫描所有的Controller注解 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.sakebow.study.ssm.controller"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 处理静态资源 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">"/js/**"</span> <span class="attr">location</span>=<span class="string">"/js/"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">"/css/**"</span> <span class="attr">location</span>=<span class="string">"/css/"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">"/images/**"</span> <span class="attr">location</span>=<span class="string">"/images/"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">"/bootstrap/**"</span> <span class="attr">location</span>=<span class="string">"/bootstrap/"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置视图解析器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span></span></span><br><span class="line"><span class="tag">            <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/jsp/"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>你觉得你可以了，还没完！你<strong>还有tomcat没配</strong>！</p><p>当你狠下心配好了之后，你的电脑排风扇开始疯转，笔记本电脑键盘开始发烫。等了好久，终于，浏览器自己出来了，然后页面上一个“Hello World！”。你如释重负地笑了笑，然后把手边的保温杯摔在地上：“淦！”</p><p>然而，在SpringBoot中，你<strong>什么都不用配置</strong>。以上xml配置文件全部不需要。这谁还用SSM啊！而且，SpringBoot的速度明显快一点。</p><p>好了，接下来我们直接开始运行。在IDEA中，直接点击右上角绿色播放按钮，然后等控制台输出了<code>Started BootApplication in 2.884 seconds (JVM running for 4.813)</code>类似的字样后，打开浏览器，访问localhost:8080/hello，于是你看到了“Hello World！”</p><p><img src="http://47.111.252.78/images/spring-boot-web/helloworld.png" alt="Hello World！"></p><p>虽然SpringBoot需要手动打开浏览器，但是比起自动打开浏览器的SSM，各种各样的配置真的受不住。</p><h2 id="导入静态资源"><a href="#导入静态资源" class="headerlink" title="导入静态资源"></a>导入静态资源</h2><p>以前SSM我们将所有的资源放在<code>/WEB-INF/</code>下面，里面的文件也是随意乱放，心情好整理一下，心情不好一锅端，也没什么特别的规则。</p><p>而现在，SpringBoot将一切都设置好了，并给了我们两个分好类的文件夹：<code>static</code>和<code>templates</code>，光是从单词意思就知道，一个放图片、视频之类的静态资源，一个放模板资源。</p><blockquote><p>在这里插播一个有关<strong>Nginx</strong>的小板块：</p><p>由于tomcat比较吃内存，所以Tomcat在处理静态资源的时候往往会有点吃力。而Nginx在处理静态资源的时候完全不消耗内存，所以作为静态资源服务器有着较大的优势。</p><p>博主建议，使用Nginx部署，也就是所有的部分全部经过Nginx，但是只有特定后缀名的文件才由Nginx处理，例如JPG、JPEG、JIFF等等，其他的全部直接通过Nginx到Tomcat。</p><p>这将会在后面的博客中有所体现。</p></blockquote><p>至于静态资源放在服务器中的哪里呢？这个我们要看看源码。（👉🔪🌶👴👄❤の⚪🐎环节）</p><p>之前讲过，<strong>Properties</strong>和<strong>AutoConfiguration</strong>两个文件，前者负责数据配置，后者负责自动装配。所以查看源码的时候一定要两者并用。</p><p>在WebMvcAutoConfiguration中，这个类你可以在External Library中找到，具体如下图：</p><img src="http://47.111.252.78/images/spring-boot-web/关于静态资源的问题.png" alt="通过源码分析静态资源的存放位置" style="zoom:70%;" /><p>在<code>WebMvcProperties</code>中里面有个字段是<code>staticPathPattern</code>。立马就想到，根据yaml的松散绑定原则，一定有一个字段是<code>spring.mvc.static-path-pattern</code>，在自己定义的application.yaml中重新定义就可以覆盖默认值了。</p><p>另外，由于我们规定方法名要见名知意，所以去<code>WebMvcAutoConfiguration</code>中按照“静态资源”这个意思去找，发现了<code>addResourceHandlers</code>这个方法。为了便于理解，我把源码搬过来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果没找到这个属性，则无法使用默认值</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.resourceProperties.isAddMappings()) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Default resource handling disabled"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Duration cachePeriod = <span class="keyword">this</span>.resourceProperties.getCache().getPeriod();</span><br><span class="line">        CacheControl cacheControl = <span class="keyword">this</span>.resourceProperties.getCache().getCachecontrol().toHttpCacheControl();</span><br><span class="line">        <span class="comment">// 以下就是导入静态资源的核心</span></span><br><span class="line">        <span class="keyword">if</span> (!registry.hasMappingForPattern(<span class="string">"/webjars/**"</span>)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.customizeResourceHandlerRegistration(registry.addResourceHandler(<span class="keyword">new</span> String[]&#123;<span class="string">"/webjars/**"</span>&#125;).addResourceLocations(<span class="keyword">new</span> String[]&#123;<span class="string">"classpath:/META-INF/resources/webjars/"</span>&#125;).setCachePeriod(<span class="keyword">this</span>.getSeconds(cachePeriod)).setCacheControl(cacheControl));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 静态资源的位置</span></span><br><span class="line">        String staticPathPattern = <span class="keyword">this</span>.mvcProperties.getStaticPathPattern();</span><br><span class="line">        <span class="keyword">if</span> (!registry.hasMappingForPattern(staticPathPattern)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.customizeResourceHandlerRegistration(registry.addResourceHandler(<span class="keyword">new</span> String[]&#123;staticPathPattern&#125;).addResourceLocations(WebMvcAutoConfiguration.getResourceLocations(<span class="keyword">this</span>.resourceProperties.getStaticLocations())).setCachePeriod(<span class="keyword">this</span>.getSeconds(cachePeriod)).setCacheControl(cacheControl));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据注释，相信你也猜到一些什么东西了。没错，<strong>resources文件夹下的webjars文件夹</strong>就是我们要放静态资源的位置。</p><p>但什么是webjars？我们去搜一搜：</p><p><img src="http://47.111.252.78/images/spring-boot-web/webjars%E6%90%9C%E7%B4%A2%E7%BB%93%E6%9E%9C.png" alt="webjars搜索结果"></p><p><strong>你发现了一个网站</strong>，并打开了它：</p><p><img src="http://47.111.252.78/images/spring-boot-web/webjars%E7%BD%91%E7%AB%99%E4%BD%9C%E7%94%A8.png" alt="webjars网站的作用"></p><p>然后恍然大悟，这玩意就是将所有能用到的静态资源全部都整合了个遍，还设置了很多不同的导入方式。于是博主将用的最欢的vue加进了根目录下的pom文件中。当然有SSM基础的同学估计想都没想就往里面塞了。</p><p>让我们去External Library中看看导入成功了没：</p><img src="http://47.111.252.78/images/spring-boot-web/导入结果.png" alt="导入结果" style="zoom:70%;" /><p>好家伙，一个没少！就是用jar包的形式将vue完全封装了一遍！在这里不得不佩服框架开发者的奇思妙想。但是我又遇到了另一个问题：ElementUI作为和Vue配套的UI组件，好像查不到欸……没有关系！博主在<strong><a href="https://mvnrepository.com/artifact/org.webjars.npm/element-u" target="_blank" rel="noopener">Maven</a></strong>中又找到了他。于是将依赖贴进去，也成了。</p><p>如果你想看到实实在在的代码，我们直接使用域名+/webjars/+对应路径。就拿上面的Vue来说，应该是<code>localhost:8080/webjars/vue/2.6.11/vue.js</code></p><p><img src="http://47.111.252.78/images/spring-boot-web/%E8%AE%BF%E9%97%AE%E6%88%90%E5%8A%9F.png" alt="成功访问到了vuejs的代码"></p><p><strong>当然这只是第一种方式</strong>。另外还有四种方法，分别是：</p><ul><li>resources文件夹下的<code>所有文件（或者文件夹）</code></li><li>resources文件夹下的<code>public</code>文件夹</li><li>resources文件夹下的<code>static</code>文件夹</li><li>resources文件夹下的<code>resources</code>文件夹（<del>禁止套娃</del>）</li></ul><p>同样的，这些选项之间还是有特定的启动顺序的。</p><p>其中resources文件夹下的resources文件夹中的资源优先级最高，然后才是static，最后是public。</p><p>所以我们只在public中放一些公共的资源，即公交车；而static中放一些静态资源，比如图片；最后resources放一些客户端上传的文件。</p><p>如果你自己定义了新的资源文件夹，那么以上内容<strong>全部失效</strong>。你敢不敢动嘛。</p><p>和webjars导入不同，在resources文件夹下的所有文件夹中都只需要使用IP或者域名访问就够了。</p><p>例如，如果我再resources文件夹下的resources文件夹中放了一个表情包，我就只需要<code>localhost:8080/表情包.jpg</code>就可以了。</p><h2 id="首页"><a href="#首页" class="headerlink" title="首页"></a>首页</h2><p>当然，这玩意怎么配置也是在源码中才可以明白的。同样是<code>WebMvcAutoConfiguration</code>类中，找到<code>getWelcomePage</code>、<code>getIndexHtml</code>、<code>WelcomePageHandlerMapping</code>这三个连在一起的方法。</p><p>他们分别提供了三个布置首页的地方，首先就是<code>resources</code>文件夹下除去<code>templates</code>文件夹的任意位置都可以，这样我们直接进去就是首页。于是，我们把首页放在<code>static</code>文件夹下，然后访问<code>localhost:8080</code>，OK，直接就是首页。</p><p>除了首页，我们还有网页标签<code>icon</code>也可以自定义设置，在之前的版本里只需要把图片命名为<code>favicon.ico</code>，并放在resources文件夹下的<code>public</code>、<code>static</code>、<code>resources</code>三个文件夹中的任意一个里面，最后还要禁用系统默认图标，即在yaml配置文件中添加：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mvc:</span></span><br><span class="line">    <span class="attr">favicon:</span></span><br><span class="line">      <span class="attr">enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>以上是旧版本对网页图标的控制，但是最新版本似乎将这个功能删除了。</p><p>但是怎么跳转跳转到首页？当然你可以使用a标签，但是我们为了搞事，考虑在后台写一个Controller如何？</p><p>于是首页被放到了<code>templates</code>文件夹下。可是这么一放我的首页就不能通过输入网址（也可以笼统地叫做<strong>GET请求</strong>）直接访问了。他们<strong>只能通过Controller编辑路由才可以访问，而且需要模板引擎的支持</strong>。</p><p>emmmmmm好吧！那就用吧！</p><h2 id="模板引擎"><a href="#模板引擎" class="headerlink" title="*模板引擎"></a>*模板引擎</h2><p>实际上可用的模板引擎有非常多种。博主学的教程中是<strong>thymeleaf</strong>，又有弹幕说thymeleaf很垃圾，我就试试使用实际开发中使用次数最多的，也就是<strong>freemaker</strong>。</p><p>什么是模板引擎？粗略地解释大概就是一个网页，中间的数据选择性地挖掉，等待后台动态填充。具体要挖掉哪些就得看你的业务了。</p><p>这里引用<a href="https://freemarker.apache.org/" target="_blank" rel="noopener">官方网站</a>中的图片进行说明：</p><p><img src="https://freemarker.apache.org/images/overview.png" alt="官方图片"></p><p>FreeMaker原本是用于MVC框架下的前后端分离的，所以实际上就算没有后台FreeMaker也能整起来。</p><p>首先我们注入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 将这段放在pom的dependencies标签中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-freemarker<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在application.properties中添加如下配置（你也可以用yaml文件）</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## Freemarker 配置</span></span><br><span class="line"><span class="comment">##模版存放路径（默认为 classpath:/templates/）</span></span><br><span class="line"><span class="meta">spring.freemarker.template-loader-path</span>=<span class="string">classpath:/templates/</span></span><br><span class="line"><span class="comment">##是否生成缓存，生成环境建议开启（默认为true）</span></span><br><span class="line"><span class="meta">spring.freemarker.cache</span>=<span class="string">false</span></span><br><span class="line"><span class="comment">##编码</span></span><br><span class="line"><span class="meta">spring.freemarker.charset</span>=<span class="string">UTF-8</span></span><br><span class="line"><span class="meta">spring.freemarker.check-template-location</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">##content-type类型(默认为test/html)</span></span><br><span class="line"><span class="meta">spring.freemarker.content-type</span>=<span class="string">text/html</span></span><br><span class="line"><span class="comment">## 设定所有request的属性在merge到模板的时候，是否要都添加到model中（默认为false）</span></span><br><span class="line"><span class="meta">spring.freemarker.expose-request-attributes</span>=<span class="string">false</span></span><br><span class="line"><span class="comment">##设定所有HttpSession的属性在merge到模板的时候，是否要都添加到model中.(默认为false)</span></span><br><span class="line"><span class="meta">spring.freemarker.expose-session-attributes</span>=<span class="string">false</span></span><br><span class="line"><span class="comment">##RequestContext属性的名称（默认为-）</span></span><br><span class="line"><span class="meta">spring.freemarker.request-context-attribute</span>=<span class="string">request</span></span><br><span class="line"><span class="comment">##模板后缀(默认为.ftl)</span></span><br><span class="line"><span class="meta">spring.freemarker.suffix</span>=<span class="string">.html</span></span><br></pre></td></tr></table></figure><p>接着我们在根目录下的<code>resources</code>文件夹中的<code>templates</code>文件夹下添加<code>index.html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 除了这句p标签是自己写的，其他的都是自动生成的 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello, $&#123;name&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后，我们去Controller编写跳转方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标记这个是一个控制器</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 标记只能用GET请求到的方法，而且需要用</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里的参数必须和页面名称相对应，是index页面就传入index</span></span><br><span class="line">        ModelAndView modelAndView=<span class="keyword">new</span> ModelAndView(<span class="string">"/index"</span>);</span><br><span class="line">        modelAndView.addObject(<span class="string">"name"</span>,<span class="string">"sakebow"</span>);</span><br><span class="line">        <span class="keyword">return</span> modelAndView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，点击运行，出现成功字样后访问<code>localhost:8080/hello</code>，就成功了！</p><p><img src="http://47.111.252.78/images/spring-boot-web/%E6%A8%A1%E6%9D%BF%E6%88%90%E5%8A%9F%E8%BF%90%E7%94%A8.png" alt="成功引用模板"></p><p>这样的骚操作在<strong>错误处理</strong>方面很不错，不是吗？但是想一想，为什么人家官方要配Thymeleaf而不是FreeMaker呢？我们先复习一下：</p><blockquote><p>用户在浏览器的操作由DispatcherServlet拦截，并转发到Controller。由于Controller是调用了Service的方法，所以数据先以参数的形式传入Service，然后方法结束后将处理过的数据返回到Controller。紧接着Controller将这些数据封装到ModelAndView中，再发送到视图解析器。最后返回到浏览器展示给用户之前，还会被DispatcherServlet拦截处理。</p></blockquote><p>没错！DispatcherServlet会拦截检测所有的ViewResolver。同样的，我们也在官网中找到这样一句话：</p><blockquote><p>Spring默认的自动装配顺序是ContentNegotiatingViewResolver &gt; BeanNameViewResolver &gt; ThymeleafViewResolver &gt; 自定义的ViewResolver</p></blockquote><p>所以你知道为啥官方推荐Thymeleaf了吧？</p><p>但是呢，模板毕竟是靠后台渲染的，所以耦合度还是非常的高，甚至还不如SSM的<code>M-&gt;V-&gt;C</code>编辑模式，一步一步走向巅峰。所以，这里就只介绍这么多。<strong>模板已经没有存在的必要了</strong>，只是新手学一下、测试时用一下而已，不要过分依赖。</p><h2 id="对于前后端分离"><a href="#对于前后端分离" class="headerlink" title="对于前后端分离"></a>对于前后端分离</h2><p>前后端分离并不是一件容易事。因为你需要经过深思熟虑并将所有的页面拆成很小的单元，然后让数据在者之间游走。这是非常了不得的事情，对于专职后台的博主来说工作量实在太大了。以后有机会的话一定会好好学习。</p><p>其实最难的并不是vue本身，Vue本身其实没有什么难点。最难的是将所有的页面组件化，细分为一个又一个单元，这不是一个大学生能做到的事情。</p><p>如果有机会还是希望可以和其他人一起合作积攒经验。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;这里将会简单介绍一下SpringBoot在Web开发中的实战部分，将会是从零开始创建的儿童学步教程，从打开IDEA开始的傻瓜式教学&lt;/strong&gt;。（其实这个是博主创建项目的笔记，所以会从什么都没有开始）&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://www.sakebow.cn/categories/java/"/>
    
    
      <category term="spring boot" scheme="http://www.sakebow.cn/tags/spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>spring-boot自动配置原理分析</title>
    <link href="http://www.sakebow.cn/2020/02/22/spring%E5%B0%8F%E6%8A%80%E5%B7%A7/autowired/"/>
    <id>http://www.sakebow.cn/2020/02/22/spring%E5%B0%8F%E6%8A%80%E5%B7%A7/autowired/</id>
    <published>2020-02-22T10:41:00.000Z</published>
    <updated>2020-02-22T10:53:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>大家应该都知道Autowired是自动装配的注解，但是自动装配也是有非常实用的小技巧的。如果不按照一定的规则进行注解，很有可能会获得一个空值，然后抛出NullPointerException异常，还请多加注意。</strong></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;大家应该都知道Autowired是自动装配的注解，但是自动装配也是有非常实用的小技巧的。如果不按照一定的规则进行注解，很有可能会获得一个空值，然后抛出NullPointerException异常，还请多加注意。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://www.sakebow.cn/categories/java/"/>
    
    
      <category term="spring boot" scheme="http://www.sakebow.cn/tags/spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>spring-boot配置</title>
    <link href="http://www.sakebow.cn/2020/02/22/spring-boot/spring-boot-%E9%85%8D%E7%BD%AE/"/>
    <id>http://www.sakebow.cn/2020/02/22/spring-boot/spring-boot-%E9%85%8D%E7%BD%AE/</id>
    <published>2020-02-22T09:31:00.000Z</published>
    <updated>2020-02-24T12:58:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>官方文档在配置上写了一大堆的配置文件，在这里就筛选出常用的部分，选择最重要的讲解并浅析原理。</strong></p><a id="more"></a><h2 id="入门：yaml全局配置文件简介"><a href="#入门：yaml全局配置文件简介" class="headerlink" title="入门：yaml全局配置文件简介"></a>入门：yaml全局配置文件简介</h2><p>全局配置文件要求名称为<code>application</code>，后缀名可以是properties或者是yaml（yml）。可以同时存在，只不过系统会按照自己的优先级进行选择。</p><p>相比于properties，<strong>yaml</strong>的优势在于可以配置对象。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">student:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">sakebow</span></span><br><span class="line">  <span class="attr">description:</span> <span class="string">wastrel</span></span><br><span class="line">  <span class="attr">likes:</span> <span class="string">[football,</span> <span class="string">beef,</span> <span class="string">manga]</span></span><br></pre></td></tr></table></figure><p>而<strong>properties</strong>只能这样使用：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">student.name</span>=<span class="string">sakebow</span></span><br><span class="line"><span class="meta">student.description</span>=<span class="string">wastrel</span></span><br><span class="line"><span class="comment"># 不能写数组</span></span><br></pre></td></tr></table></figure><p><strong>xml</strong>则更为累赘：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">student</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>sakebow<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>wastrel<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">likes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">like</span>&gt;</span>football<span class="tag">&lt;/<span class="name">like</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">like</span>&gt;</span>beef<span class="tag">&lt;/<span class="name">like</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">like</span>&gt;</span>manga<span class="tag">&lt;/<span class="name">like</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">likes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br></pre></td></tr></table></figure><p>虽然很多编译器在写出上半个标签的时候能自动填充下半个，但依然觉得大量的标签实在是让人喘不过气。</p><p>实际上，在<strong>Java类</strong>中也能使用注解进行赋值，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">  <span class="meta">@Value</span>(<span class="string">"student"</span>)</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="meta">@Value</span>(<span class="string">"wastrel"</span>)</span><br><span class="line">  <span class="keyword">private</span> String description;</span><br><span class="line">  <span class="comment">// 只能另外使用文件编写固定的值，或者在构造函数中赋初值</span></span><br><span class="line">  <span class="keyword">private</span> ArrayList&lt;String&gt; likes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是yaml从这三者中脱颖而出的，其实是因为yaml可以直接注入到配置类中，就像是将JSON注入js脚本一样轻松！</p><p>就只是稍微在<strong>Java类</strong>例子的基础上略微改一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"student"</span>)</span><br><span class="line"><span class="comment">// 假设根目录的resources文件夹下有一个application.yml文件，其中有student对象</span></span><br><span class="line"><span class="comment">// 可以通过ConfigurationProperties设置产生提示，如果不配置，会有错误提示，却不影响程序运行</span></span><br><span class="line"><span class="comment">// 如果想处理，会提示需要添加依赖：spring-boot-configuration-processor</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> String description;</span><br><span class="line">  <span class="keyword">private</span> ArrayList&lt;String&gt; likes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相应的，如果是properties注入，依然要使用<code>@Value(${properties文件中对应的变量名})</code>注解，反而更加累赘了。</p><p>不仅如此，yaml还可以使用<strong>随机值</strong>：<code>${random.int}</code>直接产生随机数</p><p>而且还可以使用选择表达式：<code>${student.name : &quot;sakebow&quot;}</code>，即如果找到了<code>student.name</code>变量，则作为值返回，否则返回”sakebow”。</p><h2 id="初级：yaml松散绑定"><a href="#初级：yaml松散绑定" class="headerlink" title="初级：yaml松散绑定"></a>初级：yaml松散绑定</h2><p>松散绑定其实就是说<strong>模糊匹配</strong>。举个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"student"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String nickName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而yaml文件中是这样的：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">student:</span></span><br><span class="line">  <span class="attr">nick-name:</span> <span class="string">sakebow</span></span><br></pre></td></tr></table></figure><p>依然能够成功绑定。</p><h2 id="中级：JSR303校验"><a href="#中级：JSR303校验" class="headerlink" title="中级：JSR303校验"></a>中级：JSR303校验</h2><p>类似前端中的<code>input</code>标签中，会对框内内容进行校验，如果类型不对将会抛出异常。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"student"</span>)</span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">teacher</span></span>&#123;</span><br><span class="line">    <span class="comment">// 姓名不为空，并将默认错误提示修改为“姓名属性不可以为空”</span></span><br><span class="line">    <span class="meta">@NotNull</span>(message = <span class="string">"姓名属性不可以为空"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 电话号码长度在5到13之间（虽然有点粗暴，但这样比较好解释）</span></span><br><span class="line">    <span class="meta">@Size</span>(min = <span class="number">5</span>, max = <span class="number">13</span>)</span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="comment">// 验证电子邮箱是否正确</span></span><br><span class="line">    <span class="meta">@Email</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="comment">// 年龄范围在0到120之间（可能以后120的老爷爷还在看B站？）</span></span><br><span class="line">    <span class="meta">@Range</span>(min = <span class="number">0</span>, max = <span class="number">120</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有非常多的验证，全部在<strong>spring-context</strong>的包内，只是我们在SSM中从未使用过。</p><h2 id="高级：多文件配置"><a href="#高级：多文件配置" class="headerlink" title="高级：多文件配置"></a>高级：多文件配置</h2><p>虽然配置文件名<strong>只能是application</strong>，但是<strong>可以有很多</strong>的配置文件，只要位置不一样就可以了。就像是你房里的很多个同样的容器里面分别装了可乐、雪碧、美年达等多种完全不同的饮料一样。</p><p>在官网中，这些文件可以在：</p><ul><li>根部录下的config文件夹（手动创建）内</li><li>项目根目录下</li><li>resources文件夹下，即classpath:/config/application.yaml</li><li>resource文件夹下的config文件夹（手动创建）内，即classpath:/application.yaml</li></ul><p>虽然说都存在也可以，但是系统也是有优先级排序的。</p><ul><li>项目根目录下的config文件夹中配置文件的优先级是最高的</li><li>其次是项目根目录下的配置文件</li><li>再就是resources文件夹下的config文件夹中的配置文件</li><li>最后才是resources文件夹下的配置文件（也就是系统默认）</li></ul><p>这样安排就可以方便用户覆盖系统配置。</p><p>另外，项目常常有测试环境和生产环境，为了方便用户能够自如地在这两个环境中切换，我们可以在主配置文件中需要这么声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">server: # 主环境</span><br><span class="line">  port: 8081</span><br><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active: dev&#x2F;test&#x2F;null</span><br><span class="line">---</span><br><span class="line">server: # 生产环境</span><br><span class="line">  port: 8082</span><br><span class="line">spring:</span><br><span class="line">  profiles: dev</span><br><span class="line">---</span><br><span class="line">server: # 测试环境</span><br><span class="line">  port: 8083</span><br><span class="line">spring:</span><br><span class="line">  profiles: test</span><br></pre></td></tr></table></figure><p>默认是主环境，其中spring.profiles.active属性可以选择使用什么环境。如果你使用properties配置的话，每种环境都需要新建一份properties配置文件，非常的繁琐，虽然点号连接起来的变量看起来更好看而已。</p><h2 id="附：yaml文件配置不完全详解"><a href="#附：yaml文件配置不完全详解" class="headerlink" title="附：yaml文件配置不完全详解"></a>附：yaml文件配置不完全详解</h2><h3 id="源码对应"><a href="#源码对应" class="headerlink" title="源码对应"></a>源码对应</h3><p>对于每一种配置类，都有一份默认的配置文件，初始化这个类的各种属性。比如HttpEncodingAutoConfiguration类，其中的encoding属性是有默认值<code>UTF-8</code>的。如果你觉得<code>GBK</code>会更好，就在自己创建的yaml配置文件中写下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">    <span class="attr">encoding:</span></span><br><span class="line">      <span class="attr">charset:</span> <span class="string">GBK-2312</span></span><br></pre></td></tr></table></figure><p>所以yaml能配什么，往往都可以在对应配置类的源码中找到所有的选项。<em>当然官网中也会标注出来</em>。如果你在开发中遇到了问题，但是查了半天依然不知所云的时候，可以使用ctrl+鼠标左键查看源码和注释，许多问题都能在源码内以AutoConfig、Properties结尾的类中找到答案，或者说，就在对应的yaml文件中。全部的配置都在spring-boot-autoconfiguration的包中，你能够在项目的External Library中找到，其中/META-INF/spring.factories中有大量的配置。你可能会因为那蚂蚁一样的字吓到，不过别担心，常用的也就那些；而且，我们的目的是实现需求，而不是框架测试。</p><h3 id="生效检测"><a href="#生效检测" class="headerlink" title="生效检测"></a>生效检测</h3><p>但是怎么才能知道配置能不能生效呢？加上这句就好了。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">debug:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>这样在控制台中就会显示出来了。生效的会在每个类名<strong>上一行</strong>显示<code>found</code> ，没有生效的会在每个类名<strong>上一行</strong>明确显示：<code>Did not match</code>，还有没有匹配条件的类，<strong>仅</strong>会使用<code>Unconditional</code>明确标注<strong>一次</strong>，并<strong>集中在一起显示</strong>。</p><h2 id="总结：面试问到你对springboot的理解"><a href="#总结：面试问到你对springboot的理解" class="headerlink" title="总结：面试问到你对springboot的理解"></a>总结：面试问到你对springboot的理解</h2><ul><li>SpringBoot再启动时回家再大量的自动配置类；</li><li>我们看需要的功能有没有在SpringBoot默认写好的自动配置类当中，也就是java文件中以AutoConfig结尾的类名；</li><li>我们再来看这个自动配置类中有哪些组件，也就是Java文件中以Properties结尾的类名。只要存在这些类，我们就不需要手动配置，也就从大量的java代码、xml配置中解脱出来；</li><li>给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们需要在配置文件中指定这些属性的值。当然，你可以直接修改源码中自带的yaml配置文件，也可以自定义yaml文件覆盖默认配置。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;官方文档在配置上写了一大堆的配置文件，在这里就筛选出常用的部分，选择最重要的讲解并浅析原理。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://www.sakebow.cn/categories/java/"/>
    
    
      <category term="spring boot" scheme="http://www.sakebow.cn/tags/spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>学习spring-boot框架前需要了解的知识</title>
    <link href="http://www.sakebow.cn/2020/02/15/spring-boot/spring-boot-preparation/"/>
    <id>http://www.sakebow.cn/2020/02/15/spring-boot/spring-boot-preparation/</id>
    <published>2020-02-15T04:28:00.000Z</published>
    <updated>2020-02-17T04:25:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>这里将准备开始介绍spring-boot框架。博主使用的教学视频是<a href="https://bilibili.com/av75233634" target="_blank" rel="noopener">B站上狂神的视频</a>。</strong><br><strong>在开始之前还是简单说一些基本知识，先把“是什么”填满，再把“为什么”解决。</strong></p><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://spring.io" target="_blank" rel="noopener">spring的官网</a>首页就是spring-boot。为什么不是spring本身而是spring-boot？</p><p>仔细想想，<strong>卖鞋厂怎么可能把鞋垫摆在门口啊</strong>……</p><p>这也即是说，spring-boot其实是spring、springmvc等等的封装再封装，比起原先的SSM框架封装得更为彻底。</p><p>到底有多彻底？</p><h2 id="初探"><a href="#初探" class="headerlink" title="初探"></a>初探</h2><p>首先我们去<a href="https://start.spring.io" target="_blank" rel="noopener">新手村</a>，这也是官方给出的新手教程。</p><p>看起来就像安装软件一样，勾选想要的，取消不用的。</p><p><img src="http://47.111.252.78/images/spring-boot-preparation/start.spring.io.png" alt="页面截图"></p><blockquote><p>说明一下：<br>这里使用的是谷歌截图插件<code>fireshot</code>，虽然可以截取整个页面但是不能截取position设置为fixed的元素。<br>实际上最下方还有这些按钮：<br><img src="http://47.111.252.78/images/spring-boot-preparation/fixed.png" alt="遗漏部分"></p></blockquote><p>这样，一个最基本的spring-boot框架就搭好了。<strong>当然你也可以在人人网中找到在这些资源，按照老板的要求打上补丁就好了。</strong></p><p>当然，这也只是一个方法。<strong>IDEA其实已经集成了这些</strong>。我们只需要在File-&gt;New-&gt;Project中找到<strong>Spring Initializr</strong>（确实是这么写的），一路下一步就好了。</p><p><img src="http://47.111.252.78/images/spring-boot-preparation/start.png" alt="下载框架"></p><p>然后，一个普通的spring-boot工程就建好了。你甚至可以直接运行，点击你非常熟悉的运行按钮，终端就会跳出一堆东西。</p><p><img src="http://47.111.252.78/images/spring-boot-preparation/console.png" alt="终端弹出信息"></p><blockquote><p>在这里提个醒：有些同学如果下载的是最新版的spring-boot框架，可能会提示tomcat版本不对，要求你升级。</p><p>其实这并不影响项目的运行，但是就像是看到应用市场提示你有新的APP可以升级是一样的，<strong>总觉得不爽</strong>。</p><p>于是呢，发现原因在于C:\Windows\System32文件夹下缺失了<code>tcnative-1.dll</code>或者说他的版本不对。</p><p>我们可以直接去<a href="http://archive.apache.org/dist/tomcat/tomcat-connectors/native/" target="_blank" rel="noopener">http://archive.apache.org/dist/tomcat/tomcat-connectors/native/</a>下载。</p><p>如果是Windows用户记得一定要选择对应版本号的binary，而不是source。下载解压后粘贴（如果已经有就要替换）。</p></blockquote><p>点击运行之后，IDEA并不会像以前的SSM框架一样把浏览器强行呼出。所以点击运行之后<strong>你再怎么等也是不会出来页面的</strong>。</p><p><strong>既然山不过来，我就到山那边去</strong>。打开浏览器输入<code>localhost:8080</code>，本以为会出现什么惊天地泣鬼神的极致丝滑页面，但现实却狠狠地给了你一巴掌。</p><p><img src="http://47.111.252.78/images/spring-boot-preparation/%E8%87%B4%E5%91%BD%E7%99%BD%E9%A1%B5.png" alt="致命白页"></p><p><strong>何か間違っているはずです！</strong></p><p><img src="http://47.111.252.78/images/emoji/%EF%BC%9F%EF%BC%9F%EF%BC%9F.jpg" alt="???"></p><p><strong>是我们自己想错了</strong>，<strong>而不是框架本身的错误</strong>。这里报白页完全是因为这个项目里面除了最基本的框架<strong>什么都没有</strong>。当然就会报错了。正如图片显示的，“No message available”。</p><p>到此为止，第一个项目就宣告结束了。是不是觉得排除了SSM框架中非常繁琐的手动配置框架之后，世界是不是清净了很多？当然这还没把spring-boot的理念展现的淋漓尽致。</p><p>之前在讲SSM框架的时候曾告诉过大家，要先明白框架是为了什么而诞生的。而spring-boot框架就是为了“微服务”的概念。</p><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><p>你说什么是“微服务”？</p><p>让我们按照下面的步骤进行操作试试：</p><p><img src="http://47.111.252.78/images/spring-boot-preparation/%E6%89%93%E6%88%90jar%E5%8C%85.png" alt="将项目打成jar包"></p><p>然后终端就输出了几行英文。大致意思就是下载各种各样的依赖，非常非常多的依赖，可以绕电脑屏幕几圈。最后，出现了这些字样：</p><p><img src="http://47.111.252.78/images/spring-boot-preparation/%E6%88%90%E5%8A%9F.png" alt="成功显示"></p><p>于是你在项目根目录下的target文件夹下出现了一个jar包（博主这里是叫做<code>boot-0.0.1-SNAPSHOT.jar</code>）。我们试着用命令行去执行它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar boot-<span class="number">0.0</span><span class="number">.1</span>-SNAPSHOT.jar</span><br></pre></td></tr></table></figure><p><img src="http://47.111.252.78/images/spring-boot-preparation/%E9%83%A8%E7%BD%B2.png" alt="部署成功"></p><p><strong>你发现它能够正常运行</strong>。</p><p>博主将这个jar包<strong>复制粘贴</strong>到服务器上，直接使用同样的命令运行，也能成功。不同的是，就算是别人的电脑也可以直接使用公网IP访问，真正做到了web项目的部署。</p><p>这就是微服务，部署非常方便，适合频繁发布版本。如果工程量比较小，部署只需要非常小的时间代价就可以完成，用户也不会等得着急火燎，去买杯咖啡回来立马就可以用了。</p><p>同时，我们也知道，SSM在部署的时候需要借助tomcat，结果比较不尽人意。原因有以下几点：</p><ul><li>tomcat<strong>允许的最大访问量本身有非常有限</strong>，能保持稳定链接的最大访问量只有<strong>250</strong><sup>[1]</sup>；</li><li>tomcat在部署的时候<strong>需要手动修改</strong>xml文件tomcat；</li><li><strong>不支持热部署</strong>。也就是说当我们需要修改某个地方的时候整个服务器就停掉然后开始重新加载，这个过程非常消耗时间和资源。</li></ul><h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><p>[1]Tomcat能够稳定支持的最大用户并发数.CSDN用户“她的博客”.<a href="https://blog.csdn.net/hll814/article/details/50935765" target="_blank" rel="noopener">https://blog.csdn.net/hll814/article/details/50935765</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;这里将准备开始介绍spring-boot框架。博主使用的教学视频是&lt;a href=&quot;https://bilibili.com/av75233634&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;B站上狂神的视频&lt;/a&gt;。&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;在开始之前还是简单说一些基本知识，先把“是什么”填满，再把“为什么”解决。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://www.sakebow.cn/categories/java/"/>
    
    
      <category term="spring boot" scheme="http://www.sakebow.cn/tags/spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>spring-boot框架启动流程</title>
    <link href="http://www.sakebow.cn/2020/02/15/spring-boot/spring-booot-%E6%A1%86%E6%9E%B6%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    <id>http://www.sakebow.cn/2020/02/15/spring-boot/spring-booot-%E6%A1%86%E6%9E%B6%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</id>
    <published>2020-02-15T04:22:00.000Z</published>
    <updated>2020-02-24T12:58:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>这里将会简单地将spring-boot框架在启动时地运作流程进行简单的梳理，将会涉及非常多意义不明的英文名词和许多不明所以的专业名词，学起来非常的生涩枯燥。如果只想学技术就跳过这一篇，如果想了解原理就坚持看下去。</strong></p><a id="more"></a><ul><li>@SpringBootApplication<ul><li>@SpringBootConfiguration<ul><li>@Configuration<ul><li>@Component</li></ul></li></ul></li><li>@EnableAutoConfiguration：自动导包<ul><li>@AutoConfiguration<ul><li>@Import(AutoConfigurationPackagesRegister.class)：自动注册包</li></ul></li><li>@Import(AutoConfigurationImportSelector.class)：自动导包的核心<ul><li>AutoConfigrationImportSelector<ul><li>getAutoConfigurationEntity：获得自动配置的实体</li><li>getCandidateConfigurations：获取候选的配置（被getAutoConfigurationEntity调用）<ul><li>getStringFactoriesLoaderFactoryClass：标注了EnableAutoConfiguration的注解类</li></ul></li><li>loadFactoryName：获取所有的加载配置</li><li>loadSpringFactories<ul><li>getResource：获取项目资源<ul><li>从“META-INF/spring.factories”中获取项目配置文件</li><li>spring-boot-autoconfiguration.jar &gt; META-INF &gt; spring.factories：所有的自动配置类全部在这里了<ul><li>核心注解@ConditionLoadOn<jar name>，如果这些内容全部满足，才会生效</li></ul></li></ul></li><li>getSystemResource：获取系统资源（获取位置同上）</li><li>从这些资源中遍历了所有的元素nextElement：查找可自动配置的元素，完成后转为Properties供我们使用</li></ul></li></ul></li></ul></li></ul></li><li>@ComponentScan：扫描当前启动类同级的包（扫描了去@Import(AutoConfigurationPackagesRegister.class)中注册）</li></ul></li></ul><p>于是：springboot所有的自动配置都是在启动的时候扫描并加载：<code>spring.factories</code>。所有的自动配置类都在这里，但不一定生效。要判断条件是否成立，即是否导入对应的start包，就有对应的启动器，就会使自动装配生效，然后配置成功。</p><ul><li>springboot在启动的时候，从类路径下<code>/META-INF/spring.factories</code>获取指定值</li><li>将这些自动配置的类导入容器，自动配置就会生效，帮我进行自动配置</li><li>以前我们需要自动配置的东西，springboot帮我们做了。</li><li>整合JavaEE、解决方案和自动配置等等的东西，全部整合在spring-boot-auotconfiguration包中</li><li>它会将所有需要导入的组件，以类名的方式返回，这些组件就会被添加到容器</li><li>容器中也会有非常多以AutoConfiguration结尾的文件，就是这些类给容器导入了这个场景所需要的所有组件，并自动配置，即@Configuration，或者是JavaConfig</li><li>有了自动配置，才会让我们从配置文件中解脱出来</li></ul><blockquote><p>注：一共有两种JavaConfig</p><ul><li>@Configuration：配置</li><li>@Bean：组件</li></ul></blockquote><p>启动时，运行了SpringApplication.run，看起来只是执行了主函数，其实他还自己开了一个服务。<br>他主要做了四件事：</p><ul><li>检测是普通项目还是web项目</li><li>查找并加载所有的可用初始化器，设置到initializers属性中</li><li>找出所有的应用程序监听器</li><li>推断并设置main方法的定义类</li></ul><p>常考面试题：<br>关于SpringBoot，谈谈你的理解：</p><ul><li>SpringBoot的自动装配</li><li>主函数中的run方法</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;这里将会简单地将spring-boot框架在启动时地运作流程进行简单的梳理，将会涉及非常多意义不明的英文名词和许多不明所以的专业名词，学起来非常的生涩枯燥。如果只想学技术就跳过这一篇，如果想了解原理就坚持看下去。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://www.sakebow.cn/categories/java/"/>
    
    
      <category term="spring boot" scheme="http://www.sakebow.cn/tags/spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存管理</title>
    <link href="http://www.sakebow.cn/2020/02/09/JVM/JVM-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://www.sakebow.cn/2020/02/09/JVM/JVM-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2020-02-09T13:48:00.000Z</published>
    <updated>2020-02-09T14:14:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>C或者C++在开发的时候需要手动分配内存，比如在Linux的一些平台开发中需要将IP地址放在指定的内存区域，并在合适的时候释放掉占用的内存块。而JVM不同，它完全自己控制，包括内存分配、垃圾回收等等。</strong></p><p><strong>但也正由于是自动化控制，所以往往在不同的环境下总会出现不尽人意的地方。为了避免这些不尽人意的地方，JVM内存管理也就成了Java工程师的必修课。</strong></p><a id="more"></a><h2 id="JVM的逻辑结构"><a href="#JVM的逻辑结构" class="headerlink" title="JVM的逻辑结构"></a>JVM的逻辑结构</h2><p>JVM分为几大板块：<strong>线程共享区</strong>、<strong>线程独占区</strong>、<strong>执行引擎</strong>、<strong>本地库接口</strong>、<strong>本地方法区</strong>。</p><p>这里引用现成的图片，这里是<a href="https://blog.csdn.net/qq_25940921/article/details/81263632" target="_blank" rel="noopener">原帖地址</a></p><p><img src="https://images2018.cnblogs.com/blog/937492/201807/937492-20180728171510397-1144464786.png" alt="JVM内存区域划分"></p><h3 id="线程共享区"><a href="#线程共享区" class="headerlink" title="线程共享区"></a>线程共享区</h3><ul><li>Java堆<ul><li>Java堆是被所有线程共享的一块内存区域，在JVM启动时创建，大小固定，<strong>但是可以根据一定的算法拓展</strong>。</li><li>但是拓展不是无限的，<strong>多线程情况下就会抛出OOM</strong>的异常。由于OOM是个大坑，所以移到了单独的版块。<a href="">点击此处查看OOM介绍</a>。</li></ul></li><li>方法区<h3 id="线程独占区"><a href="#线程独占区" class="headerlink" title="线程独占区"></a>线程独占区</h3></li><li>虚拟机栈</li><li>本地方法栈</li><li>程序计数器<h3 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h3><h3 id="本地库接口"><a href="#本地库接口" class="headerlink" title="本地库接口"></a>本地库接口</h3><h3 id="本地方法区"><a href="#本地方法区" class="headerlink" title="本地方法区"></a>本地方法区</h3></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;C或者C++在开发的时候需要手动分配内存，比如在Linux的一些平台开发中需要将IP地址放在指定的内存区域，并在合适的时候释放掉占用的内存块。而JVM不同，它完全自己控制，包括内存分配、垃圾回收等等。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但也正由于是自动化控制，所以往往在不同的环境下总会出现不尽人意的地方。为了避免这些不尽人意的地方，JVM内存管理也就成了Java工程师的必修课。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://www.sakebow.cn/categories/java/"/>
    
    
      <category term="JVM" scheme="http://www.sakebow.cn/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>jdk8的新特性</title>
    <link href="http://www.sakebow.cn/2020/02/09/JVM/What&#39;s-new-in-jdk8/"/>
    <id>http://www.sakebow.cn/2020/02/09/JVM/What&#39;s-new-in-jdk8/</id>
    <published>2020-02-09T09:15:00.000Z</published>
    <updated>2020-02-09T13:56:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>这里将会解释jdk8的一些新特性，比如lambda表达式、默认静态方法等等。由于jdk8是目前的主流，所以jdk8的新特性就比较重要。</strong></p><a id="more"></a><h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><p>lambda表达式允许程序员将一个函数作为参数，也就是<strong>函数式编程</strong>，这种写法可以将代码简化并比原来更紧凑。</p><p>原来定义一个接口的流程是：</p><h3 id="原方法"><a href="#原方法" class="headerlink" title="原方法"></a>原方法</h3><h4 id="定义接口（com-sakebow-dao）"><a href="#定义接口（com-sakebow-dao）" class="headerlink" title="定义接口（com.sakebow.dao）"></a>定义接口（com.sakebow.dao）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于接收用户操作的接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> userName（用户名），pwd（密码）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UsersOperation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">findUserByUserNameAndPassword</span><span class="params">(String userName, String pwd)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定义实例化的类（com-sakebow-dao-impl）"><a href="#定义实例化的类（com-sakebow-dao-impl）" class="headerlink" title="定义实例化的类（com.sakebow.dao.impl）"></a>定义实例化的类（com.sakebow.dao.impl）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Login接口的实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Login</span> <span class="keyword">implements</span> <span class="title">UsersOperation</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写input方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userName（用户名），pwd（密码）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findUserByUserNameAndPassword</span><span class="params">(String userName, String pwd)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"userName: "</span> + userName + <span class="string">"\t"</span> + <span class="string">"password: "</span> + pwd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试（com-sakebow-test）"><a href="#测试（com-sakebow-test）" class="headerlink" title="测试（com.sakebow.test）"></a>测试（com.sakebow.test）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用junit4进行测试，login实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLogin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Login login = <span class="keyword">new</span> Login();</span><br><span class="line">    login.findUserByUserNameAndPassword(<span class="string">"sakebow"</span>, <span class="string">"123456"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在只考虑dao包的情况下就需要同时修改3个包，如果加上service包就需要修改5个。</p><h3 id="新方法-lambda表达式"><a href="#新方法-lambda表达式" class="headerlink" title="新方法 - lambda表达式"></a>新方法 - lambda表达式</h3><h4 id="定义接口（没有变化，com-sakebow-dao）"><a href="#定义接口（没有变化，com-sakebow-dao）" class="headerlink" title="定义接口（没有变化，com.sakebow.dao）"></a>定义接口（没有变化，com.sakebow.dao）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于接收用户操作的接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> userName（用户名），pwd（密码）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">UsersOperation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">findUserByUserNameAndPassword</span><span class="params">(String userName, String pwd)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用（com-sakebow-test）"><a href="#使用（com-sakebow-test）" class="headerlink" title="使用（com.sakebow.test）"></a>使用（com.sakebow.test）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用junit4进行测试，测试用户登录接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Login login = (userName, pwd) -&gt;</span><br><span class="line">        System.out.println(<span class="string">"userName: "</span> + userName + <span class="string">"\t"</span> + <span class="string">"password: "</span> + pwd);</span><br><span class="line">    login.findUserByUserNameAndPassword(<span class="string">"sakebow"</span>, <span class="string">"123456"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>在这里lambda表达式起到了传递数据的作用，将findUserByUserNameAndPassword中使用到的两个参数传到了没有名字的函数内进行使用。</p><p>值得注意的是，lambda表达式也是有一些局限性的，比如只能用于含<strong>有且仅有一个</strong>方法的接口类中，但是非常方便的语法确实给这唯一的一个方法减少了工作量。</p><p>lambda表达式使用得最舒服的应该就是swing了。非常多的按钮可能就只实现一个方法，专门为了这个方法修改大量的包是非常消耗时间消耗精力的。</p><ul><li><em>由于现在swing已经过时了，所以不举例子。</em> *</li></ul><p>但是与之相对应的，swing与Android开发有非常多的相似的地方，在Android开发中各式各样的监听器中也可以大量使用lambda表达式进行代码的简化。</p><h2 id="接口可以定义默认方法和静态方法"><a href="#接口可以定义默认方法和静态方法" class="headerlink" title="接口可以定义默认方法和静态方法"></a>接口可以定义默认方法和静态方法</h2><p>默认方法使用<code>default</code>关键字进行修饰。使用default方法的好处在于：<strong>父类如果明确定义了default方法，则子类不用定义。</strong></p><p>这个在<strong>普通游戏编程</strong>中用的比较多。非常经典的“坦克大战”游戏中，不管是“敌军坦克”还是“己方坦克”都要继承自“坦克”类，为了不增加代码的冗余，可以定义<code>default</code>函数，这样己方坦克和敌方坦克就可以各用各的默认函数而不需要重复继承接口了。</p><p>或者某些会员制网站中，多种VIP和普通用户存在大量重复字段的情况下，也是可以酌情采取这种方法简化代码。</p><h2 id="接口冲突"><a href="#接口冲突" class="headerlink" title="接口冲突"></a>接口冲突</h2><p>如果实现的多个接口中存在同名默认方法的时候，必须重写方法才可以使用。Web开发中这类情况遇到的非常少，所以也不能举个非常贴切的例子。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;这里将会解释jdk8的一些新特性，比如lambda表达式、默认静态方法等等。由于jdk8是目前的主流，所以jdk8的新特性就比较重要。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://www.sakebow.cn/categories/java/"/>
    
    
      <category term="JVM" scheme="http://www.sakebow.cn/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>MySQL索引简介</title>
    <link href="http://www.sakebow.cn/2020/02/07/MySQLpro/MySQLpro-index/"/>
    <id>http://www.sakebow.cn/2020/02/07/MySQLpro/MySQLpro-index/</id>
    <published>2020-02-07T09:05:00.000Z</published>
    <updated>2020-02-09T09:08:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>这里将会介绍有关索引的简介，对索引的概念、功能、性能做一个简单的分析</strong></p><a id="more"></a><h2 id="索引的概念"><a href="#索引的概念" class="headerlink" title="索引的概念"></a>索引的概念</h2><p>索引是数据库针对表中一列或者多列的值进行排序的一种数据结构，<strong>使数据库中特定信息检索加快</strong>。（来自百度百科）</p><p>简单地说，<strong>索引就是一种有序的、加快检索的数据结构</strong>。于是你发现了<strong>华点</strong>：他可以影响后续的<strong>ORDER BY操作</strong>和<strong>WHERE操作</strong>。</p><p>但是这可如何操作呢？在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式指向数据。这就是<strong>B树</strong>。</p><p>如果没有特别指定，索引是指B树的数据结构，还有B+树、Hash树等等。</p><h3 id="小拓展"><a href="#小拓展" class="headerlink" title="小拓展"></a>小拓展</h3><p>为什么那些DBA成员都不是把数据物理删除而是设置标志位将其逻辑删除？一方面，为了以后的数据分析使用；另一方面，是为了建立索引。</p><p>数据越是增加、删除、修改的时候，索引越是不准。一般来说，索引本身也很大，不可能全部存储在内存中。因此索引往往以索引文件形式存储的磁盘上。</p><h3 id="单值索引"><a href="#单值索引" class="headerlink" title="单值索引"></a>单值索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idx_user_name <span class="keyword">ON</span> t_user(username);</span><br><span class="line"><span class="comment">-- 根据t_user表内的username字段建立索引</span></span><br></pre></td></tr></table></figure><p>由于这个索引只针对一个属性，所以也叫做<strong>单值索引</strong>。</p><h3 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idx_user_name <span class="keyword">ON</span> t_user(username, <span class="keyword">password</span>);</span><br><span class="line"><span class="comment">-- 根据t_user表内的username和password字段建立索引</span></span><br></pre></td></tr></table></figure><p>由于这个索引针对超过一个属性，所以叫做<strong>复合索引</strong>，也做“多值索引”<br>在实际开发中：</p><ul><li>多值索引<strong>往往优于</strong>单值索引；</li><li>一张表最多不可以多于5个索引；在MySQL中会有自动优化功能，于是往往同一时间只有一个索引被使用。于是出现了<strong>一核猛冲，四核干看</strong>的<strong>名义“五核处理器”</strong>。<h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3></li></ul><p><strong>索引列的值必须唯一，但是允许有空值</strong>，比如<strong>UNIQUE约束</strong>。</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span>] <span class="keyword">INDEX</span> index_name <span class="keyword">ON</span> table_name(column_list);</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">ALTER</span> table_name <span class="keyword">ADD</span> [<span class="keyword">UNIQUE</span>] <span class="keyword">INDEX</span> [index_name] <span class="keyword">ON</span> (column_list);</span><br><span class="line"><span class="comment">--一般用idx_ 加上 table_name_ 加上 自定义名称 作为索引名称</span></span><br></pre></td></tr></table></figure><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">INDEX</span> [index_name] <span class="keyword">ON</span> table_name</span><br></pre></td></tr></table></figure><h4 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">INDEX</span> <span class="keyword">FROM</span> table_name\G</span><br></pre></td></tr></table></figure><h2 id="索引的优势"><a href="#索引的优势" class="headerlink" title="索引的优势"></a>索引的优势</h2><p>为什么要索引？</p><p>在建表之初、没有建立索引之前，表内的所有内容都是<strong>杂乱无章</strong>的，查询就像是<strong>从一堆发了霉的账单里面找出一张揉得不像样的小额度账单一样</strong>。</p><p>而针对某个字段建立了索引之后，表内将会根据该字段进行排序，查询就会变得像是从整理得有序的图书馆中找到一本想要的书一样，快捷迅速。就像是京东多条件选择筛选一样，针对每个条件都加上索引的话查询会非常的快。</p><p>体现在哪些方面呢？一方面是<strong>降低IO成本</strong>，从而提高检索的效率；另一方面是<strong>通过索引列对数据进行排序，降低数据排序的成本</strong>，降低了CPU在选择操作上的消耗。</p><h2 id="索引的劣势"><a href="#索引的劣势" class="headerlink" title="索引的劣势"></a>索引的劣势</h2><ul><li>实际上，索引<strong>实际上也是一张表</strong>，该表保存了主键与索引字段，并指向实体表的记录。所以索引也会占用空间。</li><li>虽然索引提高了查询速度，却降低了更新表的速度。CUD操作后，MySQL不仅要保存数据，还要保存以下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。</li><li>索引知识提高效率的一个因素，如果你的MySQL有大数据量的表，就需要花时间建立最优秀的索引。也就是建了又删，删了又建，不断在分析中优化，最终达到对于当前环境下最优秀的索引结构。</li></ul><h2 id="索引的结构"><a href="#索引的结构" class="headerlink" title="索引的结构"></a>索引的结构</h2><h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><p>由于树深就是索引次数，故B树比起二叉树有更加小的树高，查找就非常的有优势。但是所有的数据都真实存储，所以对内存的负担非常大。每次查找也有一次磁盘的IO，效率相对提高，但还是不尽人意。</p><p>而B+树的优势，就在<strong>非叶子节点的数据都是不存在于数据表中</strong>，只指向搜索的方向，这样就减少了磁盘IO的次数，相比B+树更加迅速。</p><h3 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h3><p>哈希索引基于哈希表实现，也就是使用散列函数计算生成的数组，存储引擎会使用这个方法对所有的数据行计算一个哈希码。</p><p>其实现原理其实更贴近于<strong>贪心算法</strong>，不停的将大问题中的子问题进行求解，并且最优解就包含在子问题中。</p><p>哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。</p><h2 id="索引的使用"><a href="#索引的使用" class="headerlink" title="索引的使用"></a>索引的使用</h2><h3 id="在什么时候可以创建索引"><a href="#在什么时候可以创建索引" class="headerlink" title="在什么时候可以创建索引"></a>在什么时候可以创建索引</h3><ul><li>主键<strong>自动创建唯一索引</strong></li><li><strong>查找频率非常高的字段</strong>可以创建索引<ul><li>银行卡号</li><li>微信文章标题</li><li>QQ的QQ号码</li><li>学号</li><li>诸如此类</li></ul></li><li>查询中与其他表关联的字段，<strong>外键关系创建索引</strong><ul><li>学号（学生和教师联立的班级表中，学号、教师号分别作为外键需要建立索引）</li></ul></li><li><strong>频繁更新的字段不适合创建索引</strong><ul><li>更新字段的时候不仅更新值，还会更新索引树，所以开销非常大</li></ul></li><li>WHERE条件中<strong>用不到</strong>的字段不创建索引<ul><li>控制索引在5个以内</li></ul></li><li><strong>高并发下</strong>倾向于创建组合索引</li><li>查询中<strong>使用了ORDER BY的字段</strong>可以创建索引来加快排序速度</li><li>查询中<strong>统计或者分组字段</strong>，即COUNT(col_name)和GROUP BY选项<h3 id="什么时候不可以创建索引"><a href="#什么时候不可以创建索引" class="headerlink" title="什么时候不可以创建索引"></a>什么时候不可以创建索引</h3></li><li>表记录非常少<ul><li>MySQL在三百万数据量的时候性能急剧下降</li></ul></li><li>经常增删改的表不建立索引</li><li>数据重复且分布平均的字段不需要建索引<ul><li>应该只为最经常查询和最经常排序的数据列创建索引</li><li>如果该表重复量太大，索引没有实际效果<ul><li>比如“国籍”字段，就算71亿全部人入库，也才206个不同的国籍，性能提升不大。</li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;这里将会介绍有关索引的简介，对索引的概念、功能、性能做一个简单的分析&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="http://www.sakebow.cn/categories/MySQL/"/>
    
    
      <category term="MySQLpro" scheme="http://www.sakebow.cn/tags/MySQLpro/"/>
    
  </entry>
  
</feed>
