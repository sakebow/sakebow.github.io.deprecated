<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sakebow的小博客</title>
  
  <subtitle>一条苦苦挣扎的废柴大学狗</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.sakebow.cn/"/>
  <updated>2020-09-01T14:54:46.739Z</updated>
  <id>http://www.sakebow.cn/</id>
  
  <author>
    <name>Sakebow</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python进阶训练：聊天室</title>
    <link href="http://www.sakebow.cn/2020/08/20/python/python%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%EF%BC%9A%E8%81%8A%E5%A4%A9%E5%AE%A4/"/>
    <id>http://www.sakebow.cn/2020/08/20/python/python%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%EF%BC%9A%E8%81%8A%E5%A4%A9%E5%AE%A4/</id>
    <published>2020-08-19T16:01:00.000Z</published>
    <updated>2020-09-01T14:54:46.739Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>既然我们完成了基本的链表功能，相信也对<code>Python</code>语言有了一定的了解。那么我们现在开始进阶：<code>Python</code>聊天室（命令行版）。</strong></p><a id="more"></a><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>使用<code>UDP</code>代码库，使得两个进程之间得以通信。接收的时候直接输出到终端；发送的时候直接发送到指定端口，并使用死循环监听信息。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义全局变量udp</span></span><br><span class="line">udp = socket(AF_INET, SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_data</span><span class="params">(send_data, target_ip)</span>:</span></span><br><span class="line">  udp.sendto(send_data.encode(encoding = <span class="string">'utf-8'</span>), target_ip)</span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 接受数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recv_data</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="comment"># 拿到传输数据和源地址</span></span><br><span class="line">  socket_data, addr = udp.recvfrom(<span class="number">1024</span>)</span><br><span class="line">  <span class="comment"># 当前时间</span></span><br><span class="line">  current_time = time.strftime(<span class="string">'%Y-%m-%d %X'</span>, time.localtime(time.time()))</span><br><span class="line">  print(<span class="string">'================================================='</span>)</span><br><span class="line">  <span class="comment"># 输出到终端</span></span><br><span class="line">  print(<span class="string">f'now: <span class="subst">&#123;current_time&#125;</span>, IP: <span class="subst">&#123;addr[<span class="number">0</span>]&#125;</span>:<span class="subst">&#123;addr[<span class="number">1</span>]&#125;</span>\ncontent: <span class="subst">&#123;socket_data.decode(encoding = <span class="string">"utf-8"</span>)&#125;</span>'</span>)</span><br><span class="line">  print(<span class="string">'================================================='</span>)</span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>最后，我们在主函数中使用死循环监听这两个函数就好了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  <span class="comment"># 客户端1用8998端口</span></span><br><span class="line">  addr_bind = (<span class="string">''</span>, <span class="number">8998</span>)</span><br><span class="line">  udp.bind(addr_bind)</span><br><span class="line">  <span class="comment"># 客户端2用8999端口 / 本机IP192.168.1.111</span></span><br><span class="line">  target_ip = (<span class="string">'192.168.1.111'</span>, <span class="number">8999</span>)</span><br><span class="line">  <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    send_text = input(<span class="string">'say something: '</span>)</span><br><span class="line">    <span class="keyword">if</span> send_text == <span class="string">'bye'</span>:</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    <span class="comment"># 客户端1 - 先发送再接收</span></span><br><span class="line">    <span class="comment"># 客户端2 - 先接收再发送</span></span><br><span class="line">    send_data(send_text, target_ip)</span><br><span class="line">    recv_data()</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>到这里，简单的聊天室就完成了。</p><h2 id="结束？"><a href="#结束？" class="headerlink" title="结束？"></a>结束？</h2><p>你以为这样就能交作业了吗？<strong>还早着呢</strong>。这样只能实现两个端的交流，而且还只能限定从客户端1开始，从客户端2结束。作为多对多的<code>UDP</code>觉得自己非常吃亏，而且没有<code>GUI</code>的项目就不是一个好项目。</p><p>所以，在这里划一条线，我们将认真开始。</p><hr><h2 id="进阶1-添加服务器"><a href="#进阶1-添加服务器" class="headerlink" title="进阶1 - 添加服务器"></a>进阶1 - 添加服务器</h2><p><strong>前排提示</strong>：所有的文件都将放到<a href="https://github.com/sakebow/python-chat" target="_blank" rel="noopener"><code>GitHub</code></a>上，不会在这里花很多篇幅展示。所以希望学习的同学们可以两边结合起来看。</p><h3 id="综述"><a href="#综述" class="headerlink" title="综述"></a><strong>综述</strong></h3><p>就拿我们最常用的<strong>QQ</strong>和<strong>微信</strong>来说，都是由腾讯提供服务器，我们交流的时候首先提交到服务器上，然后再由服务器回显到各个客户端中。</p><p>所以，我们的首要目标就是<strong>建立服务器</strong>并让客户端和服务器能够<strong>正常连接</strong>。</p><p>首先我们需要明确服务器的功能。每次有数据提交到服务器的时候，服务器其实没有<strong>长期保留</strong>这个数据的必要，只不过是拿到了数据，并<strong>转发</strong>给所有的客户端而已。所以，实际上服务器只是需要做到<strong>接收</strong>和<strong>发送</strong>两个功能就足够了。</p><p>于是，这个项目的架构就差不多定下来了：</p><p>/ 根目录</p><p>┣ <code>config.py</code> 项目配置文件</p><p>┣ <code>ssocket.py</code> 基础socket实现类</p><p>┣ <code>server.py</code> 服务器实例类和功能实现</p><p>┣ <code>wrapper.py</code> 数据帧封装类</p><p>┗ <code>test.py</code> 输出测试类</p><p>看起来没什么毛病。就算有毛病估计你现在也是一脸蒙。接下来我将详细展开每个文件是干什么。</p><p>那么我们就开始准备了。既然是服务器的实现，那么就需要完善基本的网络通信，即<code>socket</code>库的具体业务实现。</p><h3 id="步骤一：确定基本配置项和底层实现方法"><a href="#步骤一：确定基本配置项和底层实现方法" class="headerlink" title="步骤一：确定基本配置项和底层实现方法"></a><strong>步骤一：确定基本配置项和底层实现方法</strong></h3><p><code>Python</code>的<code>socket</code>库和<code>C</code>语言的<code>socket</code>库有着异曲同工之妙，如果是使用<code>Ubuntu</code>系统编程的话应该能够很明显地感觉到这两者几乎很多都是相同的，只不过是再封装而已。发送就是<code>send()</code>，接收就是<code>recv()</code>。即：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">soc = socket()</span><br><span class="line"><span class="comment"># 发送 / 开辟大小为1024B的缓冲区，并对发送的Python对象使用*utf-8*编码为二进制数据</span></span><br><span class="line">soc.send(<span class="number">1024</span>).encode(<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="comment"># 接收 / 开辟大小为1024B的缓冲区，并对接收的二进制数据使用*utf-8*解码为Python对象</span></span><br><span class="line">soc.recv(<span class="number">1024</span>).decode(<span class="string">'utf-8)</span></span><br></pre></td></tr></table></figure><p>看起来没什么问题。但是如果就这么写进项目中，每次收发都这么写绝对很累赘，大量重复的<code>utf-8</code>和<code>1024</code>，如果有一天需要修改的话将会是一场恶梦。</p><p><strong>所以新建<code>config.py</code>记录配置。</strong></p><p>这里需要说明的是，如果是这么定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是作为配置项很不*方便*的写法，仅供参考，请勿模仿</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SOCKET_CONFIG</span><span class="params">(object)</span>:</span></span><br><span class="line">  SOCKET_MAX_CACHE = <span class="number">1232896</span> <span class="comment"># 2的20次方</span></span><br><span class="line">  SOCKET_CHARSET_ENCODING = <span class="string">'utf-8'</span></span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>这样的话你的<code>SOCKET_MAX_CACHE</code>和<code>SOCKET_CHARSET_ENCODING</code>都被<code>Python</code>记为私有变量，不可访问。需要画很多时间构建<code>getter</code>和<code>setter</code>。虽然可以使用<code>@property</code>简化，但是需要我们手动编辑，而且我在<code>Ubuntu2004</code>中使用<code>VScode</code>直接编译不通过，他有自己的想法。所以我放弃了<code>@property</code>并选择了使用<strong>枚举类型</strong>简化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SOCKET_CONFIG</span><span class="params">(Enum)</span>:</span> <span class="comment"># 继承Enum枚举类，属性直接用</span></span><br><span class="line">  SOCKET_MAX_CACHE = <span class="number">1232896</span></span><br><span class="line">  SOCKET_CHARSET_ENCODING = <span class="string">'utf-8'</span></span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>这样的话我们在任何地方就可以直接使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> config <span class="keyword">import</span> * <span class="comment"># 这么引入的前提是当前文件和config.py是同级</span></span><br><span class="line">a = SOCKET_CONFIG.SOCKET_MAX_CAHCE.value </span><br><span class="line"><span class="comment"># 枚举类直接用&#123;名称.value&#125;，直接使用名称得不到值</span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/sakebow/python-chat/blob/master/config.py" target="_blank" rel="noopener">点击这里查看config.py文件具体内容</a></p><p>当然，你也可以选择使用<code>yaml</code>、<code>properties</code>、<code>csv</code>、<code>json</code>和<code>xml</code>文件记录配置，这就看你愿意怎么使用了。如果想省事，直接用<code>py</code>吧；如果是想探索知识、需要构建大型项目或者说已经有一整套配置文件读取的代码库，建议使用单独的配置文件。</p><h3 id="步骤2：封装底层方法"><a href="#步骤2：封装底层方法" class="headerlink" title="步骤2：封装底层方法"></a><strong>步骤2：封装底层方法</strong></h3><p>使用<code>socket</code>创建专门针对某一个特定点的服务的时候，我们更倾向于使用端对端的<code>TCP/IP</code>协议，简单的说就是<strong>针对特定IP的特定端口号发送数据</strong>。根据这个定义我们就知道，需要我们确定<code>IP</code>和<code>端口号</code>，也就是在收发数据之前绑定<code>IP</code>和<code>端口号</code>。但是每一次都绑定肯定会显得累赘。</p><p><strong>所以我们创建<code>ssocket.py</code>封装<code>socket</code>用以绑定基本信息</strong></p><p>其中创建了继承自<code>socket.socket</code>的<code>ServerSocket</code>类，使用<code>AF_INET</code>协议（<code>TCP/IP</code>协议簇中的<code>IPv4</code>协议）和<code>SOCK_STREAM</code>（<code>TCP</code>流，即使用可靠的、端对端的连接进行通信；与之对应的是<code>SOCK_DGRAM</code>，是<code>UDP</code>流，不可靠的、多对多的连接进行通信）。</p><p>接着，我们使用<code>socket.bind()</code>方法传入<code>IP</code>信息和<code>端口号</code>。是以<strong>元组</strong>的形式传入的，即：<code>socket.bind((&#39;127.0.0.1&#39;, 8080))</code>。</p><p>最后，打开监听：<code>socket.listen(128)</code>。</p><p><a href="">点击这里查看ssocket.py文件具体内容</a></p><p>有了这个准备好的<code>ServerSocket</code>，我们就能开始准备<code>Server</code>实体类了。</p><p>在这里插入一个小技巧：</p><p><em><code>Server</code>类其实没有必要继承<code>ServerSocket</code>类，因为可以在<code>Server</code>类中使用<code>ServerSocket</code>对象；当然也可以继承，因为两者在本质上就是对<code>socket</code>进行操作，<code>Server</code>完全可以继承<code>ServerSocket</code>的操作，并在类内对<code>ServerSocket</code>进行拓展。</em></p><p>由于一个小项目，所以就不弄那么复杂了。直接使用实例化对象。</p><p><strong>所以接下来新建<code>server.py</code>，编辑<code>Server</code>类</strong></p><h3 id="步骤三：如何启动服务器"><a href="#步骤三：如何启动服务器" class="headerlink" title="步骤三：如何启动服务器"></a><strong>步骤三：如何启动服务器</strong></h3><p>定义了类之后，我们就需要开始定义具体的服务了。用过<code>Tomcat</code>的应该都知道，我们在配环境的时候会使用<code>startup</code>语句，所以我们这里也定义一个启动服务的<code>start</code>方法。</p><p>具体我们需要做什么呢？因为我们的监听已经开启了，所以我们需要做的就是等待客户端的连接，即使用<code>socket.accept()</code>方法获得两个返回值，一个是从客户端发送过来的数据帧，另一个则是数据源，也就是<strong>IP地址</strong>和<strong>端口号</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">soc, addr = socket.accept()</span><br><span class="line"><span class="comment"># soc是包含了此次传输的内容二进制编码等很多种数据的套接字</span></span><br><span class="line"><span class="comment"># addr则是数据源，是个元组，addr[0]是IP，addr[1]是端口号</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拿到套接字我们可以顺势接收发送的数据，也能返回对套接字的响应</span></span><br><span class="line">print(soc.recv(<span class="number">1024</span>).decode(<span class="string">'utf-8'</span>)) <span class="comment"># 打印是为了查看是否正常</span></span><br><span class="line">soc.send(<span class="string">"hello world!"</span>.encode(<span class="string">'utf-8'</span>))</span><br></pre></td></tr></table></figure><p>当然，还是一样的问题：每次都这么做要重复太多的<code>utf-8</code>和<code>1024</code>，所以封装起来。</p><p><strong>所以我们新建<code>wrapper.py</code>封装客户端套接字</strong></p><p>由于我们之前已经将缓冲区大小、默认编码封装在了<code>config.py</code>里面，所以直接拿来使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recv_data</span><span class="params">(self)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> socket.recv(SOCKET_CONFIG.SOCKET_MAX_CACHE.value).decode(SOCKET_CONFIG.SOCKET_CHARSET_ENCODING.value)</span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_data</span><span class="params">(self, message)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> socket.send(message.encode(SOCKET_CONFIG.SOCKET_CHARSET_ENCODING.value))</span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>为了保证使用之后还能够关闭<code>socket</code>以释放资源，最后再加上一个关闭的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.close()</span><br></pre></td></tr></table></figure><p><a href="https://github.com/sakebow/python-chat/blob/master/wrapper.py" target="_blank" rel="noopener">点击这里查看wrapper.py文件内容</a></p><p>有了<code>wrapper</code>封装之后，我们就直接在<code>Server</code>类中使用<code>wrapper.py</code>定义的实例化对象，这里我定义的是<code>SocketWrapper</code>类，所以<code>Server</code>类在使用<code>accept</code>方法获得套接字后这么使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">soc, addr = socket.accept()</span><br><span class="line">client_soc = SocketWrapper(soc)</span><br></pre></td></tr></table></figure><p>针对单个客户端的单次接入，我们直接使用我们封装好的<code>client_soc</code>就好了。因为是服务器，所以是先<strong>接收</strong>来自客户端的信息，再发送回显给客户端。最后，使用<code>wrapper,py</code>中封装好的<code>close</code>方法关闭连接释放资源。</p><p>具体来说就是这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 严重警告：此处的完整代码仅展示用，有缺陷，请勿模仿</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self)</span>:</span></span><br><span class="line">  <span class="comment"># 获得数据和数据源</span></span><br><span class="line">  soc, addr = self.server_socket.accept()</span><br><span class="line">  <span class="comment"># 绑定封装好的IP和端口，并开启监听</span></span><br><span class="line">  client_soc = SocketWrapper(soc)</span><br><span class="line">  <span class="comment"># 输出查看数据是否正确</span></span><br><span class="line">  print(client_soc.recv_data())</span><br><span class="line">  <span class="comment"># 回显客户端</span></span><br><span class="line">  client_soc.send_data(<span class="string">'connection established!'</span>)</span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>看起来没有问题，但是这样子一个客户端发完一条信息之后，整个服务进程都结束了，再也不能接收客户端传来的消息，除非重启服务器。每条信息都要重启服务器的话也实在是太反人类了。所以我们需要服务器一直在线，那么就加上一个死循环：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 严重警告：此处的完整代码仅展示用，有缺陷，请勿模仿</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self)</span>:</span></span><br><span class="line">  <span class="comment"># 获得数据和数据源</span></span><br><span class="line">  soc, addr = self.server_socket.accept()</span><br><span class="line">  <span class="comment"># 绑定封装好的IP和端口，并开启监听</span></span><br><span class="line">  client_soc = SocketWrapper(soc)</span><br><span class="line">  <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 输出查看数据是否正确</span></span><br><span class="line">    print(client_soc.recv_data())</span><br><span class="line">    <span class="comment"># 回显客户端</span></span><br><span class="line">    client_soc.send_data(<span class="string">'connection established!'</span>)</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>好了，客户端能够一直发信息了。</p><p>但是，这依然不够。这可是聊天室，客户端连接到服务器之后直接使用主进程的死循环收发信息，这样必然导致其他的<strong>任何客户端都不能和服务器交互</strong>，相当于莫名其妙的全员禁言了。这可要不得。</p><p>如果是以前用过<code>SpringBoot</code>开发<code>Web</code>的话，应该非常熟悉<code>@Asyn</code>这个注解，也就是使用子进程实现来自<code>Controller</code>的请求、调用<code>Service</code>的方法、操作<code>Dao</code>的接口等等。为何不借鉴一下这种思想呢？</p><p>所有的客户端一旦接入服务器便立马开启新的子进程，让所有的交互在子进程中完成。这样的话，主进程就可以完完全全地监听信息的接入，就像是<strong>前台接待</strong>一样，全权负责将到店的客户送到指定的房间（<em>子进程</em>）中。这就完成了<code>Server</code>的最终版。</p><p><a href="https://github.com/sakebow/python-chat/blob/master/server.py" target="_blank" rel="noopener">点击这里查看server.py文件具体内容</a></p><p>最后，我们来测试一下结果如何。</p><p><strong>这里就新建<code>test.py</code>来模拟客户端发送<code>socket</code>到服务器</strong></p><p><a href="https://github.com/sakebow/python-chat/blob/master/test.py" target="_blank" rel="noopener">点击这里查看<code>test.py</code>文件内容</a></p><p>到这里，这个聊天室就能够支持多个客户端收发信息、服务器处理多个请求了。但是他依然存在一个问题：<strong>不能显示其他人发送的信息</strong>。</p><p>而给其他人发送信息则又必须使用<code>socket</code>给其他<code>IP</code>发送消息。可是服务器一次只能处理一个请求，这就导致<strong>每次处理的时候只能弄到一个<code>IP</code>地址</strong>。虽然你可以写在文件里，但是这就把一个小项目写复杂了，也因为增加了硬盘的<code>IO</code>而大大降低了速度。所以，为了能够将速度发挥到极致，我这里使用<strong>单线程多路复用</strong>的<code>redis</code>来保存<strong>注册的用户信息</strong>和<strong>登录的用户信息</strong>。你可能会想这不是一样的么？<strong>实际上不一样</strong>。因为登录信息是需要写在当前在线人数表中的，同时服务器也只能给当前在线的人发送信息，否则给不在线的用户发送信息时会因为连接未建立<strong>给每个人抛了个错</strong>，结果所有在线的人一脸蒙逼地给不在线的人背锅。这明显不合理。</p><p>当然，还有一个优点就是<code>redis</code>还能当非关系型数据库使用，可以用于聊天记录的保存。这就是后话了。</p><p>那么问题来了，既然需要<code>redis</code>就需要服务器跑起来。所以这里就使用<code>Docker</code>运行一个简单的<code>redis</code>服务器。</p><p>首先准备<code>docker-compose.yml</code>文件，用于<code>docker</code>镜像的构建：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">redis-30xx:</span> <span class="comment"># 因为端口号不好记，所以记录端口号前两位到三位</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">'redis:latest'</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">'redis-30xx'</span> <span class="comment"># 方便以后避开这些端口号，名字也改改</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">'3079:6379'</span> <span class="comment"># 使用30xx端口映射默认的6379</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/usr/local/docker/redis/config:/conf</span> <span class="comment"># 配置文件</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/usr/local/docker/redis/data:/data</span> <span class="comment"># 数据文件</span></span><br></pre></td></tr></table></figure><p>然后在你的<code>Ubuntu</code>系统下使用超管权限运行<code>docker-compose up -d</code>，这样你的<code>redis</code>就启动起来了。</p><p>这里由于需要操作两个用户组，所以使用<code>redis</code>的集合和<code>python</code>的集合相对应，都是<code>sadd</code>方法用于添加用户，应用在登录和注册上；而<code>srem</code>用于移除用户，应用在用户注销上。</p><h2 id="进阶2-GUI"><a href="#进阶2-GUI" class="headerlink" title="进阶2 - GUI"></a>进阶2 - <code>GUI</code></h2><p>这里就直接使用<code>PyQT</code>作为<code>GUI</code>的搭建。虽然有<code>Qt Creator</code>用来简便绘制用户界面，但是底层却是<code>C++</code>。为了保证这个教程不掺杂一点与<code>Python</code>无关的东西，并为了能够让<code>Python</code>体现出网络编程中标准库的便捷性，这里直接使用一整套<code>Python</code>解决方案。</p><p>既然我们用的最熟悉的是QQ和微信，那么我们就干脆模仿微信的界面。当然，因为技术原因不能很好的模仿，所以就干脆就作出一点点小小的改变。不会很离谱，但也相当乱来。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;既然我们完成了基本的链表功能，相信也对&lt;code&gt;Python&lt;/code&gt;语言有了一定的了解。那么我们现在开始进阶：&lt;code&gt;Python&lt;/code&gt;聊天室（命令行版）。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程进阶综合测验" scheme="http://www.sakebow.cn/categories/%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6%E7%BB%BC%E5%90%88%E6%B5%8B%E9%AA%8C/"/>
    
    
      <category term="Python" scheme="http://www.sakebow.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>python基础综合：链表</title>
    <link href="http://www.sakebow.cn/2020/08/17/python/python%E5%9F%BA%E7%A1%80%E7%BB%BC%E5%90%88%EF%BC%9A%E9%93%BE%E8%A1%A8/"/>
    <id>http://www.sakebow.cn/2020/08/17/python/python%E5%9F%BA%E7%A1%80%E7%BB%BC%E5%90%88%EF%BC%9A%E9%93%BE%E8%A1%A8/</id>
    <published>2020-08-17T14:00:00.000Z</published>
    <updated>2020-08-27T07:22:44.904Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>因为研究生生涯开始了，所以需要暂时停掉<code>Java</code>的学习，开始使用<code>Python</code>的学习和实践了。于是花了一个小时从完全没学过到实现了最基础的单链表。这里就记录一下。</strong></p><a id="more"></a><h2 id="链表结构复习"><a href="#链表结构复习" class="headerlink" title="链表结构复习"></a>链表结构复习</h2><p>首先我们回顾链表由什么构成。在<code>C</code>语言中，对链表的定义就是：</p><blockquote><p>链表是一种动态数据结构。它主要是利用动态内存分配、使用结构体并配合之镇来实现的一种数据结构。</p><p>——摘自《C语言程序设计（第三版）》苏小红、王宇颖、孙志岗等编著</p></blockquote><p>也就是说，链表有以下几个特点：</p><ul><li><p>是类似数组的链式结构</p></li><li><p>内存分配并不像数组一样完全连续</p></li><li><p>每个节点使用结构体，每个节点也就有了更高的自由度和更大的存储量</p></li><li><p>下一个节点的位置保存在上一个节点中</p></li></ul><h2 id="Python对比预习"><a href="#Python对比预习" class="headerlink" title="Python对比预习"></a><code>Python</code>对比预习</h2><p>复习了链表之后，让我们再看看<code>Python</code>语言相对于<code>C</code>语言和<code>Java</code>有什么不同：</p><ul><li><p>不需要显式声明<code>private</code>、<code>protected</code>和<code>public</code></p></li><li><p>对象名直接对应对象的地址，这一点和<code>Java</code>非常相似</p></li><li><p>没有括号限制函数体，直接用缩进表示</p></li><li><p><code>None</code>对应<code>C</code>语言和<code>Java</code>的<code>null</code></p></li><li><p><code>self</code>代替了<code>C</code>语言和<code>Java</code>的<code>this</code>指针</p></li><li><p>魔法函数<code>__init__</code>直接定义了结构体的属性构成，而不需要显式定义结构体具体有哪些属性</p></li></ul><p>主要就是这些了。具体的细节我们遇到了再去查<a href="https://www.runoob.com/python3/python3-tutorial.html" target="_blank" rel="noopener"><strong>菜鸟教程</strong></a>就好了。当然，如果能够直接查<a href="https://docs.python.org/zh-cn/3/" target="_blank" rel="noopener"><code>Python</code></a>官方文档更好，毕竟都贴心地给出了中文版（但是点进去每个函数的解释还是<strong>英文</strong>，而且没有实例）。</p><h2 id="从节点的定义开始编码"><a href="#从节点的定义开始编码" class="headerlink" title="从节点的定义开始编码"></a>从节点的定义开始编码</h2><p>那么，为了先熟悉<code>Python</code>的语法，我们先来个小小的结构体试试水：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="comment"># 链表节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data, next, index)</span>:</span></span><br><span class="line">    self.data = data</span><br><span class="line">    self.next = next</span><br><span class="line">    self.index = index</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试节点</span></span><br><span class="line">node = Node(<span class="number">0</span>, <span class="literal">None</span>, <span class="number">0</span>)</span><br><span class="line">print(node.data)</span><br></pre></td></tr></table></figure><p>当然，没有悬念，输出<code>0</code>。</p><p>第一行首先是确认字符编码。默认是<code>UTF-8</code>，根据需要可以更换成别的；其次是使用<code>__init__</code>函数定义一个具有三个属性的类作为结构体；最后的pass则是占位符，表示一个域的结束，相当于<code>}</code>。因为<code>Python</code>直接使用缩进表示是否结束，所以这个仅仅作为个人习惯出现在这里。</p><h2 id="从链表的功能开始完善"><a href="#从链表的功能开始完善" class="headerlink" title="从链表的功能开始完善"></a>从链表的功能开始完善</h2><p>既然我们完成了节点的构造，那么我们一口气把整个链表攻下来吧！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Link</span>:</span></span><br><span class="line">  <span class="comment"># 初始化 / 不需要参数，自带空的头节点</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.head = <span class="literal">None</span></span><br><span class="line">    self.length = <span class="number">0</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  <span class="comment"># 尾插法插入数据</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">insert_tail</span><span class="params">(self, index, data)</span>:</span></span><br><span class="line">    <span class="comment"># 当尾节点为空时，使用头插法确定尾节点</span></span><br><span class="line">    <span class="keyword">if</span> self.tail <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">      self.insert_head(index, data)</span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    <span class="comment"># 在尾节点非空时往后接节点</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      node = Node(data, <span class="literal">None</span>, index)</span><br><span class="line">      self.tail.next = node</span><br><span class="line">      self.tail = node</span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  <span class="comment"># 头插法插入数据</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">insert_head</span><span class="params">(self, index, data)</span>:</span></span><br><span class="line">    node = Node(data, self.head, index)</span><br><span class="line">    self.head = node</span><br><span class="line">    self.length += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 当只有一个元素的时候，确定尾节点</span></span><br><span class="line">    <span class="keyword">if</span> self.length == <span class="number">1</span>:</span><br><span class="line">      self.tail = node</span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  <span class="comment"># 输出链表 / 从头开始顺序输出</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">output</span><span class="params">(self)</span>:</span></span><br><span class="line">    node = self.head</span><br><span class="line">    <span class="keyword">while</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">      print(<span class="string">f'<span class="subst">&#123;node.index&#125;</span>: <span class="subst">&#123;node.data&#125;</span>'</span>, end = <span class="string">' '</span>)</span><br><span class="line">      node = node.next</span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    print()</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">link = Link()</span><br><span class="line">link.insert_head(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">link.insert_tail(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">link.output()</span><br></pre></td></tr></table></figure><p>在这里的<code>self</code>关键字在<strong>函数体内</strong>就是<strong>作为<code>this</code>指针</strong>使用，而作为<strong>参数</strong>出现的时候就是声明该函数是一个<strong>成员函数</strong>。后面有一句：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">f'<span class="subst">&#123;node.index&#125;</span>: <span class="subst">&#123;node.data&#125;</span>'</span>, end = <span class="string">' '</span>)</span><br></pre></td></tr></table></figure><p>这是<code>Python</code>3.6以后的新特性，使用<code>f</code>直接将字符串格式化，另外使用<code>end</code>规定输出结尾是空格而不是默认的换行结尾。</p><p>于是，这次的输出就是：<code>1:2 3:4</code>。</p><h2 id="全自动构造链表"><a href="#全自动构造链表" class="headerlink" title="全自动构造链表"></a>全自动构造链表</h2><p>但是这还差一个输入。不想一个字一个字输入的我直接定义了一个随机生成的函数，让链表自己随便生成什么东西。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文件开头加上：</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">LETTERS = <span class="string">'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'</span></span><br><span class="line">LETTERS_LEN = len(LETTERS)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在Link类中添加成员函数</span></span><br><span class="line"><span class="comment"># 随机生成链表</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_link</span><span class="params">(self)</span>:</span></span><br><span class="line">  size = random.randint(<span class="number">0</span>, <span class="number">20</span>)</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, size):</span><br><span class="line">    self.insert_tail(i + <span class="number">1</span>, LETTERS[random.randint(<span class="number">0</span>, LETTERS_LEN - <span class="number">1</span>)])</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 全自动生成</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  link = Link()</span><br><span class="line">  link.random_link()</span><br><span class="line">  link.output()</span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>于是每次编译输出都有完全不一样的结果。</p><p>好了，到这里构造链表就没有什么大问题了。</p><h2 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h2><p>接下来就是很恼人的删除节点了。和<code>C++</code>一样，可以直接使用<code>del</code>命令显式删除对象。值得一提的是，这里显式删除之后只是将内存标记为“<strong>可使用</strong>”，该部分内存并没有被回收。之后<code>GC</code>会过来打扫的。</p><p>为了能够保持数组每次都是一致的，方便查看位置，这里添加了文件读取，能够在每次运行的时候从<code>linklist.csv</code>中读取一模一样的数据。</p><p>数据文件<code>linklist.csv</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">3</span><br><span class="line">1000</span><br><span class="line">7</span><br><span class="line">p</span><br><span class="line">q</span><br><span class="line">h</span><br><span class="line">@</span><br><span class="line">!</span><br><span class="line">,</span><br><span class="line">&gt;</span><br><span class="line">shift</span><br></pre></td></tr></table></figure><p>然后是读取文件并删掉<code>readline</code>方法读取时最后的字符<code>\n</code>误读的情况：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取固定的链表</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_file</span><span class="params">(self, filepath)</span>:</span></span><br><span class="line">  index = <span class="number">1</span></span><br><span class="line">  <span class="keyword">with</span> open(filepath, <span class="string">'r'</span>) <span class="keyword">as</span> lines:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">      self.insert_tail(index, line.rstrip(<span class="string">'\n'</span>))</span><br><span class="line">      index += <span class="number">1</span></span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>接着是删除某个位置的节点。这里虽然没有难点，但是很难在细节上保持平衡。需要考虑以下几种情况：</p><ul><li><p>链表<strong>没有节点</strong></p></li><li><p>链表<strong>有且仅有</strong>一个节点</p></li><li><p>中间<strong>任意位置</strong>删除</p></li><li><p>要删除的是<strong>第一个元素</strong></p></li><li><p>要删除的是<strong>最后一个元素</strong></p></li></ul><p>如果面面俱到，代码一定会纷繁复杂。所以我们需要根据这些非常神奇的地方巧妙避雷：</p><ul><li><p>如果链表没有节点，<strong>直接结束</strong></p></li><li><p>如果链表仅一个节点，删除时需要同时解除<code>head</code>指针、<code>tail</code>指针，<strong>避免指针指了个寂寞</strong>，然后一脸哀怨的给你报了个错</p></li><li><p>在删除的时候，使用临时指针<code>node</code>指向<code>head</code>指针或者<code>tail</code>指针，并删除<code>node</code>指针的时候，你会发现<code>head</code>和<code>tail</code>实际指向的地址依然存在原有的实例对象。所以实际步骤应当是<strong>先重置原先指向需要删除地址的指针，再删除临时指针</strong></p></li><li><p>删除的时候需要在最后修改链表长度，避免下次使用的时候<strong>索引超限</strong></p></li></ul><h2 id="删除节点实现"><a href="#删除节点实现" class="headerlink" title="删除节点实现"></a>删除节点实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用索引删除节点</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_node_by_index</span><span class="params">(self, index)</span>:</span></span><br><span class="line">  <span class="comment"># 没有节点</span></span><br><span class="line">  <span class="keyword">if</span> self.head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  <span class="comment"># 删除头</span></span><br><span class="line">  <span class="keyword">elif</span> index == <span class="number">1</span>:</span><br><span class="line">    node = self.head</span><br><span class="line">    self.head = self.head.next</span><br><span class="line">    <span class="keyword">del</span> node</span><br><span class="line">    <span class="comment"># 检查是不是只有这个节点</span></span><br><span class="line">    <span class="comment"># 如果无视tail，head将会为None而tail保持原样</span></span><br><span class="line">    <span class="keyword">if</span> self.head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">      self.tail = self.head</span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  <span class="comment"># 中间任意位置删除</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    node = self.get_node(index - <span class="number">1</span>)</span><br><span class="line">    temp = node.next</span><br><span class="line">    <span class="keyword">if</span> temp <span class="keyword">is</span> self.tail:</span><br><span class="line">      node.next = <span class="literal">None</span></span><br><span class="line">      self.tail = node</span><br><span class="line">      <span class="keyword">del</span> temp</span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      node.next = temp.next</span><br><span class="line">      <span class="keyword">del</span> temp</span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>然后我们来测试一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试删除是否成功</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  link = Link()</span><br><span class="line">  link.read_file(<span class="string">'/home/sakebow/python/linklist/linklist.csv'</span>)</span><br><span class="line">  link.delete_node_by_index(link.length)</span><br><span class="line">  link.output()</span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>这里要强调的是<code>read_file</code>命令需要<strong>完整的绝对路径</strong>，否则无法读取文件。</p><p>当然，很完美地删掉了最后一个元素：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1: 1 2: 2 3: 3 4: 10 5: 11 6: a 7: b 8: 3 9: 1000 10: 7 11: p 12: q 13: h 14: @ 15: ! 16: , 17: &gt;</span><br></pre></td></tr></table></figure><h2 id="删除节点进阶"><a href="#删除节点进阶" class="headerlink" title="删除节点进阶"></a>删除节点进阶</h2><p>接着我们再来完善匹配所有项的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 匹配内容删除节点</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_node_by_data</span><span class="params">(self, data)</span>:</span></span><br><span class="line">  <span class="comment"># 强行改为有头节点的链表 / 内容随意，仅需保证next指向head</span></span><br><span class="line">  node = Node(<span class="string">'a'</span>, self.head, <span class="number">0</span>)</span><br><span class="line">  <span class="comment"># 保持标识，最后需要删除</span></span><br><span class="line">  <span class="comment"># 如果head移动了也不要紧，node将会控制下一跳的位置</span></span><br><span class="line">  stay_head = node</span><br><span class="line">  <span class="comment"># 游标，规定temp为必删项，node为上一项</span></span><br><span class="line">  temp = self.head</span><br><span class="line">  <span class="comment"># 遍历链表</span></span><br><span class="line">  <span class="keyword">while</span> temp <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="comment"># 如果要删第一个</span></span><br><span class="line">    <span class="keyword">if</span> temp <span class="keyword">is</span> self.head <span class="keyword">and</span> temp.data == data:</span><br><span class="line">      <span class="comment"># 先重置</span></span><br><span class="line">      node.next = temp.next</span><br><span class="line">      <span class="comment"># 检查tail</span></span><br><span class="line">      <span class="keyword">if</span> temp <span class="keyword">is</span> self.tail:</span><br><span class="line">        self.tail = self.head = node.next</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">      <span class="comment"># 再删除</span></span><br><span class="line">      <span class="keyword">del</span> temp</span><br><span class="line">      <span class="comment"># 因为下次循环依然需要使用temp，所以重置为node下一跳</span></span><br><span class="line">      temp = node.next</span><br><span class="line">      <span class="comment"># 修改长度</span></span><br><span class="line">      self.length -= <span class="number">1</span></span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    <span class="comment"># 中间任意项删除</span></span><br><span class="line">    <span class="comment"># 原理同上</span></span><br><span class="line">    <span class="keyword">elif</span> temp <span class="keyword">is</span> <span class="keyword">not</span> self.head <span class="keyword">and</span> temp.data == data:</span><br><span class="line">      node.next = temp.next</span><br><span class="line">      <span class="keyword">if</span> temp <span class="keyword">is</span> self.tail:</span><br><span class="line">        self.tail = node</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">      <span class="keyword">del</span> temp</span><br><span class="line">      temp = node.next</span><br><span class="line">      self.length -= <span class="number">1</span></span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    <span class="comment"># 如果不匹配，全部下一跳，且长度不变</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      temp = temp.next</span><br><span class="line">      node = node.next</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  <span class="comment"># 最终删除辅助节点</span></span><br><span class="line">  <span class="keyword">del</span> stay_head</span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>那我们来测试一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  link = Link()</span><br><span class="line">  link.read_file(<span class="string">'/home/sakebow/python/linklist/linklist.csv'</span>)</span><br><span class="line">  <span class="comment"># 因为数据集里面3出现了两次，所以选择3</span></span><br><span class="line">  link.delete_node_by_data(<span class="string">'3'</span>)</span><br><span class="line">  link.output()</span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>当然，最终结果把两个3全部删掉了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1: 1 2: 2 4: 10 5: 11 6: a 7: b 9: 1000 10: 7 11: p 12: q 13: h 14: @ 15: ! 16: , 17: &gt; 18: shift</span><br></pre></td></tr></table></figure><p>也没有问题！</p><p>当然你也可以使用各种各样的数据测试。就算是60万行数据也能用$1’32’’$秒给出答案。（<em>实际测量可能和电脑运算能力有误差</em>）</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后，为了代码简洁、项目结构清晰，我们将各个部分拆开。这里贴上各个部分的文件内容：</p><h3 id="Node-py"><a href="#Node-py" class="headerlink" title="Node.py"></a>Node.py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 链表节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data, next, index)</span>:</span></span><br><span class="line">    self.data = data</span><br><span class="line">    self.next = next</span><br><span class="line">    self.index = index</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h3 id="Link-py"><a href="#Link-py" class="headerlink" title="Link.py"></a>Link.py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Node <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># 链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Link</span>:</span></span><br><span class="line">  <span class="comment"># 初始化 / 不需要参数，自带空的头节点</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.head = <span class="literal">None</span></span><br><span class="line">    self.tail = <span class="literal">None</span></span><br><span class="line">    self.length = <span class="number">0</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 尾插法插入数据</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">insert_tail</span><span class="params">(self, index, data)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> self.tail <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">      self.insert_head(index, data)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      node = Node(data, <span class="literal">None</span>, index)</span><br><span class="line">      self.tail.next = node</span><br><span class="line">      self.tail = node</span><br><span class="line">      self.length += <span class="number">1</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 头插法插入数据 </span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">insert_head</span><span class="params">(self, index, data)</span>:</span></span><br><span class="line">    node = Node(data, self.head, index)</span><br><span class="line">    self.head = node</span><br><span class="line">    self.length += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 当只有一个元素的时候，确定尾节点</span></span><br><span class="line">    <span class="keyword">if</span> self.length == <span class="number">1</span>:</span><br><span class="line">      self.tail = node</span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 输出链表</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">output</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> self.head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">      print(<span class="string">'Nothing'</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      node = self.head</span><br><span class="line">      <span class="keyword">while</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        print(<span class="string">f'<span class="subst">&#123;node.index&#125;</span>: <span class="subst">&#123;node.data&#125;</span>'</span>, end=<span class="string">' '</span>)</span><br><span class="line">        node = node.next</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">      print()</span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 随机生成链表</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">random_link</span><span class="params">(self)</span>:</span></span><br><span class="line">    size = random.randint(<span class="number">0</span>, <span class="number">20</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, size):</span><br><span class="line">      self.insert_tail(i + <span class="number">1</span>, LETTERS[random.randint(<span class="number">0</span>, LETTERS_LEN - <span class="number">1</span>)])</span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 读取固定的链表</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">read_file</span><span class="params">(self, filepath)</span>:</span></span><br><span class="line">    index = <span class="number">1</span></span><br><span class="line">    <span class="keyword">with</span> open(filepath, <span class="string">'r'</span>) <span class="keyword">as</span> lines:</span><br><span class="line">      <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        self.insert_tail(index, line.rstrip(<span class="string">'\n'</span>))</span><br><span class="line">        index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 通过索引获得指定节点</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get_node</span><span class="params">(self, index)</span>:</span></span><br><span class="line">    node = self.head</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, index):</span><br><span class="line">      node = node.next</span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 匹配内容删除节点</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">delete_node_by_data</span><span class="params">(self, data)</span>:</span></span><br><span class="line">    <span class="comment"># 强行改为有头节点的链表</span></span><br><span class="line">    node = Node(<span class="string">'a'</span>, self.head, <span class="number">0</span>)</span><br><span class="line">    <span class="comment"># 保持标识，最后需要删除</span></span><br><span class="line">    stayHead = node</span><br><span class="line">    <span class="comment"># 游标，规定temp为必删项，node为上一项</span></span><br><span class="line">    temp = self.head</span><br><span class="line">    <span class="keyword">while</span> temp <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">      <span class="keyword">if</span> temp <span class="keyword">is</span> self.head <span class="keyword">and</span> temp.data == data:</span><br><span class="line">        node.next = self.head = temp.next</span><br><span class="line">        <span class="keyword">if</span> temp <span class="keyword">is</span> self.tail:</span><br><span class="line">          self.tail = self.head = node.next</span><br><span class="line">          <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">del</span> temp</span><br><span class="line">        temp = node.next</span><br><span class="line">        self.length -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">      <span class="keyword">elif</span> temp <span class="keyword">is</span> <span class="keyword">not</span> self.head <span class="keyword">and</span> temp.data == data:</span><br><span class="line">        node.next = temp.next</span><br><span class="line">        <span class="keyword">if</span> temp <span class="keyword">is</span> self.tail:</span><br><span class="line">          self.tail = node</span><br><span class="line">          <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">del</span> temp</span><br><span class="line">        temp = node.next</span><br><span class="line">        self.length -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">        temp = temp.next</span><br><span class="line">        node = node.next</span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">del</span> stayHead</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 使用索引删除节点</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">delete_node_by_index</span><span class="params">(self, index)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> self.head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">elif</span> index == <span class="number">1</span>:</span><br><span class="line">      node = self.head</span><br><span class="line">      self.head = self.head.next</span><br><span class="line">      <span class="keyword">if</span> self.head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        self.tail = self.head</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">      <span class="keyword">del</span> node</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      node = self.get_node(index - <span class="number">1</span>)</span><br><span class="line">      temp = node.next</span><br><span class="line">      <span class="keyword">if</span> temp <span class="keyword">is</span> self.tail:</span><br><span class="line">        node.next = <span class="literal">None</span></span><br><span class="line">        self.tail = node</span><br><span class="line">        <span class="keyword">del</span> temp</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">        node.next = temp.next</span><br><span class="line">        <span class="keyword">del</span> temp</span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h3 id="linklist-csv"><a href="#linklist-csv" class="headerlink" title="linklist.csv"></a>linklist.csv</h3><p>这个文件后来我改得非常大，一共22932行数据，不方便展开，各位可以自行<a href="https://github.com/sakebow/python-linklist/blob/master/linklist.csv" target="_blank" rel="noopener">点击我的<code>GitHub</code></a>下载。</p><h3 id="linklist-py（主文件）"><a href="#linklist-py（主文件）" class="headerlink" title="linklist.py（主文件）"></a>linklist.py（主文件）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> Link <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">LETTERS = <span class="string">'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'</span></span><br><span class="line">LETTERS_LEN = len(LETTERS)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  link = Link()</span><br><span class="line">  link.read_file(<span class="string">'/home/sakebow/python/linklist/linklist.csv'</span>)</span><br><span class="line">  <span class="comment"># 测试</span></span><br><span class="line">  link.delete_node_by_data(<span class="string">'3'</span>)</span><br><span class="line">  link.output()</span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>如果觉得大段大段的代码在这里看不怎么清楚的话，直接在<a href="https://github.com/sakebow/python-linklist" target="_blank" rel="noopener">我的GitHub</a>中下载也可以。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;因为研究生生涯开始了，所以需要暂时停掉&lt;code&gt;Java&lt;/code&gt;的学习，开始使用&lt;code&gt;Python&lt;/code&gt;的学习和实践了。于是花了一个小时从完全没学过到实现了最基础的单链表。这里就记录一下。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程基础综合测验" scheme="http://www.sakebow.cn/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%BB%BC%E5%90%88%E6%B5%8B%E9%AA%8C/"/>
    
    
      <category term="Python" scheme="http://www.sakebow.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>回老家的四天假期</title>
    <link href="http://www.sakebow.cn/2020/08/06/diary/%E5%9B%9E%E8%80%81%E5%AE%B6%E7%9A%84%E5%9B%9B%E5%A4%A9%E5%81%87%E6%9C%9F/"/>
    <id>http://www.sakebow.cn/2020/08/06/diary/%E5%9B%9E%E8%80%81%E5%AE%B6%E7%9A%84%E5%9B%9B%E5%A4%A9%E5%81%87%E6%9C%9F/</id>
    <published>2020-08-06T13:48:11.000Z</published>
    <updated>2020-08-09T03:29:43.426Z</updated>
    
    <content type="html"><![CDATA[<script src="/crypto-js.js"></script><script src="/mcommon.js"></script><h3 id="encrypt-message">如果你坚持要看，请联系我。</h3><link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.min.css"> <link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap-theme.min.css"> <script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script> <script src="//cdn.bootcss.com/bootstrap/3.3.5/js/bootstrap.min.js"></script> <div id="security"> <div> <div class="input-group"> <input type="text" class="form-control" aria-label="Enter the password." id="pass"/> <div class="input-group-btn"> <button type="button" class="btn btn-default" onclick="decryptAES()">Decrypt</button> </div> </div> </div> </div> <div id="encrypt-blog" style="display:none"> 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 </div>]]></content>
    
    <summary type="html">
    
      本文针对老家的一点见闻说一些真心感受。当然，因为是个人偏见所以不对外开放。
    
    </summary>
    
    
      <category term="日记" scheme="http://www.sakebow.cn/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="假期" scheme="http://www.sakebow.cn/tags/%E5%81%87%E6%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>多元梯度函数的梯度下降</title>
    <link href="http://www.sakebow.cn/2020/08/01/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%AE%97%E6%B3%95%E6%A8%A1%E5%9E%8B/%E5%A4%9A%E5%85%83%E6%A2%AF%E5%BA%A6%E5%87%BD%E6%95%B0%E7%9A%84%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/"/>
    <id>http://www.sakebow.cn/2020/08/01/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%AE%97%E6%B3%95%E6%A8%A1%E5%9E%8B/%E5%A4%9A%E5%85%83%E6%A2%AF%E5%BA%A6%E5%87%BD%E6%95%B0%E7%9A%84%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/</id>
    <published>2020-08-01T03:25:00.000Z</published>
    <updated>2020-08-27T04:25:13.326Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>当然，本篇完全有理由和我之前写的<a href="/2020/07/26/人工智能/算法模型/梯度下降/">梯度下降</a>一文并在一起。但是，我还是觉得应当单独拉出来。前一篇<a href="/2020/07/26/人工智能/算法模型/梯度下降/">梯度下降</a>仅仅只是针对梯度下降的原理和流程作了一些阐释，用三个维度的例子说明了一个通用解法。而这里才是实际应用的具体表现，同时也包含很多小技巧。从这里开始，就是动真格的了！</strong></p><a id="more"></a><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>当然，还是那个海拔图，有高有低，有近有远。你要做的，就是从山顶上下山。环顾四周，一跳接一跳地往山下走。</p><h2 id="代价函数的确定"><a href="#代价函数的确定" class="headerlink" title="代价函数的确定"></a>代价函数的确定</h2><p>当然，代价函数就是我们需要训练的目标函数。只要代价函数最小，我们最后训练的结果就会接近事实。</p><p>可是，光是二元函数构成的三维图就已经包含了很多的不确定性，陷入局部最优解、收敛慢、内存溢出……这都是很无奈但是可控的问题。不如我们逆转过来：既然没有便利，就创造便利。</p><p>这里就还是用你的猫娘作为例子，但是这次代入了更多自变量：</p><blockquote><p>你再次收集了20万猫娘的信息，包括年龄（<code>age</code>）、体重（<code>weight</code>）、身高（<code>height</code>）、最大跳跃距离（<code>distence</code>）、胸围（<code>bust</code>）、腰围（<code>waist</code>）、臀围（<code>hip</code>）、基础社会科学考试分数（<code>score</code>）……</p></blockquote><p>虽然可能还有很多指标，但是现在就先列举这8项。是不是觉得非常的麻烦？而且这下我们连图都画不出来了，甚至无法想象8个自变量如何构成一个解空间，更无法想象涉及8个自变量的函数将会是怎样一个扭曲的形态。</p><p>行，套公式嘛，<strong>矩阵求解</strong>。</p><h2 id="函数化简"><a href="#函数化简" class="headerlink" title="函数化简"></a>函数化简</h2><blockquote><p>你整理出了一张含有$n$行数据的表，其中每一行数据都代表一只猫娘的所有收集到的信息，所以你为每一行整理了一个矩阵：</p><script type="math/tex; mode=display">\left[\begin{matrix}age_i（岁） \\weight_i（千克）\\height_i（米）\\distance_i（米）\\bust_i（厘米）\\waist_i（厘米）\\hip_i（厘米）\end{matrix}\right],i\in\{1,2,3,\ldots,n\}</script></blockquote><p><strong>这里插播一句：</strong></p><p><em>因为面对这样一个生物，对于科研人员来说就是个名副其实的黑匣子：什么都不知道，只知道输入和输出。所以在确定函数关系式的时候相当的麻烦。所以往往是一个个变量分析，优先找出一个个独立不相关的变量，然后分析相关变量的影响。这里就完全不是拟合算法能够做到的了，而是来自不同领域的科研人员齐心协力研究发现最终的出来的结果。这里因为赌的成分过高，并且和梯度下降并没有什么直接的关系，所以直接跳过。现在就直接跳到你找到了每个自变量的精确幂指数和对数底数以及对应的线性关系的情况。</em></p><blockquote><p>然后你又双叒叕凭着你对猫娘的热爱找出了这8个变量的大致关系：</p><script type="math/tex; mode=display">y=f(age,weight,height,distance,bust,waist,hip)\\\Downarrow\\y=\epsilon+\alpha_1a+\alpha_2weight^2+\alpha_3height+\alpha_4d^3+\frac{\alpha_5}{3}(b^2+waist^2+hip^2)</script><p>其中，</p><script type="math/tex; mode=display">\epsilon,\alpha_1,\alpha_2,\alpha_3,\alpha_4,\alpha_5\in\mathbb{R}</script></blockquote><p><em>如果你还有印象，那么你应该记得$\epsilon$服从正态分布$N(0,\sigma^2)$，是随机误差。在一开始决定各种自变量的系数的时候往往会先忽视这个小东西，然后在全部得出结果之后加上以保证函数能够兼容一些“<strong>偶然</strong>”</em></p><blockquote><p>看到这样群魔乱舞的函数，你感觉到背脊发凉。完全没办法想象的解空间、完全无法想象的图形走向，更不用说最终目标的图像意义都无法解释……（<em>当然，这里是为了节目效果如此设计的</em>。）</p><p>这没难倒你。你把式子化为<strong>矩阵</strong>形式表达，就变成了这样：</p><script type="math/tex; mode=display">y=\left[\begin{matrix}  1&\alpha_1&\alpha_2&\alpha_3&\alpha_4&\alpha_5\over3&\alpha_5\over3&\alpha_5\over3\end{matrix}\right]\times\left[\begin{matrix}\epsilon\\age\\weight^2\\height\\distance^3\\bust^2\\waist^2\\hip^2\end{matrix}\right]\\\Downarrow\\y=\left[\begin{matrix}  1&\alpha_1&\alpha_2&\alpha_3&\alpha_4&\alpha_5\over3&\alpha_5\over3&\alpha_5\over3\end{matrix}\right]\\\times\left[\begin{matrix}  \epsilon\\age\\weight\\height\\distance\\bust\\waist\\hip\end{matrix}\right]\\\times\left[\begin{matrix}  \epsilon\\&1\\&&weight\\&&&height\\&&&&distance\\&&&&&bust\\&&&&&&waist\\&&&&&&&hip\end{matrix}\right]\\\times\left[\begin{matrix}  1\\&1\\&&1\\&&&1\\&&&&distance\\&&&&&1\\&&&&&&1\\&&&&&&&1\end{matrix}\right]</script></blockquote><p><em>由于版面问题，这个公式只能勉强这么写着了……</em></p><p><img src="https://sakebow.gitee.io/images/emoji/fuck-off.jpg" width="150" /></p><p>先不管版面了，若稍微简化一些，我们发现系数和幂指数<strong>完全相同</strong>的$bust$、$waist$和$hip$可以<strong>合并</strong>为一个变量$\eta_1$。</p><blockquote><p>再简化一些，更抽象一些，那就成为了：</p><script type="math/tex; mode=display">y=\alpha^T\eta</script><p>其中，$\alpha$是待定系数的矩阵，而$\eta$则是自变量经过各自合适变化之后的矩阵，即：</p><script type="math/tex; mode=display">\alpha^T=\left[\begin{matrix}  \alpha_1&\alpha_2\cdots\alpha_n\end{matrix}\right]_n,\\\eta=\left[\begin{matrix}  \eta_1\\\eta_2\\\vdots\\\eta_n\end{matrix}\right]_n,</script><p>而$\eta_i$则能代表很多，可以是$x_i$，也可以是$(x_i+x_{i+1})^2$等等。</p></blockquote><p>到这里，也就只是单纯的将变量合并，将复杂的公式变成简单易懂的矩阵向量，强行转成2个矩阵维度的<strong>解空间</strong>。当然，我们还是想象不到，只不过大致可以理解为某种类似$x$轴和$y$轴的神奇坐标轴在帮助我们标记位置。这么一想的话，就算是不能想象数轴的样子，也能够想象出解空间是个什么样了，而我们最终要求的目标函数最小值大概也能模模糊湖地猜出来在哪。</p><h2 id="目标函数最终展开"><a href="#目标函数最终展开" class="headerlink" title="目标函数最终展开"></a>目标函数最终展开</h2><p>但是你发现，到这里还是和上次讲到的梯度下降没有区别。没错，后面还有内容。</p><p>由于我们已经将目标函数改成了多元一次函数，所以，我们需要将目标函数彻底展开成为级数的形式，方便我们进一步设计算法。</p><p>还记得我们最初的公式么？</p><script type="math/tex; mode=display">\beta_i=\beta_i-\frac{\alpha}{m}\sum^n_{i=1}(f(x_i)-y_i)^2</script><p>我们的目标就是让$\frac{1}{m}\sum^n_{i=1}(f(x_i)-y_i)^2$尽可能地小。那么问题就简单了，针对这个函数分析就好了。另：</p><script type="math/tex; mode=display">\phi(\beta)=\frac{1}{m}\sum^n_{i=1}(f(x_i)-y_i)^2</script><p>求个导：</p><script type="math/tex; mode=display">\dot{\phi(\beta)}=\frac{2}{m}\sum^n_{i=1}[f(x_i)-y_i]\dot{f(x_i)}</script><p>这里最核心的部分就是$\dot{f(x_i)}$的理解。首先，我们寻找的是有关系数的函数，所以在这里的自变量是$\beta$，所以求导的时候不应当是已经知道具体数值的$x_i$，而是完全未知的$\beta_i$，故求导结果为$x_i$。即：</p><script type="math/tex; mode=display">\dot{\phi(\beta)}=\frac{2}{m}\sum^n_{i=1}[\dot{f(x_i)}-y_i]x_i</script><p>为了求导不要新增太多没有意义的单项式或多项式，所以我们将系数$2$删掉，也就是将目标函数改为：</p><script type="math/tex; mode=display">\phi(\beta)=\frac{1}{2m}\sum^n_{i=1}(f(x_i)-y_i)^2</script><p>这也就是吴恩达教授的课程中一直使用的函数的由来。求导之后就是：</p><script type="math/tex; mode=display">\dot{\phi(\beta)}=\frac{1}{m}\sum^n_{i=1}[f(x_i)-y_i]x_i</script><p>简单多了，不是么？</p><p>所以我们进而修改一下机器学习的算法：</p><script type="math/tex; mode=display">\theta_j=\theta_j-\frac{\alpha}{m}\sum^n_{i=1}[f(x_i)-y_i]x_i</script><p>到这，似乎就对计算机来说非常的方便了。</p><h2 id="theta-0-和-x-0"><a href="#theta-0-和-x-0" class="headerlink" title="$\theta_0$和$x_0$"></a>$\theta_0$和$x_0$</h2><p>对于一些课程中，你一定会遇到加设待定常数$\theta_0$和固定初始参数$x_0=1$的教师。为什么要这么做？我个人认为和数列添加初项是一样的。有些算法并不能很好地概括初项，所以强行加上去方便计算机处理。有些非常巧合的数列能够不需要初项，这就看怎么处理了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;当然，本篇完全有理由和我之前写的&lt;a href=&quot;/2020/07/26/人工智能/算法模型/梯度下降/&quot;&gt;梯度下降&lt;/a&gt;一文并在一起。但是，我还是觉得应当单独拉出来。前一篇&lt;a href=&quot;/2020/07/26/人工智能/算法模型/梯度下降/&quot;&gt;梯度下降&lt;/a&gt;仅仅只是针对梯度下降的原理和流程作了一些阐释，用三个维度的例子说明了一个通用解法。而这里才是实际应用的具体表现，同时也包含很多小技巧。从这里开始，就是动真格的了！&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="人工智能" scheme="http://www.sakebow.cn/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
      <category term="算法模型" scheme="http://www.sakebow.cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>建模工具：octave</title>
    <link href="http://www.sakebow.cn/2020/07/26/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%AE%97%E6%B3%95%E6%A8%A1%E5%9E%8B/%E5%BB%BA%E6%A8%A1%E5%B7%A5%E5%85%B7%EF%BC%9Aoctave/"/>
    <id>http://www.sakebow.cn/2020/07/26/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%AE%97%E6%B3%95%E6%A8%A1%E5%9E%8B/%E5%BB%BA%E6%A8%A1%E5%B7%A5%E5%85%B7%EF%BC%9Aoctave/</id>
    <published>2020-07-26T15:23:00.000Z</published>
    <updated>2020-09-03T15:13:00.581Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>终于，使用<code>Ubuntu</code>系统的我遇到了最尴尬的问题：建模工具<code>Matlab</code>没有<code>linux</code>发行版。虽然可以使用<code>wine</code>勉强跑起来，但毕竟不是运行在<code>Windows</code>内核下，所以往往有很多事情都非常尴尬。所以，我看上了这一款：<code>octave</code>。不仅支持<code>Ubuntu</code>，还能够兼容<code>Matlab</code>，是非常不错的替代品。</strong></p><a id="more"></a><h2 id="界面展示"><a href="#界面展示" class="headerlink" title="界面展示"></a>界面展示</h2><p>先看看<code>octave</code>的软件界面，体验一下吧。</p><p><img src="https://sakebow.gitee.io/images/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/octave%E7%95%8C%E9%9D%A2.png" alt="octave界面"></p><p>可以看到左边由上至下依次是：文件目录、工作空间和历史记录，而左边则是命令行界面。</p><p>是不是非常熟悉？没错，这简直不能再像<code>Matlab</code>了。即使顶部功能菜单并没有<code>Matlab</code>那么丰富，却也足够了。</p><h2 id="更换命令行"><a href="#更换命令行" class="headerlink" title="更换命令行"></a>更换命令行</h2><p>如果你有丰富的<code>shell</code>编程经验，那么你应该对这个<code>&gt;&gt;</code>非常熟悉。<code>Matlab</code>使用的是<code>&gt;&gt;</code>，<code>MySQL</code>使用的是<code>&gt;</code>，<code>sqlplus</code>（<em><code>Oracle</code></em>）使用的是<code>&gt;</code>，<code>Python</code>使用的是<code>&gt;&gt;&gt;</code>，<code>Ubuntu</code>普通用户使用的是<code>$</code>，<code>Ubuntu</code>超管使用的是<code>#</code>……</p><p>如果说你用惯了想要换，还是可以的。直接输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 这段字符串复制自我的Ubuntu终端</span></span><br><span class="line">PS1("sakebow@Lenovo-V310-14IKB:~$ ")</span><br></pre></td></tr></table></figure><p>这样就能够保持和终端一模一样的风格了。当然为了区分也可以改称其他的，比如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ……懂的都懂……</span></span><br><span class="line">PS1("お兄ちゃん、頑張るね、大好きだよ❤　")</span><br></pre></td></tr></table></figure><h2 id="基于Linux的特点"><a href="#基于Linux的特点" class="headerlink" title="基于Linux的特点"></a>基于<code>Linux</code>的特点</h2><p>当然，因为开源免费的<code>octave</code>是使用<code>C</code>语言基于<code>Linux</code>系统开发的，所以也会保留一些<code>Linux</code>系统的命令。比如：</p><ul><li><code>pwd</code>显示当前所在文件夹</li><li><code>ls</code>显示当前文件夹中所有的文件</li><li><code>cd</code>跳转到制定文件夹</li><li><code>exit</code>退出程序</li></ul><p>即使是安装在<code>Windows</code>系统下的<code>octave</code>也是能够使用这些命令的。</p><h2 id="清空矩阵"><a href="#清空矩阵" class="headerlink" title="清空矩阵"></a>清空矩阵</h2><p>在<code>Ubuntu</code>系统中你可以直接使用<code>Ctrl+L</code>清空命令行。所有的指令会存在历史记录<code>Command History</code>栏内</p><p>当然你也可以输入<code>clc</code>并回车就能够清空命令行</p><h2 id="快速矩阵"><a href="#快速矩阵" class="headerlink" title="快速矩阵"></a>快速矩阵</h2><blockquote><p>这些<code>Octave</code>内置的快速矩阵摘自摘自<a href="https://www.youtube.com/watch?v=X0xLTKRWPgo&amp;list=PL1A2CSdiySGJ6oZe6" target="_blank" rel="noopener">油土鳖上一位印度阿三的教程</a>（英语略微有一些咖喱味，但已经很不错了）</p></blockquote><script type="math/tex; mode=display">ones(n, m) = \left[  \begin{matrix}    1, \cdots, 1\\\vdots\\    1, \cdots, 1  \end{matrix}\right]_{n\times m}\\zeros(n, m) = \left[  \begin{matrix}    0, \cdots, 0\\\vdots\\    0, \cdots, 0  \end{matrix}\right]_{n\times m}\\eye(n) = \left[  \begin{matrix}    1, 0, 0, \cdots, 0\\    0, 1, 0, \cdots, 0\\    0, 0, 1, \cdots, 0\\\vdots\\    0, 0, 0, \cdots, 1  \end{matrix}\right]_n = E\\eye(n, n + 1) = \left[  \begin{matrix}    1, 0, 0, \cdots, 0, 0\\    0, 1, 0, \cdots, 0, 0\\    0, 0, 1, \cdots, 0, 0\\\vdots\\    0, 0, 0, \cdots, 1, 0  \end{matrix}\right]_{n\times(n+1)}\\</script><p>而<code>rand(n,m)</code>则是生成<strong>n行m列</strong>的<strong>均匀分布随机数矩阵</strong>（<em>uniformly random matrix</em>），每个数字都是<strong>介于0到1之间的7位小数</strong>，且每个数字出现概率服从均匀分布$U(0, 1)$；</p><p><code>randn(n,m)</code>是生成一共<strong>n列m行</strong>的<strong>正态分布随机数矩阵</strong>（<em>normally random matrix</em>），每个数字服从正态分布$N(0, 1)$。乍一看这组数据毫无特点，实际上是$P(\mu-\sigma&lt;x&lt;\mu+\sigma)\approx0.6826$。这也就说明了为什么数字里面会有<strong>大于$1$和小于$-1$的数字了</strong></p><h2 id="矩阵构造"><a href="#矩阵构造" class="headerlink" title="矩阵构造"></a>矩阵构造</h2><p>在<code>C</code>、<code>C++</code>、<code>Java</code>、<code>C#</code>等等语言中构造矩阵永远是一个很难受的工程，拿<code>Java</code>中的<code>List&lt;List&lt;?&gt;&gt;</code>来说，向其中添加元素是一项无比复杂的工程。</p><p>而在<code>octave</code>和<code>Matlab</code>中，就只需要使用</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; s = [<span class="number">1</span>, <span class="number">2</span>; <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">s = </span><br><span class="line">  <span class="number">1</span> <span class="number">2</span></span><br><span class="line">  <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p>在这里你可以使用<strong>逗号</strong>作为分割符，也可以仅用<strong>空格</strong>作为分割符。</p><p>如果你要用<strong>克莱姆法则</strong>解多元一次方程组，那么就需要几个矩阵拆拆解解。这个时候可以把一整个矩阵当作数字：</p><ul><li><code>[A B]</code>像是<code>[1 2]</code>，将两个数字横着拼起来</li><li><code>[A; B]</code>则是<code>[1; 2]</code>，将两个数字竖着拼起来</li></ul><p>当然，我们还有矩阵的选择：</p><ul><li><code>S(m, n)</code>是选取矩阵<code>S</code>中<strong>第m行第n列</strong>的一个元素</li><li><code>S(m, [x, y, z])</code>是选择矩阵中<strong>第m行第x、y、z列</strong>的一共三个元素。如果还需要添加元素则在<code>[]</code>内追加</li><li><em>下方冒号表达式继续介绍</em></li></ul><h2 id="冒号表达式"><a href="#冒号表达式" class="headerlink" title="冒号表达式"></a>冒号表达式</h2><p>如果你熟悉<code>C</code>、<code>C++</code>、<code>Java</code>、<code>C#</code>等等（<em><code>Python</code>除外</em>），你应该会经常使用到冒号表达式，即是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出该学生是否可以购买打折的火车票</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; 学生.学生证 === null ? <span class="string">"火车票不能打折"</span> : <span class="string">"火车票可以打折"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>但是在<code>octave</code>和<code>Matlab</code>就完全不一样了。冒号表达式会这么用：<code>start[:step]:end</code>，即创建一个从<code>start</code>到<code>end</code>的数组，其中每个数字之间间隔<code>step</code>，默认<code>step</code>值为<strong>1</strong>，即依次递增。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; s = <span class="number">1</span> : <span class="number">5</span></span><br><span class="line">&gt;&gt; <span class="built_in">ans</span> =</span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line">&gt;&gt; </span><br><span class="line">&gt;&gt; s = <span class="number">1</span>:<span class="number">3</span>:<span class="number">10</span></span><br><span class="line">&gt;&gt; <span class="built_in">ans</span> =</span><br><span class="line">[<span class="number">1</span> <span class="number">4</span> <span class="number">7</span> <span class="number">10</span>]</span><br></pre></td></tr></table></figure><p>当然冒号不止这一个用途。刚刚我们说了矩阵的构造，在矩阵中冒号还能够用作选择器。</p><p>我们在选择矩阵中元素的时候会使用一个<strong>数组</strong>作为范围，而如果这个范围<strong>正好</strong>可以用冒号表示的时候，就可以是这样：</p><ul><li><p><code>S(m, [start : end])</code>，也就是说选取<strong>第m行从start开始到end结束的所有元素</strong></p></li><li><p>如果没有规定<code>start</code>和<code>end</code>，也就像是：<code>S(m, :)</code>，那么就是选取<strong>第m行一整行</strong></p></li></ul><h2 id="个数计算"><a href="#个数计算" class="headerlink" title="个数计算"></a>个数计算</h2><p><code>Java</code>中，对集合使用<code>size()</code>方法求集合内元素个数，对数组使用<code>length()</code>方法求数组内元素个数。</p><p>在<code>octave</code>中，我们两个都可以用，但是<code>size()</code>方法返回的是行和列两个数字，而<code>length</code>方法则是从<code>size()</code>方法返回的两个数字中选择一个最大的。举个例子：</p><p>假设你这个时候又闲着没事创建了一个随机数组<code>rand(5, 1)</code>，那么<code>size()</code>方法返回的是<code>[5 1]</code>两个数字，前者是行数，后者是列数；而<code>length()</code>方法返回的是<strong>5</strong>，是<strong>5</strong>和<strong>1</strong>中较大的数。</p><p>同样的，如果你只有一个数组<code>[1 2 4]</code>，<code>size()</code>方法返回的依然是<code>[1 3]</code>两个数，而<code>length()</code>方法就返回<strong>3</strong>。</p><h2 id="其他数学函数"><a href="#其他数学函数" class="headerlink" title="其他数学函数"></a>其他数学函数</h2><ul><li><code>ceil(x)</code> - 取比x大的第一个最近的整数，即向上取整</li><li><code>floor(x)</code> - 取比x小的第一个最近的整数，即向下取整</li><li><code>round(x)</code> - 取距离x最近的一个整数。如果$x=0.7$，则结果为$1$；如果$x=0.3$，则结果为$0$</li><li><code>max(x)</code> / <code>min(x)</code> - 取一个数组中最大/最小的数</li></ul><p>对于<code>max(x)</code>和<code>min(x)</code>在官方给的说明里面指明的是vector，也就是说这个函数同样适用于矩阵、向量等等。但是实际测试的时候是这样的：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; <span class="built_in">rand</span>(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"> <span class="number">0.097667</span>   <span class="number">0.295360</span>   <span class="number">0.710065</span></span><br><span class="line"> <span class="number">0.858128</span>   <span class="number">0.141471</span>   <span class="number">0.729432</span></span><br><span class="line"> <span class="number">0.073253</span>   <span class="number">0.503299</span>   <span class="number">0.379730</span></span><br><span class="line"> <span class="number">0.329683</span>   <span class="number">0.839168</span>   <span class="number">0.076656</span></span><br><span class="line"> <span class="number">0.662468</span>   <span class="number">0.514276</span>   <span class="number">0.020735</span></span><br><span class="line">&gt;&gt;</span><br><span class="line">&gt;&gt; <span class="built_in">min</span>(<span class="built_in">ans</span>)</span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"> <span class="number">0.073253</span>   <span class="number">0.141471</span>   <span class="number">0.020735</span></span><br></pre></td></tr></table></figure><p>不难发现，对比的时候将一整列作为一个数组进行纵向的对比，每一列选出了一个最小的。在上面这个例子中，数组<code>ans[0..4][0..2]</code>每一列选出了最小的，也就是<code>ans[2, 0]</code>、<code>ans[1, 1]</code>和<code>ans[3, 2]</code>。<code>max(ans)</code>也是一样的算法，只不过会每列找出一个最大的。</p><h2 id="数据集的导入和导出"><a href="#数据集的导入和导出" class="headerlink" title="数据集的导入和导出"></a>数据集的导入和导出</h2><p>如果有一天我们使用计算机去证明歌德巴赫猜想，把所有的数字塞进去日复一日地算，终于算出来了一大批数字。我们不可能使用人工一个个抄下来，肯定是让计算机自己保存。这个时候就用<code>save</code>命令让计算机保存所有的数字。</p><p>例如，我现在弄出了很大一批随机数<code>randn(1000, 1000)</code>，但是我突然发现笔记本电不够了，得保存下来。就这么使用：<code>save ${文件名} ${变量名}</code>，意思就是：将变量的值保存在指定中。当然你也可以指定别的后缀名，比如我这里选择：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">save <span class="built_in">randn</span>.json <span class="built_in">ans</span></span><br></pre></td></tr></table></figure><p>于是就有了如下效果：</p><p><img src="https://sakebow.gitee.io/images/机器学习/octave保存数据.png" alt="保存了十万条随机数"></p><p>但是呢，为了能够更直观地区分各个文件，我们尽可能按照大家默认的规矩来，这里推荐万能的<code>.csv</code>文件。更何况，我这里导出的文件并不符合<code>json</code>文件的编写规范。</p><p>就像是<code>Java</code>的导包一样，我们会使用<code>import</code>导入一整个<code>jar</code>包。而在<code>octave</code>中，我们将会使用<code>load</code>命令导入文件。</p><p>如果再次使用，我们就使用<code>load</code>命令，即：<code>load randn.dat</code>（<em>我这里是.json</em>）</p><p><strong>看起来很简单？我们再来点奇葩的：</strong></p><p>有一天你们哥几个凑一起跑数据，结果突然发现两个人风格极其相近以至于命名都完全一样。现在重新改已经很头疼了，怎么办？</p><p>我们就用<strong>临时文件</strong>。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 创建临时文件</span></span><br><span class="line">f = tmpfile</span><br><span class="line"><span class="comment">% 将变量存入临时文件</span></span><br><span class="line">save f variable</span><br><span class="line"><span class="comment">% &#123;</span></span><br><span class="line">  拿同名变量处理一大堆事情</span><br><span class="line">&#125; <span class="comment">%</span></span><br><span class="line"><span class="comment">% 读取临时文件</span></span><br><span class="line">load f</span><br><span class="line"><span class="comment">% 这个时候同名变量就被覆盖了</span></span><br></pre></td></tr></table></figure><p>打个比方的话，就像是<code>C</code>语言的<strong>局部变量</strong>和<strong>全局变量</strong>一样。</p><p>当然，这只是一个非常极端的例子，我们强烈建议各小组之间事先商量好再码字，正如<code>SpringBoot</code>所倡导的：“<strong>约束大于业务</strong>”、“<strong>习惯大于编码</strong>”</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;终于，使用&lt;code&gt;Ubuntu&lt;/code&gt;系统的我遇到了最尴尬的问题：建模工具&lt;code&gt;Matlab&lt;/code&gt;没有&lt;code&gt;linux&lt;/code&gt;发行版。虽然可以使用&lt;code&gt;wine&lt;/code&gt;勉强跑起来，但毕竟不是运行在&lt;code&gt;Windows&lt;/code&gt;内核下，所以往往有很多事情都非常尴尬。所以，我看上了这一款：&lt;code&gt;octave&lt;/code&gt;。不仅支持&lt;code&gt;Ubuntu&lt;/code&gt;，还能够兼容&lt;code&gt;Matlab&lt;/code&gt;，是非常不错的替代品。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="人工智能" scheme="http://www.sakebow.cn/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
      <category term="建模工具" scheme="http://www.sakebow.cn/tags/%E5%BB%BA%E6%A8%A1%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>梯度下降</title>
    <link href="http://www.sakebow.cn/2020/07/26/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%AE%97%E6%B3%95%E6%A8%A1%E5%9E%8B/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/"/>
    <id>http://www.sakebow.cn/2020/07/26/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%AE%97%E6%B3%95%E6%A8%A1%E5%9E%8B/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/</id>
    <published>2020-07-26T15:23:00.000Z</published>
    <updated>2020-08-01T03:24:09.400Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>你可能又觉得梯度下降是一个完全没有接触过的新词。不过放心，依然能对上。</strong></p><a id="more"></a><h2 id="方向导数和梯度"><a href="#方向导数和梯度" class="headerlink" title="方向导数和梯度"></a>方向导数和梯度</h2><p>在说明怎么进行梯度下降之前，我们需要复习一下方向导数和梯度。</p><p>就拿最简单的两个变量为例：</p><blockquote><p>下图就是一张海拔图。</p><p><img src="https://sakebow.gitee.io/images/机器学习/二元函数梯度下降演示.jpg" alt="下降演示"></p><p>有一天，你乘坐的飞机失事了，在山顶坠毁，只有你一个人活了下来。弹尽粮绝的你几近绝望。但是你看到眼前有一大片水源，你想着找到了水源就能够活下去。所以你决定在你饿倒、冻死、被野兽咬杀之前，<strong>尽快达到山底的水源</strong>，越快越好。在这种紧急情况下，已经<strong>没有时间让你把所有的路全都探索一遍</strong>了，因为你随时可能在山上出事。</p><p>在陡峭的山上，有若干个比较平缓的落脚点。你站在出发的落脚点上，环顾四周，发现了若干能够安全到达的落脚点。于是你在这几个里面选择了最低的一个，跳了过去。接着在下一个落脚点继续寻找更低的落脚点。</p></blockquote><p>这就是“<strong>下降</strong>”，而<strong>梯度</strong>则是选择一条<strong>最优下降方向</strong>的参考。</p><p>所以问题来了，怎么样才能选出<strong>最优下降方向</strong>？如果就只是找遍目力所及的所有落脚点、计算落差，这样当然可行，但是代价太大。所以，我们在这里将使用一定的<strong>数学方法</strong>推算出来。</p><p>首先对于在平面$D$（<em>海平面</em>）上具有连续一阶偏导数的二元函数$z=f(x,y)$（<em>山高计算式</em>）上的任意一点，都有一个向量：</p><script type="math/tex; mode=display">\vec{grad}f(x,y)=\{\frac{\partial f}{\partial x},\frac{\partial f}{\partial y}\}</script><p>又由于方向导数：</p><script type="math/tex; mode=display">\vec{f_L}(x_0,y_0)=({\partial f\over\partial x},{\partial f\over\partial y})\cdot(cos\theta,sin\theta)</script><p>所以，不难得出：</p><blockquote><p>方向导数是二元函数$z=f(x,y)$在各个方向上的变化量，而当方向导数最大的时候，必定是方向导数和梯度方向重合的时候。而<strong>方向导数最大时</strong>，<strong>函数增长最快</strong>；反之亦然，<strong>方向导数最大时的反方向函数减少最快</strong>。</p><p>也就是说，我们在下山的时候唯一需要注意的就是：寻找梯度。</p></blockquote><p>当然我们还有一些需要注意的细节，<strong>下山的速度</strong>就是其中之一，它有个学术名称叫做<strong>学习率（<em><code>learning rate</code></em>）</strong>，多记为$\eta$。当学习率提高的时候，下山的速率就非常快，很快你就会达到一个区域最优解，但也可能因为步长太大忽略了某个关键点甚至可能导致不收敛；而学习率降低的时候，下山速率就非常低，只不过这样的话你能够找到更多的落脚点，从而一定程度上减少了陷入局部最优解的可能。</p><p>拿下面这个图举个例子：</p><p><img src="https://sakebow.gitee.io/images/机器学习/梯度说明图.png" alt="梯度说明"></p><p>很清楚地看到，在$x\in(0,1)$和$x\in(4,5)$的时候，函数下降速度和上升速度都非常快，这个时候可以<strong>适当减少学习率</strong>，就像是<strong>单机FPS游戏里放慢步伐寻找隐藏点</strong>一样，避免错过了任何一个细节。但是过小的步伐会导致收敛速度非常慢，一直再重复无效的学习；而在$x\in(1,4)$的时候，函数不管是上升还是下降都非常缓慢，基本没有什么起伏，可以<strong>适当加快步伐</strong>，就像是<strong>GalGame二刷回收CG</strong>一样，只抓重点，忽略细节。但是过大的步伐会导致你忽略掉$x\in(3,4)$的极值点。</p><p>总的来说，<strong>步长小了可能会陷入局部最优解；而步长大了可能会离最优解越来越远，最终得出错误的结果</strong>。</p><p><em>不过呢，三维我们还能勉强想象，但是拓展到四维、五维等超越3个维度的坐标系时，作为三次元的我们将无法想象那样的存在。所以，我们目前所能做的极限就是讨论三元变量的关系了。有没有三维以上的方向导数解法？当然有，本篇说明的就是<strong>通用解法</strong>，只不过对于三维以上的数据就<strong>无法说明几何意义</strong>了。</em></p><h2 id="梯度下降是什么"><a href="#梯度下降是什么" class="headerlink" title="梯度下降是什么"></a>梯度下降是什么</h2><p>经过复习，聪明的你应该能够明白，所谓梯度下降即是：</p><ul><li><p>从图像的意义上来看，就可以总结为：任意选取一个落脚点，然后搜索周边看能不能找到更低的落脚点。这个点不出意外的话应该在梯度方向的反方向上。</p></li><li><p>从数学的意义上来看，就可以总结为：任意选取<strong>损失函数</strong>上的一个点，一步一步寻找区域极值，并坚信其中一个极值是全域最小值，逐渐逼近使得<strong>损失函数</strong>的值最小的点。</p></li></ul><p><em>数学的角度听起来有点贪心算法的味道了？有一说一，确实。当然，不出意外的话，极值中确实会有最值；只不过时常会有意外，也就是说，最值不在极值中，而是在边界。</em></p><p>“<strong>不识庐山真面目，只缘身在此山中</strong>”。这也正是贪心算法的“贪心”所在啊，偏偏想要<strong>使用最少的次数碰运气似的找到最优解</strong>。实际上，你朝梯度的反方向看到的“<strong>最低点</strong>”，也仅仅是通过一般的数学计算才出现的<strong>预测的点</strong>，实际最低点甚至可能出现在<strong>任何地方</strong>。虽然异常的尴尬，但这也正是贪心算法想要解决的，不是么？起码7位数的数据遍历起来实在是有点难受啊……</p><h2 id="为什么选择梯度下降"><a href="#为什么选择梯度下降" class="headerlink" title="为什么选择梯度下降"></a>为什么选择梯度下降</h2><p>这个方法不仅用于线性方程求解，而且还适用于机器学习的很多个领域。找到代价函数最小值和各维度的值，同时找出根据很多自变量变化的因变量拟合函数，可以在非常多的方面说明问题，比如<strong>决策</strong>、<strong>推荐</strong>、<strong>预测</strong>、<strong>分类</strong>等等。</p><p>其实最重要的是，他能够用比较低的时间复杂度找到最好的一个解。这对于信息爆炸式增长的今天是非常有必要的。中国14亿人，就算只有一半的网民，也是7亿的并发量；面对这7亿用户的偏好分析，实在是等不起十几天慢慢磨出一份精简的报告。</p><h2 id="随机梯度下降"><a href="#随机梯度下降" class="headerlink" title="随机梯度下降"></a>随机梯度下降</h2><p>好了，现在开始进入正题：梯度下降的步骤。</p><p>我们先不要弄得太复杂，还是老例子：</p><blockquote><p>时间回溯到你研究猫娘食量那会。你确确实实拿到了20万数据，每个数据都是以（年龄，食量）这样的坐标形式出现。这看起来没什么问题，只不过你突然发现猫娘们的食量增长速度在成年之后随着年龄的增长而不断趋于平稳，成年之前却疯狂增长。你觉得线性方程不再适用。这样的函数你似乎希望是对数函数，可是这是不是因为有其他因素的影响？</p><p>于是，你凭着对猫娘疯狂的热爱，开始了第二波数据收集。这次你拿到了年龄(age)、身高(height)、体重(weight)和食量(quantity)四个数据，构成了函数$Q=f(a,h,w)$。</p></blockquote><p>这次涉及了三个维度和一个自变量，虽然复杂了很多，但也勉强能够画出来。只不过梯度下降的图像意义便不再是<strong>下山</strong>了，而是构建一个平面或者瞄准某一个中心。</p><blockquote><p><del>你凭着自己的性癖</del>……你随机选择了一位猫娘，将她的数据使用矩阵形式记录了下来：</p><script type="math/tex; mode=display">neko_0=\left[\begin{matrix}  a_0\\h_0\\w_0\end{matrix}\right]</script><p>紧接着，下一个数据就是：</p><script type="math/tex; mode=display">neko_1=\left[\begin{matrix}  a_1\\h_1\\w_1\end{matrix}\right]=\left[\begin{matrix}  a_0\\h_0\\w_0\end{matrix}\right]-\eta\left[\begin{matrix}{\partial\over\partial a} f(a_0,h_0,w_0)\\{\partial\over\partial h} f(a_0,h_0,w_0)\\{\partial\over\partial w} f(a_0,h_0,w_0)\end{matrix}\right]</script></blockquote><p>当然，$neko_1$是有实际数值的，而使用<code>学习率</code>、$neko_0$和<code>损失函数的偏导数</code>计算出来的$neko_1$并不是真实的数据。那么使用哪一个数据？当然是都使用。因为现在猫娘的食量和年龄变成了非线性关系，也就是说在<strong>x取值范围同样长的情况下</strong>，不同取值范围中函数的<strong>变化量不一样</strong>，部分密集，部分稀疏。所以应对<strong>密集部分</strong>我们需要<strong>加大学习率</strong>，尽快过渡到稀疏部分，从而减少重复学习的时间；应对<strong>稀疏部分</strong>我们要<strong>减少学习率</strong>，尽量避免忽略了重要区间的情况。</p><blockquote><p>好了，现在你通过数学计算拿到了$neko_1$，于是你准备获取$neko_2$。同样的，代入公式：</p><script type="math/tex; mode=display">neko_2=\left[\begin{matrix}  a_2\\h_2\\w_2\end{matrix}\right]=\left[\begin{matrix}  a_1\\h_1\\w_1\end{matrix}\right]-\eta\left[\begin{matrix}{\partial\over\partial a} f(a_1,h_1,w_1)\\{\partial\over\partial h} f(a_1,h_1,w_1)\\{\partial\over\partial w} f(a_1,h_1,w_1)\end{matrix}\right]</script><p>经过一番辛苦，你也得出来了这个数据。但是你实在算不下去了，虽然对猫娘包含热情，但是在完全机械的计算过程中，再怎么高涨的热情都会逐渐被消耗殆尽。于是你希望计算机能够帮助运算，便大致写下了一串伪代码：</p><p><code>repeat until convergence {</code></p><script type="math/tex; mode=display">\left[\begin{matrix}  a_i\\h_i\\w_i\end{matrix}\right]:=\left[\begin{matrix}  a_i\\h_i\\w_i\end{matrix}\right]-\eta\left[\begin{matrix}  {\partial\over\partial a} f(a_i,h_i,w_i)\\  {\partial\over\partial h} f(a_i,h_i,w_i)\\  {\partial\over\partial w} f(a_i,h_i,w_i)\end{matrix}\right]</script><p><code>}</code></p></blockquote><p><em>伪代码中<code>=</code>和<code>:=</code>略有区别，分别是<strong>相等</strong>和<strong>赋值</strong>的意思</em></p><p>这样看似乎没有什么大问题，但是在实际代码实现中，我们尤其需要注意一个很难注意到的细节：</p><p><strong>这个矩阵形式的写法意味着$a_i$、$h_i$、$w_i$是同步更新的！！！</strong></p><p><strong>这个矩阵形式的写法意味着$a_i$、$h_i$、$w_i$是同步更新的！！！</strong></p><p><strong>这个矩阵形式的写法意味着$a_i$、$h_i$、$w_i$是同步更新的！！！</strong></p><p>重要的事情说三遍！如果不是同步的话，<strong>错误的梯度下降</strong>伪代码将会变成这样：</p><blockquote><p><code>repeat until convergence {</code></p><script type="math/tex; mode=display"> temp_a={\partial\over\partial a} f(a_i,h_i,w_i)\cdots①\\ a_i = temp_a\\ temp_h={\partial\over\partial h} f(a_i,h_i,w_i)\cdots②\\ \ldots</script><p><code>}</code></p></blockquote><p>注意到了吗？①式和②式中，$a_i$的值不同了！这是严重的逻辑错误！</p><p><strong>正确的梯度下降</strong>伪代码就应该是这样：</p><blockquote><p><code>repeat until convergence {</code></p><script type="math/tex; mode=display"> temp_a=a_i-\eta{\partial\over\partial a} f(a_i,h_i,w_i)\\ temp_h=h_i-\eta{\partial\over\partial h} f(a_i,h_i,w_i)\\ temp_w=w_i-\eta{\partial\over\partial w} f(a_i,h_i,w_i)\\ a_i = temp_a\\ h_i = temp_h\\ w_i = temp_w</script><p><code>}</code></p></blockquote><p><strong>要么全部修改，要么全不修改</strong>。像极了数据库的<strong>原子性</strong>不是么？</p><p><em>在说明时我强调了是<strong>错误的梯度下降伪代码</strong>，而不是<strong>错误的伪代码</strong>，这是因为这本来就是一种正确的算法，但不是梯度下降，而是一种其他的什么代码。这就要各位读者继续读下去来寻找正确答案了。</em></p><p>没错，这就是通用解法，无论多少维，用这个矩阵解法都会有一个结果。随着学习的进行，导数或者偏导数都会逐渐变化，$\eta$也应当随之而变化。他也有另外一个名字，叫<strong>随机梯度下降</strong>，因为我们刚刚是随机选择初始点、根据梯度寻找下一跳、逐步靠近最优解，所以收敛的时候有很大的随机性，收敛时也会在局部最优附近疯狂抖动。还是用个反常的例子类比：</p><blockquote><p>你的猫娘很生气，你想逗她开心。你身边有很多东西，毛球、老鼠玩具、吉他、钢琴等等。你知道这些她都喜欢，但是你不知道这次怎么样才能让她开心。于是你开始疯狂试探。</p><p>有时候她笑了一下，有时候又挠你几下，有时候保持冷漠……在心情在变好和变坏之间反复横跳。最后，你终于拿出口琴吹起了她喜欢的音乐，把她哄好了。</p></blockquote><p>当然，公式归公式，解法是解法，这两个可以不需要严格意义上保持一致。也就是说，如果$f(a,h,w)$在求导的时候极大地增加了复杂度，就比如$\sqrt{\frac{1+sinx}{1-cosx}}$，我们可以人为地分段、化简，变成方便计算的其他公式，就像吴恩达教授的视频课程中将线性方程$Y=\beta_0+\beta_1x$中待定系数的求解从二次通过求导降为一次。（<em>如果你不清楚为什么是二次，请查看我之前写的<a href="/2020/07/26/人工智能/算法模型/代价函数">代价函数</a>一文</em>）</p><h2 id="一个尴尬的细节"><a href="#一个尴尬的细节" class="headerlink" title="一个尴尬的细节"></a>一个尴尬的细节</h2><p>好了，到了这里，相信各位读者对梯度下降也有一定的了解了。那么，各位有没有注意到一个小小的细节：<strong>我们是为什么需要根据一定的步长移动</strong>？其实是基于“<strong>最初随机选到的点并不是极值点</strong>”这一前提下展开的。那么我们就极端一点，最初就那么运气不好，选到了极值点，会怎么样呢？很显然，极值点的导数或偏导数都是0，最终我们的计算式也就化简成为了：</p><script type="math/tex; mode=display">\left[\begin{matrix}  a_i\\h_i\\w_i\end{matrix}\right]:=\left[\begin{matrix}  a_i\\h_i\\w_i\end{matrix}\right]-\eta\left[\begin{matrix}  {\partial\over\partial a} f(a_i,h_i,w_i)\\  {\partial\over\partial h} f(a_i,h_i,w_i)\\  {\partial\over\partial w} f(a_i,h_i,w_i)\end{matrix}\right]=\left[\begin{matrix}  a_i\\h_i\\w_i\end{matrix}\right]-\eta\times0=\left[\begin{matrix}  a_i\\h_i\\w_i\end{matrix}\right]</script><p>也就是说在这里我们将原地踏步。如果这里并不是全域最优解，而是局部最优解，我们也就像一开始介绍梯度下降是所说的一样：<strong>陷入局部最优解</strong>。这也正是<strong>步长过小</strong>造成的<strong>必然结果</strong>。</p><p>当然，既然有让你陷入局部最优解的情况，也有只能收敛到全局最优解的情况。用比较学术一点的话来说，就是“<strong>目标函数$f(a,h,w)$是一个凹函数</strong>”（<em>国外这里叫<strong>凸函数</strong>，因为看的方向不一样所以叫法不一样</em>），即目标函数的二阶偏导数<strong>恒大于0</strong>。这就导致一阶偏导数最多也就1个零点，即最多有一个极值，原函数要么是个碗，极值即最值；要么就单调，端点是最值。</p><p>很尴尬，也很无奈。当然办法还是有的，也就是<strong>贪心算法</strong>。这就依靠大家打怪升级之后解锁新篇章了，这里只介绍这么多有关梯度的内容。</p><h2 id="批量（Bacth）梯度下降"><a href="#批量（Bacth）梯度下降" class="headerlink" title="批量（Bacth）梯度下降"></a>批量（<code>Bacth</code>）梯度下降</h2><p>我相信你会等不及找答案的。所以这里提供一个临时的解决办法：批量梯度下降。</p><p>为什么是批量？在这里我们每次迭代都会整个训练集都试一遍，然后找到一个局部最优解，然后剪枝，重新遍历整个数据集，然后又找到下一个局部最优解，再剪枝……整个过程将会行走在非常标准的直通线路上。</p><p>当然，缺点也非常明显，整个训练一遍意味着需要大量的内存和大量的计算。如果训练集足够大，内存将无法一次性执行完，要么直接<code>OutOfMemoryException</code>，要么在内存加载的内容全部计算完后等待磁盘经过漫长的时间加载所需的下一批数据。整体来说还是相当的憋屈，所以也在逐渐的弃用这个方法。</p><p>是不是有点能理解了呢？</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>在吴恩达教授的课程中，解向量是这么求的：</p><script type="math/tex; mode=display">\left[\begin{matrix}  a_i\\h_i\\w_i\end{matrix}\right]:=\left[\begin{matrix}  a_i\\h_i\\w_i\end{matrix}\right]-\eta\left[\begin{matrix}  {\partial\over\partial a} f(a_0,h_0,w_0)\\  {\partial\over\partial h} f(a_0,h_0,w_0)\\  {\partial\over\partial w} f(a_0,h_0,w_0)\end{matrix}\right]</script><p>其中在循环之中不停调整$a_0$、$h_0$、$w_0$的值。实际上这么做的核心目的依然是保持同步，只不过用本篇所讲述的方法是普遍都在使用的方法，因为看起来更简洁。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;你可能又觉得梯度下降是一个完全没有接触过的新词。不过放心，依然能对上。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="人工智能" scheme="http://www.sakebow.cn/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
      <category term="算法模型" scheme="http://www.sakebow.cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Hexo添加数学公式渲染器</title>
    <link href="http://www.sakebow.cn/2020/07/26/hexo/hexo%E6%B7%BB%E5%8A%A0%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E6%B8%B2%E6%9F%93%E5%99%A8/"/>
    <id>http://www.sakebow.cn/2020/07/26/hexo/hexo%E6%B7%BB%E5%8A%A0%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E6%B8%B2%E6%9F%93%E5%99%A8/</id>
    <published>2020-07-26T01:47:00.000Z</published>
    <updated>2020-07-26T15:37:39.753Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong><code>markdown</code>作为非常强大的编辑器，在公式编辑和网页兼容上做的非常不错。但是，还是有非常多没能兼顾的地方，这里就以我正在使用的<code>NexT</code>主题为例详细讲述公式编辑插件的安装。参考教程为<code>ShadowLearner</code>的<a href="https://www.jianshu.com/p/7ab21c7f0674" target="_blank" rel="noopener">在Hexo中渲染MathJax数学公式</a>一文。</strong></p><a id="more"></a><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>如果你是<code>Windows</code>系统，直接使用<code>Git Bash</code>的命令行在<code>Hexo</code>根目录下使用命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure><p>即删除默认的<code>hexo-renderer-marked</code>插件、安装<code>hexo-renderer-kramed</code>插件。</p><p>如果你是<code>Ubuntu</code>系统，请使用超管权限：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo npm uninstall hexo-renderer-marked --save</span><br><span class="line">sudo npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure><p>否则<code>NodeJS</code>就根本不会卸载或下载。</p><p>当然，其他的教程上也说明了语义冲突，你也可以对根目录下的<code>/node_modules/kramed/lib/rules/inline.js</code>稍加修改：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var inline = &#123;</span><br><span class="line">  // 第2行修改</span><br><span class="line">  escape: /^\\([`*\[\]()#$+\-.!_&gt;])/,</span><br><span class="line">  ...</span><br><span class="line">  // 第20行修改（也可能是21行）</span><br><span class="line">  em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="打开开关"><a href="#打开开关" class="headerlink" title="打开开关"></a>打开开关</h2><p>教程中会有很多说明要打开开关，于是你无脑地复制了教程中的代码，贴在了自己的配置中，然后发现一点动静都没有，怒砸电脑。</p><p>实际上，你应该这么想：既然是有人已经做成了类似<code>SpringBoot</code>这种开箱即用的插件式模块，那么肯定是所有配置都齐全了的。所以，找到根目录下的<code>/themes/next/_config.yml</code>文件，按下<code>Ctrl+F</code>，在弹出的搜索框中输入<code>mathjax</code>查找匹配项，然后你找到了这样几行字：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># MathJax Support</span></span><br><span class="line"><span class="attr">mathjax:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">cdn:</span> <span class="string">//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML</span></span><br></pre></td></tr></table></figure><p><img src="https://sakebow.gitee.io/images/hexos/mathjax配置位置.png" alt="查到配置的位置"></p><p>把所有的<code>false</code>改成<code>true</code></p><p><code>enable</code>就是配置<code>mathjax</code>插件的启用与否；而<code>per_page</code>则是确认渲染所有还是逐个查找开启渲染的页进行渲染。</p><h2 id="页面渲染"><a href="#页面渲染" class="headerlink" title="页面渲染"></a>页面渲染</h2><p>这是在<code>per_page</code>配置为<code>true</code>的基础上才需要做的。如果你删除了这个配置项，那么就是默认选择<code>false</code>；如果你依然保持<code>false</code>，那么所有的页面将会渲染，这一步对你来说没有意义；如果你选择了<code>true</code>，那么你需要在<code>Hexo</code>的标题区（学术一点的称呼是<code>Front-matter</code>）中声明：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">这里是标题</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2020</span><span class="number">-07</span><span class="number">-26</span> <span class="number">09</span><span class="string">:27</span></span><br><span class="line"><span class="attr">categories:</span> <span class="string">自定义分类</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">自定义标签1</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">自定义标签2</span></span><br><span class="line"><span class="attr">mathjax:</span> <span class="literal">true</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>于是，你就可以使用<code>mathjax</code>作为你的公式渲染器了。</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>使用时即使使用``包裹住依然会被强行转码，所以尽可能在不需要转码的地方使用</p><p>为了给大家看看效果，这里就摆出所有可以使用的公式：</p><blockquote><p>以下内容全部整理自<strong>DanielGavin</strong>的<a href="https://www.jianshu.com/p/e74eb43960a1" target="_blank" rel="noopener"><code>Markdown</code>数学公式语法</a>一文。</p></blockquote><h3 id="单项式"><a href="#单项式" class="headerlink" title="单项式"></a>单项式</h3><ul><li><p>一对<code>$</code>包裹的就是嵌入一行文字内任意位置的公式： $xyz$</p></li><li><p>两对就是单独另起一行的公式：</p></li></ul><script type="math/tex; mode=display">abc</script><ul><li><p>用<code>^</code>标记含有上标的公式：$x^4y$</p></li><li><p>绝对值能够开平方：${\sqrt[2]{x^2}}=|x|$</p></li><li><p>用对数表示时间复杂度：$O(n\log_2(n))$</p></li><li><p>硫代硫酸根的化学式：${S}_{2}O_{3}^{2-}$</p></li></ul><h3 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h3><ul><li><p>x的<strong>向量</strong>（<em>也叫<strong>矢量</strong></em>）：$\vec{x}$</p></li><li><p>a的<strong>最小二乘估计量</strong>：$\hat{a}$</p></li><li><p>a的<strong>样本平均值</strong>：$\bar{a}$</p></li><li><p>函数$f(x)$的<strong>一阶导数</strong>：$\dot{f(x)}$</p></li><li><p><strong>二阶导数</strong>：$\ddot{f(x)}$</p></li><li><p>$f(x)$在一个范围内<strong>单调递增</strong>。这里的<code>uparrow</code>可以把<code>U</code>大写</p></li><li><p>极限里面的<strong>x趋近于0</strong>：$x\rightarrow0$，也可以用$\to$。两者虽然不同，但是非常相似，看你的喜好。趋近于无穷就是$x\to\infty$</p></li><li><p>限定范围：$\forall x\in\mathbb{R}，s.t.\dot{f(x)}^2=\ddot{f(x)f(x)}$</p></li></ul><h3 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h3><ul><li><p>普通的两项相加：$x+y$</p></li><li><p>虚数：$2-\imath$</p></li><li><p>二元虚数：$a\imath+b\jmath$</p></li><li><p>表示误差：$20\pm0.5$</p></li><li><p>分段函数：</p></li></ul><script type="math/tex; mode=display">y=\left\{\begin{aligned}-x+10 &,  &x  &\in  &(-\infty, -10) \\20    &,  &x  &\in  &(-10, 10)      \\x+10  &,  &x  &\in  &(10, +\infty)\end{aligned}\right.</script><ul><li>化学方程式</li></ul><script type="math/tex; mode=display">2H_2O_2 \xlongequal[\Delta]{M_nO_2} 2H_2O+O_2\uparrow</script><ul><li>化学表达式</li></ul><script type="math/tex; mode=display">C_{6}H_{12}O_{6} \xrightarrow{酶} H_2O+CO_2+ATP</script><ul><li><p>常用多项式展开式</p><ul><li><strong>三次方的展开式</strong>：</li></ul></li></ul><script type="math/tex; mode=display">a^3 \pm b^3 = (a \pm b)(a^2 \mp ab + b^2)</script><ul><li><strong>泰勒展开式</strong>：</li></ul><script type="math/tex; mode=display">e^x = 1 + x + {1\over2!}x^2 + {\frac{1}{3!}}x^3</script><ul><li><p>逻辑运算也是毫无压力的：</p><ul><li><p>大于小于等于没有区别，分别是：$x+y&gt;z$、$x+y&lt;z$、$x+y=z$</p></li><li><p>大于等于：$x+y \geq z$。这里由于<code>geq</code>可能会和<code>z</code>连在一起变成歧义，所以<strong>必须要有个空格</strong>避免歧义。下同。</p></li><li><p>小于等于：$x+y \leq z$</p></li><li><p>不等于：$x+y \neq z$</p></li><li><p>不大于等于：$x+y \ngeq z$</p></li><li><p>不小于等于：$x+y \nleq z$</p></li><li><p>约等于：$x+y \approx z$</p></li><li><p>恒等于：$x+y \equiv z$</p></li></ul></li><li><p>集合运算：</p><ul><li><p>表示<strong>元素x</strong>属于<strong>集合y</strong>：$x \in y$</p></li><li><p>表示<strong>元素x</strong>不属于<strong>集合y</strong>：$x \notin y$，当然也可以是$x \not\in y$</p></li><li><p>表示<strong>集合x</strong>的全部元素和<strong>集合y</strong>的部分元素相同：$x \subset y$</p></li><li><p>表示<strong>集合y</strong>的全部元素和<strong>集合x</strong>的部分元素相同：$x \supset y$。和刚刚的区别就是，开口向哪边，哪边就比较大。下同。</p></li><li><p>表示<strong>集合x</strong>的全部元素和<strong>集合y</strong>的一部分元素相同，但<strong>集合y</strong>还有<strong>集合x</strong>所没有的元素：$x \subseteq y$。和<code>subset</code>的区别在于这里明确说明了<strong>集合y</strong>比<strong>集合x</strong>更多，而<code>subset</code>没有说明，可以多，可以等，但不能少。</p></li><li><p>表示<strong>集合x</strong>是<strong>集合y</strong>的真子集，也就是说，<strong>集合y</strong>包含了<strong>集合x</strong>的全部元素，但是<strong>集合y</strong>和<strong>集合x</strong>不能完全相等：$x \subsetneq y$</p></li><li><p>$x \supseteq y$</p></li><li><p>$x \supsetneq y$</p></li><li><p>$x \not\subset y$</p></li><li><p>$x \not\supset y$</p></li><li><p>表示<strong>集合x</strong>和<strong>集合y</strong>所有元素合成新集合，但是要剔除重复的：$x \cup y$</p></li><li><p>表示选出<strong>集合x</strong>和<strong>集合y</strong>相同的元素组成新集合：$x \cap y$</p></li><li><p>表示将<strong>集合x</strong>中的元素选出和<strong>集合y</strong>相同的元素并删除，剩下的组合成新集合：$x \setminus y$</p></li><li><p>实数集合：$\mathbb{R}$</p></li><li><p>自然数集合：$\mathbb{Z}$</p></li><li><p>空集：$\emptyset$</p></li><li><p>同或运算，如：$x \bigodot y$</p></li><li><p>同与运算，如：$x \bigotimes y$</p></li></ul></li></ul><h3 id="高级运算"><a href="#高级运算" class="headerlink" title="高级运算"></a>高级运算</h3><ul><li>找规律类的给定项数运算，也可以求均值：</li></ul><script type="math/tex; mode=display">\overline{a}=\overbrace{a_1+a_2+ \cdots +a_n}^{200}=E(a)</script><ul><li>求一元极限：</li></ul><script type="math/tex; mode=display">\lim_{x \to 0} (1 + x)^{1 \over x} = e</script><ul><li>求二元极限：</li></ul><script type="math/tex; mode=display">\displaystyle \lim^{x \to \infty}_{y \to \infty}{\frac{(xy)^2}{x^2+y^2}}</script><ul><li>级数求和：</li></ul><script type="math/tex; mode=display">\sum^{n \rightarrow \infty}_{i=1}{\frac{i}{n^2}} = {1\over2}</script><ul><li>级数化简：</li></ul><script type="math/tex; mode=display">\sum^{n \rightarrow \infty}_{i=1}{\frac{i}{n^2}} = \int^1_0{xdx} = \frac{x^2}{2} | ^1_0 = {1\over2}</script><ul><li>偏微分:</li></ul><script type="math/tex; mode=display">\int^{+\infty}_{-\infty}\int^{+\infty}_{-\infty}\frac{\partial f(x,y)}{\partial y} dx + \frac{\partial f(x,y)}{\partial x} dy</script><ul><li>矩阵</li></ul><script type="math/tex; mode=display">\left[\begin{matrix}  a+b   &a      &0      &\cdots &0      &0\\  b     &a+b    &a      &\cdots &0      &0\\  0     &b      &a+b    &\cdots &0      &0\\  \vdots&\vdots &\vdots &\ddots &\vdots &\vdots\\  0     &0      &0      &\cdots &a+b    &a\\  0     &0      &0      &\cdots &b      &a+b\\\end{matrix}\right]_n = \frac{a^{n+1}-b^{n+1}}{a-b}</script><h3 id="希腊符号"><a href="#希腊符号" class="headerlink" title="希腊符号"></a>希腊符号</h3><p><strong>注：<code>代码</code>栏首字母大写只能写出部分字母，而其他和英文字母重复的则不被支持</strong></p><div class="table-container"><table><thead><tr><th>大写</th><th>字符</th><th>代码</th></tr></thead><tbody><tr><td>A</td><td>$\alpha$</td><td>\alpha</td></tr><tr><td>B</td><td>$\beta$</td><td>\beta</td></tr><tr><td>$\Gamma$</td><td>$\gamma$</td><td>\gamma</td></tr><tr><td>$\Delta$</td><td>$\delta$</td><td>\delta</td></tr><tr><td>E</td><td>$\epsilon$</td><td>\epsilon</td></tr><tr><td>Z</td><td>$\zeta$</td><td>zeta</td></tr><tr><td>H</td><td>$\eta$</td><td>\eta</td></tr><tr><td>$\Theta$</td><td>$\theta$</td><td>\theta</td></tr><tr><td>I</td><td>$\iota$</td><td>\iota</td></tr><tr><td>K</td><td>$\kappa$</td><td>\kappa</td></tr><tr><td>$\Lambda$</td><td>$\lambda$</td><td>\lambda</td></tr><tr><td>M</td><td>$\mu$</td><td>\mu</td></tr><tr><td>N</td><td>$\nu$</td><td>\nu</td></tr><tr><td>$\Xi$</td><td>$\xi$</td><td>\xi</td></tr><tr><td>O</td><td>$\omicron$</td><td>\omicron</td></tr><tr><td>$\Pi$</td><td>$\pi$</td><td>\pi</td></tr><tr><td>P</td><td>$\rho$</td><td>\rho</td></tr><tr><td>$\Sigma$</td><td>$\sigma$</td><td>\sigma</td></tr><tr><td>T</td><td>$\tau$</td><td>\tau</td></tr><tr><td>$\Upsilon$</td><td>$\upsilon$</td><td>\upsilon</td></tr><tr><td>$\Phi$</td><td>$\phi$</td><td>\phi</td></tr><tr><td>X</td><td>$\chi$</td><td>\chi</td></tr><tr><td>$\Psi$</td><td>$\psi$</td><td>\psi</td></tr><tr><td>$\Omega$</td><td>$\omega$</td><td>\omega</td></tr></tbody></table></div><h2 id="最后给点小玩意"><a href="#最后给点小玩意" class="headerlink" title="最后给点小玩意"></a>最后给点小玩意</h2><p>当然，<code>markdown</code>也并不是万能的，因为还有很多类似序号等特殊段首标记无法打出来。<code>Windows10</code>现在自带的微软输入法可能会带这些东西，但是<code>Ubuntu</code>的<code>iBus-pinyin</code>就是没有，很无奈，所以在这里贴出来一些：</p><blockquote><p>⓪ ① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ ㉑ ㉒ ㉓ ㉔ ㉕ ㉖ ㉗ ㉘ ㉙ ㉚ ㉛ ㉜ ㉝ ㉞ ㉟ ㊱ ㊲ ㊳ ㊴ ㊵ ㊶ ㊷ ㊸ ㊹ ㊺ ㊻ ㊼ ㊽ ㊾ ㊿</p><p>⓿ ❶ ❷ ❸ ❹ ❺ ❻ ❼ ❽ ❾ ❿⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴</p><p>——摘自<strong>Applied Sciences</strong>的<a href="https://blog.csdn.net/appleyuchi/article/details/84036985" target="_blank" rel="noopener">带圆圈的数字和markdown常用表达式记录(持续更新中)</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;markdown&lt;/code&gt;作为非常强大的编辑器，在公式编辑和网页兼容上做的非常不错。但是，还是有非常多没能兼顾的地方，这里就以我正在使用的&lt;code&gt;NexT&lt;/code&gt;主题为例详细讲述公式编辑插件的安装。参考教程为&lt;code&gt;ShadowLearner&lt;/code&gt;的&lt;a href=&quot;https://www.jianshu.com/p/7ab21c7f0674&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;在Hexo中渲染MathJax数学公式&lt;/a&gt;一文。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hexo" scheme="http://www.sakebow.cn/categories/Hexo/"/>
    
    
      <category term="NexT主题踩坑" scheme="http://www.sakebow.cn/tags/NexT%E4%B8%BB%E9%A2%98%E8%B8%A9%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>代价函数</title>
    <link href="http://www.sakebow.cn/2020/07/26/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%AE%97%E6%B3%95%E6%A8%A1%E5%9E%8B/%E4%BB%A3%E4%BB%B7%E5%87%BD%E6%95%B0/"/>
    <id>http://www.sakebow.cn/2020/07/26/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%AE%97%E6%B3%95%E6%A8%A1%E5%9E%8B/%E4%BB%A3%E4%BB%B7%E5%87%BD%E6%95%B0/</id>
    <published>2020-07-26T01:27:00.000Z</published>
    <updated>2020-07-30T08:52:53.761Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>这里将会从一个简单的例子引入话题。例子是一个自变量和一个因变量构成的一元一次函数。因为同时兼顾了有趣和浅显，例子也是相当的乱来，能会意就行，吐槽就免了吧。</strong></p><a id="more"></a><h2 id="回归函数"><a href="#回归函数" class="headerlink" title="回归函数"></a>回归函数</h2><p>在说明代价函数前我们先复习回归函数。</p><blockquote><p>现在你突发奇想，想知道<strong>猫娘年龄和猫粮食用量之间的关系</strong>，你跑遍了全世界找了所有的<strong>20万只猫娘</strong>，问到了食量，作了个匿名记录，记下了<strong>年龄</strong>和<strong>食量</strong>的关系，并总结出了一张<strong>散点图</strong>。你看着你家幼小的猫娘，看了看散点表，<strong>预测</strong>出了她这个年龄大概吃多少。当然，你非常疼爱你的猫娘，<strong>不够吃的话肯定还是会加</strong>，<strong>吃不下也会多加调整</strong>。</p><p><img src="https://sakebow.gitee.io/images/background/illust_80183815_20200714_143825.jpg" width="200" alt="pid=143825"></p></blockquote><p><strong>我知道你很想吐槽，现在憋着。</strong></p><p>首先，通过这个例子，我们先重点强调一些细节：</p><ul><li><p>十几万只猫娘是你的<strong>样本容量</strong>，虽然数量不是很大，但是足以说明问题；</p></li><li><p>这里自变量是年龄，因变量是食量，只是一个单纯的<strong>一元一次方程</strong>;</p></li><li><p>虽然能够收集非常多数据，但是你<strong>只能画出散点图</strong>；</p></li><li><p>你需要为你的小猫娘<strong>预测</strong>食量；</p></li></ul><p>明白了这些细节之后，我们应该怎么操作呢？从初中到大学我们学到的<strong>线性回归方程</strong>就是为了这个问题服务的。</p><p>通过散点图，你可以使用一条直线贯穿大部分的点，一些<strong>少有偏离可能是个体差异</strong>，比如活泼、好动、成长期<del>还有发情期</del>等等；同样也一定有<strong>过于偏离</strong>这条直线的散点数据，<strong>少量则有可能是记录错误</strong>，而大量的话要么是<strong>有其他决定条件</strong>，要么是<strong>数学模型选择错误</strong>。<strong>这里我们就假定没有其他条件而且数学模型就是一元一次函数</strong>。</p><p>如果你大学认真学习了《概率论与数理统计》，那么你应该对线性回归方程不陌生。</p><p>于是你熟练地写出：</p><blockquote><p>猫娘的食量<code>Y</code>和猫娘的年龄<code>x</code>之间有线性关系，设</p><p>Y = $\beta_0$ + ${\beta_1}x+\epsilon$，其中$\beta_0$和$\beta_1$是待定系数，$\epsilon$是随机误差，满足$\epsilon$~$N(0,\sigma^2)$</p></blockquote><p>既然$\epsilon$服从正态分布，那么<code>Y</code>呢？</p><p>由于<code>Y</code>与<code>x</code>的关系为线性关系，所以就有：</p><p>$EY=E(\beta_0+{\beta_1}x)=\beta_0+{\beta_1}E(x)$</p><p>所以你接着写下：</p><blockquote><p>依题意，$Y$~$N(\beta_0+{\beta_1}x,\sigma^2)$</p></blockquote><p>你可能会怀疑到这一步能够得出什么。这个只能说在一定的正确率范围内预测这个事实，而不能完完全全的当作必然。</p><p>那么，怎么预测呢？在这个只有离散型数据的图表中，如何才可以制定一个尽可能正确的线性方程呢？这就需要<strong>最小二乘估计</strong>。</p><p>我们先忽略$\epsilon$的影响，因为无法预测；然后将线性方程简化为我们能够预测的样子，并将我们所收集的样本值一一对应进去。所以你写着：</p><script type="math/tex; mode=display">\hat{y_i}=\hat{\beta_0}+\hat{\beta_1}x_i</script><p>需要注意的是，这个是我们的预测函数，而不是实际规律。没人知道实际规律，因为总有这样那样的误差，只能说尽可能的出一个大家都认同的规律。</p><p>代入每一个实际的$x_i$，我们都能获得一个预测的$\hat{y_i}$。而实际的$x_i$却又对应事实成立的$y_i$，两者的差就是偏离度。为了尽可能拟合数据，我们应当尽可能缩小这个偏差。于是，我们准备求出每一组偏差距离，也就是<strong>y坐标差的绝对值</strong>，即$|y_i-\hat{y_i}|$，也就是$|y_i-\beta_0-{\beta_1}x|$，并让他最小。这部分就是高数的<strong>拉格朗日定理</strong>了。</p><p>于是你接着写下：</p><blockquote><p>由20组已知数据组$(x_i,y_i)$，则将x、y设为已知量，令n=200,000，且</p><script type="math/tex; mode=display">L(\beta_0,\beta_1)=\sum^{n}_{i=1}(y_i-\beta_0-{\beta_1}x_i)^2</script><p>分别对$\beta_0$和$\beta_1$求偏导，并令偏导为0，能够得出两个等式：</p><script type="math/tex; mode=display">{\frac{\partial L(\beta_0,\beta_1)}{\partial\beta_0}}=-2\sum^{n}_{i=1}(y_i-\beta_0-{\beta_1}x)=0\cdots①</script><script type="math/tex; mode=display">{\frac{\partial L(\beta_0,\beta_1)}{\partial\beta_1}}=-2\sum^{n}_{i=1}(y_i-\beta_0-{\beta_1}x)=0\cdots②</script><p>解得：</p><script type="math/tex; mode=display">\beta_0=\frac{(\sum^n_{i=1}y_i)(\sum^n_{i=1}x_i^2)-(\sum^n_{i=1}x_i)(\sum^n_{i=1}x_iy_i)}{n(\sum^n_{i=1}x_i^2)-(\sum^n_{i=1}x_i)^2}</script><script type="math/tex; mode=display">\beta_1=\frac{n(\sum^n_{i=1}x_iy_i)-(\sum^n_{i=1}x_i)(\sum^n_{i=1}y_i)}{n(\sum^n_{i=1}x_i^2)-(\sum^n_{i=1}x_i)^2}</script></blockquote><p>相信你解到这一步的时候都快疯掉了，直接看答案的估计也蒙圈了。你放心，这玩意在2020年绝对不会靠人算，如果真的碰到了那也只能祝你好运了。</p><p>不过就算是这种算式也是能够简化到一定地步的。别忘了还有这些：</p><blockquote><p>记$\bar{x}=\frac{\sum^n_{i=1}x_i}{n}$，$\bar{y}=\frac{\sum^n_{i=1}y_i}{n}$</p><p>整理得：</p><script type="math/tex; mode=display">\hat{\beta_1}=\frac{\sum^n_{i=1}x_iy_i-n\bar{x}\bar{y}}{\sum^n_{i=1}x_i^2-n\bar{x}^2}</script><script type="math/tex; mode=display">\hat{\beta_0}=\bar{y}-\bar{x}\hat{\beta_1}</script></blockquote><p>是不是觉得好看多了？而且这样子也更便于计算。</p><blockquote><p>故代入方程得：</p><script type="math/tex; mode=display">\hat{Y}=\hat{\beta_0}+\hat{\beta_1}x</script></blockquote><p>这下子你就能够用这个方程来预测你的小猫娘会吃多少啦！</p><p><img src="https://sakebow.gitee.io/images/background/illust_79288093_20200714_142659.png" width="250" alt="pid=142659"></p><h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><p>好了，讲了这么久的回归函数，是不是完全不知道这玩意和代价函数有什么关系？别担心，慢慢来。</p><p>在机器学习中，我们主要希望计算机尽可能贴近事实，也就是尽可能计算最为贴近所有样本的一元线性函数（<em>当然也有可能是别的什么函数，这里以一元线性为例</em>）。</p><p>既然是尽可能贴近，我们就会在其中筛选不贴近的、折衷较为贴近的、选取最为贴近的。于是：</p><ul><li><p>针对<strong>单个样本</strong>，我们规定了<strong>损失函数</strong>，也就是在整个线性规划的过程中产生偏差的量；</p></li><li><p>针对<strong>全部取样样本</strong>，我们规定了<strong>代价函数</strong>，也就是研究在线性规划中整个取样的样本产生偏差的量；</p></li><li><p>针对<strong>最终结果</strong>，我们规定了<strong>目标函数</strong>，也就是在尽可能照顾到所有取样样本之后研究出的最贴近事实的函数</p></li></ul><p>一开始听起来像是三个新词？这么一说明，是不是开始和以前的线性规划对上了？</p><p><strong>损失函数</strong>，其实就是<strong>残差</strong>，以前我们记为$e$；而<strong>代价函数</strong>其实就是残差的绝对值的和，但是因为计算不方便，我们全部平方了，也就是残差的平方和，最后求导再除2就是最终结果；而<strong>目标函数</strong>，就是在<strong>代价函数在取值范围内最小</strong>的情况下拟合出来的函数。</p><p>好了，到这里答案就出来了。代价函数就是求解线性方程时使用的拉格朗日定理构造的函数。之前我们定义的是：</p><script type="math/tex; mode=display">L(\beta_0,\beta_1)=\sum^{n}_{i=1}(y_i-\beta_0-{\beta_1}x_i)^2</script><p>但是同时要兼顾到计算的简便，我们再取一个求导之后不会有系数的函数：</p><script type="math/tex; mode=display">L(\beta_0,\beta_1)=\frac{\sum^{n}_{i=1}(\beta_0+{\beta_1}x_i-y_i)^2}{2n}</script><p>不仅在求导的时候去掉了系数$2$，还避免了符号问题，顺便还提供了一个$\frac{1}{n}$方便计算均值。不得不说，<strong>NICE</strong>！</p><p>你担心这样复杂的算法会拖垮计算机速度？当然不是把这个模型直接搬给计算机去算的啦，这只不过是数学推导过程，最后还是要根据计算机的特点尽可能化简成只有次数不多的加减、涵盖了几乎全部的重复劳动的算法。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;这里将会从一个简单的例子引入话题。例子是一个自变量和一个因变量构成的一元一次函数。因为同时兼顾了有趣和浅显，例子也是相当的乱来，能会意就行，吐槽就免了吧。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="人工智能" scheme="http://www.sakebow.cn/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
      <category term="算法模型" scheme="http://www.sakebow.cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>模型描述</title>
    <link href="http://www.sakebow.cn/2020/07/25/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%AE%97%E6%B3%95%E6%A8%A1%E5%9E%8B/%E6%A8%A1%E5%9E%8B%E6%8F%8F%E8%BF%B0/"/>
    <id>http://www.sakebow.cn/2020/07/25/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%AE%97%E6%B3%95%E6%A8%A1%E5%9E%8B/%E6%A8%A1%E5%9E%8B%E6%8F%8F%E8%BF%B0/</id>
    <published>2020-07-25T02:00:00.000Z</published>
    <updated>2020-07-25T12:44:23.422Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>我们在描述算法的时候，往往也会提到“算法模型”这个概念。模型是什么？算法和模型之间有什么联系？</strong></p><a id="more"></a><h2 id="算法的定义"><a href="#算法的定义" class="headerlink" title="算法的定义"></a>算法的定义</h2><p>如果你在大学学过了数据结构，这句话你应该耳熟能详：</p><blockquote><p>通俗地讲，算法是解决问题的一种方法或一个过程。更严格地讲，算法是由若干条指令组成的有穷序列，且满足下述4条性质</p><ul><li><p>输入：0个或者多个外部提供的量作为算法输入项</p></li><li><p>输出：算法应当产生至少一个量作为输出项</p></li><li><p>确定性：组成算法的每条指令是清晰的、没有歧义的</p></li><li><p>有限性：算法中每条指令的执行次数是有限的，执行每条指令的时间也是有限的</p></li></ul><p>——摘自《计算机算法设计与分析》（第五版），王晓东著</p></blockquote><p>那，模型又是什么？</p><h2 id="模型的概念"><a href="#模型的概念" class="headerlink" title="模型的概念"></a>模型的概念</h2><p>我们知道，现在普遍使用的算法例如深度搜索、哈密顿回路等等经典算法都是经过很长时间的发现、假说、论证、优化的不停循环才产生出来，而这个论证的过程就是将算法抽象为一系列的数学模型，然后计算时间复杂度、空间复杂度，最终在比较中筛选更为优秀的。所以我们平常所说的“<strong>模型</strong>”都是指“<strong>数学模型</strong>”。</p><p>也就是说：</p><blockquote><p>模型是一类问题的解题步骤，亦即一类问题的算法。</p><p>——摘自<strong>慕码人2483693</strong>对<a href="http://www.imooc.com/wenda/detail/447305" target="_blank" rel="noopener"><strong>模型与算法之间是什么关系</strong></a>一问的回答</p></blockquote><p>算法是一类问题的抽象解答，而模型则是一系列算法的数学表达。</p><p>如果问题不是一类问题，就单单类似<strong>这只猫接下来要做什么</strong>这样的问题，算法也就失去了存在的必要；同样的，算法如果也不是一系列算法，就单单类似<strong>这只狗吃骨头的流程</strong>这样的算法，模型也没有存在的必要。就像是数据结构中的抽象实体类<code>ADT</code>一样，它的存在就是为了描述一系列相似问题的解法的。</p><p>所以，你能够理解为什么会有<strong>推荐算法模型</strong>了么？因为一系列的<code>APP</code>都将会根据用户的使用情况收集偏好并提高用户体验，这些<code>APP</code>囊括了生活中的方方面面，包括<strong>美食</strong>、<strong>服饰</strong>、<strong>手办</strong>、<strong>模玩</strong>、<strong>家具</strong>还有<strong>电子产品</strong>甚至<strong>性癖</strong>（<del><em>比方说<code>pixiv</code></em></del>）等等。因为类似，这就抽象出来了。</p><h2 id="机器学习中模型的描述"><a href="#机器学习中模型的描述" class="headerlink" title="机器学习中模型的描述"></a>机器学习中模型的描述</h2><p>正如一开始所说的，算法需要有<strong>0个以上的输入</strong>、<strong>1个以上的输出</strong>，机器学习中的算法也是一样的，有着0个以上的<strong>数据集</strong>输入，输出至少一个<strong>结果</strong>。数据集中包括了大量的具有相似数据结构的信息，可以是事实，也可以是虚拟信息；而输出则是根据结果的预测、分类等等。就如下图所示：</p><p><img src="https://sakebow.gitee.io/images/机器学习/模型描述流程图1.png" alt="机器学习模型描述"></p><p>这个机器学习的算法并不是一成不变的，同样也是在不断的实践和训练中逐渐发现最贴近事实、最能概括所有内容的数学模型和算法。</p><p>是不是能理解了？</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;我们在描述算法的时候，往往也会提到“算法模型”这个概念。模型是什么？算法和模型之间有什么联系？&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="人工智能" scheme="http://www.sakebow.cn/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
      <category term="算法模型" scheme="http://www.sakebow.cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>监督学习</title>
    <link href="http://www.sakebow.cn/2020/07/24/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/"/>
    <id>http://www.sakebow.cn/2020/07/24/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-07-24T14:32:00.000Z</published>
    <updated>2020-07-25T01:02:22.428Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>监督学习，就如同字面意思，有人一直作为督工一直监督机器学习。</strong></p><a id="more"></a><h2 id="监督学习的定义"><a href="#监督学习的定义" class="headerlink" title="监督学习的定义"></a>监督学习的定义</h2><blockquote><p>监督学习是从标记的训练数据来推断一个功能的机器学习任务。训练数据包括一套训练示例。在监督学习中，每个实例都是由一个输入对象（通常为矢量）和一个期望的输出值（也称为监督信号）组成。监督学习算法是分析该训练数据，并产生一个推断的功能，其可以用于映射出新的实例。一个最佳的方案将允许该算法来正确地决定那些看不见的实例的类标签。这就要求学习算法是在一种“合理”的方式从一种从训练数据到看不见的情况下形成。</p><p>摘自<a href="https://baike.baidu.com/item/监督学习/9820109?fr=aladdin" target="_blank" rel="noopener">百度百科：监督学习</a></p></blockquote><p>是不是非常非常拗口而且难懂？这可能是中国学术的悲哀，说的非常的生涩难懂，似乎不是为了给别人看。这里就简单概括一下：</p><blockquote><p>监督学习是给定一组数据作为正确答案输入计算机程序中并完成适当的训练。在训练结束后机器能够在满足一定正确率的情况下进行预测。</p></blockquote><p>举个例子：</p><blockquote><p>你想要一夜暴富，但是你明白你要脚踏实地，所以你开始了一夜暴富的可行性分析。首先你收集了全球富豪的姓名、年龄、婚姻状况、政治身份、民族、家庭住址、教育背景，然后找到了全球富豪祖宗三代的同样的信息。长时间的整理之后，你作出了多张图表，分别是每个人不同属性和现持有资金的离散型数据关系。然后，你得出结论：一夜暴富的可能性几乎没有。</p></blockquote><p>虽然这个例子有点乱来，但是相信大家还是明白这个道理的。就是说，这些全球成功暴富的人，也就是以正确答案输入程序的<strong>训练集</strong>，在经过一段时间的分析，也就是<strong>适当的训练</strong>。为什么是适当呢？如果训练不够，你就会轻易地觉得自己没有希望，最终自闭。这也叫<strong>欠拟合</strong>；如果训练过当，你就会盲目自信，然后赔得内裤都没得穿。这也叫<strong>过拟合</strong>。适当训练之后，你就能够<strong>在一定正确率的情况下预测</strong>自己能不能一夜暴富。当然，这也只是说一定的正确率，是不是实际发生谁也不知道。</p><p>是不是多少明白了一点点呢？</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;监督学习，就如同字面意思，有人一直作为督工一直监督机器学习。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="人工智能" scheme="http://www.sakebow.cn/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
      <category term="机器学习" scheme="http://www.sakebow.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>非监督学习</title>
    <link href="http://www.sakebow.cn/2020/07/24/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E9%9D%9E%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/"/>
    <id>http://www.sakebow.cn/2020/07/24/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E9%9D%9E%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-07-24T14:32:00.000Z</published>
    <updated>2020-07-25T01:43:07.267Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>非监督学习，就如同字面意思，没有人监督的，也就是机器自学。</strong></p><a id="more"></a><h2 id="非监督学习的定义"><a href="#非监督学习的定义" class="headerlink" title="非监督学习的定义"></a>非监督学习的定义</h2><blockquote><p>现实生活中常常会有这样的问题：缺乏足够的先验知识，因此难以人工标注类别或进行人工类别标注的成本太高。很自然地，我们希望计算机能代我们完成这些工作，或至少提供一些帮助。根据类别未知(没有被标记)的训练样本解决模式识别中的各种问题，称之为无监督学习。</p><p>——摘自<a href="https://baike.baidu.com/item/无监督学习/810193" target="_blank" rel="noopener">百度百科：无监督学习</a></p></blockquote><p>这个定义似乎比<strong>监督学习</strong>更简单，最起码而言没有涉及过多的理科专有词汇。不过这个定义依然比较抽象，我们来举个例子看看：</p><blockquote><p>你是一个大老板，能赚很多钱，但是除了赚钱一无所知。这一天，你拿到了一车黑色液体，里面有酱油，有生抽，有可乐，甚至有枇杷膏。你知道这些是你能够发财致富的东西，可你却<strong>完全不知道它们之间的区别是什么</strong>。于是你请了一队人<strong>工具人</strong>来帮你鉴定分类，他们都是各种菜系的国家级厨师，能够很快根据自己的经验捕捉到这瓶黑色液体的显著特点，并鉴定出这到底是什么；然后给你分好类、装好箱、上好架。最后，你根据他们分好的类别去货架上贴好标签，你的店铺就被<strong>整理得整整齐齐</strong>的了。</p></blockquote><p>听起来这个例子无论是<strong>机器</strong>还是<strong>学习</strong>都扯不上半点关系，但这个例子确实说明了<strong>无监督学习的几个特点</strong>：</p><ul><li><p>缺乏足够的先验知识，因此你没有办法直接给这些黑色液体标注类别；</p></li><li><p>因为量太大，自己标注所需要花费的时间成本太高，只好交给别人，而且是极其有耐心的<strong>工具人</strong>；</p></li></ul><p>那么，我们在这两条特点的基础上继续整理出<strong>无监督学习的使用条件</strong>：</p><ul><li><p>从<strong>庞大的样本</strong>集合中选出一些具有代表性的加以标注用于分类器的训练；</p></li><li><p>先将所有样本自动分为不同的类别，再<strong>由人类对这些类别进行标注</strong>；</p></li><li><p>在<strong>无类别信息</strong>情况下，寻找好的特征；</p></li></ul><p>也就是说，只要这组数据并没有明确分类，只是整个数据集一股脑地全扔给了程序，那就需要使用无监督学习。而如果你已经明确知道了这一大串数据集中哪些是第一类，哪些是第二类，就像是垃圾邮件和星标邮件的明显区别，就是监督学习。</p><p>是不是能理解一点了？</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;非监督学习，就如同字面意思，没有人监督的，也就是机器自学。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="人工智能" scheme="http://www.sakebow.cn/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
      <category term="机器学习" scheme="http://www.sakebow.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习是什么</title>
    <link href="http://www.sakebow.cn/2020/07/24/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>http://www.sakebow.cn/2020/07/24/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%98%AF%E4%BB%80%E4%B9%88/</id>
    <published>2020-07-24T09:20:00.000Z</published>
    <updated>2020-07-24T14:35:32.383Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>这里我参考的教程是吴恩达在2019年录制的课程，在B站上有链接，只不过是全英文，<a href="https://bilibili.com/BV164411S78V" target="_blank" rel="noopener">点我跳转</a>。当然，如果你选择<a href="https://bilibili.com/BV1JE411g7XF" target="_blank" rel="noopener">李宏毅的机器学习课程</a>也可以，因为是中文所以对于更多人来说更亲切一点。</strong></p><a id="more"></a><h2 id="机器学习的定义"><a href="#机器学习的定义" class="headerlink" title="机器学习的定义"></a>机器学习的定义</h2><p><code>Arthur Samuel</code>早在1959年就给即去学习下了个定义：</p><blockquote><p><code>Field of study that gives computers the ability to learn without being explicitly programmed</code></p><p>译：在没有明确设置的情况下是计算机具有学习能力的研究领域</p></blockquote><p>当然，这个定义稍微有些陈旧了。1998年，<code>Tom Mitchell</code>更新了这个定义：</p><blockquote><p><code>A computer program is said to *learn* from experience E with respect to some task T and some performace measure P, if its performace on T, as measured by P, improves with E</code></p><p>译：计算机程序从经验<code>E</code>中学习，解决某一任务<code>T</code>，进行某一性能度量<code>P</code>，通过<code>P</code>测定在<code>T</code>上的表现因经验<code>E</code>而提高。</p></blockquote><p>听起来非常的绕口？当然啦，这是人家的比喻，吴恩达老师在这里给出了一个例子：</p><blockquote><p>你需要参加研究生招生考试，最终考上心仪的大学，走向人生巅峰。在这次考试中，你将会面对很多题目，每个题目可能对应一个甚至多个知识点。为了掌握这些知识点，刷题便是我们现在400万考研的大学生正在做的事。</p><p>那么，针对这个例子，请找出任务<code>T</code>、性能度量<code>P</code>和经验<code>E</code>。</p></blockquote><p>这个例子虽然并不是那么的恰当，但是也相当具有代表性。<strong>考上心仪的大学</strong>就是任务<code>T</code>，而<strong>考试得分</strong>就是性能度量<code>P</code>，<strong>刷题</strong>就是经验<code>E</code>。通过监测你的<strong>得分</strong><code>P</code>，<strong>考上心仪大学</strong>的任务<code>T</code>将会因为你大量的<strong>刷题</strong><code>E</code>而一步一步靠近。</p><p>如果是好不容易考上研究生的你是不是能理解了？</p><p><img src="https://sakebow.gitee.io/images/emoji/滑稽-屑狐狸版.jpg" alt="滑稽"></p><h2 id="机器学习的分类"><a href="#机器学习的分类" class="headerlink" title="机器学习的分类"></a>机器学习的分类</h2><p>机器学习主要就是<strong>监督学习</strong>和<strong>非监督学习</strong>。当然我们还有非常多的，例如强化学习、推荐系统等等。这些都是其他的具体应用了，<strong>监督学习</strong>和<strong>非监督学习</strong>更像是这一切的基础。正所谓：</p><blockquote><p>公欲善其事，必先利其器</p></blockquote><p>当然，如果你是程序大佬，你也可以直接看推荐系统的源代码，并从中学到非常多的算法，积累非常多的经验。但是，正如我曾经的足球教练所说的，完全凭着经验能够做的非常好、非常快。但是，这些人<strong>遇到瓶颈也非常快</strong>，遇到了更强的人将<strong>无法战胜</strong>。这就是<strong>基本功的重要性</strong>。</p><p>在将来的几篇中，我将详细展开这两个基本的机器学习模式。请直接点击链接跳转到相应的教程：<a href="/2020/07/24/机器学习/监督学习/">监督学习</a>、<a href="/2020/07/24/机器学习/非监督学习/">非监督学习</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;这里我参考的教程是吴恩达在2019年录制的课程，在B站上有链接，只不过是全英文，&lt;a href=&quot;https://bilibili.com/BV164411S78V&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点我跳转&lt;/a&gt;。当然，如果你选择&lt;a href=&quot;https://bilibili.com/BV1JE411g7XF&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;李宏毅的机器学习课程&lt;/a&gt;也可以，因为是中文所以对于更多人来说更亲切一点。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="人工智能" scheme="http://www.sakebow.cn/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
      <category term="机器学习" scheme="http://www.sakebow.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>针对SQL语句本身的查询优化</title>
    <link href="http://www.sakebow.cn/2020/07/19/MySQL/%E9%92%88%E5%AF%B9SQL%E8%AF%AD%E5%8F%A5%E6%9C%AC%E8%BA%AB%E7%9A%84%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/"/>
    <id>http://www.sakebow.cn/2020/07/19/MySQL/%E9%92%88%E5%AF%B9SQL%E8%AF%AD%E5%8F%A5%E6%9C%AC%E8%BA%AB%E7%9A%84%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/</id>
    <published>2020-07-19T14:24:00.000Z</published>
    <updated>2020-08-15T15:42:55.123Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>现在项目愈加复杂的需求中越来越离不开数据库了。而实际项目中，查询往往占绝大多数。所以查询的优化是整个项目的关键。</strong></p><a id="more"></a><h2 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h2><p>在我之前写的<a href="/2020/07/29/MySQL/SQL基础/">SQL基础</a>中，描述了<code>SQL</code>语句的执行顺序，还是那个手办的例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> 手办表.对应人物, 手办表.服饰, 手办表.价格, 番剧表.番剧名称, 番剧表.出场人物</span><br><span class="line"><span class="keyword">FROM</span> 手办表, 番剧表</span><br><span class="line"><span class="keyword">WHERE</span> 手办表.对应人物 = 番剧表.出场人物</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> 手办表.对应人物, 手办表.服饰, 手办表.价格, 番剧表.番剧名称, 番剧表.出场人物</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> 手办表.价格 <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p>按照之前的顺序，我们一步一步分析：</p><h2 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a><code>FROM</code></h2><p>我们将会把<code>FROM</code>后面跟着的所有的表全部加载到内存。听起来是为了方便筛选数据，但是这么做对于海量数据的表将会是毁灭性的。就单纯的像学生管理系统的学生表，涉及姓名、密码、民族、政治面貌、入学时间、毕业时间、奖惩记录等等可能上百个字段，几万行数据，相当的消耗内存。如果真的是联立表，推荐使用<code>JOIN</code>进行联立。</p><h2 id="JOIN-amp-ON"><a href="#JOIN-amp-ON" class="headerlink" title="JOIN&amp;ON"></a><code>JOIN</code>&amp;<code>ON</code></h2><p><code>ON</code>将会在联立两个表的数据之前仅加载一张表的数据，然后另一张表通过一定的条件合并到第一张表中，相对于直接联立会减小很多压力。所以，本例中的<code>SQL</code>语句可以修改为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> 手办表.对应人物, 手办表.服饰, 手办表.价格, 番剧表.番剧名称, 番剧表.出场人物</span><br><span class="line"><span class="keyword">FROM</span> 番剧表</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> 手办表</span><br><span class="line"><span class="keyword">ON</span> 手办表.对应人物 = 番剧表.出场人物</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> 手办表.对应人物, 手办表.服饰, 手办表.价格, 番剧表.番剧名称, 番剧表.出场人物</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> 手办表.价格 <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p>虽然在本例中查询出来的结果是一样的，但是查询过程略有不同：<code>LEFT JOIN</code>会保留左表所有数据，即使没有匹配成功也会显示，<code>RIGHT JOIN</code>则是保留右表；两者在查询时间上也略有区别，但是这里数据实在太少，区别不明显。如果是查询中国街道表将会有非常明显的变化。</p><h2 id="WHERE"><a href="#WHERE" class="headerlink" title="WHERE"></a><code>WHERE</code></h2><p><code>WHERE</code>作为筛选条件，虽然说没有非常明显的优化方式，但是还是想说：尽量少用字符串作为匹配条件。在匹配的时候往往会整个串遍历，时间复杂度最少也是<code>KMP</code>算法的$O(m+n)$，而数字则为$O(1)$，相对来说会少一个复杂度。不过如果字符串很短，例如学号、教工号这类不超过15个字符的就随意了。</p><h2 id="GROUP-BY-amp-HAVING"><a href="#GROUP-BY-amp-HAVING" class="headerlink" title="GROUP BY&amp;HAVING"></a><code>GROUP BY</code>&amp;<code>HAVING</code></h2><p><code>GROUP BY</code>和<code>HAVING</code>作为分组条件没有什么可以优化的了，只能说根据业务需求进行调整。</p><h2 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a><code>SELECT</code></h2><p><code>SELECT</code>将会从内存中选择列，这没什么争议。但是如果使用<code>*</code>作为属性列表将会让系统首先查找哪些字段符合条件，是极其消耗资源的方法。哪怕表内几百的字段都是需要查询的，最好也要一个个写上去。</p><h2 id="DISTINCT"><a href="#DISTINCT" class="headerlink" title="DISTINCT"></a><code>DISTINCT</code></h2><p>只是普通的剔除重复的，因为大量重复的情况很少出现，所以如果不是为了特殊业务有或无都没什么。</p><h2 id="ORDER-BY"><a href="#ORDER-BY" class="headerlink" title="ORDER BY"></a><code>ORDER BY</code></h2><p>正如我们在<a href="/2020/07/29/MySQL/SQL基础/">SQL基础</a>中说明的一样，数据库会根据<strong>索引</strong>优化树形结构。所以，排序的优化就转变为了索引的优化。这就是另外一门学问了。</p><h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><p>看起来和<code>SQL</code>语句完全没有关系，实际上正如上面<code>ORDER BY</code>一栏所述，优化结构使得查询更为便捷也是优化的一种。</p><p><code>MySQL</code>支持的最大索引数量是<strong>57</strong>个，但是实际上最好还是不超过<strong>5</strong>个，因为过多的索引不便于表结构专门针对某一个字段优化，正所谓“<strong>过犹不及</strong>”。</p><p>索引优化并没有一个定性公式，而是根据需求和实际不断权衡、各取利弊，最终达到极限。依然举个有些乱来的例子：</p><blockquote><p>你找到了一家手办店。你相当的喜欢这里面的手办，每一款都非常好看。但是因为你当前的经济能力由不得你全都要，只能购买其中最喜欢的几个。所以店长专门为整个手办店创建了索引。</p><p>说是创建索引，实际上也是根据番剧名称重新分类、重新整理数据结构而已。于是你在找你喜欢的手办（<em>数据库查询</em>）的过程中，你发现你头顶有一些标牌，标明了哪些区域是哪些番剧（<em>根据番剧创建的索引</em>）。</p><p>于是你根据这些标语找到了《Re:从零开始的异世界生活》。</p><p>但是蕾姆人气实在是太高了，魔术师、泳装、女仆装、便装、睡衣装、等身手办等等都一一展示在这个区域。于是店长精心整理了一下这里的展示柜，从下到上模型逐渐变得小巧、服饰逐渐变少；从1:4逐渐过渡到1:8（<em>根据模型大小创建的索引</em>），从羽绒服逐渐过渡到浴巾（<em>根据服饰创建的索引</em>）。这么一整理是不是比胡乱摆放的仓库好多了？</p></blockquote><p>是不是有点能理解了呢？</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;现在项目愈加复杂的需求中越来越离不开数据库了。而实际项目中，查询往往占绝大多数。所以查询的优化是整个项目的关键。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="SQL" scheme="http://www.sakebow.cn/categories/SQL/"/>
    
    
      <category term="MySQL" scheme="http://www.sakebow.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>突如其来的反思</title>
    <link href="http://www.sakebow.cn/2020/07/19/diary/%E7%AA%81%E5%A6%82%E5%85%B6%E6%9D%A5%E7%9A%84%E5%8F%8D%E6%80%9D/"/>
    <id>http://www.sakebow.cn/2020/07/19/diary/%E7%AA%81%E5%A6%82%E5%85%B6%E6%9D%A5%E7%9A%84%E5%8F%8D%E6%80%9D/</id>
    <published>2020-07-19T13:58:00.000Z</published>
    <updated>2020-07-25T07:35:15.228Z</updated>
    
    <content type="html"><![CDATA[<script src="/crypto-js.js"></script><script src="/mcommon.js"></script><h3 id="encrypt-message">如果你坚持要看，请联系我。</h3><link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.min.css"> <link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap-theme.min.css"> <script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script> <script src="//cdn.bootcss.com/bootstrap/3.3.5/js/bootstrap.min.js"></script> <div id="security"> <div> <div class="input-group"> <input type="text" class="form-control" aria-label="Enter the password." id="pass"/> <div class="input-group-btn"> <button type="button" class="btn btn-default" onclick="decryptAES()">Decrypt</button> </div> </div> </div> </div> <div id="encrypt-blog" style="display:none"> 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 </div>]]></content>
    
    <summary type="html">
    
      只不过是一点点遐想，抛出几个问题然后自己慢慢思索结果而已。没什么值得看的，而且不想公开日记。
    
    </summary>
    
    
      <category term="日记" scheme="http://www.sakebow.cn/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="随笔" scheme="http://www.sakebow.cn/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>docker创建服务器</title>
    <link href="http://www.sakebow.cn/2020/07/11/%E8%BF%90%E7%BB%B4/docker/docker%E5%88%9B%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://www.sakebow.cn/2020/07/11/%E8%BF%90%E7%BB%B4/docker/docker%E5%88%9B%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2020-07-11T12:58:00.000Z</published>
    <updated>2020-11-15T13:05:04.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>本文主要参考了<a href="https://blog.csdn.net/qq_21429153/article/details/80867813" target="_blank" rel="noopener">lzssing的“<code>Docker</code>搭建<code>CentOS</code>系统，并配置<code>ssh</code>环境”</a>，并补充了一些相关细节。本篇将按照我的尝试全过程依次排雷，这样也能够让各位看到更清晰的问题解决方案，但是照着做时需要避开明确标注了“不正确”的地方。</strong></p><a id="more"></a><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>无论是什么系统，只需要下载安装<code>Docker</code>就好了。参照我之前写的<a href="/2020/07/11/运维/docker/docker的简介与安装">docker的简介与安装</a>。如果你是<code>Ubuntu</code>系统，那么这些就够了。如果你是<code>Windows</code>系统，你可能还需要一个<a href="https://pan.baidu.com/s/1VFQVelcYuw30nd1B0jXOZA" target="_blank" rel="noopener"><code>XShell</code>（提取码：88kv）</a>用于远程连接。这里就以我使用的<code>Ubuntu</code>系统编写流程，如果你是<code>Windows</code>，你可以选择<code>Docker for Windows</code>并用<code>CMD（管理员）</code>执行同样的命令，也可以选择使用<code>Windows</code>子系统。</p><h2 id="第一次尝试"><a href="#第一次尝试" class="headerlink" title="第一次尝试"></a>第一次尝试</h2><p>首先肯定是确保自己进入了超级管理员权限，并使用docker命令下载我们需要的<code>CentOS</code>镜像。为什么是<code>CentOS</code>？因为全都是<code>Ubuntu</code>的话比较容易弄混，所以就用个其他的系统区分一下。</p><p>请求超管权限，输入密码认证之后进入超管权限。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo su</span><br></pre></td></tr></table></figure></p><p><strong>从这里之后便全是CentOS。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pull centos # 拉取镜像</span><br><span class="line">docker run -itd centos /bin/bash # 创建容器运行镜像</span><br><span class="line">docker exec -it 18 /bin/bash # 进入容器操作镜像</span><br></pre></td></tr></table></figure><p>这里需要说明的是，<code>run</code>命令中当我们使用<code>-d</code>作为参数时，容器将支持后台运行。<code>run</code>命令之后便会生成一个<strong>容器id</strong>，我的是：</p><p><code>18b400110fc8772d23016358e60b4b5ff00e3892d1ad7db4bbbc4b6d1bb13e45</code></p><p>这实在是太长了。于是我在确认了没有重复项之后缩减了长度，只写了<code>18</code>，也就是<code>exec</code>命令所示的那样。</p><p><img src="https://sakebow.gitee.io/images/运维/拉取镜像.png" alt="拉取镜像"></p><p>然后我们开始搭建<code>ssh</code>环境，因为需要使用<code>ssh</code>工具进行连接。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install passwd openssl openssh-server openssh-clients initscripts vim -y # 安装软件</span><br></pre></td></tr></table></figure><p>此处<code>-y</code>代表<strong>确认安装</strong>。这个过程实在太长而且都是一样的输出就不截图了。你担心出错？<strong>放心好了</strong>。只要你不断网，这些输出必定每个人都是一样的。</p><p><img src="https://sakebow.gitee.io/images/运维/各种包已下载完成.png" alt="下载完成"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -f /etc/ssh/ssh_host_rsa_key -N ""</span><br><span class="line">ssh-keygen -t ecdsa -f /etc/ssh/ssh_host_ecdsa_key -N ""</span><br><span class="line">ssh-keygen -t ed25519 -f /etc/ssh/ssh_host_ed25519_key -N ""</span><br></pre></td></tr></table></figure><p>运行sshd服务一共需要三种密钥，<code>rsa</code>、<code>ecdsa</code>、<code>ed25519</code>。这三种都是<strong>数字签名</strong>的算法，能够保证服务器和客户端之间有能够认证身份的<strong>唯一指定</strong>令牌。在这里就不持续展开了，总之都是<strong>世界级</strong>的加密算法。</p><p>好了，准备工作差不多就到这里了，我们不如先存个档？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exit # 从CentOS中退出来，回到超管权限下的Ubuntu</span><br><span class="line"></span><br><span class="line">docker commit -a "sakebow" -m "ssh complete" 18 centos_server/save:v1 # 保存镜像</span><br></pre></td></tr></table></figure><p><img src="https://sakebow.gitee.io/images/运维/保存修改后的镜像.png" alt="保存镜像"></p><p>既然我们已经保存了镜像，之前使用的<code>18</code>容器就不再需要了，删除了吧。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker stop 18 # 之前是保持后台运行，现在需要手动关闭容器</span><br><span class="line">docker rm 18 # 删除容器</span><br><span class="line">docker ps -a # 确认容器是否存在</span><br></pre></td></tr></table></figure><p>好了，我们再次使用新的镜像跑一下。</p><p><strong>友情提醒：从现在开始会出现错误情况，我将郑重标明</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 错误示范</span></span><br><span class="line">docker run -itd 79 /bin/bash # 创建容器并运行镜像</span><br><span class="line">docker exec -it da /bin/bash # 进入容器</span><br></pre></td></tr></table></figure><p><img src="https://sakebow.gitee.io/images/运维/进入新镜像.png" alt="进入新镜像"></p><p>这里的<code>79</code>是<strong>新镜像的id</strong>，而<code>da</code>是<strong>新容器的id</strong>。各位在这一步需要更换为<strong>自己的对应id</strong>。现在，我们已经进入了<code>CentOS</code>系统中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start sshd.service # 启动服务</span><br></pre></td></tr></table></figure><p>然后，噩梦开始了。这是第一个错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@daa9499a8f9f /]# systemctl start sshd.service</span><br><span class="line">System has not been booted with systemd as init system (PID 1). Can't operate.</span><br><span class="line">Failed to connect to bus: Host is down</span><br></pre></td></tr></table></figure><p>就很奇怪。后来在<a href="https://blog.csdn.net/baidu_38558076/article/details/103890319" target="_blank" rel="noopener">baidu_38558076的“System has not been booted with systemd as init system”一文</a>中找到了解决方案：<code>/bin/bash</code>修改为<code>/sbin/init</code>，这样才会注册主线程<code>PID 1</code>。</p><h2 id="第二次尝试"><a href="#第二次尝试" class="headerlink" title="第二次尝试"></a>第二次尝试</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">exit # 退出失败的容器</span><br><span class="line"><span class="meta">#</span><span class="bash"> 以下修改稿1 - 这说明他依然有问题</span></span><br><span class="line">docker ps -a # 确认出错容器</span><br><span class="line">docker stop da # 停掉后台的容器</span><br><span class="line">docker rm da # 删除容器</span><br><span class="line">docker run --privileged=true 94 /sbin/init # 使用不一样的方式创建镜像</span><br><span class="line">docker exec -it 94 /bin/bash # 运行</span><br></pre></td></tr></table></figure><p>截图之前没注意，参数还有顺序要求，闹了很多错误。我也就不回避这些，给大家排个雷。</p><p><img src="https://sakebow.gitee.io/images/运维/修改1.png" alt="排雷式截图：进入新容器"></p><p><code>run</code>命令一定是要<code>--privileged=true</code>在<strong>镜像id</strong>之前。</p><p>再来试试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start sshd.service # 启动服务</span><br><span class="line">ps -e | grep sshd # 查看sshd服务运行情况</span><br></pre></td></tr></table></figure><p>这次没有报错。你有些后怕？放心好了，<code>Linux</code>的哲学就是：“<strong>没有报错就是没有错误！</strong>”相信自己，他不说你有错误你就是没错误。</p><p><img src="https://sakebow.gitee.io/images/运维/成功开启服务.png" alt="成功开启服务"></p><p>我们试着用<code>ssh</code>工具连接一下。另外开一个窗口，输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@192.168.1.111 # 这个192.168.1.111是我的IP地址</span><br></pre></td></tr></table></figure><p><strong>好像行不通</strong>。以下是错误信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sakebow@sakebow-Lenovo-V310-14IKB:~$ ssh root@192.168.1.111</span><br><span class="line">ssh: connect to host 192.168.1.111 port 22: Connection refused</span><br></pre></td></tr></table></figure><p>为什么？因为<code>Docker</code>是运行在本机的，开的端口就是本机的端口，也就是默认监听<code>22</code>端口。这个端口又是其他机器连接本机的关键，<strong>不允许被占用</strong>，所以直接被拒绝了。</p><p>那怎么搞嘛！<strong>换端口</strong>。</p><h2 id="第三次尝试"><a href="#第三次尝试" class="headerlink" title="第三次尝试"></a>第三次尝试</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 这次是正确的</span></span><br><span class="line"></span><br><span class="line">exit # 同样退出错误的容器</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 同样重开重进</span></span><br><span class="line">docker ps -a</span><br><span class="line">docker stop 94 e5 10</span><br><span class="line">docker rm 94 e5 10</span><br><span class="line">docker run -itd --privileged=true -p 1000:22 79 /sbin/init</span><br><span class="line">docker exec -it be /bin/bash</span><br><span class="line"></span><br><span class="line">systemctl start sshd # 同样在CentOS里面开启服务</span><br></pre></td></tr></table></figure><p>没有错误提示。连接试试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@192.168.1.111 -p 1000</span><br></pre></td></tr></table></figure><p>出现了新的对话！</p><p><img src="https://sakebow.gitee.io/images/运维/连接成功.png" alt="连接成功"></p><p>确定继续连接吗？确定的话<code>CentOS</code>（服务器）中的指纹就会保存在<code>Ubuntu</code>（客户机）中，方便下次连接。输入<code>yes</code>录入指纹，也就是以后允许这台机器输入密码认证，这样其他任何机器输入的密码即使是正确的也不会核对；如果选择<code>no</code>将会终止连接，虽然指纹依然在服务器<code>CentOS</code>上，但是客户机<code>Ubuntu</code>没有指纹，将不会核对密码。</p><p>密码正确后，进入服务器。</p><p>到这里全部完成。</p><h2 id="总结正确的全过程"><a href="#总结正确的全过程" class="headerlink" title="总结正确的全过程"></a>总结正确的全过程</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Ubuntu</span></span><br><span class="line">sudo su</span><br><span class="line">docker pull centos # 此处获得mirror_id_1</span><br><span class="line">docker run -itd $&#123;mirror_id_1&#125; /bin/bash # 此处填入你的mirror_id_1，执行后生成container_id_1</span><br><span class="line">docker exec -it $&#123;container_id_1&#125; /bin/bash # 填入你获得的container_id_1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> CentOS</span></span><br><span class="line">yum install passwd openssl openssh-server openssh-clients initscripts vim -y</span><br><span class="line">ssh-keygen -t rsa -f /etc/ssh/ssh_host_rsa_key -N ""</span><br><span class="line">ssh-keygen -t ecdsa -f /etc/ssh/ssh_host_ecdsa_key -N ""</span><br><span class="line">ssh-keygen -t ed25519 -f /etc/ssh/ssh_host_ed25519_key -N ""</span><br><span class="line">systemctl start sshd.service # sshd.service可以简写为sshd</span><br><span class="line">exit</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Ubuntu</span></span><br><span class="line">docker commit -a "$&#123;custom_author&#125;" -m "$&#123;custom_comments&#125;" $&#123;container_id_1&#125; $&#123;custom_mirror_name&#125; # 输入自定义的作者信息、备注信息 和 container_id_1，并获得mirror_id_2</span><br><span class="line">docker stop $&#123;container_id_1&#125; # 输入你的container_id_1</span><br><span class="line">docker rm $&#123;container_id_1&#125; # 输入你的container_id_1</span><br><span class="line">docker ps -a</span><br><span class="line">docker run -itd --privileged=true -p $&#123;custom_port&#125;:22 $&#123;mirror_id_2&#125; /sbin/init # 此处填入你的自定义端口号custom_port，mirror_id_2</span><br><span class="line">ssh root@$&#123;IP_HOST&#125; -p $&#123;port&#125; # 此处填入你的IP_HOST和custom_port</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本文主要参考了&lt;a href=&quot;https://blog.csdn.net/qq_21429153/article/details/80867813&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;lzssing的“&lt;code&gt;Docker&lt;/code&gt;搭建&lt;code&gt;CentOS&lt;/code&gt;系统，并配置&lt;code&gt;ssh&lt;/code&gt;环境”&lt;/a&gt;，并补充了一些相关细节。本篇将按照我的尝试全过程依次排雷，这样也能够让各位看到更清晰的问题解决方案，但是照着做时需要避开明确标注了“不正确”的地方。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="运维" scheme="http://www.sakebow.cn/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="docker" scheme="http://www.sakebow.cn/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker的简介与安装</title>
    <link href="http://www.sakebow.cn/2020/07/11/%E8%BF%90%E7%BB%B4/docker/docker%E7%9A%84%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%89%E8%A3%85/"/>
    <id>http://www.sakebow.cn/2020/07/11/%E8%BF%90%E7%BB%B4/docker/docker%E7%9A%84%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%89%E8%A3%85/</id>
    <published>2020-07-11T09:18:00.000Z</published>
    <updated>2020-07-19T09:16:11.674Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p>简介部分主要参考了<strong>尚硅谷周阳</strong>的<a href="https://bilibili.com/BV1Vs411E7AR" target="_blank" rel="noopener">B站视频</a>，安装部分主要参考了<a href="https://www.cnblogs.com/walker-lin/p/11214127.html" target="_blank" rel="noopener"><code>walker_lin</code>的<code>docker</code>学习（一）<code>ubuntu</code>上安装<code>docker</code>一文</a></p><a id="more"></a><h2 id="第一感觉"><a href="#第一感觉" class="headerlink" title="第一感觉"></a>第一感觉</h2><p><img src="https://sakebow.gitee.io/images/%E8%BF%90%E7%BB%B4/docker.png" alt="docker"></p><p>什么是<code>Docker</code>？<code>Dock</code>是容器的意思，那么<code>Docker</code>也就有容器管理员的意思了。既然是管理员，那么也就有容器的来源、状态和去向三个属性的管理。</p><h2 id="Docker架构"><a href="#Docker架构" class="headerlink" title="Docker架构"></a><code>Docker</code>架构</h2><p><code>Docker</code>是一个<code>C/S</code>架构的应用，虽然我们能看到的非常有限，却在设计之初就已经构想了一整套完美的生态。整个生态包括<code>Docker镜像仓库</code>、<code>Docker</code>容器和<code>Docker</code>客户端，这三个分别掌管来源、状态和去向。</p><h3 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h3><p>来源虽说是容器的来源，其实就是说<code>Docker</code>镜像的来源，也就指向<code>Docker</code>庞大的代码仓库。从代码仓库中下载最小限度的镜像之后，在确定运行这些镜像之后，就会自动创建一个容器，并塞入镜像。而这个仓库则是在开发人员和众多社区大佬的共同努力下逐渐丰富起来的一个网站，叫<a href="https://hub.docker.com" target="_blank" rel="noopener"><code>Docker Hub</code></a>。</p><p>听起来就像<strong>超市购物</strong>一样，我在超市里找到了我想要的商品（<em>镜像</em>），然后装进袋子（<em>容器</em>）里。</p><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p>状态普遍只会用到两种，一种是<strong>停止</strong>，另一种是<strong>运行中</strong>。这是两种正确执行之后才会出现的状态，而其他则是<strong>由命令不正确导致空容器</strong>、由<strong>无网络造成的创建失败</strong>等等状态。由于其他状态相当于<strong>错误</strong>，需要被处理，所以就没有一一列出的必要。</p><p>要管理容器状态，其实也就是操作容器，<strong>关闭</strong>、<strong>打开</strong>、<strong>创建</strong>、<strong>删除</strong>四大基本操作，其他的操作都类似这四大操作的<strong>旁支</strong>，比如<strong>后台挂起</strong>，也相当于<strong>打开</strong>。当然，如果遇到了刚刚所说的<strong>错误</strong>，这些<strong>旁支</strong>就<strong>没有效果</strong>了。</p><p>如果要打比方的话，状态就类似守门的大爷，对一个个的停车位是选择<strong>开门</strong>、<strong>关门</strong>、<strong>监视</strong>还是<strong>放任</strong>。</p><h3 id="去向"><a href="#去向" class="headerlink" title="去向"></a>去向</h3><p>去向说的是容器的去向，实际上也就是容器到底是<strong>留存</strong>还是<strong>删除</strong>。无论是<strong>停止</strong>还是<strong>保持运行</strong>，容器都还在，是<strong>留存</strong>；<strong>删除</strong>则是将容器<strong>彻底删除</strong>，在容器运行期间对镜像的<strong>一切修改将不会保存</strong>，但是最初的镜像将会完好地保存下来，因为容器中运行的是镜像的备份。</p><p>这就像是快递检货一样，无论发往哪里，都是<strong>检验合格（<em>确认要用</em>）</strong>；而<strong>检验不合格（<em>确认不用</em>）</strong>将会直接<strong>处理掉（<em>删除</em>）</strong>。这里的合不合格则是由<strong>快递员（<em>开发者</em>）来</strong>决定。</p><h2 id="为什么是Docker"><a href="#为什么是Docker" class="headerlink" title="为什么是Docker"></a>为什么是<code>Docker</code></h2><p><code>Docker</code>能够下载镜像、创建容器并运行镜像。这就像是虚拟机一样，我们去网上下载镜像，然后挂载到机器上，成为虚拟系统。但是这两者完全不相同。</p><p>这里使用<a href="https://www.zhihu.com/question/48174633" target="_blank" rel="noopener">知乎中针对“<code>docker</code>容器与虚拟机有什么区别？”这一问题<code>water Cc</code>给出的回答（3楼）</a>中的图片来说明：</p><p><img src="https://pic1.zhimg.com/80/20006deca0fccda0d536edd626835e9e_720w.jpg?source=1940ef5c" alt="虚拟机和docker的区别"></p><p>我们可以看到，左边是<strong>虚拟机</strong>的架构，而右边是<strong>Docker</strong>的架构。最底下的<code>Server</code>和<code>Host OS</code>合起来构成物理主机，也就是我们平常所用的个人电脑。</p><p>其中，<strong>虚拟机</strong>使用了<code>Hypervisor</code>，全称是<strong>虚拟机监视器</strong>，是一种运行在基础物理服务器和操作系统之间的中间软件层，可允许多个操作系统和应用共享硬件。也就是说，我们在针对<strong>虚拟机</strong>中挂载的系统操作的时候，<strong>挂载的系统</strong>监听到了操作，并交给挂载的操作系统处理，然后被<strong>虚拟机监视器</strong>监听到，收集数据后发送给<strong>物理主机</strong>，最终由<strong>物理主机</strong>完成系统调用，最后返还给<strong>挂载的系统</strong>并回显结果。这一整串过程是不是非常复杂？是不是能够理解为什么虚拟机挂载的时候慢一点了？</p><p>而<strong>Docker</strong>就不一样，取消了<strong>Hypervisor</strong>和<strong>挂载的系统</strong>，直接使用对应的基础代码库。这个基础代码库甚至可以不是操作系统，可以是<strong>单纯的某个应用</strong>，比如<code>MySQL</code>、<code>Zookeeper</code>等等，这就在灵活性上提升了一个数量级；其次，取消了<code>Hypervisor</code>能够让<code>Docker</code>运行中容器里的操作直接交给物理主机进行系统调用，速度上非常占优，相应非常迅速。</p><p>但是相对而言两者也同样有利有弊。</p><p>对于虚拟机来说，经过<strong>Hypervisor</strong>和<strong>挂载的系统</strong>能够实现非常完美的隔离性；而仅使用<strong>Docker Engine</strong>运行的几个容器隔离性相对较弱。</p><p>不仅如此，直接将请求传送给物理主机进行系统调用的<strong>Docker</strong>是非常依赖物理主机的架构和操作系统内核的。例如：<code>Windows</code>能够使用<code>Docker</code>运行<code>Windows Server</code>和<code>Linux</code>系统，但是<code>Linux</code>系统则只能够使用<code>Docker</code>运行<code>Linux</code>系统，因为内核完全不支持；而使用<strong>Hypervisor</strong>的<strong>虚拟机</strong>则使用中间件屏蔽了操作系统内核和架构的具体实现，从而使得<strong>虚拟机</strong>能够挂载<code>Windows</code>、<code>Linux</code>甚至<code>MacOS</code>。</p><p>二者差别还是非常大的，但在不同的环境下也各有千秋，开发者们需要根据自己的需求选择合适的实现方法。当然实际生产环境中还是希望能够使用更为轻量级的<code>Docker</code>来实现比较不错的响应速度。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>简介主要介绍了<code>Docker</code>相关，包括生态和优缺点。相信大家已经对<code>Docker</code>有了基本的了解。由于<code>Windows</code>有一键安装<code>Docker</code>的安装包，所以接下来我们就在<code>Ubuntu</code>下安装<code>Docker</code>，就不考虑<code>Windows</code>了。</p><p>首先确认我们要<strong>删除旧版本</strong>（<em>如果没有可以跳过</em>）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get purge docker</span><br><span class="line">sudo apt-get purge docker-ce</span><br><span class="line">sudo apt-get remove -y docker-*</span><br></pre></td></tr></table></figure><p>然后<strong>开始安装</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Ubuntuan安装Docker</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 0 - 进入root权限</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 没有设置root用户的密码使用如下语句</span></span><br><span class="line">sudo su</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置了root用户的密码使用如下语句</span></span><br><span class="line">su</span><br><span class="line"><span class="meta">#</span><span class="bash"> 1 - 下载必要的包</span></span><br><span class="line">apt-get install \</span><br><span class="line">  apt-transport-https \</span><br><span class="line">  ca-certificates \</span><br><span class="line">  curl gnupg-agent \</span><br><span class="line">  software-properties-common -y</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2 - 添加国内阿里云docker-ce镜像的GPG-key</span></span><br><span class="line">curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | apt-key add -</span><br><span class="line"><span class="meta">#</span><span class="bash"> 3 - 添加国内阿里云docker-ce镜像源</span></span><br><span class="line">add-apt-repository \</span><br><span class="line">  "deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \</span><br><span class="line"><span class="meta">  $</span><span class="bash">(lsb_release -cs) \</span></span><br><span class="line">  stable"</span><br><span class="line"><span class="meta">#</span><span class="bash"> 4 - 更新包</span></span><br><span class="line">apt-get update</span><br><span class="line"><span class="meta">#</span><span class="bash"> 5 - 安装包</span></span><br><span class="line">apt-get install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure><p><code>CentOS</code>安装<code>Docker</code>的方法也附上，你会用到的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> CentOS安装Docker</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1 - 下载必要的包</span></span><br><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2 - 配置源</span></span><br><span class="line">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"><span class="meta">#</span><span class="bash"> 3 - 列出所有版本</span></span><br><span class="line">yum list docker-ce --showduplicates | sort -r</span><br><span class="line"><span class="meta">#</span><span class="bash"> 4 - 选择安装版本并填入<span class="variable">$&#123;version&#125;</span></span></span><br><span class="line">yum install docker-ce-$&#123;version&#125; -y</span><br></pre></td></tr></table></figure><p>到这里大致上就<strong>结束</strong>了。我们来检验一下是不是安装好了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker --version</span><br></pre></td></tr></table></figure><p>如果输出是这样的，那么就是安装成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Docker version 19.03.12, build 48a66213fe</span><br></pre></td></tr></table></figure><p>当然，这其中的数字和字符串可能每个人选择的版本不同就会显示不一样的结果，这一点无需担心，只要确认能够出现这样的信息就是<strong>安装成功</strong>。</p><p>下面是<strong>安装失败</strong>的输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command 'docker' not found, but there are 21 similar ones.</span><br></pre></td></tr></table></figure><p>安装完之后就是使用了。但是由于客户端默认连接的<code>Docker Hub</code>是国外的镜像仓库，所以下载速度非常慢，这里就需要更改默认配置为国内镜像仓库。</p><p><strong>首先是确认用什么仓库</strong>。目前比较好的库就是<strong>Docker CN</strong>、网易、阿里云等等。但是阿里云镜像需要自行申请，手续麻烦而且界面不够人性化，所以我选择网易，也就是<code>http://hub-mirror.c.163.com</code>。</p><p>其次，来<strong>确认<code>Docker</code>服务是否启动</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo docker images # 查看镜像列表，如果报错则服务未启动</span><br><span class="line">systemctl status docker # 系统调用查看服务</span><br></pre></td></tr></table></figure><p><strong>如果没有启动就打开</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker # 安装后第一次运行需要启动服务</span><br></pre></td></tr></table></figure><p>启动之后就会生成<code>/etc/docker</code>文件夹，如果没有请检查是否启动失败。</p><p>在里面添加<code>daemon.json</code>文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/docker</span><br><span class="line">sudo touch daemon.json</span><br><span class="line">sudo vi daemon.json</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输入文本：</span></span><br><span class="line">&#123;</span><br><span class="line">  "registry-mirrors": ["http://hub-mirror.c.163.com"]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我是选择了网易镜像，你也可以替换为其他镜像。</p><p>然后拉取速度就非常快了。</p><p><strong>愉快的玩耍吧</strong>！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;简介部分主要参考了&lt;strong&gt;尚硅谷周阳&lt;/strong&gt;的&lt;a href=&quot;https://bilibili.com/BV1Vs411E7AR&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;B站视频&lt;/a&gt;，安装部分主要参考了&lt;a href=&quot;https://www.cnblogs.com/walker-lin/p/11214127.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;walker_lin&lt;/code&gt;的&lt;code&gt;docker&lt;/code&gt;学习（一）&lt;code&gt;ubuntu&lt;/code&gt;上安装&lt;code&gt;docker&lt;/code&gt;一文&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="运维" scheme="http://www.sakebow.cn/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="docker" scheme="http://www.sakebow.cn/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>SQL基础</title>
    <link href="http://www.sakebow.cn/2020/07/09/MySQL/SQL%E5%9F%BA%E7%A1%80/"/>
    <id>http://www.sakebow.cn/2020/07/09/MySQL/SQL%E5%9F%BA%E7%A1%80/</id>
    <published>2020-07-09T10:25:00.000Z</published>
    <updated>2020-07-30T15:01:58.778Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong><code>SQL</code>语句是所有数据库系统没有办法绕开的。与其说是基础，不如说是所有数据库系统遵循的“行业规范”。</strong></p><a id="more"></a><h2 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h2><p>因为数据库的数据非常多，内存往往不能满足所有数据的存储，而且当服务器断电后，内存中的所有数据将会立即消失，是非常严重的事故。如果涉及交易，这将会是毁灭性的灾难。</p><p>所以数据往往都是存在硬盘中，也作“<strong>磁盘</strong>”，大容量、信息不随着电的消失而消失，是非常不错的载体。但是速度奇慢，无法在有效时间内回复大量的查询请求。于是，人们发明了<strong>B+树</strong>。</p><p><strong>B+树</strong>的特点就是非叶子节点并不占用内存，只有真正找到了位置并读取数据的时候才有一次磁盘IO，在此之前完全基于内存的操作极大提升了查询速度。而使得数据按照一定规律排列成B+树的就是数据库的<strong>索引</strong>。</p><p>索引能够根据指定的字段重构数据库表用于存储的树形结构，从而能够在一定程度上优化查询，从$O(n)$降到$O(\log(n))$，如果是4000行数据，将会从4000次对比降到20次以内，这是非常贴近理想的优化。</p><h2 id="SQL语句基本公式"><a href="#SQL语句基本公式" class="headerlink" title="SQL语句基本公式"></a><code>SQL</code>语句基本公式</h2><p>每个计算机语言都有他的公式，比如<strong>C语言</strong>的<code>printf(&quot;%d&quot;, &amp;n)</code>，又如<strong>Java</strong>的<code>System.out.println(&quot;Hello World&quot;)</code>，都是有规律可循。依照规律，无论是平时作业还是大型项目都是信手拈来。下面给出<code>SQL</code>语句的公式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> &lt;选择字段&gt;</span><br><span class="line"><span class="keyword">FROM</span> &lt;左表&gt; &lt;<span class="keyword">join</span>类型&gt;</span><br><span class="line"><span class="keyword">JOIN</span> &lt;右表&gt; <span class="keyword">ON</span> &lt;<span class="keyword">join</span>条件&gt;</span><br><span class="line"><span class="keyword">WHERE</span> &lt;选择条件&gt;</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;集合条件&gt;</span><br><span class="line"><span class="keyword">HAVING</span> &lt;聚合条件&gt;</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;排序条件&gt;</span><br><span class="line"><span class="keyword">LIMIT</span> &lt;每页选择行数&gt; <span class="comment">-- 这里是MySQL特有的分页</span></span><br></pre></td></tr></table></figure><h2 id="运行解析"><a href="#运行解析" class="headerlink" title="运行解析"></a>运行解析</h2><p>当然，<code>SQL</code>是一门高级语言，机器无法识别，只能说是由机器解释后运行。解析便和编辑完全是两回事了。我们假设有这么一句<code>SQL</code>和上面给出的公式完全一样的顺序，解析之后就会变成这样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FROM &lt;左表&gt; -- 获得笛卡尔积</span><br><span class="line">ON &lt;join条件&gt; -- 主表保留</span><br><span class="line">&lt;JOIN类型&gt; JOIN &lt;右表&gt; -- 不符合ON的数据也添加进去</span><br><span class="line">WHERE &lt;选择条件&gt; -- 非聚合数据</span><br><span class="line">GROUP BY &lt;集合条件&gt; -- 改变对表的引用</span><br><span class="line">HAVING &lt;聚合条件&gt; -- 之作用分组后</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">DISTINCT</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;排序条件&gt; <span class="comment">-- 可使用SELECT别名</span></span><br><span class="line"><span class="keyword">LIMIT</span> &lt;每页选择行数&gt; <span class="comment">-- 行数、偏移量</span></span><br></pre></td></tr></table></figure><p>有些人估计就直接蒙圈了。来举个例子吧：</p><blockquote><p>你迷恋上了手办，准备搜罗一下有没有自己喜欢的，然后统一入手。初期，你收集了一点点信息，并做成了表格：</p><p><strong>手办表</strong></p><div class="table-container"><table><thead><tr><th>手办id</th><th>对应人物</th><th>服饰</th><th>价格</th></tr></thead><tbody><tr><td>1</td><td>蕾姆</td><td>蓝色比基尼</td><td>99.00</td></tr><tr><td>2</td><td>巧克力</td><td>红色长袖睡衣</td><td>258.00</td></tr><tr><td>3</td><td>香草</td><td>蓝色短袖睡衣</td><td>258.00</td></tr></tbody></table></div><p><strong>番剧表</strong></p><div class="table-container"><table><thead><tr><th>番剧id</th><th>番剧名称</th><th>出场人物</th></tr></thead><tbody><tr><td>1</td><td>NEKOPARA</td><td>巧克力</td></tr><tr><td>1</td><td>NEKOPARA</td><td>香草</td></tr><tr><td>2</td><td>Re:从零开始的异世界生活</td><td>蕾姆</td></tr></tbody></table></div><p>然后，你想把这两个表对应起来，于是编写<code>SQL</code>：</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> 手办表.对应人物, 手办表.服饰, 手办表.价格, 番剧表.番剧名称, 番剧表.出场人物</span><br><span class="line"><span class="keyword">FROM</span> 手办表, 番剧表</span><br><span class="line"><span class="keyword">WHERE</span> 手办表.对应人物 = 番剧表.出场人物</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> 手办表.对应人物, 手办表.服饰, 手办表.价格, 番剧表.番剧名称, 番剧表.出场人物;</span><br><span class="line">ORDER BY 手办表.价格 DESC</span><br></pre></td></tr></table></figure><blockquote><p>运行这样的语句之后，你的表格就变成了这样：</p><p><strong>番剧手办表</strong></p><div class="table-container"><table><thead><tr><th>对应人物</th><th>服饰</th><th>番剧名称</th><th>价格</th></tr></thead><tbody><tr><td>蕾姆</td><td>蓝色比基尼</td><td>Re:0</td><td>99</td></tr><tr><td>巧克力</td><td>红色长袖睡衣</td><td>NEKOPARA</td><td>258.00</td></tr><tr><td>香草</td><td>蓝色短袖睡衣</td><td>NEKOPARA</td><td>258.00</td></tr></tbody></table></div><p>看起来挺不错的。</p><p>在系统里面他们又是怎么运行的呢？</p></blockquote><p>首先，我们<strong>向内存中加载</strong><code>FROM</code>语句后面所有的表，并<strong>交叉相联合</strong>，也就是我们最为熟悉的<strong>排列组合</strong>，番剧表三条记录、手办表三条记录，所以内存一共加载了$3\times3=9$条记录；</p><p>其次，没有发现<code>ON</code>、<code>JOIN</code>语句，跳过；</p><p>然后发现有<code>WHERE</code>语句，所以系统将会按照<code>WHERE</code>语句给出的条件筛选手办对应任务和番剧出场人物相同的行。这里一共匹配到了三项，也就是上面的“<strong>番剧手办表</strong>”所显示的内容；</p><p>接着就发现了<code>GROUP BY</code>语句，于是根据所有选择的项进行分组。一般情况下应当是所有出现在<code>SELECT</code>列表上的<strong>所有项都应该出现在这里</strong>；</p><p><code>HAVING</code>是分组条件，也就是在<code>GROUP BY</code>存在的情况下才能使用。具体使用其实和<code>WHERE</code>是完全一样的。只不过分组的时候更倾向于使用范围，也就是<code>HAVING field &gt; 0</code>之类的语句；</p><p>分组完成后就是列出所有项了。<code>SELECT</code>将会从已经加载在内存里所有的列中选取指定的列；后面紧跟着的<code>DISTINCT</code>就是保证选出来的所有行不会有相同的数据；</p><p>最后就是<code>ORDER BY</code>对最终得出的行根据指定的字段进行排列，整段代码最后的<code>DESC</code>是倒序排列的意思；而默认情况是<code>ASC</code>，即正序排列。</p><p>这么过了一遍原理，会不会有点理解了？</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;SQL&lt;/code&gt;语句是所有数据库系统没有办法绕开的。与其说是基础，不如说是所有数据库系统遵循的“行业规范”。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="SQL" scheme="http://www.sakebow.cn/categories/SQL/"/>
    
    
      <category term="MySQL" scheme="http://www.sakebow.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>版本控制的另一种打开方式</title>
    <link href="http://www.sakebow.cn/2020/07/08/Java/SpringCloud/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/"/>
    <id>http://www.sakebow.cn/2020/07/08/Java/SpringCloud/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/</id>
    <published>2020-07-08T13:02:00.000Z</published>
    <updated>2020-11-13T07:32:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>节奏越来越开的现今社会，项目完成速度也越发加快，于是一个项目的人数也就越来越多。这个时候版本控制也就尤为重要。本篇将不再说明使用<code>coding</code>、<code>Gitee</code>或者<code>GitHub</code>进行托管的方法，而是使用<code>GitLab</code>和<code>Nenux</code>实现的<code>DIY</code>托管平台</strong></p><a id="more"></a><h2 id="什么是GitLab"><a href="#什么是GitLab" class="headerlink" title="什么是GitLab"></a>什么是GitLab</h2><p><code>GitLab</code>实际上也是一种<code>GitHub</code>，只不过<code>GitLab</code>可以本地部署，这样就能够实现<code>GitHub</code>的私有代码库，并且<code>GitLab</code>免费开源。细心的你应该很容易就发现了<code>GitHub</code>官网在创建代码库的时候能够让用户选择创建开源仓库或者私有仓库，可是还有一行小字：<strong>每个月$7</strong>。这就很伤心了。所以<code>GitLab</code>实际上也是给了我们一个自己动手创建私有仓库的小办法。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p><code>GitLab</code>使用<code>Ruby on Rails</code>搭建，虽然有一定的便利性，却安装步骤极其麻烦，是现在不可多得的<strong>反人类</strong>开源框架。不过，就算再怎么反人类，也是有办法制服他的。<del><em>以下就是早期人类制服野生<code>GitLab</code>的记录。</em></del></p><p>首先是<code>GitLab</code>。我们选择中文版的安装包：<code>twang2218/gitlab-ce-zh</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull twang2218/gitlab-ce-zh</span><br></pre></td></tr></table></figure><p>这个包一共<strong>1.61G</strong>，非常庞大，下载需要一些时间。如果是国外镜像很容易下载失败。如果可以的话尽可能使用国内镜像。</p><p>紧接着我们需要一份<code>docker-compose.yml</code>文件，通过<code>docker-compose</code>我们能够更快速、更一体化地完成镜像的创建。</p><p>下面是<code>docker-compose.yml</code>文件的具体内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span> <span class="comment"># 版本号</span></span><br><span class="line"><span class="attr">services:</span> <span class="comment"># 开启服务</span></span><br><span class="line">  <span class="attr">gitlab:</span> <span class="comment"># 服务名称</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">'twang2218/gitlab-ce-zh:latest'</span> <span class="comment"># 使用镜像</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">'GitLab'</span> <span class="comment"># 主机名称（自定义）</span></span><br><span class="line">    <span class="attr">environment:</span> <span class="comment"># 环境配置</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">'Asia/Shanghai'</span></span><br><span class="line">      <span class="attr">GITLAB_OMNIBUS_CONFIG:</span> <span class="string">|</span></span><br><span class="line">        <span class="string">external_url</span> <span class="string">'http://192.168.1.112:8080'</span></span><br><span class="line">        <span class="string">gitlab_rails['gitlab_shell_ssh_port']</span> <span class="string">=</span> <span class="number">4022</span></span><br><span class="line">        <span class="string">unicorn['port']</span> <span class="string">=</span> <span class="number">8888</span></span><br><span class="line">        <span class="string">nginx['listen_port']</span> <span class="string">=</span> <span class="number">8080</span></span><br><span class="line">    <span class="attr">ports:</span> <span class="comment"># 端口映射</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">'4080:8080'</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">'4443:8443'</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">'4022:22'</span></span><br><span class="line">    <span class="attr">volumes:</span> <span class="comment"># 挂载卷</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/usr/local/docker/gitlab/config:/etc/gitlab</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/usr/local/docker/gitlab/data:/var/opt/gitlab</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/usr/local/docker/gitlab/logs:/var/log/gitlab</span></span><br></pre></td></tr></table></figure><p><strong>在文件中尤其注意以下几点</strong>：</p><ul><li><p><code>external_url</code>规定了我们访问地址，但是映射之后就变成了<code>192.168.1.111:4080</code>，连规定的<code>IP</code>地址都掰成了物理主机的<code>IP</code>地址，即<code>192.168.1.111</code>。</p></li><li><p><code>nginx</code>的监听端口一定要和<code>external_url</code>的端口保持一致</p></li></ul><p>好了，我们开始吧。既然文件中规定了各种配置文件的位置，那么我们就把<code>docker-compose.yml</code>文件放到<code>/usr/local/docker/gitlab</code>中吧！接着跳转到这个文件夹中输入命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p><img src="https://sakebow.gitee.io/images/SpringCloud/Docker开启GitLab服务.png" alt="输入流程"></p><p>这里需要声明一点：命令<code>docker-compose up -d</code>中的<code>-d</code>千万不可省略，是使容器后台运行的参数。因为是服务器，所以需要持续监听，也就是说将会有大量的日志信息会<strong>不间断输出</strong>。所以不加上<code>-d</code>的同学就只是干看着命令行一行行滚动，实际上什么时候编译好了都不知道。就像下面这样不停的输出：</p><p><img src="https://sakebow.gitee.io/images/SpringCloud/无止境的日志文件.png" alt="无休止的等待界面"></p><p>然后就是漫长的等待……好吧其实也不是很漫长。启动之后访问，不停的刷新，首先出来的是这个页面：</p><p><img src="https://sakebow.gitee.io/images/SpringCloud/等待界面.png" alt="等待界面"></p><p>然后就到了这里。</p><p><img src="https://sakebow.gitee.io/images/SpringCloud/进入界面.png" alt="正确界面"></p><p>由于我使用的内存是<strong>4+16G</strong>，全过程一共90秒。</p><h2 id="帐号登陆"><a href="#帐号登陆" class="headerlink" title="帐号登陆"></a>帐号登陆</h2><p>然后，到这一步，就尬住了。新账号？确认密码？什么东西？<code>GitLab</code>官网还上不去怎么办？</p><p>别担心，我们可以直接操作服务器。</p><p>我们不是已经用<code>Docker</code>启动了一个本地服务器嘛，就直接用<code>docker exec</code>命令接入服务器，修改用户名和密码就好了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Ubuntu</span></span><br><span class="line">sudo su # 超管权限</span><br><span class="line">docker ps -a # 查看我们启动的容器编号是多少，我这里是45d3728d94c4</span><br><span class="line">docker exec -it 45 /bin/bash # 进入容器</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 容器内</span></span><br><span class="line">gitlab-rails console production # 操作gitlab</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> GitLab操作台</span></span><br><span class="line">user = User.where(id:1).first # 显示默认用户信息</span><br><span class="line">user.password = $&#123;YOUR PASSWORD&#125; # 设置自定义密码</span><br><span class="line">user.save! # 保存用户信息</span><br></pre></td></tr></table></figure><p><img src="https://sakebow.gitee.io/images/SpringCloud/修改默认用户信息.png" alt="输入"></p><p>这时我们再进去修改密码就可以使用了。</p><p><img src="https://sakebow.gitee.io/images/SpringCloud/成功.png" alt="进入界面"></p><p>其他的就是和<code>GitHub</code>一样的用了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;节奏越来越开的现今社会，项目完成速度也越发加快，于是一个项目的人数也就越来越多。这个时候版本控制也就尤为重要。本篇将不再说明使用&lt;code&gt;coding&lt;/code&gt;、&lt;code&gt;Gitee&lt;/code&gt;或者&lt;code&gt;GitHub&lt;/code&gt;进行托管的方法，而是使用&lt;code&gt;GitLab&lt;/code&gt;和&lt;code&gt;Nenux&lt;/code&gt;实现的&lt;code&gt;DIY&lt;/code&gt;托管平台&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://www.sakebow.cn/categories/java/"/>
    
    
      <category term="SpringCloud" scheme="http://www.sakebow.cn/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud简介</title>
    <link href="http://www.sakebow.cn/2020/07/08/Java/SpringCloud/SpringCloud%E7%AE%80%E4%BB%8B/"/>
    <id>http://www.sakebow.cn/2020/07/08/Java/SpringCloud/SpringCloud%E7%AE%80%E4%BB%8B/</id>
    <published>2020-07-08T13:02:00.000Z</published>
    <updated>2020-12-09T15:47:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>不得不说，<code>Java</code>行业变动实在太大。从一开始的<code>J2EE</code>，到<code>SSH</code>、<code>SSM</code>，接着就马上迎来了<code>SpringBoot</code>和<code>SpringCloud</code>。这里我使用的是<a href="https://bilibili.com/BV1jJ411S7xr" target="_blank" rel="noopener">狂神说Java的SpringCloud视频</a>，说的非常浅显，也很全面。</strong></p><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>首先声明，<code>SpringCloud</code>严格意义上来说不是一个新的框架，而是一个由旧的技术抽象出统一的规范而形成的很大的生态。从<code>SpringCloud</code>官网中就能看出，它不是一个配一配就能用的框架，而是一个很大的工程，下面附带非常多的子项目，包括网关、分布式、权限管理等等非常多的内容，但是本质还是<code>Spring</code>，模块也是基于<code>SpringBoot</code>，是一个典型的旧事新篇。</p><h2 id="怎么学"><a href="#怎么学" class="headerlink" title="怎么学"></a>怎么学</h2><p>如果你是完全没有编程基础，或者说从未接触过分布式，那就来跟着我一起学吧，不要有任何怀疑。如果你有一定的基础，还请多看看<code>JVM</code>，有余力甚至可以尝试当前热门的<code>Python</code>和<code>Go</code>，这个框架学习笔记已经满足不了你了。</p><p>另外呢，许多社区的共同努力也让<code>SpringCloud</code>有了足够的拓展了，目前的热门开源项目就是原生的<code>SpringCloud</code>和阿里的<code>SpringCloud Alibaba</code>。但是两者有着较大的差别。更详细的差别还请查看<a href="https://blog.csdn.net/feichitianxia/article/details/92682828" target="_blank" rel="noopener">木子雷的“通过对比<code>Dubbo</code>和<code>SpringCloud</code>，综合选择最合适的”</a>，这里简单总结就是：阿里的<code>SpringCloud Alibaba</code><strong>生态还未成熟</strong>，许多关键点还未有对应成熟框架开源，而且集成第三方框架也有些许困难，在技术成熟度上，原生的<code>SpringCloud</code>更胜一筹，这也是为什么目前原生的使用更广泛。</p><h2 id="知识储备"><a href="#知识储备" class="headerlink" title="知识储备"></a>知识储备</h2><p>不管是做什么都是要事先做一点知识储备的，学习也不例外。这里并不推荐什么学习顺序，因为每个人的学习方式都有所不同，有些人喜欢实践优先，而有些人喜欢理论优先，大家还是根据自己的步调，急也急不来。</p><p>另外，多多少少还是需要有一点点<code>Maven</code>基础，如果没有深入了解的话起码应该有一个<code>SSM</code>项目经验，这个就是典型的<code>Maven</code>应用。如果对<code>Spring</code>没有更深入的了解，有最基本的<code>API</code>使用经验也是足够的，最起码学会如何使用<code>SpringCloud</code>是够了。如果还需要进阶的话就需要<code>JVM</code>和<code>Spring</code>以及<code>SpringMVC</code>的基础了。当然，这些都是后话了。这篇笔记本来就是入门笔记，所以要求比较低，各位还请放心观看。如果避开所有说明就是一个快速无原理速通秘籍。在这里还是希望各位不要在掌握了<code>API</code>的调用之后沾沾自喜，想要生活得更体面还是需要进阶的。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>首先是<strong>硬件</strong>的选择。一台足够顺手的电脑是一个好的开始，比如键盘短路、内存不足等等都是很让人头疼的问题。这些可以尽快联系专业人士或者多关注拆装机博客自行安装。如果是比较小的问题，比如更换键盘、加装内存等等建议自行解决，拆机装机能够极大锻炼一些小技巧，面对众多螺丝钉的时候也能够极大地锻炼你的耐心和细心。</p><p>接着就是<strong>系统</strong>的选择。如果你已经厌烦了<code>Windows</code>冗赘的后台，不妨尝试免费的<code>Ubuntu</code>、<code>CentOS</code>等，或者国产的<code>Deepin</code>、<code>UOS</code>等。当然，你也可以选择有些昂贵的<code>MacOS</code>，这些都是需要认真考虑的。如果你自制力较差，选择了<code>Windows</code>却学一会了马上打开了游戏，可以考虑更换系统协助戒网瘾。如果希望尝试新系统却无法抛弃原先<code>Windows</code>的使用习惯，<code>Deepin</code>和<code>MacOS</code>将会是一个很不错的选择；如果你有条件，建议直接选择<code>MacOS</code>或者选择<strong>黑苹果</strong>，因为这一系统设计的初衷就是为了设计人员和编程人员；如果没有条件还是建议选择<code>Ubuntu</code>系统，因为是专为编程人员打造的专业系统，也因为它比较方便而且美观，对<code>Linux</code>新手来说是一个不错的选择。</p><p><strong>配置环境</strong>就不再赘述了，无论是<code>Windows</code>还是<code>Ubuntu</code>抑或<code>MacOS</code>，都有非常多、非常详细的说明，这里大家自行根据自己的情况选择合适的教程，需要安装的有<code>jdk</code>、<code>Maven</code>。</p><p>然后就是<strong>应用</strong>。当前<code>IntelliJ</code>公司做的一系列产品已经足够优秀了，但是收费。能够通过一些其他方式获得或者有条件支持正版的话推荐使用，毕竟代码自动补充、源码追溯、全域查找等功能实在是太人性化了。而<code>Eclipse</code>虽然逊色一点，却也是经典的<code>Java</code>程序编辑器。很多企业还是喜欢使用自己魔改的<code>Eclipse</code>来进行各种各样的操作，到目前为止也有较多的社区在为<code>Eclipse</code>插件做贡献，总能找到你喜欢的一款。但是由于我弄到了一款<code>IntelliJ</code>的<code>IDEA</code>，所以就不再使用<code>Eclipse</code>演示了。</p><p>最后，<strong>寻找合适的教程开始吧</strong>！我选择了狂神，如果你觉得可以，就跟上我一起吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;不得不说，&lt;code&gt;Java&lt;/code&gt;行业变动实在太大。从一开始的&lt;code&gt;J2EE&lt;/code&gt;，到&lt;code&gt;SSH&lt;/code&gt;、&lt;code&gt;SSM&lt;/code&gt;，接着就马上迎来了&lt;code&gt;SpringBoot&lt;/code&gt;和&lt;code&gt;SpringCloud&lt;/code&gt;。这里我使用的是&lt;a href=&quot;https://bilibili.com/BV1jJ411S7xr&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;狂神说Java的SpringCloud视频&lt;/a&gt;，说的非常浅显，也很全面。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://www.sakebow.cn/categories/java/"/>
    
    
      <category term="SpringCloud" scheme="http://www.sakebow.cn/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>MySQL简介</title>
    <link href="http://www.sakebow.cn/2020/07/07/MySQL/MySQL%E7%AE%80%E4%BB%8B/"/>
    <id>http://www.sakebow.cn/2020/07/07/MySQL/MySQL%E7%AE%80%E4%BB%8B/</id>
    <published>2020-07-07T09:16:00.000Z</published>
    <updated>2020-12-07T23:44:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong><code>MySQL</code>是最流行的关系型数据库管理系统之一，因为其轻量级、自由度高、免费开源而备受青睐。现在国内也有非常多的大型企业魔改<code>MySQL</code>而特化某种极端场景，其中以阿里为典型代表。</strong></p><a id="more"></a><blockquote><p><code>Oracle</code>数据库是它是一种高效率、可靠性好的、适应高吞吐量的数据库方案。（<em>摘自百度百科：<a href="https://baike.baidu.com/item/Oracle%E6%95%B0%E6%8D%AE%E5%BA%93" target="_blank" rel="noopener">Oracle数据库</a></em>）</p></blockquote><p>这是<code>Oracle</code>留给我们的印象。现在许多政府主导的项目多使用的就是<code>Oracle</code>，因为适应高并发且安全稳定，但是相当的重量级，对服务器的配置要求相当的高，安装时也要求图形化界面，对于少有<code>GUI</code>界面的<code>Linux Server</code>并不是非常的友好，对于后台线程繁多的<code>Windows</code>系统也并没有好很多。但是它最大的特点就是数据恢复。每次的操作都保存在了磁盘上，可以随时恢复，<code>Oracle</code>公司也能够对企业提供对应的收费服务。</p><p>而与之对应的，MySQL不仅数据容易丢失，而且诊断调优解决方案少，安全上也更容易被仿冒进而被攻击，可以说在各种程度上还在起跑阶段。但是由于其开源、免费两个特点，不少社区已经逐渐在丰富<code>MySQL</code>的性能和缺陷。许多公司也在根据自己的需求修改并使用。</p><p>更详细的对比情况如下所示：（总结自<a href="https://www.cnblogs.com/xu-cceed3w/p/8824199.html" target="_blank" rel="noopener">IT小黑的博客</a>）</p><h2 id="MySQL和Oracle的对比"><a href="#MySQL和Oracle的对比" class="headerlink" title="MySQL和Oracle的对比"></a>MySQL和Oracle的对比</h2><h3 id="事务提交"><a href="#事务提交" class="headerlink" title="事务提交"></a>事务提交</h3><div class="table-container"><table><thead><tr><th>MySQL</th><th>Oracle</th></tr></thead><tbody><tr><td>自动提交</td><td>手动使用<code>commit</code>命令</td></tr></tbody></table></div><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><div class="table-container"><table><thead><tr><th>MySQL</th><th>Oracle</th></tr></thead><tbody><tr><td><code>limit</code>命令</td><td>伪列<code>ROWNUM</code>和嵌套查询</td></tr></tbody></table></div><h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><p>两者都支持<code>serializable</code>串行化事务隔离级别，都实现了最高级别的读一致性，即一个<code>session</code>提交后其他<code>session</code>才能够看到提交的修改</p><ul><li><p>MySQL</p><p><code>read commited</code>的隔离级别。</p></li><li><p>Oracle</p><p><code>repeatable commit</code>的隔离级别。不同的是，Oracle会在undo表中构造多个版块，能够让开发者能够查询旧数据块。举一个比较简单的例子，当插入学生数据的时候系统自动确定学号，并添加10点积分。代码如下：</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">TRIGGER</span> JWXT.TRI_STUDENT_ID_CALC</span><br><span class="line"><span class="comment">-- 在JWXT中创建触发器TRI_STUDENT_ID_CALC</span></span><br><span class="line"><span class="keyword">BEFORE</span> <span class="keyword">INSERT</span></span><br><span class="line"><span class="comment">-- 在插入数据之前触发该触发器定义的事件</span></span><br><span class="line"><span class="keyword">ON</span> TB_STUDENT</span><br><span class="line"><span class="comment">-- 对应TB_STUDENT表进行操作</span></span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span></span><br><span class="line"><span class="comment">-- 触发器针对每一行触发</span></span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">  student_no <span class="built_in">VARCHAR</span>(<span class="number">100</span>);</span><br><span class="line">  <span class="comment">-- 定义字段 student_no 记录当前是第几个学生</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="comment">-- 触发器主体</span></span><br><span class="line"><span class="comment">-- 假设 TB_STUDNET 表建立了序列 SEQ_STUDNET</span></span><br><span class="line"><span class="comment">-- 假设 TB_STUDENT 表记录学生学号的字段是 student_id</span></span><br><span class="line">  <span class="keyword">SELECT</span> SEQ_STUDENT.NEXTVAL <span class="keyword">INTO</span> student_no <span class="keyword">FROM</span> SYS.dual;</span><br><span class="line">  <span class="comment">-- 将当前序列输入变量 student_no</span></span><br><span class="line">  :NEW.student_id := to_char(sysdate, "yyyyMMddhhmmss") || student_no;</span><br><span class="line">  <span class="comment">-- 修改student_id</span></span><br><span class="line">  :NEW.count := :OLD.count + 10;</span><br><span class="line">  <span class="comment">-- 给帐务添加10点积分</span></span><br><span class="line"><span class="comment">-- 错误处理</span></span><br><span class="line">EXCEPTION</span><br><span class="line">  RAISE_APPLICATION_ERROR(100031, "学号生成出错"); <span class="comment">-- 抛出异常</span></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>这里的<code>:NEW</code>和<code>:OLD</code>就是典型的访问<strong>新数据</strong>和<strong>旧数据</strong>。</p><h3 id="事务支持"><a href="#事务支持" class="headerlink" title="事务支持"></a>事务支持</h3><div class="table-container"><table><thead><tr><th>MySQL</th><th>Oracle</th></tr></thead><tbody><tr><td>仅在<code>InnoDB</code>引擎中开启行级所的情况下才支持事务</td><td>完全支持</td></tr></tbody></table></div><h3 id="数据持久"><a href="#数据持久" class="headerlink" title="数据持久"></a>数据持久</h3><div class="table-container"><table><thead><tr><th>MySQL</th><th>Oracle</th></tr></thead><tbody><tr><td>重启服务将会完全丢失所有数据、数据库更新字段后立即丢失原先数据</td><td>提交数据的操作全部存在磁盘上，随时可恢复；并且<code>Oracle</code>公司提供数据恢复的收费服务</td></tr></tbody></table></div><h3 id="并发支持"><a href="#并发支持" class="headerlink" title="并发支持"></a>并发支持</h3><ul><li><p>MySQL</p><p><code>MyISAM</code>引擎下仅支持表级锁，即当一个<code>session</code>修改表后，整个表被锁住，其他任何会话无法对表进行任何操作。这对高并发要求极不友好，大量的时间都在等待上一个甚至几个<code>session</code>退出</p></li><li><p>Oracle</p><p>完全支持行锁。在当前<code>session</code>修改表的过程中，其他<code>session</code>能够访问并修改其他行，单位时间内能够处理更多的请求</p></li></ul><h3 id="逻辑备份"><a href="#逻辑备份" class="headerlink" title="逻辑备份"></a>逻辑备份</h3><div class="table-container"><table><thead><tr><th>MySQL</th><th>Oracle</th></tr></thead><tbody><tr><td>锁住整张表，影响数据库的增删改操作</td><td>不锁表，对其他操作无影响</td></tr></tbody></table></div><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><ul><li><p>MySQL</p><p>复制服务器配置简单。但主库出问题时，从库有可能丢失一定的数据。且需要手工切换从库到主库</p></li><li><p>Oracle</p><p>既有推或拉式的传统数据复制，也有dataguard的双机或多机容灾机制，主库出现问题是，可以自动切换备库到主库，但配置管理较复杂。</p></li></ul><h3 id="性能诊断"><a href="#性能诊断" class="headerlink" title="性能诊断"></a>性能诊断</h3><div class="table-container"><table><thead><tr><th>MySQL</th><th>Oracle</th></tr></thead><tbody><tr><td>调优方法较少，主要是<code>慢查询日志</code></td><td>调优方法成熟，可实现多种自动分析、诊断调优功能，有<code>awr</code>、<code>addm</code>、<code>sqltrace</code>、<code>tkproof</code>等</td></tr></tbody></table></div><h3 id="权限安全"><a href="#权限安全" class="headerlink" title="权限安全"></a>权限安全</h3><div class="table-container"><table><thead><tr><th>MySQL</th><th>Oracle</th></tr></thead><tbody><tr><td>仅和主机IP有关，容易被仿冒</td><td>安全认证思想比较传统，中规中矩</td></tr></tbody></table></div><h3 id="分区索引"><a href="#分区索引" class="headerlink" title="分区索引"></a>分区索引</h3><div class="table-container"><table><thead><tr><th>MySQL</th><th>Oracle</th></tr></thead><tbody><tr><td>技术不成熟</td><td>技术成熟</td></tr></tbody></table></div><h3 id="管理工具"><a href="#管理工具" class="headerlink" title="管理工具"></a>管理工具</h3><div class="table-container"><table><thead><tr><th>MySQL</th><th>Oracle</th></tr></thead><tbody><tr><td>除了自带的命令行就是第三方</td><td>有多种应用程序解决方案</td></tr></tbody></table></div><h3 id="附加服务"><a href="#附加服务" class="headerlink" title="附加服务"></a>附加服务</h3><div class="table-container"><table><thead><tr><th>MySQL</th><th>Oracle</th></tr></thead><tbody><tr><td>无</td><td>数据恢复等由<code>Oracle</code>公司提供的完整服务</td></tr></tbody></table></div><h3 id="其他条件"><a href="#其他条件" class="headerlink" title="其他条件"></a>其他条件</h3><div class="table-container"><table><thead><tr><th>MySQL</th><th>Oracle</th></tr></thead><tbody><tr><td>免费开源、轻量级</td><td>付费服务、超重量级</td></tr></tbody></table></div><h2 id="为什么选择MySQL"><a href="#为什么选择MySQL" class="headerlink" title="为什么选择MySQL"></a>为什么选择MySQL</h2><p>这么一罗列似乎<code>MySQL</code>始终处于劣势。但是<code>MySQL</code>它本身的轻量级提供了非常方便的部署环境。众多中小企业还是非常喜欢使用<code>MySQL</code>的。其次就是因为他灵活的架构。</p><p>他是这么一个架构：（图源来自<a href="https://blog.csdn.net/weixin_42358062/article/details/80730694" target="_blank" rel="noopener">CSDN</a>）</p><p><img src="https://images2018.cnblogs.com/blog/1411859/201806/1411859-20180617124155105-273948974.png" alt="MySQL架构图"></p><p>形象一点地说，大概就是这样子：</p><ul><li><p>连接层——守门大爷</p><p>首先就是数据库连接池管理所有的连接，基本上所有的数据库都有这么一个东西。比如<code>Oracle</code>的<code>ODAC</code>就是其中之一。对外于各种语言连接器相对应，对内则于数据的读写相对应。</p></li><li><p>服务层——客服中心</p><ul><li><p>事务管理器——客服小姐</p><p>事务管理器接到请求之后立马转发到<code>SQL</code>接口，即立马转告对应工厂部门</p></li><li><p>优化器——技术顾问</p><p><code>SQL</code>并不像<code>C</code>语言，所写即所运行，而是有专门的优化器来根据系统自己的想法来优化当前的算法，也就像是一个了解技术的顾问一样帮助挑选较优的选择。</p><p>当然，这个选择不一定是最好的，也不一定适合当前环境，但确实是根据系统特定的优化算法算出来的最优解。就像是店家推荐不一定是用户所爱，但也象征了一些什么。</p><p>当然，<code>SQL</code>调优可不单纯是根据数学算算就好了，是结合实际不断的调整，不断的放弃，最终得出来无限接近极限的算法。这就不是系统自带的优化器能够做到的了。就像阿里，既然已经有可靠的<code>DBA</code>数据库管理员就直接魔改<code>MySQL</code>，删掉相对来说没多大作用的优化器，更接近极限响应时间。</p></li><li><p>缓存和缓冲——搬运工</p><p>就如字面意思，搬运数据、暂存数据等等</p></li></ul></li><li><p>引擎层——办公中心</p><p>这里可以说是整个<code>MySQL</code>的精髓所在。这部分最大的特点就是<strong>可插拔</strong>，也就是按需添加删除存储引擎，对应不同的应用场景魔改成不同的<code>MySQL</code>，这是<code>Oracle</code>没有的，也是<code>MySQL</code>无限的潜能所在。各种社区、各种企业、各种研究所都在慢慢魔改，并生成贴合对应生产环境的数据库系统，同时兼顾了轻量级和高可用，相对于什么都有的超重量级<code>Oracle</code>而言是非常大的优点。</p><p>目前用的最多的就是支持行锁的<code>InnoDB</code>引擎。当然也有使用其他引擎的，这都是看企业自己的选择了。</p></li><li><p>存储层——仓库</p><p>这部分主要是文件系统，所有的数据都保存在磁盘上来实现数据的持久化。对于<code>InnoDB</code>而言，这部分就是通过<code>B+树</code>实现的文件系统，由于非叶子节点不占用实际内存，所以减小了内存压力，同时也减少了磁盘IO，极大加快了查询速度。这也是<code>InnoDB</code>这么受欢迎的原因之一。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>有关<code>MySQL</code>的基础知识大概就是这些了。之后将会逐步深挖，从入门的索引、<code>SQL</code>再到进阶的调优、主从等，逐步了解<code>MySQL</code>数据库。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;MySQL&lt;/code&gt;是最流行的关系型数据库管理系统之一，因为其轻量级、自由度高、免费开源而备受青睐。现在国内也有非常多的大型企业魔改&lt;code&gt;MySQL&lt;/code&gt;而特化某种极端场景，其中以阿里为典型代表。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="SQL" scheme="http://www.sakebow.cn/categories/SQL/"/>
    
    
      <category term="MySQL" scheme="http://www.sakebow.cn/tags/MySQL/"/>
    
  </entry>
  
</feed>
