<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sakebow的小博客</title>
  
  <subtitle>一条苦苦挣扎的废柴大学狗</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.sakebow.cn/"/>
  <updated>2020-09-18T12:34:32.375Z</updated>
  <id>http://www.sakebow.cn/</id>
  
  <author>
    <name>Sakebow</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>决策树算法</title>
    <link href="http://www.sakebow.cn/2020/09/23/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%AE%97%E6%B3%95%E6%A8%A1%E5%9E%8B/%E5%86%B3%E7%AD%96%E6%A0%91%E7%AE%97%E6%B3%95/"/>
    <id>http://www.sakebow.cn/2020/09/23/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%AE%97%E6%B3%95%E6%A8%A1%E5%9E%8B/%E5%86%B3%E7%AD%96%E6%A0%91%E7%AE%97%E6%B3%95/</id>
    <published>2020-09-23T12:23:00.000Z</published>
    <updated>2020-09-18T12:34:32.375Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>决策树，听起来就像是有许多分支的树，也听起来像是能够帮助我们作出某种决策的方法。</strong></p><a id="more"></a><h2 id="决策树的定义"><a href="#决策树的定义" class="headerlink" title="决策树的定义"></a>决策树的定义</h2><p>既然是树，那么首先就有<strong>根</strong>，其次有<strong>树枝</strong>，然后有<strong>果实</strong>。</p><p><strong>根</strong>，就是一个对象实体；<strong>树枝</strong>则是一个对象的多种属性；<strong>果实</strong>则是<strong>基于这个对象实体、对照该对象实体的某种属性，就能够得出某种结果</strong>。</p><p>听起来非常难懂？那还是老套路，你家的猫娘又出来了。</p><p>当然，<strong>单看你家里的一只猫娘是没有什么参考性的</strong>。所以，你还是收集了20万只猫娘的很多种属性，然后对照总结。</p><p>这只猫娘的眼白有些发红，所以有可能生病了，带进诊所给医生看看；那只猫娘在检查的时候一直“啊吧啊吧”地流口水，有可能是紧张了，也有可能是口腔有些疾病，带进观察室呆一会；又有一只猫娘晚上打呼噜很大声，那么她就是单纯的打呼噜很大声，给她一只毛线球去快乐地玩耍吧……</p><p>看完这个例子，不难发现，<strong>根</strong>就是猫娘这一物种，<strong>树枝</strong>就是眼睛发红、流口水、打呼噜等等特征，<strong>果实</strong>则是由这些特征的猫娘会有什么样的症状。但是光有根、树枝和果实的树并不能够非常完美地构成猫娘这一物种，而正是这20万组猫娘的数据构成了这颗决策树的树干，丰富了猫娘这一物种，让这一物种更为饱满、更<strong>有依可寻</strong>。</p><h2 id="决策树的思想"><a href="#决策树的思想" class="headerlink" title="决策树的思想"></a>决策树的思想</h2><p>“<strong>是什么</strong>”说明白了，接下来要说“<strong>为什么</strong>”了。</p><p>决策树和分治算法、动态规划这些<strong>分而治之</strong>的思想不太一样，虽然都有剪枝，但是决策树在剪枝的基础上增加了概率。这和<strong>分而治之</strong>思想中<strong>一票否决</strong>的硬杠杆不一样，更像是遇到多个问题的时候逐个投票，然后根据人数占比的统计和可接受度的比较，最终得出了结果。</p><p>打个比方，如果使用<strong>分而治之</strong>的思想来对待你的猫娘，那么就会是这个样子：</p><p>你的猫娘在你收拾的时候瞎捣乱，</p><ul><li>你狠狠地责备了她。</li></ul><p>如果是<code>GalGame</code>的话选了这个选项估计直接就走入<code>Bad End</code>了。</p><p>而如果是决策树，就会这样：</p><p>你的猫娘在你收拾的时候瞎捣乱，</p><ul><li><p>首先碰翻了垃圾桶，由于是空桶所以就只是把桶扶起来，摸摸她的头，笑着说：“小捣蛋鬼！”</p></li><li><p>之后把桌子上的东西都打在地上了，由于掉下去的都是抽纸、不锈钢盘子、遥控器等等，没什么散落一地的东西，也没泼什么东西在地上，就把东西重新放好。她再把东西推下去，你就把拳头扬起来做出一副要打下去的样子。起初她张牙舞爪的准备迎击，看你一直没打下去放松了戒备。然后你趁机弹了一下她的脑门，她就捂着额头跑掉了。你也就有了机会继续收拾。</p></li><li><p>接着爬到你背上胡抓乱挠，由于收拾得差不多了，你把她从背上抓下来，索陪她性大玩特玩。</p></li></ul><p>有<code>Happy End</code>的感觉了！</p><p>仔细看这个例子，你会发现每次遇到事件的时候，你都会好好地根据当前一些特征现象进行选择，比如<strong>不责备和责备</strong>、<strong>陪她玩和继续收拾</strong>。</p><p>和每遇到一个条件就剪枝的<strong>分而治之</strong>算法不同，决策树最大的特点就是会根据许多不同的特征无序地按照一定的概率筛选。就像给猫娘看病一样，并不是一开始就从脑袋开始检查，也并不是最终一定要把检查脚底放在最后。</p><p>这样的话，在与猫娘相处时发生的很多事情来看，决策树往往更灵活、更温柔。当然，这也需要你对很多事情有更多的观察、参照和经历，就过程而言并不容易。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;决策树，听起来就像是有许多分支的树，也听起来像是能够帮助我们作出某种决策的方法。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="人工智能" scheme="http://www.sakebow.cn/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
      <category term="算法模型" scheme="http://www.sakebow.cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>随机森林算法</title>
    <link href="http://www.sakebow.cn/2020/09/19/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%AE%97%E6%B3%95%E6%A8%A1%E5%9E%8B/%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E7%AE%97%E6%B3%95/"/>
    <id>http://www.sakebow.cn/2020/09/19/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%AE%97%E6%B3%95%E6%A8%A1%E5%9E%8B/%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E7%AE%97%E6%B3%95/</id>
    <published>2020-09-19T08:23:00.000Z</published>
    <updated>2020-09-17T12:27:52.728Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>随机森林算法，就像名字一样，是很多树构成的算法。而这树也不是一般的树，是决策树。</strong></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;随机森林算法，就像名字一样，是很多树构成的算法。而这树也不是一般的树，是决策树。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="人工智能" scheme="http://www.sakebow.cn/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
      <category term="算法模型" scheme="http://www.sakebow.cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>TSNE紧急学习</title>
    <link href="http://www.sakebow.cn/2020/09/17/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%AE%97%E6%B3%95%E6%A8%A1%E5%9E%8B/TSNE%E7%B4%A7%E6%80%A5%E5%AD%A6%E4%B9%A0/"/>
    <id>http://www.sakebow.cn/2020/09/17/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%AE%97%E6%B3%95%E6%A8%A1%E5%9E%8B/TSNE%E7%B4%A7%E6%80%A5%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-09-17T01:14:00.000Z</published>
    <updated>2020-09-18T02:19:08.061Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>因为是紧急学习，所以这里将会是无原理速通。实际上这也是在研究生数学建模竞赛中短短的五天内紧急学习的成果。虽然不会有什么高见，但也还是希望各位能够尽可能指正。</strong></p><a id="more"></a><h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p>我们先来看看<a href="https://scikit-learn.org/stable/auto_examples/manifold/plot_t_sne_perplexity.html#sphx-glr-auto-examples-manifold-plot-t-sne-perplexity-py" target="_blank" rel="noopener">一个例子</a></p><p>单纯的贴出所有的代码就没意思了。所以这里我将会用注释的方式来解释这个程序到底在干什么：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Author: Narine Kokhlikyan &lt;narine@slice.com&gt;</span></span><br><span class="line"><span class="comment"># License: BSD</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(__doc__) -- 不知道什么用</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导包：numpy，matplotlib，sklearn，time</span></span><br><span class="line"><span class="comment"># 如果你是ubuntu19及以上系统，请使用pip3安装依赖包，因为只内置了pip3</span></span><br><span class="line"><span class="comment"># 如果你是windows或者ubuntu19以下系统，你也可以使用pip下载依赖</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> matplotlib.ticker <span class="keyword">import</span> NullFormatter</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> manifold, datasets</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确定样本数量和支线数量</span></span><br><span class="line">n_samples = <span class="number">300</span></span><br><span class="line">n_components = <span class="number">2</span></span><br><span class="line"><span class="comment"># 绘制图片，图片中包含3行5列图表，每张图表宽15，长8</span></span><br><span class="line">(fig, subplots) = plt.subplots(<span class="number">3</span>, <span class="number">5</span>, figsize=(<span class="number">15</span>, <span class="number">8</span>))</span><br><span class="line"><span class="comment"># 设置不同的困惑度</span></span><br><span class="line">perplexities = [<span class="number">5</span>, <span class="number">30</span>, <span class="number">50</span>, <span class="number">100</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用sklearn库的make_circles方法生成同心圆</span></span><br><span class="line"><span class="comment"># 其中规定一共n_samples个点，两个圆圈的距离比例为0.5，异常点占比5%</span></span><br><span class="line">X, y = datasets.make_circles(n_samples=n_samples, factor=<span class="number">.5</span>, noise=<span class="number">.05</span>)</span><br><span class="line"><span class="comment"># 如果y是0，记为红色</span></span><br><span class="line">red = y == <span class="number">0</span></span><br><span class="line"><span class="comment"># 如果y是1，记为绿色</span></span><br><span class="line">green = y == <span class="number">1</span></span><br><span class="line"><span class="comment"># 创建多个子图</span></span><br><span class="line">ax = subplots[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"><span class="comment"># </span></span><br><span class="line">ax.scatter(X[red, <span class="number">0</span>], X[red, <span class="number">1</span>], c=<span class="string">"r"</span>)</span><br><span class="line">ax.scatter(X[green, <span class="number">0</span>], X[green, <span class="number">1</span>], c=<span class="string">"g"</span>)</span><br><span class="line">ax.xaxis.set_major_formatter(NullFormatter())</span><br><span class="line">ax.yaxis.set_major_formatter(NullFormatter())</span><br><span class="line">plt.axis(<span class="string">'tight'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, perplexity <span class="keyword">in</span> enumerate(perplexities):</span><br><span class="line">    ax = subplots[<span class="number">0</span>][i + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    t0 = time()</span><br><span class="line">    tsne = manifold.TSNE(n_components=n_components, init=<span class="string">'random'</span>,</span><br><span class="line">                         random_state=<span class="number">0</span>, perplexity=perplexity)</span><br><span class="line">    Y = tsne.fit_transform(X)</span><br><span class="line">    t1 = time()</span><br><span class="line">    print(<span class="string">"circles, perplexity=%d in %.2g sec"</span> % (perplexity, t1 - t0))</span><br><span class="line">    ax.set_title(<span class="string">"Perplexity=%d"</span> % perplexity)</span><br><span class="line">    ax.scatter(Y[red, <span class="number">0</span>], Y[red, <span class="number">1</span>], c=<span class="string">"r"</span>)</span><br><span class="line">    ax.scatter(Y[green, <span class="number">0</span>], Y[green, <span class="number">1</span>], c=<span class="string">"g"</span>)</span><br><span class="line">    ax.xaxis.set_major_formatter(NullFormatter())</span><br><span class="line">    ax.yaxis.set_major_formatter(NullFormatter())</span><br><span class="line">    ax.axis(<span class="string">'tight'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Another example using s-curve</span></span><br><span class="line">X, color = datasets.make_s_curve(n_samples, random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">ax = subplots[<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">ax.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">2</span>], c=color)</span><br><span class="line">ax.xaxis.set_major_formatter(NullFormatter())</span><br><span class="line">ax.yaxis.set_major_formatter(NullFormatter())</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, perplexity <span class="keyword">in</span> enumerate(perplexities):</span><br><span class="line">    ax = subplots[<span class="number">1</span>][i + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    t0 = time()</span><br><span class="line">    tsne = manifold.TSNE(n_components=n_components, init=<span class="string">'random'</span>,</span><br><span class="line">                         random_state=<span class="number">0</span>, perplexity=perplexity)</span><br><span class="line">    Y = tsne.fit_transform(X)</span><br><span class="line">    t1 = time()</span><br><span class="line">    print(<span class="string">"S-curve, perplexity=%d in %.2g sec"</span> % (perplexity, t1 - t0))</span><br><span class="line"></span><br><span class="line">    ax.set_title(<span class="string">"Perplexity=%d"</span> % perplexity)</span><br><span class="line">    ax.scatter(Y[:, <span class="number">0</span>], Y[:, <span class="number">1</span>], c=color)</span><br><span class="line">    ax.xaxis.set_major_formatter(NullFormatter())</span><br><span class="line">    ax.yaxis.set_major_formatter(NullFormatter())</span><br><span class="line">    ax.axis(<span class="string">'tight'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Another example using a 2D uniform grid</span></span><br><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">1</span>, int(np.sqrt(n_samples)))</span><br><span class="line">xx, yy = np.meshgrid(x, x)</span><br><span class="line">X = np.hstack([</span><br><span class="line">    xx.ravel().reshape(<span class="number">-1</span>, <span class="number">1</span>),</span><br><span class="line">    yy.ravel().reshape(<span class="number">-1</span>, <span class="number">1</span>),</span><br><span class="line">])</span><br><span class="line">color = xx.ravel()</span><br><span class="line">ax = subplots[<span class="number">2</span>][<span class="number">0</span>]</span><br><span class="line">ax.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=color)</span><br><span class="line">ax.xaxis.set_major_formatter(NullFormatter())</span><br><span class="line">ax.yaxis.set_major_formatter(NullFormatter())</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, perplexity <span class="keyword">in</span> enumerate(perplexities):</span><br><span class="line">    ax = subplots[<span class="number">2</span>][i + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    t0 = time()</span><br><span class="line">    tsne = manifold.TSNE(n_components=n_components, init=<span class="string">'random'</span>,</span><br><span class="line">                         random_state=<span class="number">0</span>, perplexity=perplexity)</span><br><span class="line">    Y = tsne.fit_transform(X)</span><br><span class="line">    t1 = time()</span><br><span class="line">    print(<span class="string">"uniform grid, perplexity=%d in %.2g sec"</span> % (perplexity, t1 - t0))</span><br><span class="line"></span><br><span class="line">    ax.set_title(<span class="string">"Perplexity=%d"</span> % perplexity)</span><br><span class="line">    ax.scatter(Y[:, <span class="number">0</span>], Y[:, <span class="number">1</span>], c=color)</span><br><span class="line">    ax.xaxis.set_major_formatter(NullFormatter())</span><br><span class="line">    ax.yaxis.set_major_formatter(NullFormatter())</span><br><span class="line">    ax.axis(<span class="string">'tight'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>在这里面涉及了一些非常新颖的词汇：</p><h2 id="迷惑度"><a href="#迷惑度" class="headerlink" title="迷惑度"></a>迷惑度</h2><p>迷惑度，又称<code>perplexity</code>，是<code>NLP</code>算法中评价算法拟合度好坏的标准。虽然针对不同的问题，<code>perplexity</code>是越大越好还是越小越好并没有一个非常统一的答案。不过，在大多数情况下，迷惑度基本上是越小越好。</p><p>那么什么是迷惑度？我们来打个比方：</p><p>你家里的猫娘带着朋友来家里玩了。可是猫娘之间的交流就可以不说人话了，不管是肢体语言、腺体激素分泌还是尾巴的动作，都是她们交流的方式。这个时候你就非常的迷惑：“<strong>我是谁？我在哪？她们在说啥？</strong>”。突然，另一只猫娘冲着你“喵”了一声。突如其来的事情让你在风中零乱，<strong>迷惑度直接飙升到100%</strong>。</p><p>突然你家的猫娘看着你在不知所云的神情，用人话说明了她想吃饼干（<em>虽然看起来很没礼貌，但很可爱就原谅她了</em>）。<strong>你恍然大悟，迷惑度降到最低</strong>，然后像个侍奉主子的奴才一样端上了饼干。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;因为是紧急学习，所以这里将会是无原理速通。实际上这也是在研究生数学建模竞赛中短短的五天内紧急学习的成果。虽然不会有什么高见，但也还是希望各位能够尽可能指正。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="人工智能" scheme="http://www.sakebow.cn/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
      <category term="算法模型" scheme="http://www.sakebow.cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>JWT简介</title>
    <link href="http://www.sakebow.cn/2020/09/15/Java/SpringBoot/JWT%E7%AE%80%E4%BB%8B/"/>
    <id>http://www.sakebow.cn/2020/09/15/Java/SpringBoot/JWT%E7%AE%80%E4%BB%8B/</id>
    <published>2020-09-15T15:33:00.000Z</published>
    <updated>2020-09-16T09:16:35.628Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong><code>JWT</code>，全称<code>Json Web Token</code>，我们平常所说的<code>token</code>实际上就是说<code>JWT</code>技术中的<code>T</code>。</strong></p><a id="more"></a><h2 id="Session和Token的对比"><a href="#Session和Token的对比" class="headerlink" title="Session和Token的对比"></a><code>Session</code>和<code>Token</code>的对比</h2><p>如果你对<code>jsp</code>和<code>Servlet</code>非常熟悉，你应该对<code>Session</code>非常熟悉。每当用户登录的时候都会使用<code>Cookie</code>和<code>Session</code>联动起来，服务端使用<code>session.setAttribute()</code>方法完整地保存用户的信息，并使用<code>session.getAttribute()</code>方法完整地获取用户的信息。听起来非常方便？</p><p>可是呢，如果你读过我之前写的<a href="/2020/02/24/Java/面试常考/Session工作原理/"><code>Session</code>工作原理</a>，你会发现：<code>Session</code>对于服务器的压力还是相当大的。如果项目突然迎来了海量数据和大量并发，服务器宕机的概率大大增加，对于已经落地的项目甚至会产生不可逆转的错误。</p><p>于是，用户在线时就每时每刻维护一个<code>Session</code>的方法逐渐被摒弃；进而选择了用户每次请求的时候发送用户信息，顺便检查权限。一举两得，岂不美哉？<code>JWT</code>就应运而生了。在分布式场景中，仅在请求时服务器产生少许压力的<code>token</code>也就比始终给服务器施加压力并无法释放的<code>Session</code>更为实用。</p><h2 id="Token的结构"><a href="#Token的结构" class="headerlink" title="Token的结构"></a><code>Token</code>的结构</h2><p><code>Token</code>本质上是一串字符串，其中包含三个部分，三个部分分别是<strong>头部</strong>、<strong>负载</strong>和<strong>签名</strong>，每个部分由英文句号<code>.</code>来分开。</p><p>为什么这么做？因为这个字符串可以直接作为用户的标识，一旦被其他人截获，便能够直接作为请求使用。所以，我们往往会将这三个部分使用<code>Base64</code>算法进行编码，请求发送到服务器之后再将信息使用<code>Base64</code>算法进行解码。</p><h3 id="头部"><a href="#头部" class="headerlink" title="头部"></a>头部</h3><p><strong>头部</strong>主要是包含两段信息：<strong>数据类型</strong>和<strong>签名算法</strong>。</p><p><strong>数据类型</strong>一般是选择<code>JWT</code>作为数据类型，不同于一般的<code>Json</code>又不同于普通的字符串；</p><p><strong>签名算法</strong>一般是选择<code>HS256</code>，这也是官方推荐的算法。</p><h3 id="负载"><a href="#负载" class="headerlink" title="负载"></a>负载</h3><p>第二个部分则是<strong>负载</strong>，也作<strong>有效负载</strong>。其中包含了一些有必要的数据声明。比如，我们可以将用户<code>id</code>和用户权限码等等非常重要的信息。</p><p>但是呢，如果你发送的信息真的被截获了，还是会被很简单的解码获得了信息，所以只能在这部分只能尽可能不要放一些敏感信息，否则会被盗号。</p><p>同样的，这部分也会使用<code>Base64</code>算法编码。</p><h3 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h3><p><strong>签名</strong>就像是交付的时候有个安全员通过唯一指定的识别器来确认操作的用户确实是你，而不是其他的什么人。</p><p>所以签名这部分就是头部和负载的结合，再使用一个<strong>随机盐</strong>再次编码。每当用户发送请求的时候，服务器都会首先使用第一部分和第二部分使用<strong>只有服务器知道</strong>的随机盐加密，再和第三部分比对。加密后的信息和第三部分是相同的，那么就是正确的，本次识别器确认了用户信息，否则就是非法登录。</p><p>这个算法从逻辑上能够在一定程度上保证请求信息不会被其他用户非法使用。但是呢，这个算法还是不能够保证别有用心的人修改你的个人隐私。这就很无奈了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;JWT&lt;/code&gt;，全称&lt;code&gt;Json Web Token&lt;/code&gt;，我们平常所说的&lt;code&gt;token&lt;/code&gt;实际上就是说&lt;code&gt;JWT&lt;/code&gt;技术中的&lt;code&gt;T&lt;/code&gt;。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://www.sakebow.cn/categories/java/"/>
    
    
      <category term="SpringBoot" scheme="http://www.sakebow.cn/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>遗传算法</title>
    <link href="http://www.sakebow.cn/2020/09/15/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%AE%97%E6%B3%95%E6%A8%A1%E5%9E%8B/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/"/>
    <id>http://www.sakebow.cn/2020/09/15/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%AE%97%E6%B3%95%E6%A8%A1%E5%9E%8B/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/</id>
    <published>2020-09-15T09:01:00.000Z</published>
    <updated>2020-09-15T09:44:14.017Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>机器学习中有非常多的算法，遗传算法就是其中之一。正因为有所特点，所以才被人们广为使用。</strong></p><a id="more"></a><h2 id="遗传算法的定义"><a href="#遗传算法的定义" class="headerlink" title="遗传算法的定义"></a>遗传算法的定义</h2><p>为什么偏偏把这个算法叫做“<strong>遗传</strong>”算法？那是因为这个算法是一种<strong>进化算法</strong>，基本原理是效仿生物界中“<strong>物竞天择，适者生存</strong>”的演化法则。具体来说就是这个样子：</p><ul><li>在算法开始之前，所有的数据就作为一个<strong>生态圈</strong>出现在了我们的面前。</li><li>生态圈中的任何一个个体都遵循一样的规律：<strong>有血</strong>、<strong>有肉</strong>、<strong>要呼吸</strong>；也就是说这个数据集中需要按照一定的结构表示成基本相似的数据类型。</li><li>等到所有的生物都就位了之后（<em>数据集准备好了之后</em>），生态圈残酷的斗争和竞争就开始了。类比到数据集的筛选就是针对每个数据使用同一个适应度来评估数据的优劣。同样的，在这里优胜劣汰</li><li>适应度并不是千篇一律的，而是针对每一个不同的问题有完全不同的解决方案。</li></ul><p>算法思想又是如何呢？</p><ul><li><strong>选择</strong>：选择是为了能够选出优秀的个体，并使用这些个体产生后代</li><li><strong>交叉</strong>：如果是生物学，这里应该就是称为<strong>交配</strong>了。当然，这里是人为地选择一些个体进行信息交换，而不是任由这些数字胡乱交换</li><li><strong>变异</strong>：如果是生物学，这里应该就是对应<strong>基因突变</strong>了。当然，这里是人为地选择一些个体，按照一定的概率强行修改数据集中的某一个数据。正因为自然界中变异概率极小，大概$10^{-9}$，所以在这里变异的概率也非常非常小。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;机器学习中有非常多的算法，遗传算法就是其中之一。正因为有所特点，所以才被人们广为使用。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="人工智能" scheme="http://www.sakebow.cn/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
      <category term="算法模型" scheme="http://www.sakebow.cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>python进阶训练：聊天室</title>
    <link href="http://www.sakebow.cn/2020/08/20/python/python%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%EF%BC%9A%E8%81%8A%E5%A4%A9%E5%AE%A4/"/>
    <id>http://www.sakebow.cn/2020/08/20/python/python%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%EF%BC%9A%E8%81%8A%E5%A4%A9%E5%AE%A4/</id>
    <published>2020-08-19T16:01:00.000Z</published>
    <updated>2020-09-01T14:54:46.739Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>既然我们完成了基本的链表功能，相信也对<code>Python</code>语言有了一定的了解。那么我们现在开始进阶：<code>Python</code>聊天室（命令行版）。</strong></p><a id="more"></a><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>使用<code>UDP</code>代码库，使得两个进程之间得以通信。接收的时候直接输出到终端；发送的时候直接发送到指定端口，并使用死循环监听信息。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义全局变量udp</span></span><br><span class="line">udp = socket(AF_INET, SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_data</span><span class="params">(send_data, target_ip)</span>:</span></span><br><span class="line">  udp.sendto(send_data.encode(encoding = <span class="string">'utf-8'</span>), target_ip)</span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 接受数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recv_data</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="comment"># 拿到传输数据和源地址</span></span><br><span class="line">  socket_data, addr = udp.recvfrom(<span class="number">1024</span>)</span><br><span class="line">  <span class="comment"># 当前时间</span></span><br><span class="line">  current_time = time.strftime(<span class="string">'%Y-%m-%d %X'</span>, time.localtime(time.time()))</span><br><span class="line">  print(<span class="string">'================================================='</span>)</span><br><span class="line">  <span class="comment"># 输出到终端</span></span><br><span class="line">  print(<span class="string">f'now: <span class="subst">&#123;current_time&#125;</span>, IP: <span class="subst">&#123;addr[<span class="number">0</span>]&#125;</span>:<span class="subst">&#123;addr[<span class="number">1</span>]&#125;</span>\ncontent: <span class="subst">&#123;socket_data.decode(encoding = <span class="string">"utf-8"</span>)&#125;</span>'</span>)</span><br><span class="line">  print(<span class="string">'================================================='</span>)</span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>最后，我们在主函数中使用死循环监听这两个函数就好了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  <span class="comment"># 客户端1用8998端口</span></span><br><span class="line">  addr_bind = (<span class="string">''</span>, <span class="number">8998</span>)</span><br><span class="line">  udp.bind(addr_bind)</span><br><span class="line">  <span class="comment"># 客户端2用8999端口 / 本机IP192.168.1.111</span></span><br><span class="line">  target_ip = (<span class="string">'192.168.1.111'</span>, <span class="number">8999</span>)</span><br><span class="line">  <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    send_text = input(<span class="string">'say something: '</span>)</span><br><span class="line">    <span class="keyword">if</span> send_text == <span class="string">'bye'</span>:</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    <span class="comment"># 客户端1 - 先发送再接收</span></span><br><span class="line">    <span class="comment"># 客户端2 - 先接收再发送</span></span><br><span class="line">    send_data(send_text, target_ip)</span><br><span class="line">    recv_data()</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>到这里，简单的聊天室就完成了。</p><h2 id="结束？"><a href="#结束？" class="headerlink" title="结束？"></a>结束？</h2><p>你以为这样就能交作业了吗？<strong>还早着呢</strong>。这样只能实现两个端的交流，而且还只能限定从客户端1开始，从客户端2结束。作为多对多的<code>UDP</code>觉得自己非常吃亏，而且没有<code>GUI</code>的项目就不是一个好项目。</p><p>所以，在这里划一条线，我们将认真开始。</p><hr><h2 id="进阶1-添加服务器"><a href="#进阶1-添加服务器" class="headerlink" title="进阶1 - 添加服务器"></a>进阶1 - 添加服务器</h2><p><strong>前排提示</strong>：所有的文件都将放到<a href="https://github.com/sakebow/python-chat" target="_blank" rel="noopener"><code>GitHub</code></a>上，不会在这里花很多篇幅展示。所以希望学习的同学们可以两边结合起来看。</p><h3 id="综述"><a href="#综述" class="headerlink" title="综述"></a><strong>综述</strong></h3><p>就拿我们最常用的<strong>QQ</strong>和<strong>微信</strong>来说，都是由腾讯提供服务器，我们交流的时候首先提交到服务器上，然后再由服务器回显到各个客户端中。</p><p>所以，我们的首要目标就是<strong>建立服务器</strong>并让客户端和服务器能够<strong>正常连接</strong>。</p><p>首先我们需要明确服务器的功能。每次有数据提交到服务器的时候，服务器其实没有<strong>长期保留</strong>这个数据的必要，只不过是拿到了数据，并<strong>转发</strong>给所有的客户端而已。所以，实际上服务器只是需要做到<strong>接收</strong>和<strong>发送</strong>两个功能就足够了。</p><p>于是，这个项目的架构就差不多定下来了：</p><p>/ 根目录</p><p>┣ <code>config.py</code> 项目配置文件</p><p>┣ <code>ssocket.py</code> 基础socket实现类</p><p>┣ <code>server.py</code> 服务器实例类和功能实现</p><p>┣ <code>wrapper.py</code> 数据帧封装类</p><p>┗ <code>test.py</code> 输出测试类</p><p>看起来没什么毛病。就算有毛病估计你现在也是一脸蒙。接下来我将详细展开每个文件是干什么。</p><p>那么我们就开始准备了。既然是服务器的实现，那么就需要完善基本的网络通信，即<code>socket</code>库的具体业务实现。</p><h3 id="步骤一：确定基本配置项和底层实现方法"><a href="#步骤一：确定基本配置项和底层实现方法" class="headerlink" title="步骤一：确定基本配置项和底层实现方法"></a><strong>步骤一：确定基本配置项和底层实现方法</strong></h3><p><code>Python</code>的<code>socket</code>库和<code>C</code>语言的<code>socket</code>库有着异曲同工之妙，如果是使用<code>Ubuntu</code>系统编程的话应该能够很明显地感觉到这两者几乎很多都是相同的，只不过是再封装而已。发送就是<code>send()</code>，接收就是<code>recv()</code>。即：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">soc = socket()</span><br><span class="line"><span class="comment"># 发送 / 开辟大小为1024B的缓冲区，并对发送的Python对象使用*utf-8*编码为二进制数据</span></span><br><span class="line">soc.send(<span class="number">1024</span>).encode(<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="comment"># 接收 / 开辟大小为1024B的缓冲区，并对接收的二进制数据使用*utf-8*解码为Python对象</span></span><br><span class="line">soc.recv(<span class="number">1024</span>).decode(<span class="string">'utf-8)</span></span><br></pre></td></tr></table></figure><p>看起来没什么问题。但是如果就这么写进项目中，每次收发都这么写绝对很累赘，大量重复的<code>utf-8</code>和<code>1024</code>，如果有一天需要修改的话将会是一场恶梦。</p><p><strong>所以新建<code>config.py</code>记录配置。</strong></p><p>这里需要说明的是，如果是这么定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是作为配置项很不*方便*的写法，仅供参考，请勿模仿</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SOCKET_CONFIG</span><span class="params">(object)</span>:</span></span><br><span class="line">  SOCKET_MAX_CACHE = <span class="number">1232896</span> <span class="comment"># 2的20次方</span></span><br><span class="line">  SOCKET_CHARSET_ENCODING = <span class="string">'utf-8'</span></span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>这样的话你的<code>SOCKET_MAX_CACHE</code>和<code>SOCKET_CHARSET_ENCODING</code>都被<code>Python</code>记为私有变量，不可访问。需要画很多时间构建<code>getter</code>和<code>setter</code>。虽然可以使用<code>@property</code>简化，但是需要我们手动编辑，而且我在<code>Ubuntu2004</code>中使用<code>VScode</code>直接编译不通过，他有自己的想法。所以我放弃了<code>@property</code>并选择了使用<strong>枚举类型</strong>简化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SOCKET_CONFIG</span><span class="params">(Enum)</span>:</span> <span class="comment"># 继承Enum枚举类，属性直接用</span></span><br><span class="line">  SOCKET_MAX_CACHE = <span class="number">1232896</span></span><br><span class="line">  SOCKET_CHARSET_ENCODING = <span class="string">'utf-8'</span></span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>这样的话我们在任何地方就可以直接使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> config <span class="keyword">import</span> * <span class="comment"># 这么引入的前提是当前文件和config.py是同级</span></span><br><span class="line">a = SOCKET_CONFIG.SOCKET_MAX_CAHCE.value </span><br><span class="line"><span class="comment"># 枚举类直接用&#123;名称.value&#125;，直接使用名称得不到值</span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/sakebow/python-chat/blob/master/config.py" target="_blank" rel="noopener">点击这里查看config.py文件具体内容</a></p><p>当然，你也可以选择使用<code>yaml</code>、<code>properties</code>、<code>csv</code>、<code>json</code>和<code>xml</code>文件记录配置，这就看你愿意怎么使用了。如果想省事，直接用<code>py</code>吧；如果是想探索知识、需要构建大型项目或者说已经有一整套配置文件读取的代码库，建议使用单独的配置文件。</p><h3 id="步骤2：封装底层方法"><a href="#步骤2：封装底层方法" class="headerlink" title="步骤2：封装底层方法"></a><strong>步骤2：封装底层方法</strong></h3><p>使用<code>socket</code>创建专门针对某一个特定点的服务的时候，我们更倾向于使用端对端的<code>TCP/IP</code>协议，简单的说就是<strong>针对特定IP的特定端口号发送数据</strong>。根据这个定义我们就知道，需要我们确定<code>IP</code>和<code>端口号</code>，也就是在收发数据之前绑定<code>IP</code>和<code>端口号</code>。但是每一次都绑定肯定会显得累赘。</p><p><strong>所以我们创建<code>ssocket.py</code>封装<code>socket</code>用以绑定基本信息</strong></p><p>其中创建了继承自<code>socket.socket</code>的<code>ServerSocket</code>类，使用<code>AF_INET</code>协议（<code>TCP/IP</code>协议簇中的<code>IPv4</code>协议）和<code>SOCK_STREAM</code>（<code>TCP</code>流，即使用可靠的、端对端的连接进行通信；与之对应的是<code>SOCK_DGRAM</code>，是<code>UDP</code>流，不可靠的、多对多的连接进行通信）。</p><p>接着，我们使用<code>socket.bind()</code>方法传入<code>IP</code>信息和<code>端口号</code>。是以<strong>元组</strong>的形式传入的，即：<code>socket.bind((&#39;127.0.0.1&#39;, 8080))</code>。</p><p>最后，打开监听：<code>socket.listen(128)</code>。</p><p><a href="">点击这里查看ssocket.py文件具体内容</a></p><p>有了这个准备好的<code>ServerSocket</code>，我们就能开始准备<code>Server</code>实体类了。</p><p>在这里插入一个小技巧：</p><p><em><code>Server</code>类其实没有必要继承<code>ServerSocket</code>类，因为可以在<code>Server</code>类中使用<code>ServerSocket</code>对象；当然也可以继承，因为两者在本质上就是对<code>socket</code>进行操作，<code>Server</code>完全可以继承<code>ServerSocket</code>的操作，并在类内对<code>ServerSocket</code>进行拓展。</em></p><p>由于一个小项目，所以就不弄那么复杂了。直接使用实例化对象。</p><p><strong>所以接下来新建<code>server.py</code>，编辑<code>Server</code>类</strong></p><h3 id="步骤三：如何启动服务器"><a href="#步骤三：如何启动服务器" class="headerlink" title="步骤三：如何启动服务器"></a><strong>步骤三：如何启动服务器</strong></h3><p>定义了类之后，我们就需要开始定义具体的服务了。用过<code>Tomcat</code>的应该都知道，我们在配环境的时候会使用<code>startup</code>语句，所以我们这里也定义一个启动服务的<code>start</code>方法。</p><p>具体我们需要做什么呢？因为我们的监听已经开启了，所以我们需要做的就是等待客户端的连接，即使用<code>socket.accept()</code>方法获得两个返回值，一个是从客户端发送过来的数据帧，另一个则是数据源，也就是<strong>IP地址</strong>和<strong>端口号</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">soc, addr = socket.accept()</span><br><span class="line"><span class="comment"># soc是包含了此次传输的内容二进制编码等很多种数据的套接字</span></span><br><span class="line"><span class="comment"># addr则是数据源，是个元组，addr[0]是IP，addr[1]是端口号</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拿到套接字我们可以顺势接收发送的数据，也能返回对套接字的响应</span></span><br><span class="line">print(soc.recv(<span class="number">1024</span>).decode(<span class="string">'utf-8'</span>)) <span class="comment"># 打印是为了查看是否正常</span></span><br><span class="line">soc.send(<span class="string">"hello world!"</span>.encode(<span class="string">'utf-8'</span>))</span><br></pre></td></tr></table></figure><p>当然，还是一样的问题：每次都这么做要重复太多的<code>utf-8</code>和<code>1024</code>，所以封装起来。</p><p><strong>所以我们新建<code>wrapper.py</code>封装客户端套接字</strong></p><p>由于我们之前已经将缓冲区大小、默认编码封装在了<code>config.py</code>里面，所以直接拿来使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recv_data</span><span class="params">(self)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> socket.recv(SOCKET_CONFIG.SOCKET_MAX_CACHE.value).decode(SOCKET_CONFIG.SOCKET_CHARSET_ENCODING.value)</span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_data</span><span class="params">(self, message)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> socket.send(message.encode(SOCKET_CONFIG.SOCKET_CHARSET_ENCODING.value))</span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>为了保证使用之后还能够关闭<code>socket</code>以释放资源，最后再加上一个关闭的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.close()</span><br></pre></td></tr></table></figure><p><a href="https://github.com/sakebow/python-chat/blob/master/wrapper.py" target="_blank" rel="noopener">点击这里查看wrapper.py文件内容</a></p><p>有了<code>wrapper</code>封装之后，我们就直接在<code>Server</code>类中使用<code>wrapper.py</code>定义的实例化对象，这里我定义的是<code>SocketWrapper</code>类，所以<code>Server</code>类在使用<code>accept</code>方法获得套接字后这么使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">soc, addr = socket.accept()</span><br><span class="line">client_soc = SocketWrapper(soc)</span><br></pre></td></tr></table></figure><p>针对单个客户端的单次接入，我们直接使用我们封装好的<code>client_soc</code>就好了。因为是服务器，所以是先<strong>接收</strong>来自客户端的信息，再发送回显给客户端。最后，使用<code>wrapper,py</code>中封装好的<code>close</code>方法关闭连接释放资源。</p><p>具体来说就是这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 严重警告：此处的完整代码仅展示用，有缺陷，请勿模仿</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self)</span>:</span></span><br><span class="line">  <span class="comment"># 获得数据和数据源</span></span><br><span class="line">  soc, addr = self.server_socket.accept()</span><br><span class="line">  <span class="comment"># 绑定封装好的IP和端口，并开启监听</span></span><br><span class="line">  client_soc = SocketWrapper(soc)</span><br><span class="line">  <span class="comment"># 输出查看数据是否正确</span></span><br><span class="line">  print(client_soc.recv_data())</span><br><span class="line">  <span class="comment"># 回显客户端</span></span><br><span class="line">  client_soc.send_data(<span class="string">'connection established!'</span>)</span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>看起来没有问题，但是这样子一个客户端发完一条信息之后，整个服务进程都结束了，再也不能接收客户端传来的消息，除非重启服务器。每条信息都要重启服务器的话也实在是太反人类了。所以我们需要服务器一直在线，那么就加上一个死循环：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 严重警告：此处的完整代码仅展示用，有缺陷，请勿模仿</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self)</span>:</span></span><br><span class="line">  <span class="comment"># 获得数据和数据源</span></span><br><span class="line">  soc, addr = self.server_socket.accept()</span><br><span class="line">  <span class="comment"># 绑定封装好的IP和端口，并开启监听</span></span><br><span class="line">  client_soc = SocketWrapper(soc)</span><br><span class="line">  <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 输出查看数据是否正确</span></span><br><span class="line">    print(client_soc.recv_data())</span><br><span class="line">    <span class="comment"># 回显客户端</span></span><br><span class="line">    client_soc.send_data(<span class="string">'connection established!'</span>)</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>好了，客户端能够一直发信息了。</p><p>但是，这依然不够。这可是聊天室，客户端连接到服务器之后直接使用主进程的死循环收发信息，这样必然导致其他的<strong>任何客户端都不能和服务器交互</strong>，相当于莫名其妙的全员禁言了。这可要不得。</p><p>如果是以前用过<code>SpringBoot</code>开发<code>Web</code>的话，应该非常熟悉<code>@Asyn</code>这个注解，也就是使用子进程实现来自<code>Controller</code>的请求、调用<code>Service</code>的方法、操作<code>Dao</code>的接口等等。为何不借鉴一下这种思想呢？</p><p>所有的客户端一旦接入服务器便立马开启新的子进程，让所有的交互在子进程中完成。这样的话，主进程就可以完完全全地监听信息的接入，就像是<strong>前台接待</strong>一样，全权负责将到店的客户送到指定的房间（<em>子进程</em>）中。这就完成了<code>Server</code>的最终版。</p><p><a href="https://github.com/sakebow/python-chat/blob/master/server.py" target="_blank" rel="noopener">点击这里查看server.py文件具体内容</a></p><p>最后，我们来测试一下结果如何。</p><p><strong>这里就新建<code>test.py</code>来模拟客户端发送<code>socket</code>到服务器</strong></p><p><a href="https://github.com/sakebow/python-chat/blob/master/test.py" target="_blank" rel="noopener">点击这里查看<code>test.py</code>文件内容</a></p><p>到这里，这个聊天室就能够支持多个客户端收发信息、服务器处理多个请求了。但是他依然存在一个问题：<strong>不能显示其他人发送的信息</strong>。</p><p>而给其他人发送信息则又必须使用<code>socket</code>给其他<code>IP</code>发送消息。可是服务器一次只能处理一个请求，这就导致<strong>每次处理的时候只能弄到一个<code>IP</code>地址</strong>。虽然你可以写在文件里，但是这就把一个小项目写复杂了，也因为增加了硬盘的<code>IO</code>而大大降低了速度。所以，为了能够将速度发挥到极致，我这里使用<strong>单线程多路复用</strong>的<code>redis</code>来保存<strong>注册的用户信息</strong>和<strong>登录的用户信息</strong>。你可能会想这不是一样的么？<strong>实际上不一样</strong>。因为登录信息是需要写在当前在线人数表中的，同时服务器也只能给当前在线的人发送信息，否则给不在线的用户发送信息时会因为连接未建立<strong>给每个人抛了个错</strong>，结果所有在线的人一脸蒙逼地给不在线的人背锅。这明显不合理。</p><p>当然，还有一个优点就是<code>redis</code>还能当非关系型数据库使用，可以用于聊天记录的保存。这就是后话了。</p><p>那么问题来了，既然需要<code>redis</code>就需要服务器跑起来。所以这里就使用<code>Docker</code>运行一个简单的<code>redis</code>服务器。</p><p>首先准备<code>docker-compose.yml</code>文件，用于<code>docker</code>镜像的构建：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">redis-30xx:</span> <span class="comment"># 因为端口号不好记，所以记录端口号前两位到三位</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">'redis:latest'</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">'redis-30xx'</span> <span class="comment"># 方便以后避开这些端口号，名字也改改</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">'3079:6379'</span> <span class="comment"># 使用30xx端口映射默认的6379</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/usr/local/docker/redis/config:/conf</span> <span class="comment"># 配置文件</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/usr/local/docker/redis/data:/data</span> <span class="comment"># 数据文件</span></span><br></pre></td></tr></table></figure><p>然后在你的<code>Ubuntu</code>系统下使用超管权限运行<code>docker-compose up -d</code>，这样你的<code>redis</code>就启动起来了。</p><p>这里由于需要操作两个用户组，所以使用<code>redis</code>的集合和<code>python</code>的集合相对应，都是<code>sadd</code>方法用于添加用户，应用在登录和注册上；而<code>srem</code>用于移除用户，应用在用户注销上。</p><h2 id="进阶2-GUI"><a href="#进阶2-GUI" class="headerlink" title="进阶2 - GUI"></a>进阶2 - <code>GUI</code></h2><p>这里就直接使用<code>PyQT</code>作为<code>GUI</code>的搭建。虽然有<code>Qt Creator</code>用来简便绘制用户界面，但是底层却是<code>C++</code>。为了保证这个教程不掺杂一点与<code>Python</code>无关的东西，并为了能够让<code>Python</code>体现出网络编程中标准库的便捷性，这里直接使用一整套<code>Python</code>解决方案。</p><p>既然我们用的最熟悉的是QQ和微信，那么我们就干脆模仿微信的界面。当然，因为技术原因不能很好的模仿，所以就干脆就作出一点点小小的改变。不会很离谱，但也相当乱来。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;既然我们完成了基本的链表功能，相信也对&lt;code&gt;Python&lt;/code&gt;语言有了一定的了解。那么我们现在开始进阶：&lt;code&gt;Python&lt;/code&gt;聊天室（命令行版）。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程进阶综合测验" scheme="http://www.sakebow.cn/categories/%E7%BC%96%E7%A8%8B%E8%BF%9B%E9%98%B6%E7%BB%BC%E5%90%88%E6%B5%8B%E9%AA%8C/"/>
    
    
      <category term="Python" scheme="http://www.sakebow.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>python基础综合：链表</title>
    <link href="http://www.sakebow.cn/2020/08/17/python/python%E5%9F%BA%E7%A1%80%E7%BB%BC%E5%90%88%EF%BC%9A%E9%93%BE%E8%A1%A8/"/>
    <id>http://www.sakebow.cn/2020/08/17/python/python%E5%9F%BA%E7%A1%80%E7%BB%BC%E5%90%88%EF%BC%9A%E9%93%BE%E8%A1%A8/</id>
    <published>2020-08-17T14:00:00.000Z</published>
    <updated>2020-08-27T07:22:44.904Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>因为研究生生涯开始了，所以需要暂时停掉<code>Java</code>的学习，开始使用<code>Python</code>的学习和实践了。于是花了一个小时从完全没学过到实现了最基础的单链表。这里就记录一下。</strong></p><a id="more"></a><h2 id="链表结构复习"><a href="#链表结构复习" class="headerlink" title="链表结构复习"></a>链表结构复习</h2><p>首先我们回顾链表由什么构成。在<code>C</code>语言中，对链表的定义就是：</p><blockquote><p>链表是一种动态数据结构。它主要是利用动态内存分配、使用结构体并配合之镇来实现的一种数据结构。</p><p>——摘自《C语言程序设计（第三版）》苏小红、王宇颖、孙志岗等编著</p></blockquote><p>也就是说，链表有以下几个特点：</p><ul><li><p>是类似数组的链式结构</p></li><li><p>内存分配并不像数组一样完全连续</p></li><li><p>每个节点使用结构体，每个节点也就有了更高的自由度和更大的存储量</p></li><li><p>下一个节点的位置保存在上一个节点中</p></li></ul><h2 id="Python对比预习"><a href="#Python对比预习" class="headerlink" title="Python对比预习"></a><code>Python</code>对比预习</h2><p>复习了链表之后，让我们再看看<code>Python</code>语言相对于<code>C</code>语言和<code>Java</code>有什么不同：</p><ul><li><p>不需要显式声明<code>private</code>、<code>protected</code>和<code>public</code></p></li><li><p>对象名直接对应对象的地址，这一点和<code>Java</code>非常相似</p></li><li><p>没有括号限制函数体，直接用缩进表示</p></li><li><p><code>None</code>对应<code>C</code>语言和<code>Java</code>的<code>null</code></p></li><li><p><code>self</code>代替了<code>C</code>语言和<code>Java</code>的<code>this</code>指针</p></li><li><p>魔法函数<code>__init__</code>直接定义了结构体的属性构成，而不需要显式定义结构体具体有哪些属性</p></li></ul><p>主要就是这些了。具体的细节我们遇到了再去查<a href="https://www.runoob.com/python3/python3-tutorial.html" target="_blank" rel="noopener"><strong>菜鸟教程</strong></a>就好了。当然，如果能够直接查<a href="https://docs.python.org/zh-cn/3/" target="_blank" rel="noopener"><code>Python</code></a>官方文档更好，毕竟都贴心地给出了中文版（但是点进去每个函数的解释还是<strong>英文</strong>，而且没有实例）。</p><h2 id="从节点的定义开始编码"><a href="#从节点的定义开始编码" class="headerlink" title="从节点的定义开始编码"></a>从节点的定义开始编码</h2><p>那么，为了先熟悉<code>Python</code>的语法，我们先来个小小的结构体试试水：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="comment"># 链表节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data, next, index)</span>:</span></span><br><span class="line">    self.data = data</span><br><span class="line">    self.next = next</span><br><span class="line">    self.index = index</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试节点</span></span><br><span class="line">node = Node(<span class="number">0</span>, <span class="literal">None</span>, <span class="number">0</span>)</span><br><span class="line">print(node.data)</span><br></pre></td></tr></table></figure><p>当然，没有悬念，输出<code>0</code>。</p><p>第一行首先是确认字符编码。默认是<code>UTF-8</code>，根据需要可以更换成别的；其次是使用<code>__init__</code>函数定义一个具有三个属性的类作为结构体；最后的pass则是占位符，表示一个域的结束，相当于<code>}</code>。因为<code>Python</code>直接使用缩进表示是否结束，所以这个仅仅作为个人习惯出现在这里。</p><h2 id="从链表的功能开始完善"><a href="#从链表的功能开始完善" class="headerlink" title="从链表的功能开始完善"></a>从链表的功能开始完善</h2><p>既然我们完成了节点的构造，那么我们一口气把整个链表攻下来吧！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Link</span>:</span></span><br><span class="line">  <span class="comment"># 初始化 / 不需要参数，自带空的头节点</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.head = <span class="literal">None</span></span><br><span class="line">    self.length = <span class="number">0</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  <span class="comment"># 尾插法插入数据</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">insert_tail</span><span class="params">(self, index, data)</span>:</span></span><br><span class="line">    <span class="comment"># 当尾节点为空时，使用头插法确定尾节点</span></span><br><span class="line">    <span class="keyword">if</span> self.tail <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">      self.insert_head(index, data)</span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    <span class="comment"># 在尾节点非空时往后接节点</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      node = Node(data, <span class="literal">None</span>, index)</span><br><span class="line">      self.tail.next = node</span><br><span class="line">      self.tail = node</span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  <span class="comment"># 头插法插入数据</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">insert_head</span><span class="params">(self, index, data)</span>:</span></span><br><span class="line">    node = Node(data, self.head, index)</span><br><span class="line">    self.head = node</span><br><span class="line">    self.length += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 当只有一个元素的时候，确定尾节点</span></span><br><span class="line">    <span class="keyword">if</span> self.length == <span class="number">1</span>:</span><br><span class="line">      self.tail = node</span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  <span class="comment"># 输出链表 / 从头开始顺序输出</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">output</span><span class="params">(self)</span>:</span></span><br><span class="line">    node = self.head</span><br><span class="line">    <span class="keyword">while</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">      print(<span class="string">f'<span class="subst">&#123;node.index&#125;</span>: <span class="subst">&#123;node.data&#125;</span>'</span>, end = <span class="string">' '</span>)</span><br><span class="line">      node = node.next</span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    print()</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">link = Link()</span><br><span class="line">link.insert_head(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">link.insert_tail(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">link.output()</span><br></pre></td></tr></table></figure><p>在这里的<code>self</code>关键字在<strong>函数体内</strong>就是<strong>作为<code>this</code>指针</strong>使用，而作为<strong>参数</strong>出现的时候就是声明该函数是一个<strong>成员函数</strong>。后面有一句：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">f'<span class="subst">&#123;node.index&#125;</span>: <span class="subst">&#123;node.data&#125;</span>'</span>, end = <span class="string">' '</span>)</span><br></pre></td></tr></table></figure><p>这是<code>Python</code>3.6以后的新特性，使用<code>f</code>直接将字符串格式化，另外使用<code>end</code>规定输出结尾是空格而不是默认的换行结尾。</p><p>于是，这次的输出就是：<code>1:2 3:4</code>。</p><h2 id="全自动构造链表"><a href="#全自动构造链表" class="headerlink" title="全自动构造链表"></a>全自动构造链表</h2><p>但是这还差一个输入。不想一个字一个字输入的我直接定义了一个随机生成的函数，让链表自己随便生成什么东西。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文件开头加上：</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line">LETTERS = <span class="string">'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'</span></span><br><span class="line">LETTERS_LEN = len(LETTERS)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在Link类中添加成员函数</span></span><br><span class="line"><span class="comment"># 随机生成链表</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_link</span><span class="params">(self)</span>:</span></span><br><span class="line">  size = random.randint(<span class="number">0</span>, <span class="number">20</span>)</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, size):</span><br><span class="line">    self.insert_tail(i + <span class="number">1</span>, LETTERS[random.randint(<span class="number">0</span>, LETTERS_LEN - <span class="number">1</span>)])</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 全自动生成</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  link = Link()</span><br><span class="line">  link.random_link()</span><br><span class="line">  link.output()</span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>于是每次编译输出都有完全不一样的结果。</p><p>好了，到这里构造链表就没有什么大问题了。</p><h2 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h2><p>接下来就是很恼人的删除节点了。和<code>C++</code>一样，可以直接使用<code>del</code>命令显式删除对象。值得一提的是，这里显式删除之后只是将内存标记为“<strong>可使用</strong>”，该部分内存并没有被回收。之后<code>GC</code>会过来打扫的。</p><p>为了能够保持数组每次都是一致的，方便查看位置，这里添加了文件读取，能够在每次运行的时候从<code>linklist.csv</code>中读取一模一样的数据。</p><p>数据文件<code>linklist.csv</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">3</span><br><span class="line">1000</span><br><span class="line">7</span><br><span class="line">p</span><br><span class="line">q</span><br><span class="line">h</span><br><span class="line">@</span><br><span class="line">!</span><br><span class="line">,</span><br><span class="line">&gt;</span><br><span class="line">shift</span><br></pre></td></tr></table></figure><p>然后是读取文件并删掉<code>readline</code>方法读取时最后的字符<code>\n</code>误读的情况：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取固定的链表</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_file</span><span class="params">(self, filepath)</span>:</span></span><br><span class="line">  index = <span class="number">1</span></span><br><span class="line">  <span class="keyword">with</span> open(filepath, <span class="string">'r'</span>) <span class="keyword">as</span> lines:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">      self.insert_tail(index, line.rstrip(<span class="string">'\n'</span>))</span><br><span class="line">      index += <span class="number">1</span></span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>接着是删除某个位置的节点。这里虽然没有难点，但是很难在细节上保持平衡。需要考虑以下几种情况：</p><ul><li><p>链表<strong>没有节点</strong></p></li><li><p>链表<strong>有且仅有</strong>一个节点</p></li><li><p>中间<strong>任意位置</strong>删除</p></li><li><p>要删除的是<strong>第一个元素</strong></p></li><li><p>要删除的是<strong>最后一个元素</strong></p></li></ul><p>如果面面俱到，代码一定会纷繁复杂。所以我们需要根据这些非常神奇的地方巧妙避雷：</p><ul><li><p>如果链表没有节点，<strong>直接结束</strong></p></li><li><p>如果链表仅一个节点，删除时需要同时解除<code>head</code>指针、<code>tail</code>指针，<strong>避免指针指了个寂寞</strong>，然后一脸哀怨的给你报了个错</p></li><li><p>在删除的时候，使用临时指针<code>node</code>指向<code>head</code>指针或者<code>tail</code>指针，并删除<code>node</code>指针的时候，你会发现<code>head</code>和<code>tail</code>实际指向的地址依然存在原有的实例对象。所以实际步骤应当是<strong>先重置原先指向需要删除地址的指针，再删除临时指针</strong></p></li><li><p>删除的时候需要在最后修改链表长度，避免下次使用的时候<strong>索引超限</strong></p></li></ul><h2 id="删除节点实现"><a href="#删除节点实现" class="headerlink" title="删除节点实现"></a>删除节点实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用索引删除节点</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_node_by_index</span><span class="params">(self, index)</span>:</span></span><br><span class="line">  <span class="comment"># 没有节点</span></span><br><span class="line">  <span class="keyword">if</span> self.head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  <span class="comment"># 删除头</span></span><br><span class="line">  <span class="keyword">elif</span> index == <span class="number">1</span>:</span><br><span class="line">    node = self.head</span><br><span class="line">    self.head = self.head.next</span><br><span class="line">    <span class="keyword">del</span> node</span><br><span class="line">    <span class="comment"># 检查是不是只有这个节点</span></span><br><span class="line">    <span class="comment"># 如果无视tail，head将会为None而tail保持原样</span></span><br><span class="line">    <span class="keyword">if</span> self.head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">      self.tail = self.head</span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  <span class="comment"># 中间任意位置删除</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    node = self.get_node(index - <span class="number">1</span>)</span><br><span class="line">    temp = node.next</span><br><span class="line">    <span class="keyword">if</span> temp <span class="keyword">is</span> self.tail:</span><br><span class="line">      node.next = <span class="literal">None</span></span><br><span class="line">      self.tail = node</span><br><span class="line">      <span class="keyword">del</span> temp</span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      node.next = temp.next</span><br><span class="line">      <span class="keyword">del</span> temp</span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>然后我们来测试一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试删除是否成功</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  link = Link()</span><br><span class="line">  link.read_file(<span class="string">'/home/sakebow/python/linklist/linklist.csv'</span>)</span><br><span class="line">  link.delete_node_by_index(link.length)</span><br><span class="line">  link.output()</span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>这里要强调的是<code>read_file</code>命令需要<strong>完整的绝对路径</strong>，否则无法读取文件。</p><p>当然，很完美地删掉了最后一个元素：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1: 1 2: 2 3: 3 4: 10 5: 11 6: a 7: b 8: 3 9: 1000 10: 7 11: p 12: q 13: h 14: @ 15: ! 16: , 17: &gt;</span><br></pre></td></tr></table></figure><h2 id="删除节点进阶"><a href="#删除节点进阶" class="headerlink" title="删除节点进阶"></a>删除节点进阶</h2><p>接着我们再来完善匹配所有项的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 匹配内容删除节点</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_node_by_data</span><span class="params">(self, data)</span>:</span></span><br><span class="line">  <span class="comment"># 强行改为有头节点的链表 / 内容随意，仅需保证next指向head</span></span><br><span class="line">  node = Node(<span class="string">'a'</span>, self.head, <span class="number">0</span>)</span><br><span class="line">  <span class="comment"># 保持标识，最后需要删除</span></span><br><span class="line">  <span class="comment"># 如果head移动了也不要紧，node将会控制下一跳的位置</span></span><br><span class="line">  stay_head = node</span><br><span class="line">  <span class="comment"># 游标，规定temp为必删项，node为上一项</span></span><br><span class="line">  temp = self.head</span><br><span class="line">  <span class="comment"># 遍历链表</span></span><br><span class="line">  <span class="keyword">while</span> temp <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="comment"># 如果要删第一个</span></span><br><span class="line">    <span class="keyword">if</span> temp <span class="keyword">is</span> self.head <span class="keyword">and</span> temp.data == data:</span><br><span class="line">      <span class="comment"># 先重置</span></span><br><span class="line">      node.next = temp.next</span><br><span class="line">      <span class="comment"># 检查tail</span></span><br><span class="line">      <span class="keyword">if</span> temp <span class="keyword">is</span> self.tail:</span><br><span class="line">        self.tail = self.head = node.next</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">      <span class="comment"># 再删除</span></span><br><span class="line">      <span class="keyword">del</span> temp</span><br><span class="line">      <span class="comment"># 因为下次循环依然需要使用temp，所以重置为node下一跳</span></span><br><span class="line">      temp = node.next</span><br><span class="line">      <span class="comment"># 修改长度</span></span><br><span class="line">      self.length -= <span class="number">1</span></span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    <span class="comment"># 中间任意项删除</span></span><br><span class="line">    <span class="comment"># 原理同上</span></span><br><span class="line">    <span class="keyword">elif</span> temp <span class="keyword">is</span> <span class="keyword">not</span> self.head <span class="keyword">and</span> temp.data == data:</span><br><span class="line">      node.next = temp.next</span><br><span class="line">      <span class="keyword">if</span> temp <span class="keyword">is</span> self.tail:</span><br><span class="line">        self.tail = node</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">      <span class="keyword">del</span> temp</span><br><span class="line">      temp = node.next</span><br><span class="line">      self.length -= <span class="number">1</span></span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    <span class="comment"># 如果不匹配，全部下一跳，且长度不变</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      temp = temp.next</span><br><span class="line">      node = node.next</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  <span class="comment"># 最终删除辅助节点</span></span><br><span class="line">  <span class="keyword">del</span> stay_head</span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>那我们来测试一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  link = Link()</span><br><span class="line">  link.read_file(<span class="string">'/home/sakebow/python/linklist/linklist.csv'</span>)</span><br><span class="line">  <span class="comment"># 因为数据集里面3出现了两次，所以选择3</span></span><br><span class="line">  link.delete_node_by_data(<span class="string">'3'</span>)</span><br><span class="line">  link.output()</span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>当然，最终结果把两个3全部删掉了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1: 1 2: 2 4: 10 5: 11 6: a 7: b 9: 1000 10: 7 11: p 12: q 13: h 14: @ 15: ! 16: , 17: &gt; 18: shift</span><br></pre></td></tr></table></figure><p>也没有问题！</p><p>当然你也可以使用各种各样的数据测试。就算是60万行数据也能用$1’32’’$秒给出答案。（<em>实际测量可能和电脑运算能力有误差</em>）</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后，为了代码简洁、项目结构清晰，我们将各个部分拆开。这里贴上各个部分的文件内容：</p><h3 id="Node-py"><a href="#Node-py" class="headerlink" title="Node.py"></a>Node.py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 链表节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data, next, index)</span>:</span></span><br><span class="line">    self.data = data</span><br><span class="line">    self.next = next</span><br><span class="line">    self.index = index</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h3 id="Link-py"><a href="#Link-py" class="headerlink" title="Link.py"></a>Link.py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Node <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># 链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Link</span>:</span></span><br><span class="line">  <span class="comment"># 初始化 / 不需要参数，自带空的头节点</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.head = <span class="literal">None</span></span><br><span class="line">    self.tail = <span class="literal">None</span></span><br><span class="line">    self.length = <span class="number">0</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 尾插法插入数据</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">insert_tail</span><span class="params">(self, index, data)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> self.tail <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">      self.insert_head(index, data)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      node = Node(data, <span class="literal">None</span>, index)</span><br><span class="line">      self.tail.next = node</span><br><span class="line">      self.tail = node</span><br><span class="line">      self.length += <span class="number">1</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 头插法插入数据 </span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">insert_head</span><span class="params">(self, index, data)</span>:</span></span><br><span class="line">    node = Node(data, self.head, index)</span><br><span class="line">    self.head = node</span><br><span class="line">    self.length += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 当只有一个元素的时候，确定尾节点</span></span><br><span class="line">    <span class="keyword">if</span> self.length == <span class="number">1</span>:</span><br><span class="line">      self.tail = node</span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 输出链表</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">output</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> self.head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">      print(<span class="string">'Nothing'</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      node = self.head</span><br><span class="line">      <span class="keyword">while</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        print(<span class="string">f'<span class="subst">&#123;node.index&#125;</span>: <span class="subst">&#123;node.data&#125;</span>'</span>, end=<span class="string">' '</span>)</span><br><span class="line">        node = node.next</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">      print()</span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 随机生成链表</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">random_link</span><span class="params">(self)</span>:</span></span><br><span class="line">    size = random.randint(<span class="number">0</span>, <span class="number">20</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, size):</span><br><span class="line">      self.insert_tail(i + <span class="number">1</span>, LETTERS[random.randint(<span class="number">0</span>, LETTERS_LEN - <span class="number">1</span>)])</span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 读取固定的链表</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">read_file</span><span class="params">(self, filepath)</span>:</span></span><br><span class="line">    index = <span class="number">1</span></span><br><span class="line">    <span class="keyword">with</span> open(filepath, <span class="string">'r'</span>) <span class="keyword">as</span> lines:</span><br><span class="line">      <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        self.insert_tail(index, line.rstrip(<span class="string">'\n'</span>))</span><br><span class="line">        index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 通过索引获得指定节点</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get_node</span><span class="params">(self, index)</span>:</span></span><br><span class="line">    node = self.head</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, index):</span><br><span class="line">      node = node.next</span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 匹配内容删除节点</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">delete_node_by_data</span><span class="params">(self, data)</span>:</span></span><br><span class="line">    <span class="comment"># 强行改为有头节点的链表</span></span><br><span class="line">    node = Node(<span class="string">'a'</span>, self.head, <span class="number">0</span>)</span><br><span class="line">    <span class="comment"># 保持标识，最后需要删除</span></span><br><span class="line">    stayHead = node</span><br><span class="line">    <span class="comment"># 游标，规定temp为必删项，node为上一项</span></span><br><span class="line">    temp = self.head</span><br><span class="line">    <span class="keyword">while</span> temp <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">      <span class="keyword">if</span> temp <span class="keyword">is</span> self.head <span class="keyword">and</span> temp.data == data:</span><br><span class="line">        node.next = self.head = temp.next</span><br><span class="line">        <span class="keyword">if</span> temp <span class="keyword">is</span> self.tail:</span><br><span class="line">          self.tail = self.head = node.next</span><br><span class="line">          <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">del</span> temp</span><br><span class="line">        temp = node.next</span><br><span class="line">        self.length -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">      <span class="keyword">elif</span> temp <span class="keyword">is</span> <span class="keyword">not</span> self.head <span class="keyword">and</span> temp.data == data:</span><br><span class="line">        node.next = temp.next</span><br><span class="line">        <span class="keyword">if</span> temp <span class="keyword">is</span> self.tail:</span><br><span class="line">          self.tail = node</span><br><span class="line">          <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">del</span> temp</span><br><span class="line">        temp = node.next</span><br><span class="line">        self.length -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">        temp = temp.next</span><br><span class="line">        node = node.next</span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">del</span> stayHead</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 使用索引删除节点</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">delete_node_by_index</span><span class="params">(self, index)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> self.head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">elif</span> index == <span class="number">1</span>:</span><br><span class="line">      node = self.head</span><br><span class="line">      self.head = self.head.next</span><br><span class="line">      <span class="keyword">if</span> self.head <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        self.tail = self.head</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">      <span class="keyword">del</span> node</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      node = self.get_node(index - <span class="number">1</span>)</span><br><span class="line">      temp = node.next</span><br><span class="line">      <span class="keyword">if</span> temp <span class="keyword">is</span> self.tail:</span><br><span class="line">        node.next = <span class="literal">None</span></span><br><span class="line">        self.tail = node</span><br><span class="line">        <span class="keyword">del</span> temp</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">        node.next = temp.next</span><br><span class="line">        <span class="keyword">del</span> temp</span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h3 id="linklist-csv"><a href="#linklist-csv" class="headerlink" title="linklist.csv"></a>linklist.csv</h3><p>这个文件后来我改得非常大，一共22932行数据，不方便展开，各位可以自行<a href="https://github.com/sakebow/python-linklist/blob/master/linklist.csv" target="_blank" rel="noopener">点击我的<code>GitHub</code></a>下载。</p><h3 id="linklist-py（主文件）"><a href="#linklist-py（主文件）" class="headerlink" title="linklist.py（主文件）"></a>linklist.py（主文件）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> Link <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">LETTERS = <span class="string">'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'</span></span><br><span class="line">LETTERS_LEN = len(LETTERS)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  link = Link()</span><br><span class="line">  link.read_file(<span class="string">'/home/sakebow/python/linklist/linklist.csv'</span>)</span><br><span class="line">  <span class="comment"># 测试</span></span><br><span class="line">  link.delete_node_by_data(<span class="string">'3'</span>)</span><br><span class="line">  link.output()</span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>如果觉得大段大段的代码在这里看不怎么清楚的话，直接在<a href="https://github.com/sakebow/python-linklist" target="_blank" rel="noopener">我的GitHub</a>中下载也可以。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;因为研究生生涯开始了，所以需要暂时停掉&lt;code&gt;Java&lt;/code&gt;的学习，开始使用&lt;code&gt;Python&lt;/code&gt;的学习和实践了。于是花了一个小时从完全没学过到实现了最基础的单链表。这里就记录一下。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程基础综合测验" scheme="http://www.sakebow.cn/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%BB%BC%E5%90%88%E6%B5%8B%E9%AA%8C/"/>
    
    
      <category term="Python" scheme="http://www.sakebow.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>回老家的四天假期</title>
    <link href="http://www.sakebow.cn/2020/08/06/diary/%E5%9B%9E%E8%80%81%E5%AE%B6%E7%9A%84%E5%9B%9B%E5%A4%A9%E5%81%87%E6%9C%9F/"/>
    <id>http://www.sakebow.cn/2020/08/06/diary/%E5%9B%9E%E8%80%81%E5%AE%B6%E7%9A%84%E5%9B%9B%E5%A4%A9%E5%81%87%E6%9C%9F/</id>
    <published>2020-08-06T13:48:11.000Z</published>
    <updated>2020-08-09T03:29:43.426Z</updated>
    
    <content type="html"><![CDATA[<script src="/crypto-js.js"></script><script src="/mcommon.js"></script><h3 id="encrypt-message">如果你坚持要看，请联系我。</h3><link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.min.css"> <link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap-theme.min.css"> <script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script> <script src="//cdn.bootcss.com/bootstrap/3.3.5/js/bootstrap.min.js"></script> <div id="security"> <div> <div class="input-group"> <input type="text" class="form-control" aria-label="Enter the password." id="pass"/> <div class="input-group-btn"> <button type="button" class="btn btn-default" onclick="decryptAES()">Decrypt</button> </div> </div> </div> </div> <div id="encrypt-blog" style="display:none"> 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 </div>]]></content>
    
    <summary type="html">
    
      本文针对老家的一点见闻说一些真心感受。当然，因为是个人偏见所以不对外开放。
    
    </summary>
    
    
      <category term="日记" scheme="http://www.sakebow.cn/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="假期" scheme="http://www.sakebow.cn/tags/%E5%81%87%E6%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title>多元梯度函数的梯度下降</title>
    <link href="http://www.sakebow.cn/2020/08/01/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E5%A4%9A%E5%85%83%E6%A2%AF%E5%BA%A6%E5%87%BD%E6%95%B0%E7%9A%84%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/"/>
    <id>http://www.sakebow.cn/2020/08/01/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E5%A4%9A%E5%85%83%E6%A2%AF%E5%BA%A6%E5%87%BD%E6%95%B0%E7%9A%84%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/</id>
    <published>2020-08-01T03:25:00.000Z</published>
    <updated>2020-09-19T00:02:40.474Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>当然，本篇完全有理由和我之前写的<a href="/2020/07/26/人工智能/算法模型/梯度下降/">梯度下降</a>一文并在一起。但是，我还是觉得应当单独拉出来。前一篇<a href="/2020/07/26/人工智能/算法模型/梯度下降/">梯度下降</a>仅仅只是针对梯度下降的原理和流程作了一些阐释，用三个维度的例子说明了一个通用解法。而这里才是实际应用的具体表现，同时也包含很多小技巧。从这里开始，就是动真格的了！</strong></p><a id="more"></a><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>当然，还是那个海拔图，有高有低，有近有远。你要做的，就是从山顶上下山。环顾四周，一跳接一跳地往山下走。</p><h2 id="代价函数的确定"><a href="#代价函数的确定" class="headerlink" title="代价函数的确定"></a>代价函数的确定</h2><p>当然，代价函数就是我们需要训练的目标函数。只要代价函数最小，我们最后训练的结果就会接近事实。</p><p>可是，光是二元函数构成的三维图就已经包含了很多的不确定性，陷入局部最优解、收敛慢、内存溢出……这都是很无奈但是可控的问题。不如我们逆转过来：既然没有便利，就创造便利。</p><p>这里就还是用你的猫娘作为例子，但是这次代入了更多自变量：</p><blockquote><p>你再次收集了20万猫娘的信息，包括年龄（<code>age</code>）、体重（<code>weight</code>）、身高（<code>height</code>）、最大跳跃距离（<code>distence</code>）、胸围（<code>bust</code>）、腰围（<code>waist</code>）、臀围（<code>hip</code>）、基础社会科学考试分数（<code>score</code>）……</p></blockquote><p>虽然可能还有很多指标，但是现在就先列举这8项。是不是觉得非常的麻烦？而且这下我们连图都画不出来了，甚至无法想象8个自变量如何构成一个解空间，更无法想象涉及8个自变量的函数将会是怎样一个扭曲的形态。</p><p>行，套公式嘛，<strong>矩阵求解</strong>。</p><h2 id="函数化简"><a href="#函数化简" class="headerlink" title="函数化简"></a>函数化简</h2><blockquote><p>你整理出了一张含有$n$行数据的表，其中每一行数据都代表一只猫娘的所有收集到的信息，所以你为每一行整理了一个矩阵：</p><script type="math/tex; mode=display">\left[\begin{matrix}age_i（岁） \\weight_i（千克）\\height_i（米）\\distance_i（米）\\bust_i（厘米）\\waist_i（厘米）\\hip_i（厘米）\end{matrix}\right],i\in\{1,2,3,\ldots,n\}</script></blockquote><p><strong>这里插播一句：</strong></p><p><em>因为面对这样一个生物，对于科研人员来说就是个名副其实的黑匣子：什么都不知道，只知道输入和输出。所以在确定函数关系式的时候相当的麻烦。所以往往是一个个变量分析，优先找出一个个独立不相关的变量，然后分析相关变量的影响。这里就完全不是拟合算法能够做到的了，而是来自不同领域的科研人员齐心协力研究发现最终的出来的结果。这里因为赌的成分过高，并且和梯度下降并没有什么直接的关系，所以直接跳过。现在就直接跳到你找到了每个自变量的精确幂指数和对数底数以及对应的线性关系的情况。</em></p><blockquote><p>然后你又双叒叕凭着你对猫娘的热爱找出了这8个变量的大致关系：</p><script type="math/tex; mode=display">y=f(age,weight,height,distance,bust,waist,hip)\\\Downarrow\\y=\epsilon+\alpha_1a+\alpha_2weight^2+\alpha_3height+\alpha_4d^3+\frac{\alpha_5}{3}(b^2+waist^2+hip^2)</script><p>其中，</p><script type="math/tex; mode=display">\epsilon,\alpha_1,\alpha_2,\alpha_3,\alpha_4,\alpha_5\in\mathbb{R}</script></blockquote><p><em>如果你还有印象，那么你应该记得$\epsilon$服从正态分布$N(0,\sigma^2)$，是随机误差。在一开始决定各种自变量的系数的时候往往会先忽视这个小东西，然后在全部得出结果之后加上以保证函数能够兼容一些“<strong>偶然</strong>”</em></p><blockquote><p>看到这样群魔乱舞的函数，你感觉到背脊发凉。完全没办法想象的解空间、完全无法想象的图形走向，更不用说最终目标的图像意义都无法解释……（<em>当然，这里是为了节目效果如此设计的</em>。）</p><p>这没难倒你。你把式子化为<strong>矩阵</strong>形式表达，就变成了这样：</p><script type="math/tex; mode=display">y=\left[\begin{matrix}  1&\alpha_1&\alpha_2&\alpha_3&\alpha_4&\alpha_5\over3&\alpha_5\over3&\alpha_5\over3\end{matrix}\right]\times\left[\begin{matrix}\epsilon\\age\\weight^2\\height\\distance^3\\bust^2\\waist^2\\hip^2\end{matrix}\right]\\\Downarrow\\y=\left[\begin{matrix}  1&\alpha_1&\alpha_2&\alpha_3&\alpha_4&\alpha_5\over3&\alpha_5\over3&\alpha_5\over3\end{matrix}\right]\\\times\left[\begin{matrix}  \epsilon\\age\\weight\\height\\distance\\bust\\waist\\hip\end{matrix}\right]\\\times\left[\begin{matrix}  \epsilon\\&1\\&&weight\\&&&height\\&&&&distance\\&&&&&bust\\&&&&&&waist\\&&&&&&&hip\end{matrix}\right]\\\times\left[\begin{matrix}  1\\&1\\&&1\\&&&1\\&&&&distance\\&&&&&1\\&&&&&&1\\&&&&&&&1\end{matrix}\right]</script></blockquote><p><em>由于版面问题，这个公式只能勉强这么写着了……</em></p><p><img src="https://sakebow.gitee.io/images/emoji/fuck-off.jpg" width="150" /></p><p>先不管版面了，若稍微简化一些，我们发现系数和幂指数<strong>完全相同</strong>的$bust$、$waist$和$hip$可以<strong>合并</strong>为一个变量$\eta_1$。</p><blockquote><p>再简化一些，更抽象一些，那就成为了：</p><script type="math/tex; mode=display">y=\alpha^T\eta</script><p>其中，$\alpha$是待定系数的矩阵，而$\eta$则是自变量经过各自合适变化之后的矩阵，即：</p><script type="math/tex; mode=display">\alpha^T=\left[\begin{matrix}  \alpha_1&\alpha_2\cdots\alpha_n\end{matrix}\right]_n,\\\eta=\left[\begin{matrix}  \eta_1\\\eta_2\\\vdots\\\eta_n\end{matrix}\right]_n,</script><p>而$\eta_i$则能代表很多，可以是$x_i$，也可以是$(x_i+x_{i+1})^2$等等。</p></blockquote><p>到这里，也就只是单纯的将变量合并，将复杂的公式变成简单易懂的矩阵向量，强行转成2个矩阵维度的<strong>解空间</strong>。当然，我们还是想象不到，只不过大致可以理解为某种类似$x$轴和$y$轴的神奇坐标轴在帮助我们标记位置。这么一想的话，就算是不能想象数轴的样子，也能够想象出解空间是个什么样了，而我们最终要求的目标函数最小值大概也能模模糊湖地猜出来在哪。</p><h2 id="目标函数最终展开"><a href="#目标函数最终展开" class="headerlink" title="目标函数最终展开"></a>目标函数最终展开</h2><p>但是你发现，到这里还是和上次讲到的梯度下降没有区别。没错，后面还有内容。</p><p>由于我们已经将目标函数改成了多元一次函数，所以，我们需要将目标函数彻底展开成为级数的形式，方便我们进一步设计算法。</p><p>还记得我们最初的公式么？</p><script type="math/tex; mode=display">\beta_i=\beta_i-\frac{\alpha}{m}\sum^n_{i=1}(f(x_i)-y_i)^2</script><p>我们的目标就是让$\frac{1}{m}\sum^n_{i=1}(f(x_i)-y_i)^2$尽可能地小。那么问题就简单了，针对这个函数分析就好了。另：</p><script type="math/tex; mode=display">\phi(\beta)=\frac{1}{m}\sum^n_{i=1}(f(x_i)-y_i)^2</script><p>求个导：</p><script type="math/tex; mode=display">\dot{\phi(\beta)}=\frac{2}{m}\sum^n_{i=1}[f(x_i)-y_i]\dot{f(x_i)}</script><p>这里最核心的部分就是$\dot{f(x_i)}$的理解。首先，我们寻找的是有关系数的函数，所以在这里的自变量是$\beta$，所以求导的时候不应当是已经知道具体数值的$x_i$，而是完全未知的$\beta_i$，故求导结果为$x_i$。即：</p><script type="math/tex; mode=display">\dot{\phi(\beta)}=\frac{2}{m}\sum^n_{i=1}[\dot{f(x_i)}-y_i]x_i</script><p>为了求导不要新增太多没有意义的单项式或多项式，所以我们将系数$2$删掉，也就是将目标函数改为：</p><script type="math/tex; mode=display">\phi(\beta)=\frac{1}{2m}\sum^n_{i=1}(f(x_i)-y_i)^2</script><p>这也就是吴恩达教授的课程中一直使用的函数的由来。求导之后就是：</p><script type="math/tex; mode=display">\dot{\phi(\beta)}=\frac{1}{m}\sum^n_{i=1}[f(x_i)-y_i]x_i</script><p>简单多了，不是么？</p><p>所以我们进而修改一下机器学习的算法：</p><script type="math/tex; mode=display">\theta_j=\theta_j-\frac{\alpha}{m}\sum^n_{i=1}[f(x_i)-y_i]x_i</script><p>到这，似乎就对计算机来说非常的方便了。</p><h2 id="theta-0-和-x-0"><a href="#theta-0-和-x-0" class="headerlink" title="$\theta_0$和$x_0$"></a>$\theta_0$和$x_0$</h2><p>对于一些课程中，你一定会遇到加设待定常数$\theta_0$和固定初始参数$x_0=1$的教师。为什么要这么做？我个人认为和数列添加初项是一样的。有些算法并不能很好地概括初项，所以强行加上去方便计算机处理。有些非常巧合的数列能够不需要初项，这就看怎么处理了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;当然，本篇完全有理由和我之前写的&lt;a href=&quot;/2020/07/26/人工智能/算法模型/梯度下降/&quot;&gt;梯度下降&lt;/a&gt;一文并在一起。但是，我还是觉得应当单独拉出来。前一篇&lt;a href=&quot;/2020/07/26/人工智能/算法模型/梯度下降/&quot;&gt;梯度下降&lt;/a&gt;仅仅只是针对梯度下降的原理和流程作了一些阐释，用三个维度的例子说明了一个通用解法。而这里才是实际应用的具体表现，同时也包含很多小技巧。从这里开始，就是动真格的了！&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="人工智能" scheme="http://www.sakebow.cn/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
      <category term="算法模型" scheme="http://www.sakebow.cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>建模工具：octave</title>
    <link href="http://www.sakebow.cn/2020/07/26/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E5%BB%BA%E6%A8%A1%E5%B7%A5%E5%85%B7%EF%BC%9Aoctave/"/>
    <id>http://www.sakebow.cn/2020/07/26/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E5%BB%BA%E6%A8%A1%E5%B7%A5%E5%85%B7%EF%BC%9Aoctave/</id>
    <published>2020-07-26T15:23:00.000Z</published>
    <updated>2020-09-19T00:02:36.227Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>终于，使用<code>Ubuntu</code>系统的我遇到了最尴尬的问题：建模工具<code>Matlab</code>没有<code>linux</code>发行版。虽然可以使用<code>wine</code>勉强跑起来，但毕竟不是运行在<code>Windows</code>内核下，所以往往有很多事情都非常尴尬。所以，我看上了这一款：<code>octave</code>。不仅支持<code>Ubuntu</code>，还能够兼容<code>Matlab</code>，是非常不错的替代品。</strong></p><a id="more"></a><h2 id="界面展示"><a href="#界面展示" class="headerlink" title="界面展示"></a>界面展示</h2><p>先看看<code>octave</code>的软件界面，体验一下吧。</p><p><img src="https://sakebow.gitee.io/images/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/octave%E7%95%8C%E9%9D%A2.png" alt="octave界面"></p><p>可以看到左边由上至下依次是：文件目录、工作空间和历史记录，而左边则是命令行界面。</p><p>是不是非常熟悉？没错，这简直不能再像<code>Matlab</code>了。即使顶部功能菜单并没有<code>Matlab</code>那么丰富，却也足够了。</p><h2 id="更换命令行"><a href="#更换命令行" class="headerlink" title="更换命令行"></a>更换命令行</h2><p>如果你有丰富的<code>shell</code>编程经验，那么你应该对这个<code>&gt;&gt;</code>非常熟悉。<code>Matlab</code>使用的是<code>&gt;&gt;</code>，<code>MySQL</code>使用的是<code>&gt;</code>，<code>sqlplus</code>（<em><code>Oracle</code></em>）使用的是<code>&gt;</code>，<code>Python</code>使用的是<code>&gt;&gt;&gt;</code>，<code>Ubuntu</code>普通用户使用的是<code>$</code>，<code>Ubuntu</code>超管使用的是<code>#</code>……</p><p>如果说你用惯了想要换，还是可以的。直接输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 这段字符串复制自我的Ubuntu终端</span></span><br><span class="line">PS1("sakebow@Lenovo-V310-14IKB:~$ ")</span><br></pre></td></tr></table></figure><p>这样就能够保持和终端一模一样的风格了。当然为了区分也可以改称其他的，比如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ……懂的都懂……</span></span><br><span class="line">PS1("お兄ちゃん、頑張るね、大好きだよ❤　")</span><br></pre></td></tr></table></figure><h2 id="基于Linux的特点"><a href="#基于Linux的特点" class="headerlink" title="基于Linux的特点"></a>基于<code>Linux</code>的特点</h2><p>当然，因为开源免费的<code>octave</code>是使用<code>C</code>语言基于<code>Linux</code>系统开发的，所以也会保留一些<code>Linux</code>系统的命令。比如：</p><ul><li><code>pwd</code>显示当前所在文件夹</li><li><code>ls</code>显示当前文件夹中所有的文件</li><li><code>cd</code>跳转到制定文件夹</li><li><code>exit</code>退出程序</li></ul><p>即使是安装在<code>Windows</code>系统下的<code>octave</code>也是能够使用这些命令的。</p><h2 id="清空矩阵"><a href="#清空矩阵" class="headerlink" title="清空矩阵"></a>清空矩阵</h2><p>在<code>Ubuntu</code>系统中你可以直接使用<code>Ctrl+L</code>清空命令行。所有的指令会存在历史记录<code>Command History</code>栏内</p><p>当然你也可以输入<code>clc</code>并回车就能够清空命令行</p><h2 id="快速矩阵"><a href="#快速矩阵" class="headerlink" title="快速矩阵"></a>快速矩阵</h2><blockquote><p>这些<code>Octave</code>内置的快速矩阵摘自摘自<a href="https://www.youtube.com/watch?v=X0xLTKRWPgo&amp;list=PL1A2CSdiySGJ6oZe6" target="_blank" rel="noopener">油土鳖上一位印度阿三的教程</a>（<em>英语略微有一些咖喱味，但已经很不错了</em>）</p></blockquote><script type="math/tex; mode=display">ones(n, m) = \left[  \begin{matrix}    1, \cdots, 1\\\vdots\\    1, \cdots, 1  \end{matrix}\right]_{n\times m}\\zeros(n, m) = \left[  \begin{matrix}    0, \cdots, 0\\\vdots\\    0, \cdots, 0  \end{matrix}\right]_{n\times m}\\eye(n) = \left[  \begin{matrix}    1, 0, 0, \cdots, 0\\    0, 1, 0, \cdots, 0\\    0, 0, 1, \cdots, 0\\\vdots\\    0, 0, 0, \cdots, 1  \end{matrix}\right]_n = E\\eye(n, n + 1) = \left[  \begin{matrix}    1, 0, 0, \cdots, 0, 0\\    0, 1, 0, \cdots, 0, 0\\    0, 0, 1, \cdots, 0, 0\\\vdots\\    0, 0, 0, \cdots, 1, 0  \end{matrix}\right]_{n\times(n+1)}\\</script><p>而<code>rand(n,m)</code>则是生成<strong>n行m列</strong>的<strong>均匀分布随机数矩阵</strong>（<em>uniformly random matrix</em>），每个数字都是<strong>介于0到1之间的7位小数</strong>，且每个数字出现概率服从均匀分布$U(0, 1)$；</p><p><code>randn(n,m)</code>是生成一共<strong>n列m行</strong>的<strong>正态分布随机数矩阵</strong>（<em>normally random matrix</em>），每个数字服从正态分布$N(0, 1)$。乍一看这组数据毫无特点，实际上是$P(\mu-\sigma&lt;x&lt;\mu+\sigma)\approx0.6826$。这也就说明了为什么数字里面会有<strong>大于$1$和小于$-1$的数字了</strong></p><h2 id="矩阵构造"><a href="#矩阵构造" class="headerlink" title="矩阵构造"></a>矩阵构造</h2><p>在<code>C</code>、<code>C++</code>、<code>Java</code>、<code>C#</code>等等语言中构造矩阵永远是一个很难受的工程，拿<code>Java</code>中的<code>List&lt;List&lt;?&gt;&gt;</code>来说，向其中添加元素是一项无比复杂的工程。</p><p>而在<code>octave</code>和<code>Matlab</code>中，就只需要使用</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; s = [<span class="number">1</span>, <span class="number">2</span>; <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">s = </span><br><span class="line">  <span class="number">1</span> <span class="number">2</span></span><br><span class="line">  <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p>在这里你可以使用<strong>逗号</strong>作为分割符，也可以仅用<strong>空格</strong>作为分割符。</p><p>如果你要用<strong>克莱姆法则</strong>解多元一次方程组，那么就需要几个矩阵拆拆解解。这个时候可以把一整个矩阵当作数字：</p><ul><li><code>[A B]</code>像是<code>[1 2]</code>，将两个数字横着拼起来</li><li><code>[A; B]</code>则是<code>[1; 2]</code>，将两个数字竖着拼起来</li><li><code>A&#39;</code>是矩阵的转置，就是$A^T$</li></ul><p>当然，我们还有矩阵的选择：</p><ul><li><code>S(m, n)</code>是选取矩阵<code>S</code>中<strong>第m行第n列</strong>的一个元素</li><li><code>S(m, [x, y, z])</code>是选择矩阵中<strong>第m行第x、y、z列</strong>的一共三个元素。如果还需要添加元素则在<code>[]</code>内追加</li><li><em>下方冒号表达式继续介绍</em></li></ul><h2 id="冒号表达式"><a href="#冒号表达式" class="headerlink" title="冒号表达式"></a>冒号表达式</h2><p>如果你熟悉<code>C</code>、<code>C++</code>、<code>Java</code>、<code>C#</code>等等（<em><code>Python</code>除外</em>），你应该会经常使用到冒号表达式，即是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出该学生是否可以购买打折的火车票</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; 学生.学生证 === null ? <span class="string">"火车票不能打折"</span> : <span class="string">"火车票可以打折"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>但是在<code>octave</code>和<code>Matlab</code>就完全不一样了。冒号表达式会这么用：<code>start[:step]:end</code>，即创建一个从<code>start</code>到<code>end</code>的数组，其中每个数字之间间隔<code>step</code>，默认<code>step</code>值为<strong>1</strong>，即依次递增。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; s = <span class="number">1</span> : <span class="number">5</span></span><br><span class="line">&gt;&gt; <span class="built_in">ans</span> =</span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line">&gt;&gt; </span><br><span class="line">&gt;&gt; s = <span class="number">1</span>:<span class="number">3</span>:<span class="number">10</span></span><br><span class="line">&gt;&gt; <span class="built_in">ans</span> =</span><br><span class="line">[<span class="number">1</span> <span class="number">4</span> <span class="number">7</span> <span class="number">10</span>]</span><br></pre></td></tr></table></figure><p>当然冒号不止这一个用途。刚刚我们说了矩阵的构造，在矩阵中冒号还能够用作选择器。</p><p>我们在选择矩阵中元素的时候会使用一个<strong>数组</strong>作为范围，而如果这个范围<strong>正好</strong>可以用冒号表示的时候，就可以是这样：</p><ul><li><p><code>S(m, [start : end])</code>，也就是说选取<strong>第m行从start开始到end结束的所有元素</strong></p></li><li><p>如果没有规定<code>start</code>和<code>end</code>，也就像是：<code>S(m, :)</code>，那么就是选取<strong>第m行一整行</strong></p></li></ul><h2 id="个数计算"><a href="#个数计算" class="headerlink" title="个数计算"></a>个数计算</h2><p><code>Java</code>中，对集合使用<code>size()</code>方法求集合内元素个数，对数组使用<code>length()</code>方法求数组内元素个数。</p><p>在<code>octave</code>中，我们两个都可以用，但是<code>size()</code>方法返回的是行和列两个数字，而<code>length</code>方法则是从<code>size()</code>方法返回的两个数字中选择一个最大的。举个例子：</p><p>假设你这个时候又闲着没事创建了一个随机数组<code>rand(5, 1)</code>，那么<code>size()</code>方法返回的是<code>[5 1]</code>两个数字，前者是行数，后者是列数；而<code>length()</code>方法返回的是<strong>5</strong>，是<strong>5</strong>和<strong>1</strong>中较大的数。</p><p>同样的，如果你只有一个数组<code>[1 2 4]</code>，<code>size()</code>方法返回的依然是<code>[1 3]</code>两个数，而<code>length()</code>方法就返回<strong>3</strong>。</p><h2 id="其他数学函数"><a href="#其他数学函数" class="headerlink" title="其他数学函数"></a>其他数学函数</h2><ul><li><code>ceil(x)</code> - 取比x大的第一个最近的整数，即向上取整</li><li><code>floor(x)</code> - 取比x小的第一个最近的整数，即向下取整</li><li><code>round(x)</code> - 取距离x最近的一个整数。如果$x=0.7$，则结果为$1$；如果$x=0.3$，则结果为$0$</li><li><code>max(x)</code> / <code>min(x)</code> - 取一个数组中最大/最小的数</li></ul><p>对于<code>max(x)</code>和<code>min(x)</code>在官方给的说明里面指明的是vector，也就是说这个函数同样适用于矩阵、向量等等。但是实际测试的时候是这样的：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; <span class="built_in">rand</span>(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"> <span class="number">0.097667</span>   <span class="number">0.295360</span>   <span class="number">0.710065</span></span><br><span class="line"> <span class="number">0.858128</span>   <span class="number">0.141471</span>   <span class="number">0.729432</span></span><br><span class="line"> <span class="number">0.073253</span>   <span class="number">0.503299</span>   <span class="number">0.379730</span></span><br><span class="line"> <span class="number">0.329683</span>   <span class="number">0.839168</span>   <span class="number">0.076656</span></span><br><span class="line"> <span class="number">0.662468</span>   <span class="number">0.514276</span>   <span class="number">0.020735</span></span><br><span class="line">&gt;&gt;</span><br><span class="line">&gt;&gt; <span class="built_in">min</span>(<span class="built_in">ans</span>)</span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"> <span class="number">0.073253</span>   <span class="number">0.141471</span>   <span class="number">0.020735</span></span><br></pre></td></tr></table></figure><p>不难发现，对比的时候将一整列作为一个数组进行纵向的对比，每一列选出了一个最小的。在上面这个例子中，数组<code>ans[0..4][0..2]</code>每一列选出了最小的，也就是<code>ans[2, 0]</code>、<code>ans[1, 1]</code>和<code>ans[3, 2]</code>。<code>max(ans)</code>也是一样的算法，只不过会每列找出一个最大的。</p><h2 id="数据集的导入和导出"><a href="#数据集的导入和导出" class="headerlink" title="数据集的导入和导出"></a>数据集的导入和导出</h2><p>如果有一天我们使用计算机去证明歌德巴赫猜想，把所有的数字塞进去日复一日地算，终于算出来了一大批数字。我们不可能使用人工一个个抄下来，肯定是让计算机自己保存。这个时候就用<code>save</code>命令让计算机保存所有的数字。</p><p>例如，我现在弄出了很大一批随机数<code>randn(1000, 1000)</code>，但是我突然发现笔记本电不够了，得保存下来。就这么使用：<code>save ${文件名} ${变量名}</code>，意思就是：将变量的值保存在指定中。当然你也可以指定别的后缀名，比如我这里选择：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">save <span class="built_in">randn</span>.json <span class="built_in">ans</span></span><br></pre></td></tr></table></figure><p>于是就有了如下效果：</p><p><img src="https://sakebow.gitee.io/images/机器学习/octave保存数据.png" alt="保存了十万条随机数"></p><p>但是呢，为了能够更直观地区分各个文件，我们尽可能按照大家默认的规矩来，这里推荐万能的<code>.csv</code>文件；官方更是推荐使用<code>.mat</code>文件。更何况，我这里导出的文件并不符合<code>json</code>文件的编写规范。</p><p>就像是<code>Java</code>的导包一样，我们会使用<code>import</code>导入一整个<code>jar</code>包。而在<code>octave</code>中，我们将会使用<code>load</code>命令导入文件。</p><p>如果再次使用，我们就使用<code>load</code>命令，即：<code>load randn.dat</code>（<em>我这里是.json</em>）</p><p><strong>看起来很简单？我们再来点奇葩的：</strong></p><p>有一天你们哥几个凑一起跑数据，结果突然发现两个人风格极其相近以至于命名都完全一样。现在重新改已经很头疼了，怎么办？</p><p>我们就用<strong>临时文件</strong>。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 创建临时文件</span></span><br><span class="line">f = tmpfile</span><br><span class="line"><span class="comment">% 将变量存入临时文件</span></span><br><span class="line">save f variable</span><br><span class="line"><span class="comment">% &#123;</span></span><br><span class="line">  拿同名变量处理一大堆事情</span><br><span class="line">&#125; <span class="comment">%</span></span><br><span class="line"><span class="comment">% 读取临时文件</span></span><br><span class="line">load f</span><br><span class="line"><span class="comment">% 这个时候同名变量就被覆盖了</span></span><br></pre></td></tr></table></figure><p>打个比方的话，就像是<code>C</code>语言的<strong>局部变量</strong>和<strong>全局变量</strong>一样。</p><p>当然，这只是一个非常极端的例子，我们强烈建议各小组之间事先商量好再码字，正如<code>SpringBoot</code>所倡导的：“<strong>约束大于业务</strong>”、“<strong>习惯大于编码</strong>”</p><h2 id="统计图绘制"><a href="#统计图绘制" class="headerlink" title="统计图绘制"></a>统计图绘制</h2><p>统计图必定是有数据支持的，但是现在没有数据……那么就随机生成吧：<code>rand(1, 100)</code>。于是工作空间中就有了<code>ans</code>这个变量，同时还有了一个共<strong>1行</strong>、<strong>100列</strong>的矩阵，也就是数组。</p><p>然后，我们就画图：<code>plot(ans)</code>，于是产生了一个很简单的折线图：</p><p><img src="https://sakebow.gitee.io/images/机器学习/基本折线图.png" alt="最简单的折线图"></p><p>因为是随机生成的数字，所以也看不出什么规律。</p><p>你可能会有点惊讶，为什么明明只有<code>ans</code>一个变量，谈不上所谓因变量和自变量，他是怎么画出来的？实际上这里是将<strong>下标</strong>作为横坐标、<strong><code>ans</code>的值</strong>作为纵坐标画出来的。</p><h2 id="统计图绘制样式"><a href="#统计图绘制样式" class="headerlink" title="统计图绘制样式"></a>统计图绘制样式</h2><p>如果说你不需要折线图，而是散点图，那么就更改绘图样式吧：<code>plot(ans, &#39;*&#39;)</code></p><p><img src="https://sakebow.gitee.io/images/机器学习/更换样式.png" alt="把折线图换成散点图"></p><p>当然你觉得<code>*</code>不太美观的话也可以换成中文的<code>·</code>（<em>中文输入下波浪线按钮不加<code>shift</code></em>）或者日文的<code>・</code>（<em>日文输入下问号按钮不加<code>shift</code></em>）</p><p>为了防止很多图像看混了，可以使用不同的颜色标记：<code>plot(ans, &#39;1&#39;)</code></p><p><img src="https://sakebow.gitee.io/images/机器学习/更换颜色.png" alt="更改颜色"></p><p>各种各样的数字代表了各种各样的<strong>颜色</strong>，而各种各样的字符代表了各种各样的<strong>描点</strong>。</p><p>如果你什么都不写，那么默认就是使用<code>-</code>，也就是折线图。</p><h2 id="散点图"><a href="#散点图" class="headerlink" title="散点图"></a>散点图</h2><p>好吧，用<code>plot</code>画出来的散点图多少还是有点点奇怪。那么我们干脆用专门画散点图的方法：<code>scatter</code>。</p><p>还是一样的，我们拿到了一组数据：<code>x = randn(1, 100)</code>，另外我们再来一组数据：<code>y = randn(1, 100)</code>，然后画出随机散点图：</p><p><img src="https://sakebow.gitee.io/images/机器学习/散点图.png" alt="散点图"></p><p>同样的，我们能够使用家参数的方式改变图像的样式：<code>scatter(x, y, &#39;*&#39;)</code>。只不过这里支持的字符就比较少了，经测试似乎仅支持将圆圈更换为<code>*</code>。</p><h2 id="柱状图"><a href="#柱状图" class="headerlink" title="柱状图"></a>柱状图</h2><p>柱状图也是一种重要的工具，在统计总数并比较多条数据的差值时用得多。就比如100个服从正态分布的随机数构成的柱状图中，能够清晰地看出各个概率之间分布的差值：</p><p><img src="https://sakebow.gitee.io/images/机器学习/柱状图.png" alt="柱状图"></p><p>我们知道，$P(0-1&lt;x&lt;0+1)\approx0.6826$，所以数据比较倾向于向$(-1, 1)$这个区间集中。</p><h2 id="等高线"><a href="#等高线" class="headerlink" title="等高线"></a>等高线</h2><p>就像是地理的等高线、电磁场的等势线一样，存在的目的就是为了说明哪一段是数值上相等的。在绘制的时候，我们需要提供一个至少<strong>两行两列</strong>的矩阵，然后就由<code>contour</code>方法寻找矩阵中值算出等高线。</p><p>比如对于$ans=\left[\begin{matrix}1&amp;2\\3&amp;4\\5&amp;6\\7&amp;8\end{matrix}\right]$这个矩阵画出来的等高线就是<code>contour(ans)</code>：</p><p><img src="https://sakebow.gitee.io/images/机器学习/等高线.png" alt="等高线"></p><h2 id="极坐标"><a href="#极坐标" class="headerlink" title="极坐标"></a>极坐标</h2><p>高中我们认识并狠狠地练习了<strong>极坐标</strong>这些题目，所以我们就直接从最简短的开始：$\rho=2\cos\theta$。相信你很清楚这个等式可以化为$x^2+y^2=x$，是以$(1,0)$为圆心、$1$为半径的圆。</p><p>那么就确定两个变量：<code>p = linspace(0, 1)</code>和<code>o = linspace(0, 2 * pi)</code></p><p><em>注：linspace(x, y) = x:0.01:y，即从x到y中每隔0.01取一个点</em></p><p>然后，画极坐标：polar(p, o)</p><p>就出现了这样的图：</p><p><img src="https://sakebow.gitee.io/images/机器学习/极坐标.png" alt="极坐标"></p><p>似乎和我们平常见到的直角坐标系不一样。不过没有关系，是不是在很多影视作品中看到类似的？<strong>雷达</strong>嘛。在战场上，你发送了敌机的$(x, y, z)$坐标，<strong>这谁懂啊</strong>。干脆点，报哪个方向方向多少度，往那打。这种情况下极坐标比直角坐标好用多了。</p><p>还有其他很有意思的：比如我们将刚刚的<code>p</code>和<code>o</code>调换一下位置，就成了螺旋线。</p><p><img src="https://sakebow.gitee.io/images/机器学习/螺旋线.png" alt="螺旋线"></p><h2 id="饼状图"><a href="#饼状图" class="headerlink" title="饼状图"></a>饼状图</h2><p>饼状图只是为了查看占比，所以大批量的随机数在这里并不适合作为样本。所以这里就随机生成三个数：<code>ans = randn(1, 3)</code></p><p><em>由于饼状图是组内比较，所以只能使用一组数据，即<strong>行向量</strong>或者<strong>列向量</strong>作为参数。如果生成<code>ans = randn(10, 10)</code>作为样本则会报错。使用时还请注意。</em></p><p><img src="https://sakebow.gitee.io/images/机器学习/饼状图.png" alt="饼状图"></p><p>可以看到，<code>octave</code>拿到数据之后立马进行了权重的计算，最终得出了这个结果。所以我们在实际实验中就只需要把数据整理成<strong>行向量</strong>或者<strong>列向量</strong>传入，<code>octave</code>就能够在一定程度上。</p><p>既然饼状图是查看一个部分或者多个部分的占比，为了让图片更清晰，就可以让一些部分联系起来。</p><p>时间回溯到你收集猫娘数据的那些日子（<del>别吐槽了，听就是了</del>）</p><p>你了解到全世界的猫娘们的年龄从0岁开始往上的数量依次是<code>neko = [16247, 18752, 19165, 17251, 11471, 18714, 10961, 5428, 13725, 8715, 10031, 13298, 8715, 9716, 4562, 9612, 3610]</code>（<em>随手瞎打的</em>）。你想清晰地看出在0到3岁的猫娘占比，于是你使用第二个参数：<code>explode</code>。这个参数应当是一个数组。如果数值为0，则会与下一个块区相接；而如果非0，即使是负数也会明显分开。</p><p>于是我们为了清晰地看出0到3岁的小猫娘的数量，我们使用<code>pie (neko, [1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])</code>，就会产生这样的效果：</p><p><img src="https://sakebow.gitee.io/images/机器学习/突出部分元素的饼图.png" alt="突出部分元素"></p><p>可以看到，设置为非零的前三个部分被分开了，占比$8\%+9\%+10\%=27\%$。这是不是比不突出任何元素的饼图看起来更直观呢？</p><h2 id="选择支"><a href="#选择支" class="headerlink" title="选择支"></a>选择支</h2><p>当然，作为一门高级语言，选择支是必要的。</p><p>如果你是想通过选择支筛选不同年龄段，那么就使用：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> age &lt; <span class="number">3</span>,</span><br><span class="line">  <span class="comment">% filter for age &lt; 3</span></span><br><span class="line"><span class="keyword">elseif</span> age &lt; <span class="number">10</span>,</span><br><span class="line">  <span class="comment">% filter for 3 &lt; age &lt; 10</span></span><br><span class="line"><span class="keyword">else</span>,</span><br><span class="line">  <span class="comment">% filter for age &gt; 10</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><p>这个逗号估计就是在命令划分的时候不太好识别标志加上的。虽然和<code>Java</code>、<code>Python</code>略有出入，但我相信这绝对有他的道理。</p><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p><code>while</code>循环相信各位都熟悉得不能再熟悉了。实际上<code>while</code>和<code>if</code>的用法实际上是一样的。毕竟都是判断条件并转入选择支。唯一的区别估计就是<code>if</code>语句能够接<code>else if</code>和<code>else</code>来筛选不同的条件，而<code>while</code>只能始终选择同一个条件。</p><p><code>for</code>循环相比<code>while</code>循环又多了一个神奇的功能：将一个集合里的每一个元素创建索引，并这个索引仅作用于<code>for</code>循环中，是区域变量。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 假设nekos里面保存了每只猫娘的年龄(age)和姓名(name)</span></span><br><span class="line"><span class="keyword">for</span> neko = nekos,</span><br><span class="line">  <span class="keyword">if</span> neko.age &gt; <span class="number">10</span>,</span><br><span class="line">    sprintf(<span class="string">"%i"</span>, neko.name)</span><br><span class="line">  <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><p>如果你确定这些猫娘有着不同的名字，并且你一定要找到那只叫做“<strong>chocola</strong>”的猫娘（<em>没……没夹带私货……真的！</em>），那么就这么来：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> neko = nekos,</span><br><span class="line">  <span class="keyword">if</span> neko.name == <span class="string">'chocola'</span>,</span><br><span class="line">    sprintf(<span class="string">"%i"</span>, neko.age)</span><br><span class="line">    <span class="keyword">break</span>; <span class="comment">% 跳出一层循环</span></span><br><span class="line">  <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><p>有了这个<code>break</code>，一旦找到了<strong>chocola</strong>就会退出并显示她的年龄。</p><p>而如果这些猫娘有重名却有着不容的铃铛编号呢？那么就全找出来。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> neko = nekos,</span><br><span class="line">  <span class="keyword">if</span> neko.name == <span class="string">'chocola'</span>,</span><br><span class="line">    sprintf(<span class="string">"%i"</span>, neko.id)</span><br><span class="line">    <span class="keyword">continue</span>; <span class="comment">% 强制结束本次循环</span></span><br><span class="line">  <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><p>有了<code>continue</code>，程序就不会结束，反而是直接结束<code>continue</code>后面的所有步骤，强行结束本次循环。全部显示出来之后我们再对比这些编号是不是我们想要的编号。</p><p>和<code>Java</code>、<code>Python</code>等等有着非常多的相似之处呢。即使完全没接触过<code>matlab</code>，相信你们也能用丰富的编程经验理解用法。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数看起来非常高端，实际上你可以看成多个普通命令的合集。</p><p>函数是有固定的套路的：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> $&#123;<span class="title">variable</span>&#125; = $&#123;<span class="title">function</span> <span class="title">name</span>&#125; <span class="params">($&#123;argument list&#125;)</span></span></span><br><span class="line">  <span class="comment">% to do list</span></span><br><span class="line">endfunction;</span><br></pre></td></tr></table></figure><p>但是你得明白：函数毕竟是一个包含了很多行的整体。如果你使用纯命令行编辑整个函数，一旦某个地方有所疏忽，一运行函数就有可能会报错，然后<strong>整个函数重写</strong>。这是相当考验熟练度、耐心和细心的工作。当然，肯定不会让你有这么难受的体验的。</p><p><code>octave</code>为了能够在数学处理上由所优势，就决定兼容<code>matlab</code>所使用的<code>.m</code>文件。在这个文件中，我们能够使用各种各样的变量记录函数的定义，这样即使出现了错误我们也能够通过错误信息定位到不正确的地方并修改。这样就避免了整个函数重写的惨痛经历。</p><p>如果你只有命令行，或者说只愿意使用命令行，<code>octave</code>也是提供了专门的命令：<code>edit ${file name}</code>。如果是<code>Ubuntu</code>系统，<code>octave</code>将会在<code>~/octave</code>文件夹下创建或者修改文件。在这里尤其注意文件的命名，一方面是因为这样子能够很清晰地弄清楚什么文件保存了什么函数，另一方面也是因为有些文件名是<code>octave</code>内定的<strong>特殊文件</strong>，比如<code>test.m</code>是<code>octave</code>规定的测试文件，其中含有非常多的内置函数和测试函数供用户调用、测试。而如果只是一般的命名就没有什么特殊的，只是会加上很多版权说明，并默认提供一个空函数模板以供用户根据需求修改。</p><p>有点难懂？那我们举个例子，主人公还是那个热爱猫娘的你。这次的你尽了全力也没能收集全所有的数据，有些猫娘一被问到年龄就狠狠地挠你的嘴，有些则因为怕生逃掉了，也有些则在接近之前你就被主人当成可疑人物带走了……总之，你虽然找到了20万只猫娘，却只收集了5000条残缺不全的数据，不是掉了这个就是少了那个。但是该寻找的还是要寻找，那就是查清相同年龄里成绩最好和成绩最差的两只猫娘的信息。</p><p>在写这个函数之前，我们首先明白几个非常重要的点：</p><ul><li><code>octave</code>是以<code>matlab</code>为模板创建的全平台兼容的软件，所以有什么不懂可以直接查询<code>matlab</code>的教程；</li><li><code>octave</code>与<code>matlab</code>非常相似，都是以<code>C</code>为基础搭建的，所以并没有<strong>面向对象编程</strong>的概念，整个程序就是为了<strong>面向过程</strong>而设定的。</li></ul><p>所以，我们如果使用<code>octave</code>处理猫娘们的数据的时候，只能把所有想要的全部<strong>手打</strong>或者<strong>通过脚本筛选</strong>，最终达成只包含需要被处理的部分的、单纯列出所有而不是分类整合的数据集。如果是使用各种各样括号分开的<code>json</code>数据则无法被处理为一个个对象，却只能分成许许多多的单条数据。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 文件名：filter.m</span></span><br><span class="line"><span class="comment">% 从一堆数据中寻找最小的数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter_mini</span> = <span class="title">filter</span><span class="params">(x)</span></span></span><br><span class="line">  ret = x(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">2</span>:<span class="built_in">length</span>(x),</span><br><span class="line">    <span class="keyword">if</span> x(<span class="built_in">i</span>) &lt; ret,</span><br><span class="line">      ret = x(<span class="built_in">i</span>)</span><br><span class="line">    endif;</span><br><span class="line">  endfor;</span><br><span class="line">endfunction;</span><br></pre></td></tr></table></figure><p>在这里需要非常注意的是：<strong>一个文件只能编辑一个函数</strong>，<strong>每个函数的名称必须和文件名保持一致</strong>，否则会报警告：<strong>函数名和文件名不匹配</strong>。调用则是很普通的使用文件名即可，代入参数便能得到结果。</p><p>可是，我要找出猫娘的<code>id</code>啊，你这只能找出分数欸。那就这样，我们先按照猫娘的<code>id</code>顺序排列，我们找出最大和最小的索引，再从这些索引中找出<code>id</code>就好咯。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[low, low_index, high, high_index]</span> = <span class="title">filter</span><span class="params">(x)</span></span></span><br><span class="line">  low = x(<span class="number">1</span>); high = x(<span class="number">1</span>); low_index = <span class="number">0</span>; high_index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">2</span>:<span class="built_in">length</span>(x),</span><br><span class="line">    <span class="keyword">if</span> x(<span class="built_in">i</span>) &lt; low,</span><br><span class="line">      low = x(<span class="built_in">i</span>)</span><br><span class="line">      low_index = <span class="built_in">i</span></span><br><span class="line">    <span class="keyword">elseif</span> x(<span class="built_in">i</span>) &gt; high,</span><br><span class="line">      high = x(<span class="built_in">i</span>)</span><br><span class="line">      high_index = <span class="built_in">i</span></span><br><span class="line">    endif</span><br><span class="line">  endfor</span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure><p>这样看起来没什么问题。但是却依然引出了另一个问题：一旦找出符合<code>if</code>语句的分数，程序就会立马返回并打印，然后你就发现了一大堆数字堆在那里，并只能通过肉眼筛选真正符合条件的数字。如果说明得学术一点，那就是：“<strong>打印出大量的局部最优解，并只能通过肉眼寻找全局最优解</strong>”。是不是很让人抓狂？</p><p>还是有解决办法的。也就是在调用的时候规定返回值：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[a, b, c, d] = filter(param)</span><br></pre></td></tr></table></figure><p>这样的话虽然还是会打印一大堆数字，却能够很明显地看出全局最优解的结果了。</p><p>当然，有函数就一定有错误处理：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[low, low_index, high, high_index]</span> = <span class="title">filter</span><span class="params">(x)</span></span></span><br><span class="line">  <span class="comment">% 如果不是列向量或者行向量，报错。</span></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">isvector</span>(x),</span><br><span class="line">    error(<span class="string">"filter expects a vector"</span>)</span><br><span class="line">  endif</span><br><span class="line">  low = x(<span class="number">1</span>); high = x(<span class="number">1</span>); low_index = <span class="number">0</span>; high_index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">2</span>:<span class="built_in">length</span>(x),</span><br><span class="line">    <span class="keyword">if</span> x(<span class="built_in">i</span>) &lt; low,</span><br><span class="line">      low = x(<span class="built_in">i</span>)</span><br><span class="line">      low_index = <span class="built_in">i</span></span><br><span class="line">    <span class="keyword">elseif</span> x(<span class="built_in">i</span>) &gt; high,</span><br><span class="line">      high = x(<span class="built_in">i</span>)</span><br><span class="line">      high_index = <span class="built_in">i</span></span><br><span class="line">    endif</span><br><span class="line">  endfor</span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>如果你是<code>Windows</code>环境下的纯命令行，那么你在执行了上面提到的一些画图命令之后，还需要执行<code>hold on</code>命令让图像显示出来，而<code>close</code>命令则是关闭图像。当然，毕竟是<code>Windows</code>窗体程序，你也可以选择点击右上角的<strong>关闭窗口</strong>按钮关掉这张图片。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;终于，使用&lt;code&gt;Ubuntu&lt;/code&gt;系统的我遇到了最尴尬的问题：建模工具&lt;code&gt;Matlab&lt;/code&gt;没有&lt;code&gt;linux&lt;/code&gt;发行版。虽然可以使用&lt;code&gt;wine&lt;/code&gt;勉强跑起来，但毕竟不是运行在&lt;code&gt;Windows&lt;/code&gt;内核下，所以往往有很多事情都非常尴尬。所以，我看上了这一款：&lt;code&gt;octave&lt;/code&gt;。不仅支持&lt;code&gt;Ubuntu&lt;/code&gt;，还能够兼容&lt;code&gt;Matlab&lt;/code&gt;，是非常不错的替代品。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="人工智能" scheme="http://www.sakebow.cn/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
      <category term="建模工具" scheme="http://www.sakebow.cn/tags/%E5%BB%BA%E6%A8%A1%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>梯度下降</title>
    <link href="http://www.sakebow.cn/2020/07/26/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/"/>
    <id>http://www.sakebow.cn/2020/07/26/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/</id>
    <published>2020-07-26T15:23:00.000Z</published>
    <updated>2020-09-19T00:02:43.308Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>你可能又觉得梯度下降是一个完全没有接触过的新词。不过放心，依然能对上。</strong></p><a id="more"></a><h2 id="方向导数和梯度"><a href="#方向导数和梯度" class="headerlink" title="方向导数和梯度"></a>方向导数和梯度</h2><p>在说明怎么进行梯度下降之前，我们需要复习一下方向导数和梯度。</p><p>就拿最简单的两个变量为例：</p><blockquote><p>下图就是一张海拔图。</p><p><img src="https://sakebow.gitee.io/images/机器学习/二元函数梯度下降演示.jpg" alt="下降演示"></p><p>有一天，你乘坐的飞机失事了，在山顶坠毁，只有你一个人活了下来。弹尽粮绝的你几近绝望。但是你看到眼前有一大片水源，你想着找到了水源就能够活下去。所以你决定在你饿倒、冻死、被野兽咬杀之前，<strong>尽快达到山底的水源</strong>，越快越好。在这种紧急情况下，已经<strong>没有时间让你把所有的路全都探索一遍</strong>了，因为你随时可能在山上出事。</p><p>在陡峭的山上，有若干个比较平缓的落脚点。你站在出发的落脚点上，环顾四周，发现了若干能够安全到达的落脚点。于是你在这几个里面选择了最低的一个，跳了过去。接着在下一个落脚点继续寻找更低的落脚点。</p></blockquote><p>这就是“<strong>下降</strong>”，而<strong>梯度</strong>则是选择一条<strong>最优下降方向</strong>的参考。</p><p>所以问题来了，怎么样才能选出<strong>最优下降方向</strong>？如果就只是找遍目力所及的所有落脚点、计算落差，这样当然可行，但是代价太大。所以，我们在这里将使用一定的<strong>数学方法</strong>推算出来。</p><p>首先对于在平面$D$（<em>海平面</em>）上具有连续一阶偏导数的二元函数$z=f(x,y)$（<em>山高计算式</em>）上的任意一点，都有一个向量：</p><script type="math/tex; mode=display">\vec{grad}f(x,y)=\{\frac{\partial f}{\partial x},\frac{\partial f}{\partial y}\}</script><p>又由于方向导数：</p><script type="math/tex; mode=display">\vec{f_L}(x_0,y_0)=({\partial f\over\partial x},{\partial f\over\partial y})\cdot(cos\theta,sin\theta)</script><p>所以，不难得出：</p><blockquote><p>方向导数是二元函数$z=f(x,y)$在各个方向上的变化量，而当方向导数最大的时候，必定是方向导数和梯度方向重合的时候。而<strong>方向导数最大时</strong>，<strong>函数增长最快</strong>；反之亦然，<strong>方向导数最大时的反方向函数减少最快</strong>。</p><p>也就是说，我们在下山的时候唯一需要注意的就是：寻找梯度。</p></blockquote><p>当然我们还有一些需要注意的细节，<strong>下山的速度</strong>就是其中之一，它有个学术名称叫做<strong>学习率（<em><code>learning rate</code></em>）</strong>，多记为$\eta$。当学习率提高的时候，下山的速率就非常快，很快你就会达到一个区域最优解，但也可能因为步长太大忽略了某个关键点甚至可能导致不收敛；而学习率降低的时候，下山速率就非常低，只不过这样的话你能够找到更多的落脚点，从而一定程度上减少了陷入局部最优解的可能。</p><p>拿下面这个图举个例子：</p><p><img src="https://sakebow.gitee.io/images/机器学习/梯度说明图.png" alt="梯度说明"></p><p>很清楚地看到，在$x\in(0,1)$和$x\in(4,5)$的时候，函数下降速度和上升速度都非常快，这个时候可以<strong>适当减少学习率</strong>，就像是<strong>单机FPS游戏里放慢步伐寻找隐藏点</strong>一样，避免错过了任何一个细节。但是过小的步伐会导致收敛速度非常慢，一直再重复无效的学习；而在$x\in(1,4)$的时候，函数不管是上升还是下降都非常缓慢，基本没有什么起伏，可以<strong>适当加快步伐</strong>，就像是<strong>GalGame二刷回收CG</strong>一样，只抓重点，忽略细节。但是过大的步伐会导致你忽略掉$x\in(3,4)$的极值点。</p><p>总的来说，<strong>步长小了可能会陷入局部最优解；而步长大了可能会离最优解越来越远，最终得出错误的结果</strong>。</p><p><em>不过呢，三维我们还能勉强想象，但是拓展到四维、五维等超越3个维度的坐标系时，作为三次元的我们将无法想象那样的存在。所以，我们目前所能做的极限就是讨论三元变量的关系了。有没有三维以上的方向导数解法？当然有，本篇说明的就是<strong>通用解法</strong>，只不过对于三维以上的数据就<strong>无法说明几何意义</strong>了。</em></p><h2 id="梯度下降是什么"><a href="#梯度下降是什么" class="headerlink" title="梯度下降是什么"></a>梯度下降是什么</h2><p>经过复习，聪明的你应该能够明白，所谓梯度下降即是：</p><ul><li><p>从图像的意义上来看，就可以总结为：任意选取一个落脚点，然后搜索周边看能不能找到更低的落脚点。这个点不出意外的话应该在梯度方向的反方向上。</p></li><li><p>从数学的意义上来看，就可以总结为：任意选取<strong>损失函数</strong>上的一个点，一步一步寻找区域极值，并坚信其中一个极值是全域最小值，逐渐逼近使得<strong>损失函数</strong>的值最小的点。</p></li></ul><p><em>数学的角度听起来有点贪心算法的味道了？有一说一，确实。当然，不出意外的话，极值中确实会有最值；只不过时常会有意外，也就是说，最值不在极值中，而是在边界。</em></p><p>“<strong>不识庐山真面目，只缘身在此山中</strong>”。这也正是贪心算法的“贪心”所在啊，偏偏想要<strong>使用最少的次数碰运气似的找到最优解</strong>。实际上，你朝梯度的反方向看到的“<strong>最低点</strong>”，也仅仅是通过一般的数学计算才出现的<strong>预测的点</strong>，实际最低点甚至可能出现在<strong>任何地方</strong>。虽然异常的尴尬，但这也正是贪心算法想要解决的，不是么？起码7位数的数据遍历起来实在是有点难受啊……</p><h2 id="为什么选择梯度下降"><a href="#为什么选择梯度下降" class="headerlink" title="为什么选择梯度下降"></a>为什么选择梯度下降</h2><p>这个方法不仅用于线性方程求解，而且还适用于机器学习的很多个领域。找到代价函数最小值和各维度的值，同时找出根据很多自变量变化的因变量拟合函数，可以在非常多的方面说明问题，比如<strong>决策</strong>、<strong>推荐</strong>、<strong>预测</strong>、<strong>分类</strong>等等。</p><p>其实最重要的是，他能够用比较低的时间复杂度找到最好的一个解。这对于信息爆炸式增长的今天是非常有必要的。中国14亿人，就算只有一半的网民，也是7亿的并发量；面对这7亿用户的偏好分析，实在是等不起十几天慢慢磨出一份精简的报告。</p><h2 id="随机梯度下降"><a href="#随机梯度下降" class="headerlink" title="随机梯度下降"></a>随机梯度下降</h2><p>好了，现在开始进入正题：梯度下降的步骤。</p><p>我们先不要弄得太复杂，还是老例子：</p><blockquote><p>时间回溯到你研究猫娘食量那会。你确确实实拿到了20万数据，每个数据都是以（年龄，食量）这样的坐标形式出现。这看起来没什么问题，只不过你突然发现猫娘们的食量增长速度在成年之后随着年龄的增长而不断趋于平稳，成年之前却疯狂增长。你觉得线性方程不再适用。这样的函数你似乎希望是对数函数，可是这是不是因为有其他因素的影响？</p><p>于是，你凭着对猫娘疯狂的热爱，开始了第二波数据收集。这次你拿到了年龄(age)、身高(height)、体重(weight)和食量(quantity)四个数据，构成了函数$Q=f(a,h,w)$。</p></blockquote><p>这次涉及了三个维度和一个自变量，虽然复杂了很多，但也勉强能够画出来。只不过梯度下降的图像意义便不再是<strong>下山</strong>了，而是构建一个平面或者瞄准某一个中心。</p><blockquote><p><del>你凭着自己的性癖</del>……你随机选择了一位猫娘，将她的数据使用矩阵形式记录了下来：</p><script type="math/tex; mode=display">neko_0=\left[\begin{matrix}  a_0\\h_0\\w_0\end{matrix}\right]</script><p>紧接着，下一个数据就是：</p><script type="math/tex; mode=display">neko_1=\left[\begin{matrix}  a_1\\h_1\\w_1\end{matrix}\right]=\left[\begin{matrix}  a_0\\h_0\\w_0\end{matrix}\right]-\eta\left[\begin{matrix}{\partial\over\partial a} f(a_0,h_0,w_0)\\{\partial\over\partial h} f(a_0,h_0,w_0)\\{\partial\over\partial w} f(a_0,h_0,w_0)\end{matrix}\right]</script></blockquote><p>当然，$neko_1$是有实际数值的，而使用<code>学习率</code>、$neko_0$和<code>损失函数的偏导数</code>计算出来的$neko_1$并不是真实的数据。那么使用哪一个数据？当然是都使用。因为现在猫娘的食量和年龄变成了非线性关系，也就是说在<strong>x取值范围同样长的情况下</strong>，不同取值范围中函数的<strong>变化量不一样</strong>，部分密集，部分稀疏。所以应对<strong>密集部分</strong>我们需要<strong>加大学习率</strong>，尽快过渡到稀疏部分，从而减少重复学习的时间；应对<strong>稀疏部分</strong>我们要<strong>减少学习率</strong>，尽量避免忽略了重要区间的情况。</p><blockquote><p>好了，现在你通过数学计算拿到了$neko_1$，于是你准备获取$neko_2$。同样的，代入公式：</p><script type="math/tex; mode=display">neko_2=\left[\begin{matrix}  a_2\\h_2\\w_2\end{matrix}\right]=\left[\begin{matrix}  a_1\\h_1\\w_1\end{matrix}\right]-\eta\left[\begin{matrix}{\partial\over\partial a} f(a_1,h_1,w_1)\\{\partial\over\partial h} f(a_1,h_1,w_1)\\{\partial\over\partial w} f(a_1,h_1,w_1)\end{matrix}\right]</script><p>经过一番辛苦，你也得出来了这个数据。但是你实在算不下去了，虽然对猫娘包含热情，但是在完全机械的计算过程中，再怎么高涨的热情都会逐渐被消耗殆尽。于是你希望计算机能够帮助运算，便大致写下了一串伪代码：</p><p><code>repeat until convergence {</code></p><script type="math/tex; mode=display">\left[\begin{matrix}  a_i\\h_i\\w_i\end{matrix}\right]:=\left[\begin{matrix}  a_i\\h_i\\w_i\end{matrix}\right]-\eta\left[\begin{matrix}  {\partial\over\partial a} f(a_i,h_i,w_i)\\  {\partial\over\partial h} f(a_i,h_i,w_i)\\  {\partial\over\partial w} f(a_i,h_i,w_i)\end{matrix}\right]</script><p><code>}</code></p></blockquote><p><em>伪代码中<code>=</code>和<code>:=</code>略有区别，分别是<strong>相等</strong>和<strong>赋值</strong>的意思</em></p><p>这样看似乎没有什么大问题，但是在实际代码实现中，我们尤其需要注意一个很难注意到的细节：</p><p><strong>这个矩阵形式的写法意味着$a_i$、$h_i$、$w_i$是同步更新的！！！</strong></p><p><strong>这个矩阵形式的写法意味着$a_i$、$h_i$、$w_i$是同步更新的！！！</strong></p><p><strong>这个矩阵形式的写法意味着$a_i$、$h_i$、$w_i$是同步更新的！！！</strong></p><p>重要的事情说三遍！如果不是同步的话，<strong>错误的梯度下降</strong>伪代码将会变成这样：</p><blockquote><p><code>repeat until convergence {</code></p><script type="math/tex; mode=display"> temp_a={\partial\over\partial a} f(a_i,h_i,w_i)\cdots①\\ a_i = temp_a\\ temp_h={\partial\over\partial h} f(a_i,h_i,w_i)\cdots②\\ \ldots</script><p><code>}</code></p></blockquote><p>注意到了吗？①式和②式中，$a_i$的值不同了！这是严重的逻辑错误！</p><p><strong>正确的梯度下降</strong>伪代码就应该是这样：</p><blockquote><p><code>repeat until convergence {</code></p><script type="math/tex; mode=display"> temp_a=a_i-\eta{\partial\over\partial a} f(a_i,h_i,w_i)\\ temp_h=h_i-\eta{\partial\over\partial h} f(a_i,h_i,w_i)\\ temp_w=w_i-\eta{\partial\over\partial w} f(a_i,h_i,w_i)\\ a_i = temp_a\\ h_i = temp_h\\ w_i = temp_w</script><p><code>}</code></p></blockquote><p><strong>要么全部修改，要么全不修改</strong>。像极了数据库的<strong>原子性</strong>不是么？</p><p><em>在说明时我强调了是<strong>错误的梯度下降伪代码</strong>，而不是<strong>错误的伪代码</strong>，这是因为这本来就是一种正确的算法，但不是梯度下降，而是一种其他的什么代码。这就要各位读者继续读下去来寻找正确答案了。</em></p><p>没错，这就是通用解法，无论多少维，用这个矩阵解法都会有一个结果。随着学习的进行，导数或者偏导数都会逐渐变化，$\eta$也应当随之而变化。他也有另外一个名字，叫<strong>随机梯度下降</strong>，因为我们刚刚是随机选择初始点、根据梯度寻找下一跳、逐步靠近最优解，所以收敛的时候有很大的随机性，收敛时也会在局部最优附近疯狂抖动。还是用个反常的例子类比：</p><blockquote><p>你的猫娘很生气，你想逗她开心。你身边有很多东西，毛球、老鼠玩具、吉他、钢琴等等。你知道这些她都喜欢，但是你不知道这次怎么样才能让她开心。于是你开始疯狂试探。</p><p>有时候她笑了一下，有时候又挠你几下，有时候保持冷漠……在心情在变好和变坏之间反复横跳。最后，你终于拿出口琴吹起了她喜欢的音乐，把她哄好了。</p></blockquote><p>当然，公式归公式，解法是解法，这两个可以不需要严格意义上保持一致。也就是说，如果$f(a,h,w)$在求导的时候极大地增加了复杂度，就比如$\sqrt{\frac{1+sinx}{1-cosx}}$，我们可以人为地分段、化简，变成方便计算的其他公式，就像吴恩达教授的视频课程中将线性方程$Y=\beta_0+\beta_1x$中待定系数的求解从二次通过求导降为一次。（<em>如果你不清楚为什么是二次，请查看我之前写的<a href="/2020/07/26/人工智能/算法模型/代价函数">代价函数</a>一文</em>）</p><h2 id="一个尴尬的细节"><a href="#一个尴尬的细节" class="headerlink" title="一个尴尬的细节"></a>一个尴尬的细节</h2><p>好了，到了这里，相信各位读者对梯度下降也有一定的了解了。那么，各位有没有注意到一个小小的细节：<strong>我们是为什么需要根据一定的步长移动</strong>？其实是基于“<strong>最初随机选到的点并不是极值点</strong>”这一前提下展开的。那么我们就极端一点，最初就那么运气不好，选到了极值点，会怎么样呢？很显然，极值点的导数或偏导数都是0，最终我们的计算式也就化简成为了：</p><script type="math/tex; mode=display">\left[\begin{matrix}  a_i\\h_i\\w_i\end{matrix}\right]:=\left[\begin{matrix}  a_i\\h_i\\w_i\end{matrix}\right]-\eta\left[\begin{matrix}  {\partial\over\partial a} f(a_i,h_i,w_i)\\  {\partial\over\partial h} f(a_i,h_i,w_i)\\  {\partial\over\partial w} f(a_i,h_i,w_i)\end{matrix}\right]=\left[\begin{matrix}  a_i\\h_i\\w_i\end{matrix}\right]-\eta\times0=\left[\begin{matrix}  a_i\\h_i\\w_i\end{matrix}\right]</script><p>也就是说在这里我们将原地踏步。如果这里并不是全域最优解，而是局部最优解，我们也就像一开始介绍梯度下降是所说的一样：<strong>陷入局部最优解</strong>。这也正是<strong>步长过小</strong>造成的<strong>必然结果</strong>。</p><p>当然，既然有让你陷入局部最优解的情况，也有只能收敛到全局最优解的情况。用比较学术一点的话来说，就是“<strong>目标函数$f(a,h,w)$是一个凹函数</strong>”（<em>国外这里叫<strong>凸函数</strong>，因为看的方向不一样所以叫法不一样</em>），即目标函数的二阶偏导数<strong>恒大于0</strong>。这就导致一阶偏导数最多也就1个零点，即最多有一个极值，原函数要么是个碗，极值即最值；要么就单调，端点是最值。</p><p>很尴尬，也很无奈。当然办法还是有的，也就是<strong>贪心算法</strong>。这就依靠大家打怪升级之后解锁新篇章了，这里只介绍这么多有关梯度的内容。</p><h2 id="批量（Bacth）梯度下降"><a href="#批量（Bacth）梯度下降" class="headerlink" title="批量（Bacth）梯度下降"></a>批量（<code>Bacth</code>）梯度下降</h2><p>我相信你会等不及找答案的。所以这里提供一个临时的解决办法：批量梯度下降。</p><p>为什么是批量？在这里我们每次迭代都会整个训练集都试一遍，然后找到一个局部最优解，然后剪枝，重新遍历整个数据集，然后又找到下一个局部最优解，再剪枝……整个过程将会行走在非常标准的直通线路上。</p><p>当然，缺点也非常明显，整个训练一遍意味着需要大量的内存和大量的计算。如果训练集足够大，内存将无法一次性执行完，要么直接<code>OutOfMemoryException</code>，要么在内存加载的内容全部计算完后等待磁盘经过漫长的时间加载所需的下一批数据。整体来说还是相当的憋屈，所以也在逐渐的弃用这个方法。</p><p>是不是有点能理解了呢？</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>在吴恩达教授的课程中，解向量是这么求的：</p><script type="math/tex; mode=display">\left[\begin{matrix}  a_i\\h_i\\w_i\end{matrix}\right]:=\left[\begin{matrix}  a_i\\h_i\\w_i\end{matrix}\right]-\eta\left[\begin{matrix}  {\partial\over\partial a} f(a_0,h_0,w_0)\\  {\partial\over\partial h} f(a_0,h_0,w_0)\\  {\partial\over\partial w} f(a_0,h_0,w_0)\end{matrix}\right]</script><p>其中在循环之中不停调整$a_0$、$h_0$、$w_0$的值。实际上这么做的核心目的依然是保持同步，只不过用本篇所讲述的方法是普遍都在使用的方法，因为看起来更简洁。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;你可能又觉得梯度下降是一个完全没有接触过的新词。不过放心，依然能对上。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="人工智能" scheme="http://www.sakebow.cn/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
      <category term="算法模型" scheme="http://www.sakebow.cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Hexo添加数学公式渲染器</title>
    <link href="http://www.sakebow.cn/2020/07/26/hexo/hexo%E6%B7%BB%E5%8A%A0%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E6%B8%B2%E6%9F%93%E5%99%A8/"/>
    <id>http://www.sakebow.cn/2020/07/26/hexo/hexo%E6%B7%BB%E5%8A%A0%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E6%B8%B2%E6%9F%93%E5%99%A8/</id>
    <published>2020-07-26T01:47:00.000Z</published>
    <updated>2020-07-26T15:37:39.753Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong><code>markdown</code>作为非常强大的编辑器，在公式编辑和网页兼容上做的非常不错。但是，还是有非常多没能兼顾的地方，这里就以我正在使用的<code>NexT</code>主题为例详细讲述公式编辑插件的安装。参考教程为<code>ShadowLearner</code>的<a href="https://www.jianshu.com/p/7ab21c7f0674" target="_blank" rel="noopener">在Hexo中渲染MathJax数学公式</a>一文。</strong></p><a id="more"></a><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>如果你是<code>Windows</code>系统，直接使用<code>Git Bash</code>的命令行在<code>Hexo</code>根目录下使用命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure><p>即删除默认的<code>hexo-renderer-marked</code>插件、安装<code>hexo-renderer-kramed</code>插件。</p><p>如果你是<code>Ubuntu</code>系统，请使用超管权限：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo npm uninstall hexo-renderer-marked --save</span><br><span class="line">sudo npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure><p>否则<code>NodeJS</code>就根本不会卸载或下载。</p><p>当然，其他的教程上也说明了语义冲突，你也可以对根目录下的<code>/node_modules/kramed/lib/rules/inline.js</code>稍加修改：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var inline = &#123;</span><br><span class="line">  // 第2行修改</span><br><span class="line">  escape: /^\\([`*\[\]()#$+\-.!_&gt;])/,</span><br><span class="line">  ...</span><br><span class="line">  // 第20行修改（也可能是21行）</span><br><span class="line">  em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="打开开关"><a href="#打开开关" class="headerlink" title="打开开关"></a>打开开关</h2><p>教程中会有很多说明要打开开关，于是你无脑地复制了教程中的代码，贴在了自己的配置中，然后发现一点动静都没有，怒砸电脑。</p><p>实际上，你应该这么想：既然是有人已经做成了类似<code>SpringBoot</code>这种开箱即用的插件式模块，那么肯定是所有配置都齐全了的。所以，找到根目录下的<code>/themes/next/_config.yml</code>文件，按下<code>Ctrl+F</code>，在弹出的搜索框中输入<code>mathjax</code>查找匹配项，然后你找到了这样几行字：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># MathJax Support</span></span><br><span class="line"><span class="attr">mathjax:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">cdn:</span> <span class="string">//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML</span></span><br></pre></td></tr></table></figure><p><img src="https://sakebow.gitee.io/images/hexos/mathjax配置位置.png" alt="查到配置的位置"></p><p>把所有的<code>false</code>改成<code>true</code></p><p><code>enable</code>就是配置<code>mathjax</code>插件的启用与否；而<code>per_page</code>则是确认渲染所有还是逐个查找开启渲染的页进行渲染。</p><h2 id="页面渲染"><a href="#页面渲染" class="headerlink" title="页面渲染"></a>页面渲染</h2><p>这是在<code>per_page</code>配置为<code>true</code>的基础上才需要做的。如果你删除了这个配置项，那么就是默认选择<code>false</code>；如果你依然保持<code>false</code>，那么所有的页面将会渲染，这一步对你来说没有意义；如果你选择了<code>true</code>，那么你需要在<code>Hexo</code>的标题区（学术一点的称呼是<code>Front-matter</code>）中声明：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">这里是标题</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2020</span><span class="number">-07</span><span class="number">-26</span> <span class="number">09</span><span class="string">:27</span></span><br><span class="line"><span class="attr">categories:</span> <span class="string">自定义分类</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">自定义标签1</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">自定义标签2</span></span><br><span class="line"><span class="attr">mathjax:</span> <span class="literal">true</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><p>于是，你就可以使用<code>mathjax</code>作为你的公式渲染器了。</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>使用时即使使用``包裹住依然会被强行转码，所以尽可能在不需要转码的地方使用</p><p>为了给大家看看效果，这里就摆出所有可以使用的公式：</p><blockquote><p>以下内容全部整理自<strong>DanielGavin</strong>的<a href="https://www.jianshu.com/p/e74eb43960a1" target="_blank" rel="noopener"><code>Markdown</code>数学公式语法</a>一文。</p></blockquote><h3 id="单项式"><a href="#单项式" class="headerlink" title="单项式"></a>单项式</h3><ul><li><p>一对<code>$</code>包裹的就是嵌入一行文字内任意位置的公式： $xyz$</p></li><li><p>两对就是单独另起一行的公式：</p></li></ul><script type="math/tex; mode=display">abc</script><ul><li><p>用<code>^</code>标记含有上标的公式：$x^4y$</p></li><li><p>绝对值能够开平方：${\sqrt[2]{x^2}}=|x|$</p></li><li><p>用对数表示时间复杂度：$O(n\log_2(n))$</p></li><li><p>硫代硫酸根的化学式：${S}_{2}O_{3}^{2-}$</p></li></ul><h3 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h3><ul><li><p>x的<strong>向量</strong>（<em>也叫<strong>矢量</strong></em>）：$\vec{x}$</p></li><li><p>a的<strong>最小二乘估计量</strong>：$\hat{a}$</p></li><li><p>a的<strong>样本平均值</strong>：$\bar{a}$</p></li><li><p>函数$f(x)$的<strong>一阶导数</strong>：$\dot{f(x)}$</p></li><li><p><strong>二阶导数</strong>：$\ddot{f(x)}$</p></li><li><p>$f(x)$在一个范围内<strong>单调递增</strong>。这里的<code>uparrow</code>可以把<code>U</code>大写</p></li><li><p>极限里面的<strong>x趋近于0</strong>：$x\rightarrow0$，也可以用$\to$。两者虽然不同，但是非常相似，看你的喜好。趋近于无穷就是$x\to\infty$</p></li><li><p>限定范围：$\forall x\in\mathbb{R}，s.t.\dot{f(x)}^2=\ddot{f(x)f(x)}$</p></li></ul><h3 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h3><ul><li><p>普通的两项相加：$x+y$</p></li><li><p>虚数：$2-\imath$</p></li><li><p>二元虚数：$a\imath+b\jmath$</p></li><li><p>表示误差：$20\pm0.5$</p></li><li><p>分段函数：</p></li></ul><script type="math/tex; mode=display">y=\left\{\begin{aligned}-x+10 &,  &x  &\in  &(-\infty, -10) \\20    &,  &x  &\in  &(-10, 10)      \\x+10  &,  &x  &\in  &(10, +\infty)\end{aligned}\right.</script><ul><li>化学方程式</li></ul><script type="math/tex; mode=display">2H_2O_2 \xlongequal[\Delta]{M_nO_2} 2H_2O+O_2\uparrow</script><ul><li>化学表达式</li></ul><script type="math/tex; mode=display">C_{6}H_{12}O_{6} \xrightarrow{酶} H_2O+CO_2+ATP</script><ul><li><p>常用多项式展开式</p><ul><li><strong>三次方的展开式</strong>：</li></ul></li></ul><script type="math/tex; mode=display">a^3 \pm b^3 = (a \pm b)(a^2 \mp ab + b^2)</script><ul><li><strong>泰勒展开式</strong>：</li></ul><script type="math/tex; mode=display">e^x = 1 + x + {1\over2!}x^2 + {\frac{1}{3!}}x^3</script><ul><li><p>逻辑运算也是毫无压力的：</p><ul><li><p>大于小于等于没有区别，分别是：$x+y&gt;z$、$x+y&lt;z$、$x+y=z$</p></li><li><p>大于等于：$x+y \geq z$。这里由于<code>geq</code>可能会和<code>z</code>连在一起变成歧义，所以<strong>必须要有个空格</strong>避免歧义。下同。</p></li><li><p>小于等于：$x+y \leq z$</p></li><li><p>不等于：$x+y \neq z$</p></li><li><p>不大于等于：$x+y \ngeq z$</p></li><li><p>不小于等于：$x+y \nleq z$</p></li><li><p>约等于：$x+y \approx z$</p></li><li><p>恒等于：$x+y \equiv z$</p></li></ul></li><li><p>集合运算：</p><ul><li><p>表示<strong>元素x</strong>属于<strong>集合y</strong>：$x \in y$</p></li><li><p>表示<strong>元素x</strong>不属于<strong>集合y</strong>：$x \notin y$，当然也可以是$x \not\in y$</p></li><li><p>表示<strong>集合x</strong>的全部元素和<strong>集合y</strong>的部分元素相同：$x \subset y$</p></li><li><p>表示<strong>集合y</strong>的全部元素和<strong>集合x</strong>的部分元素相同：$x \supset y$。和刚刚的区别就是，开口向哪边，哪边就比较大。下同。</p></li><li><p>表示<strong>集合x</strong>的全部元素和<strong>集合y</strong>的一部分元素相同，但<strong>集合y</strong>还有<strong>集合x</strong>所没有的元素：$x \subseteq y$。和<code>subset</code>的区别在于这里明确说明了<strong>集合y</strong>比<strong>集合x</strong>更多，而<code>subset</code>没有说明，可以多，可以等，但不能少。</p></li><li><p>表示<strong>集合x</strong>是<strong>集合y</strong>的真子集，也就是说，<strong>集合y</strong>包含了<strong>集合x</strong>的全部元素，但是<strong>集合y</strong>和<strong>集合x</strong>不能完全相等：$x \subsetneq y$</p></li><li><p>$x \supseteq y$</p></li><li><p>$x \supsetneq y$</p></li><li><p>$x \not\subset y$</p></li><li><p>$x \not\supset y$</p></li><li><p>表示<strong>集合x</strong>和<strong>集合y</strong>所有元素合成新集合，但是要剔除重复的：$x \cup y$</p></li><li><p>表示选出<strong>集合x</strong>和<strong>集合y</strong>相同的元素组成新集合：$x \cap y$</p></li><li><p>表示将<strong>集合x</strong>中的元素选出和<strong>集合y</strong>相同的元素并删除，剩下的组合成新集合：$x \setminus y$</p></li><li><p>实数集合：$\mathbb{R}$</p></li><li><p>自然数集合：$\mathbb{Z}$</p></li><li><p>空集：$\emptyset$</p></li><li><p>同或运算，如：$x \bigodot y$</p></li><li><p>同与运算，如：$x \bigotimes y$</p></li></ul></li></ul><h3 id="高级运算"><a href="#高级运算" class="headerlink" title="高级运算"></a>高级运算</h3><ul><li>找规律类的给定项数运算，也可以求均值：</li></ul><script type="math/tex; mode=display">\overline{a}=\overbrace{a_1+a_2+ \cdots +a_n}^{200}=E(a)</script><ul><li>求一元极限：</li></ul><script type="math/tex; mode=display">\lim_{x \to 0} (1 + x)^{1 \over x} = e</script><ul><li>求二元极限：</li></ul><script type="math/tex; mode=display">\displaystyle \lim^{x \to \infty}_{y \to \infty}{\frac{(xy)^2}{x^2+y^2}}</script><ul><li>级数求和：</li></ul><script type="math/tex; mode=display">\sum^{n \rightarrow \infty}_{i=1}{\frac{i}{n^2}} = {1\over2}</script><ul><li>级数化简：</li></ul><script type="math/tex; mode=display">\sum^{n \rightarrow \infty}_{i=1}{\frac{i}{n^2}} = \int^1_0{xdx} = \frac{x^2}{2} | ^1_0 = {1\over2}</script><ul><li>偏微分:</li></ul><script type="math/tex; mode=display">\int^{+\infty}_{-\infty}\int^{+\infty}_{-\infty}\frac{\partial f(x,y)}{\partial y} dx + \frac{\partial f(x,y)}{\partial x} dy</script><ul><li>矩阵</li></ul><script type="math/tex; mode=display">\left[\begin{matrix}  a+b   &a      &0      &\cdots &0      &0\\  b     &a+b    &a      &\cdots &0      &0\\  0     &b      &a+b    &\cdots &0      &0\\  \vdots&\vdots &\vdots &\ddots &\vdots &\vdots\\  0     &0      &0      &\cdots &a+b    &a\\  0     &0      &0      &\cdots &b      &a+b\\\end{matrix}\right]_n = \frac{a^{n+1}-b^{n+1}}{a-b}</script><h3 id="希腊符号"><a href="#希腊符号" class="headerlink" title="希腊符号"></a>希腊符号</h3><p><strong>注：<code>代码</code>栏首字母大写只能写出部分字母，而其他和英文字母重复的则不被支持</strong></p><div class="table-container"><table><thead><tr><th>大写</th><th>字符</th><th>代码</th></tr></thead><tbody><tr><td>A</td><td>$\alpha$</td><td>\alpha</td></tr><tr><td>B</td><td>$\beta$</td><td>\beta</td></tr><tr><td>$\Gamma$</td><td>$\gamma$</td><td>\gamma</td></tr><tr><td>$\Delta$</td><td>$\delta$</td><td>\delta</td></tr><tr><td>E</td><td>$\epsilon$</td><td>\epsilon</td></tr><tr><td>Z</td><td>$\zeta$</td><td>zeta</td></tr><tr><td>H</td><td>$\eta$</td><td>\eta</td></tr><tr><td>$\Theta$</td><td>$\theta$</td><td>\theta</td></tr><tr><td>I</td><td>$\iota$</td><td>\iota</td></tr><tr><td>K</td><td>$\kappa$</td><td>\kappa</td></tr><tr><td>$\Lambda$</td><td>$\lambda$</td><td>\lambda</td></tr><tr><td>M</td><td>$\mu$</td><td>\mu</td></tr><tr><td>N</td><td>$\nu$</td><td>\nu</td></tr><tr><td>$\Xi$</td><td>$\xi$</td><td>\xi</td></tr><tr><td>O</td><td>$\omicron$</td><td>\omicron</td></tr><tr><td>$\Pi$</td><td>$\pi$</td><td>\pi</td></tr><tr><td>P</td><td>$\rho$</td><td>\rho</td></tr><tr><td>$\Sigma$</td><td>$\sigma$</td><td>\sigma</td></tr><tr><td>T</td><td>$\tau$</td><td>\tau</td></tr><tr><td>$\Upsilon$</td><td>$\upsilon$</td><td>\upsilon</td></tr><tr><td>$\Phi$</td><td>$\phi$</td><td>\phi</td></tr><tr><td>X</td><td>$\chi$</td><td>\chi</td></tr><tr><td>$\Psi$</td><td>$\psi$</td><td>\psi</td></tr><tr><td>$\Omega$</td><td>$\omega$</td><td>\omega</td></tr></tbody></table></div><h2 id="最后给点小玩意"><a href="#最后给点小玩意" class="headerlink" title="最后给点小玩意"></a>最后给点小玩意</h2><p>当然，<code>markdown</code>也并不是万能的，因为还有很多类似序号等特殊段首标记无法打出来。<code>Windows10</code>现在自带的微软输入法可能会带这些东西，但是<code>Ubuntu</code>的<code>iBus-pinyin</code>就是没有，很无奈，所以在这里贴出来一些：</p><blockquote><p>⓪ ① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ ㉑ ㉒ ㉓ ㉔ ㉕ ㉖ ㉗ ㉘ ㉙ ㉚ ㉛ ㉜ ㉝ ㉞ ㉟ ㊱ ㊲ ㊳ ㊴ ㊵ ㊶ ㊷ ㊸ ㊹ ㊺ ㊻ ㊼ ㊽ ㊾ ㊿</p><p>⓿ ❶ ❷ ❸ ❹ ❺ ❻ ❼ ❽ ❾ ❿⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴</p><p>——摘自<strong>Applied Sciences</strong>的<a href="https://blog.csdn.net/appleyuchi/article/details/84036985" target="_blank" rel="noopener">带圆圈的数字和markdown常用表达式记录(持续更新中)</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;markdown&lt;/code&gt;作为非常强大的编辑器，在公式编辑和网页兼容上做的非常不错。但是，还是有非常多没能兼顾的地方，这里就以我正在使用的&lt;code&gt;NexT&lt;/code&gt;主题为例详细讲述公式编辑插件的安装。参考教程为&lt;code&gt;ShadowLearner&lt;/code&gt;的&lt;a href=&quot;https://www.jianshu.com/p/7ab21c7f0674&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;在Hexo中渲染MathJax数学公式&lt;/a&gt;一文。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hexo" scheme="http://www.sakebow.cn/categories/Hexo/"/>
    
    
      <category term="NexT主题踩坑" scheme="http://www.sakebow.cn/tags/NexT%E4%B8%BB%E9%A2%98%E8%B8%A9%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>代价函数</title>
    <link href="http://www.sakebow.cn/2020/07/26/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E4%BB%A3%E4%BB%B7%E5%87%BD%E6%95%B0/"/>
    <id>http://www.sakebow.cn/2020/07/26/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E4%BB%A3%E4%BB%B7%E5%87%BD%E6%95%B0/</id>
    <published>2020-07-26T01:27:00.000Z</published>
    <updated>2020-09-19T00:02:30.577Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>这里将会从一个简单的例子引入话题。例子是一个自变量和一个因变量构成的一元一次函数。因为同时兼顾了有趣和浅显，例子也是相当的乱来，能会意就行，吐槽就免了吧。</strong></p><a id="more"></a><h2 id="回归函数"><a href="#回归函数" class="headerlink" title="回归函数"></a>回归函数</h2><p>在说明代价函数前我们先复习回归函数。</p><blockquote><p>现在你突发奇想，想知道<strong>猫娘年龄和猫粮食用量之间的关系</strong>，你跑遍了全世界找了所有的<strong>20万只猫娘</strong>，问到了食量，作了个匿名记录，记下了<strong>年龄</strong>和<strong>食量</strong>的关系，并总结出了一张<strong>散点图</strong>。你看着你家幼小的猫娘，看了看散点表，<strong>预测</strong>出了她这个年龄大概吃多少。当然，你非常疼爱你的猫娘，<strong>不够吃的话肯定还是会加</strong>，<strong>吃不下也会多加调整</strong>。</p><p><img src="https://sakebow.gitee.io/images/background/illust_80183815_20200714_143825.jpg" width="200" alt="pid=143825"></p></blockquote><p><strong>我知道你很想吐槽，现在憋着。</strong></p><p>首先，通过这个例子，我们先重点强调一些细节：</p><ul><li><p>十几万只猫娘是你的<strong>样本容量</strong>，虽然数量不是很大，但是足以说明问题；</p></li><li><p>这里自变量是年龄，因变量是食量，只是一个单纯的<strong>一元一次方程</strong>;</p></li><li><p>虽然能够收集非常多数据，但是你<strong>只能画出散点图</strong>；</p></li><li><p>你需要为你的小猫娘<strong>预测</strong>食量；</p></li></ul><p>明白了这些细节之后，我们应该怎么操作呢？从初中到大学我们学到的<strong>线性回归方程</strong>就是为了这个问题服务的。</p><p>通过散点图，你可以使用一条直线贯穿大部分的点，一些<strong>少有偏离可能是个体差异</strong>，比如活泼、好动、成长期<del>还有发情期</del>等等；同样也一定有<strong>过于偏离</strong>这条直线的散点数据，<strong>少量则有可能是记录错误</strong>，而大量的话要么是<strong>有其他决定条件</strong>，要么是<strong>数学模型选择错误</strong>。<strong>这里我们就假定没有其他条件而且数学模型就是一元一次函数</strong>。</p><p>如果你大学认真学习了《概率论与数理统计》，那么你应该对线性回归方程不陌生。</p><p>于是你熟练地写出：</p><blockquote><p>猫娘的食量<code>Y</code>和猫娘的年龄<code>x</code>之间有线性关系，设</p><p>Y = $\beta_0$ + ${\beta_1}x+\epsilon$，其中$\beta_0$和$\beta_1$是待定系数，$\epsilon$是随机误差，满足$\epsilon$~$N(0,\sigma^2)$</p></blockquote><p>既然$\epsilon$服从正态分布，那么<code>Y</code>呢？</p><p>由于<code>Y</code>与<code>x</code>的关系为线性关系，所以就有：</p><p>$EY=E(\beta_0+{\beta_1}x)=\beta_0+{\beta_1}E(x)$</p><p>所以你接着写下：</p><blockquote><p>依题意，$Y$~$N(\beta_0+{\beta_1}x,\sigma^2)$</p></blockquote><p>你可能会怀疑到这一步能够得出什么。这个只能说在一定的正确率范围内预测这个事实，而不能完完全全的当作必然。</p><p>那么，怎么预测呢？在这个只有离散型数据的图表中，如何才可以制定一个尽可能正确的线性方程呢？这就需要<strong>最小二乘估计</strong>。</p><p>我们先忽略$\epsilon$的影响，因为无法预测；然后将线性方程简化为我们能够预测的样子，并将我们所收集的样本值一一对应进去。所以你写着：</p><script type="math/tex; mode=display">\hat{y_i}=\hat{\beta_0}+\hat{\beta_1}x_i</script><p>需要注意的是，这个是我们的预测函数，而不是实际规律。没人知道实际规律，因为总有这样那样的误差，只能说尽可能的出一个大家都认同的规律。</p><p>代入每一个实际的$x_i$，我们都能获得一个预测的$\hat{y_i}$。而实际的$x_i$却又对应事实成立的$y_i$，两者的差就是偏离度。为了尽可能拟合数据，我们应当尽可能缩小这个偏差。于是，我们准备求出每一组偏差距离，也就是<strong>y坐标差的绝对值</strong>，即$|y_i-\hat{y_i}|$，也就是$|y_i-\beta_0-{\beta_1}x|$，并让他最小。这部分就是高数的<strong>拉格朗日定理</strong>了。</p><p>于是你接着写下：</p><blockquote><p>由20组已知数据组$(x_i,y_i)$，则将x、y设为已知量，令n=200,000，且</p><script type="math/tex; mode=display">L(\beta_0,\beta_1)=\sum^{n}_{i=1}(y_i-\beta_0-{\beta_1}x_i)^2</script><p>分别对$\beta_0$和$\beta_1$求偏导，并令偏导为0，能够得出两个等式：</p><script type="math/tex; mode=display">{\frac{\partial L(\beta_0,\beta_1)}{\partial\beta_0}}=-2\sum^{n}_{i=1}(y_i-\beta_0-{\beta_1}x)=0\cdots①</script><script type="math/tex; mode=display">{\frac{\partial L(\beta_0,\beta_1)}{\partial\beta_1}}=-2\sum^{n}_{i=1}(y_i-\beta_0-{\beta_1}x)=0\cdots②</script><p>解得：</p><script type="math/tex; mode=display">\beta_0=\frac{(\sum^n_{i=1}y_i)(\sum^n_{i=1}x_i^2)-(\sum^n_{i=1}x_i)(\sum^n_{i=1}x_iy_i)}{n(\sum^n_{i=1}x_i^2)-(\sum^n_{i=1}x_i)^2}</script><script type="math/tex; mode=display">\beta_1=\frac{n(\sum^n_{i=1}x_iy_i)-(\sum^n_{i=1}x_i)(\sum^n_{i=1}y_i)}{n(\sum^n_{i=1}x_i^2)-(\sum^n_{i=1}x_i)^2}</script></blockquote><p>相信你解到这一步的时候都快疯掉了，直接看答案的估计也蒙圈了。你放心，这玩意在2020年绝对不会靠人算，如果真的碰到了那也只能祝你好运了。</p><p>不过就算是这种算式也是能够简化到一定地步的。别忘了还有这些：</p><blockquote><p>记$\bar{x}=\frac{\sum^n_{i=1}x_i}{n}$，$\bar{y}=\frac{\sum^n_{i=1}y_i}{n}$</p><p>整理得：</p><script type="math/tex; mode=display">\hat{\beta_1}=\frac{\sum^n_{i=1}x_iy_i-n\bar{x}\bar{y}}{\sum^n_{i=1}x_i^2-n\bar{x}^2}</script><script type="math/tex; mode=display">\hat{\beta_0}=\bar{y}-\bar{x}\hat{\beta_1}</script></blockquote><p>是不是觉得好看多了？而且这样子也更便于计算。</p><blockquote><p>故代入方程得：</p><script type="math/tex; mode=display">\hat{Y}=\hat{\beta_0}+\hat{\beta_1}x</script></blockquote><p>这下子你就能够用这个方程来预测你的小猫娘会吃多少啦！</p><p><img src="https://sakebow.gitee.io/images/background/illust_79288093_20200714_142659.png" width="250" alt="pid=142659"></p><h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><p>好了，讲了这么久的回归函数，是不是完全不知道这玩意和代价函数有什么关系？别担心，慢慢来。</p><p>在机器学习中，我们主要希望计算机尽可能贴近事实，也就是尽可能计算最为贴近所有样本的一元线性函数（<em>当然也有可能是别的什么函数，这里以一元线性为例</em>）。</p><p>既然是尽可能贴近，我们就会在其中筛选不贴近的、折衷较为贴近的、选取最为贴近的。于是：</p><ul><li><p>针对<strong>单个样本</strong>，我们规定了<strong>损失函数</strong>，也就是在整个线性规划的过程中产生偏差的量；</p></li><li><p>针对<strong>全部取样样本</strong>，我们规定了<strong>代价函数</strong>，也就是研究在线性规划中整个取样的样本产生偏差的量；</p></li><li><p>针对<strong>最终结果</strong>，我们规定了<strong>目标函数</strong>，也就是在尽可能照顾到所有取样样本之后研究出的最贴近事实的函数</p></li></ul><p>一开始听起来像是三个新词？这么一说明，是不是开始和以前的线性规划对上了？</p><p><strong>损失函数</strong>，其实就是<strong>残差</strong>，以前我们记为$e$；而<strong>代价函数</strong>其实就是残差的绝对值的和，但是因为计算不方便，我们全部平方了，也就是残差的平方和，最后求导再除2就是最终结果；而<strong>目标函数</strong>，就是在<strong>代价函数在取值范围内最小</strong>的情况下拟合出来的函数。</p><p>好了，到这里答案就出来了。代价函数就是求解线性方程时使用的拉格朗日定理构造的函数。之前我们定义的是：</p><script type="math/tex; mode=display">L(\beta_0,\beta_1)=\sum^{n}_{i=1}(y_i-\beta_0-{\beta_1}x_i)^2</script><p>但是同时要兼顾到计算的简便，我们再取一个求导之后不会有系数的函数：</p><script type="math/tex; mode=display">L(\beta_0,\beta_1)=\frac{\sum^{n}_{i=1}(\beta_0+{\beta_1}x_i-y_i)^2}{2n}</script><p>不仅在求导的时候去掉了系数$2$，还避免了符号问题，顺便还提供了一个$\frac{1}{n}$方便计算均值。不得不说，<strong>NICE</strong>！</p><p>你担心这样复杂的算法会拖垮计算机速度？当然不是把这个模型直接搬给计算机去算的啦，这只不过是数学推导过程，最后还是要根据计算机的特点尽可能化简成只有次数不多的加减、涵盖了几乎全部的重复劳动的算法。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;这里将会从一个简单的例子引入话题。例子是一个自变量和一个因变量构成的一元一次函数。因为同时兼顾了有趣和浅显，例子也是相当的乱来，能会意就行，吐槽就免了吧。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="人工智能" scheme="http://www.sakebow.cn/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
      <category term="算法模型" scheme="http://www.sakebow.cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>模型描述</title>
    <link href="http://www.sakebow.cn/2020/07/25/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E6%A8%A1%E5%9E%8B%E6%8F%8F%E8%BF%B0/"/>
    <id>http://www.sakebow.cn/2020/07/25/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/%E6%A8%A1%E5%9E%8B%E6%8F%8F%E8%BF%B0/</id>
    <published>2020-07-25T02:00:00.000Z</published>
    <updated>2020-09-19T00:05:07.340Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>我们在描述算法的时候，往往也会提到“算法模型”这个概念。模型是什么？算法和模型之间有什么联系？</strong></p><a id="more"></a><h2 id="算法的定义"><a href="#算法的定义" class="headerlink" title="算法的定义"></a>算法的定义</h2><p>如果你在大学学过了数据结构，这句话你应该耳熟能详：</p><blockquote><p>通俗地讲，算法是解决问题的一种方法或一个过程。更严格地讲，算法是由若干条指令组成的有穷序列，且满足下述4条性质</p><ul><li><p>输入：0个或者多个外部提供的量作为算法输入项</p></li><li><p>输出：算法应当产生至少一个量作为输出项</p></li><li><p>确定性：组成算法的每条指令是清晰的、没有歧义的</p></li><li><p>有限性：算法中每条指令的执行次数是有限的，执行每条指令的时间也是有限的</p></li></ul><p>——摘自《计算机算法设计与分析》（第五版），王晓东著</p></blockquote><p>那，模型又是什么？</p><h2 id="模型的概念"><a href="#模型的概念" class="headerlink" title="模型的概念"></a>模型的概念</h2><p>我们知道，现在普遍使用的算法例如深度搜索、哈密顿回路等等经典算法都是经过很长时间的发现、假说、论证、优化的不停循环才产生出来，而这个论证的过程就是将算法抽象为一系列的数学模型，然后计算时间复杂度、空间复杂度，最终在比较中筛选更为优秀的。所以我们平常所说的“<strong>模型</strong>”都是指“<strong>数学模型</strong>”。</p><p>也就是说：</p><blockquote><p>模型是一类问题的解题步骤，亦即一类问题的算法。</p><p>——摘自<strong>慕码人2483693</strong>对<a href="http://www.imooc.com/wenda/detail/447305" target="_blank" rel="noopener"><strong>模型与算法之间是什么关系</strong></a>一问的回答</p></blockquote><p>算法是一类问题的抽象解答，而模型则是一系列算法的数学表达。</p><p>如果问题不是一类问题，就单单类似<strong>这只猫接下来要做什么</strong>这样的问题，算法也就失去了存在的必要；同样的，算法如果也不是一系列算法，就单单类似<strong>这只狗吃骨头的流程</strong>这样的算法，模型也没有存在的必要。就像是数据结构中的抽象实体类<code>ADT</code>一样，它的存在就是为了描述一系列相似问题的解法的。</p><p>所以，你能够理解为什么会有<strong>推荐算法模型</strong>了么？因为一系列的<code>APP</code>都将会根据用户的使用情况收集偏好并提高用户体验，这些<code>APP</code>囊括了生活中的方方面面，包括<strong>美食</strong>、<strong>服饰</strong>、<strong>手办</strong>、<strong>模玩</strong>、<strong>家具</strong>还有<strong>电子产品</strong>甚至<strong>性癖</strong>（<del><em>比方说<code>pixiv</code></em></del>）等等。因为类似，这就抽象出来了。</p><h2 id="机器学习中模型的描述"><a href="#机器学习中模型的描述" class="headerlink" title="机器学习中模型的描述"></a>机器学习中模型的描述</h2><p>正如一开始所说的，算法需要有<strong>0个以上的输入</strong>、<strong>1个以上的输出</strong>，机器学习中的算法也是一样的，有着0个以上的<strong>数据集</strong>输入，输出至少一个<strong>结果</strong>。数据集中包括了大量的具有相似数据结构的信息，可以是事实，也可以是虚拟信息；而输出则是根据结果的预测、分类等等。就如下图所示：</p><p><img src="https://sakebow.gitee.io/images/机器学习/模型描述流程图1.png" alt="机器学习模型描述"></p><p>这个机器学习的算法并不是一成不变的，同样也是在不断的实践和训练中逐渐发现最贴近事实、最能概括所有内容的数学模型和算法。听起来很枯燥？研究不正是从这些枯燥的日常中总结出新东西的活动么？</p><p>是不是能理解了？</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;我们在描述算法的时候，往往也会提到“算法模型”这个概念。模型是什么？算法和模型之间有什么联系？&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="人工智能" scheme="http://www.sakebow.cn/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
      <category term="算法模型" scheme="http://www.sakebow.cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>非监督学习</title>
    <link href="http://www.sakebow.cn/2020/07/24/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E9%9D%9E%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/"/>
    <id>http://www.sakebow.cn/2020/07/24/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E9%9D%9E%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-07-24T14:32:00.000Z</published>
    <updated>2020-07-25T01:43:07.267Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>非监督学习，就如同字面意思，没有人监督的，也就是机器自学。</strong></p><a id="more"></a><h2 id="非监督学习的定义"><a href="#非监督学习的定义" class="headerlink" title="非监督学习的定义"></a>非监督学习的定义</h2><blockquote><p>现实生活中常常会有这样的问题：缺乏足够的先验知识，因此难以人工标注类别或进行人工类别标注的成本太高。很自然地，我们希望计算机能代我们完成这些工作，或至少提供一些帮助。根据类别未知(没有被标记)的训练样本解决模式识别中的各种问题，称之为无监督学习。</p><p>——摘自<a href="https://baike.baidu.com/item/无监督学习/810193" target="_blank" rel="noopener">百度百科：无监督学习</a></p></blockquote><p>这个定义似乎比<strong>监督学习</strong>更简单，最起码而言没有涉及过多的理科专有词汇。不过这个定义依然比较抽象，我们来举个例子看看：</p><blockquote><p>你是一个大老板，能赚很多钱，但是除了赚钱一无所知。这一天，你拿到了一车黑色液体，里面有酱油，有生抽，有可乐，甚至有枇杷膏。你知道这些是你能够发财致富的东西，可你却<strong>完全不知道它们之间的区别是什么</strong>。于是你请了一队人<strong>工具人</strong>来帮你鉴定分类，他们都是各种菜系的国家级厨师，能够很快根据自己的经验捕捉到这瓶黑色液体的显著特点，并鉴定出这到底是什么；然后给你分好类、装好箱、上好架。最后，你根据他们分好的类别去货架上贴好标签，你的店铺就被<strong>整理得整整齐齐</strong>的了。</p></blockquote><p>听起来这个例子无论是<strong>机器</strong>还是<strong>学习</strong>都扯不上半点关系，但这个例子确实说明了<strong>无监督学习的几个特点</strong>：</p><ul><li><p>缺乏足够的先验知识，因此你没有办法直接给这些黑色液体标注类别；</p></li><li><p>因为量太大，自己标注所需要花费的时间成本太高，只好交给别人，而且是极其有耐心的<strong>工具人</strong>；</p></li></ul><p>那么，我们在这两条特点的基础上继续整理出<strong>无监督学习的使用条件</strong>：</p><ul><li><p>从<strong>庞大的样本</strong>集合中选出一些具有代表性的加以标注用于分类器的训练；</p></li><li><p>先将所有样本自动分为不同的类别，再<strong>由人类对这些类别进行标注</strong>；</p></li><li><p>在<strong>无类别信息</strong>情况下，寻找好的特征；</p></li></ul><p>也就是说，只要这组数据并没有明确分类，只是整个数据集一股脑地全扔给了程序，那就需要使用无监督学习。而如果你已经明确知道了这一大串数据集中哪些是第一类，哪些是第二类，就像是垃圾邮件和星标邮件的明显区别，就是监督学习。</p><p>是不是能理解一点了？</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;非监督学习，就如同字面意思，没有人监督的，也就是机器自学。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="人工智能" scheme="http://www.sakebow.cn/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
      <category term="机器学习" scheme="http://www.sakebow.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>监督学习</title>
    <link href="http://www.sakebow.cn/2020/07/24/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/"/>
    <id>http://www.sakebow.cn/2020/07/24/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-07-24T14:32:00.000Z</published>
    <updated>2020-07-25T01:02:22.428Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>监督学习，就如同字面意思，有人一直作为督工一直监督机器学习。</strong></p><a id="more"></a><h2 id="监督学习的定义"><a href="#监督学习的定义" class="headerlink" title="监督学习的定义"></a>监督学习的定义</h2><blockquote><p>监督学习是从标记的训练数据来推断一个功能的机器学习任务。训练数据包括一套训练示例。在监督学习中，每个实例都是由一个输入对象（通常为矢量）和一个期望的输出值（也称为监督信号）组成。监督学习算法是分析该训练数据，并产生一个推断的功能，其可以用于映射出新的实例。一个最佳的方案将允许该算法来正确地决定那些看不见的实例的类标签。这就要求学习算法是在一种“合理”的方式从一种从训练数据到看不见的情况下形成。</p><p>摘自<a href="https://baike.baidu.com/item/监督学习/9820109?fr=aladdin" target="_blank" rel="noopener">百度百科：监督学习</a></p></blockquote><p>是不是非常非常拗口而且难懂？这可能是中国学术的悲哀，说的非常的生涩难懂，似乎不是为了给别人看。这里就简单概括一下：</p><blockquote><p>监督学习是给定一组数据作为正确答案输入计算机程序中并完成适当的训练。在训练结束后机器能够在满足一定正确率的情况下进行预测。</p></blockquote><p>举个例子：</p><blockquote><p>你想要一夜暴富，但是你明白你要脚踏实地，所以你开始了一夜暴富的可行性分析。首先你收集了全球富豪的姓名、年龄、婚姻状况、政治身份、民族、家庭住址、教育背景，然后找到了全球富豪祖宗三代的同样的信息。长时间的整理之后，你作出了多张图表，分别是每个人不同属性和现持有资金的离散型数据关系。然后，你得出结论：一夜暴富的可能性几乎没有。</p></blockquote><p>虽然这个例子有点乱来，但是相信大家还是明白这个道理的。就是说，这些全球成功暴富的人，也就是以正确答案输入程序的<strong>训练集</strong>，在经过一段时间的分析，也就是<strong>适当的训练</strong>。为什么是适当呢？如果训练不够，你就会轻易地觉得自己没有希望，最终自闭。这也叫<strong>欠拟合</strong>；如果训练过当，你就会盲目自信，然后赔得内裤都没得穿。这也叫<strong>过拟合</strong>。适当训练之后，你就能够<strong>在一定正确率的情况下预测</strong>自己能不能一夜暴富。当然，这也只是说一定的正确率，是不是实际发生谁也不知道。</p><p>是不是多少明白了一点点呢？</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;监督学习，就如同字面意思，有人一直作为督工一直监督机器学习。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="人工智能" scheme="http://www.sakebow.cn/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
      <category term="机器学习" scheme="http://www.sakebow.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>机器学习是什么</title>
    <link href="http://www.sakebow.cn/2020/07/24/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>http://www.sakebow.cn/2020/07/24/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%98%AF%E4%BB%80%E4%B9%88/</id>
    <published>2020-07-24T09:20:00.000Z</published>
    <updated>2020-07-24T14:35:32.383Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>这里我参考的教程是吴恩达在2019年录制的课程，在B站上有链接，只不过是全英文，<a href="https://bilibili.com/BV164411S78V" target="_blank" rel="noopener">点我跳转</a>。当然，如果你选择<a href="https://bilibili.com/BV1JE411g7XF" target="_blank" rel="noopener">李宏毅的机器学习课程</a>也可以，因为是中文所以对于更多人来说更亲切一点。</strong></p><a id="more"></a><h2 id="机器学习的定义"><a href="#机器学习的定义" class="headerlink" title="机器学习的定义"></a>机器学习的定义</h2><p><code>Arthur Samuel</code>早在1959年就给即去学习下了个定义：</p><blockquote><p><code>Field of study that gives computers the ability to learn without being explicitly programmed</code></p><p>译：在没有明确设置的情况下是计算机具有学习能力的研究领域</p></blockquote><p>当然，这个定义稍微有些陈旧了。1998年，<code>Tom Mitchell</code>更新了这个定义：</p><blockquote><p><code>A computer program is said to *learn* from experience E with respect to some task T and some performace measure P, if its performace on T, as measured by P, improves with E</code></p><p>译：计算机程序从经验<code>E</code>中学习，解决某一任务<code>T</code>，进行某一性能度量<code>P</code>，通过<code>P</code>测定在<code>T</code>上的表现因经验<code>E</code>而提高。</p></blockquote><p>听起来非常的绕口？当然啦，这是人家的比喻，吴恩达老师在这里给出了一个例子：</p><blockquote><p>你需要参加研究生招生考试，最终考上心仪的大学，走向人生巅峰。在这次考试中，你将会面对很多题目，每个题目可能对应一个甚至多个知识点。为了掌握这些知识点，刷题便是我们现在400万考研的大学生正在做的事。</p><p>那么，针对这个例子，请找出任务<code>T</code>、性能度量<code>P</code>和经验<code>E</code>。</p></blockquote><p>这个例子虽然并不是那么的恰当，但是也相当具有代表性。<strong>考上心仪的大学</strong>就是任务<code>T</code>，而<strong>考试得分</strong>就是性能度量<code>P</code>，<strong>刷题</strong>就是经验<code>E</code>。通过监测你的<strong>得分</strong><code>P</code>，<strong>考上心仪大学</strong>的任务<code>T</code>将会因为你大量的<strong>刷题</strong><code>E</code>而一步一步靠近。</p><p>如果是好不容易考上研究生的你是不是能理解了？</p><p><img src="https://sakebow.gitee.io/images/emoji/滑稽-屑狐狸版.jpg" alt="滑稽"></p><h2 id="机器学习的分类"><a href="#机器学习的分类" class="headerlink" title="机器学习的分类"></a>机器学习的分类</h2><p>机器学习主要就是<strong>监督学习</strong>和<strong>非监督学习</strong>。当然我们还有非常多的，例如强化学习、推荐系统等等。这些都是其他的具体应用了，<strong>监督学习</strong>和<strong>非监督学习</strong>更像是这一切的基础。正所谓：</p><blockquote><p>公欲善其事，必先利其器</p></blockquote><p>当然，如果你是程序大佬，你也可以直接看推荐系统的源代码，并从中学到非常多的算法，积累非常多的经验。但是，正如我曾经的足球教练所说的，完全凭着经验能够做的非常好、非常快。但是，这些人<strong>遇到瓶颈也非常快</strong>，遇到了更强的人将<strong>无法战胜</strong>。这就是<strong>基本功的重要性</strong>。</p><p>在将来的几篇中，我将详细展开这两个基本的机器学习模式。请直接点击链接跳转到相应的教程：<a href="/2020/07/24/机器学习/监督学习/">监督学习</a>、<a href="/2020/07/24/机器学习/非监督学习/">非监督学习</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;这里我参考的教程是吴恩达在2019年录制的课程，在B站上有链接，只不过是全英文，&lt;a href=&quot;https://bilibili.com/BV164411S78V&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点我跳转&lt;/a&gt;。当然，如果你选择&lt;a href=&quot;https://bilibili.com/BV1JE411g7XF&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;李宏毅的机器学习课程&lt;/a&gt;也可以，因为是中文所以对于更多人来说更亲切一点。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="人工智能" scheme="http://www.sakebow.cn/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
      <category term="机器学习" scheme="http://www.sakebow.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>针对SQL语句本身的查询优化</title>
    <link href="http://www.sakebow.cn/2020/07/19/MySQL/%E9%92%88%E5%AF%B9SQL%E8%AF%AD%E5%8F%A5%E6%9C%AC%E8%BA%AB%E7%9A%84%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/"/>
    <id>http://www.sakebow.cn/2020/07/19/MySQL/%E9%92%88%E5%AF%B9SQL%E8%AF%AD%E5%8F%A5%E6%9C%AC%E8%BA%AB%E7%9A%84%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/</id>
    <published>2020-07-19T14:24:00.000Z</published>
    <updated>2020-08-15T15:42:55.123Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>现在项目愈加复杂的需求中越来越离不开数据库了。而实际项目中，查询往往占绝大多数。所以查询的优化是整个项目的关键。</strong></p><a id="more"></a><h2 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h2><p>在我之前写的<a href="/2020/07/29/MySQL/SQL基础/">SQL基础</a>中，描述了<code>SQL</code>语句的执行顺序，还是那个手办的例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> 手办表.对应人物, 手办表.服饰, 手办表.价格, 番剧表.番剧名称, 番剧表.出场人物</span><br><span class="line"><span class="keyword">FROM</span> 手办表, 番剧表</span><br><span class="line"><span class="keyword">WHERE</span> 手办表.对应人物 = 番剧表.出场人物</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> 手办表.对应人物, 手办表.服饰, 手办表.价格, 番剧表.番剧名称, 番剧表.出场人物</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> 手办表.价格 <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p>按照之前的顺序，我们一步一步分析：</p><h2 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a><code>FROM</code></h2><p>我们将会把<code>FROM</code>后面跟着的所有的表全部加载到内存。听起来是为了方便筛选数据，但是这么做对于海量数据的表将会是毁灭性的。就单纯的像学生管理系统的学生表，涉及姓名、密码、民族、政治面貌、入学时间、毕业时间、奖惩记录等等可能上百个字段，几万行数据，相当的消耗内存。如果真的是联立表，推荐使用<code>JOIN</code>进行联立。</p><h2 id="JOIN-amp-ON"><a href="#JOIN-amp-ON" class="headerlink" title="JOIN&amp;ON"></a><code>JOIN</code>&amp;<code>ON</code></h2><p><code>ON</code>将会在联立两个表的数据之前仅加载一张表的数据，然后另一张表通过一定的条件合并到第一张表中，相对于直接联立会减小很多压力。所以，本例中的<code>SQL</code>语句可以修改为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> 手办表.对应人物, 手办表.服饰, 手办表.价格, 番剧表.番剧名称, 番剧表.出场人物</span><br><span class="line"><span class="keyword">FROM</span> 番剧表</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> 手办表</span><br><span class="line"><span class="keyword">ON</span> 手办表.对应人物 = 番剧表.出场人物</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> 手办表.对应人物, 手办表.服饰, 手办表.价格, 番剧表.番剧名称, 番剧表.出场人物</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> 手办表.价格 <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p>虽然在本例中查询出来的结果是一样的，但是查询过程略有不同：<code>LEFT JOIN</code>会保留左表所有数据，即使没有匹配成功也会显示，<code>RIGHT JOIN</code>则是保留右表；两者在查询时间上也略有区别，但是这里数据实在太少，区别不明显。如果是查询中国街道表将会有非常明显的变化。</p><h2 id="WHERE"><a href="#WHERE" class="headerlink" title="WHERE"></a><code>WHERE</code></h2><p><code>WHERE</code>作为筛选条件，虽然说没有非常明显的优化方式，但是还是想说：尽量少用字符串作为匹配条件。在匹配的时候往往会整个串遍历，时间复杂度最少也是<code>KMP</code>算法的$O(m+n)$，而数字则为$O(1)$，相对来说会少一个复杂度。不过如果字符串很短，例如学号、教工号这类不超过15个字符的就随意了。</p><h2 id="GROUP-BY-amp-HAVING"><a href="#GROUP-BY-amp-HAVING" class="headerlink" title="GROUP BY&amp;HAVING"></a><code>GROUP BY</code>&amp;<code>HAVING</code></h2><p><code>GROUP BY</code>和<code>HAVING</code>作为分组条件没有什么可以优化的了，只能说根据业务需求进行调整。</p><h2 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a><code>SELECT</code></h2><p><code>SELECT</code>将会从内存中选择列，这没什么争议。但是如果使用<code>*</code>作为属性列表将会让系统首先查找哪些字段符合条件，是极其消耗资源的方法。哪怕表内几百的字段都是需要查询的，最好也要一个个写上去。</p><h2 id="DISTINCT"><a href="#DISTINCT" class="headerlink" title="DISTINCT"></a><code>DISTINCT</code></h2><p>只是普通的剔除重复的，因为大量重复的情况很少出现，所以如果不是为了特殊业务有或无都没什么。</p><h2 id="ORDER-BY"><a href="#ORDER-BY" class="headerlink" title="ORDER BY"></a><code>ORDER BY</code></h2><p>正如我们在<a href="/2020/07/29/MySQL/SQL基础/">SQL基础</a>中说明的一样，数据库会根据<strong>索引</strong>优化树形结构。所以，排序的优化就转变为了索引的优化。这就是另外一门学问了。</p><h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><p>看起来和<code>SQL</code>语句完全没有关系，实际上正如上面<code>ORDER BY</code>一栏所述，优化结构使得查询更为便捷也是优化的一种。</p><p><code>MySQL</code>支持的最大索引数量是<strong>57</strong>个，但是实际上最好还是不超过<strong>5</strong>个，因为过多的索引不便于表结构专门针对某一个字段优化，正所谓“<strong>过犹不及</strong>”。</p><p>索引优化并没有一个定性公式，而是根据需求和实际不断权衡、各取利弊，最终达到极限。依然举个有些乱来的例子：</p><blockquote><p>你找到了一家手办店。你相当的喜欢这里面的手办，每一款都非常好看。但是因为你当前的经济能力由不得你全都要，只能购买其中最喜欢的几个。所以店长专门为整个手办店创建了索引。</p><p>说是创建索引，实际上也是根据番剧名称重新分类、重新整理数据结构而已。于是你在找你喜欢的手办（<em>数据库查询</em>）的过程中，你发现你头顶有一些标牌，标明了哪些区域是哪些番剧（<em>根据番剧创建的索引</em>）。</p><p>于是你根据这些标语找到了《Re:从零开始的异世界生活》。</p><p>但是蕾姆人气实在是太高了，魔术师、泳装、女仆装、便装、睡衣装、等身手办等等都一一展示在这个区域。于是店长精心整理了一下这里的展示柜，从下到上模型逐渐变得小巧、服饰逐渐变少；从1:4逐渐过渡到1:8（<em>根据模型大小创建的索引</em>），从羽绒服逐渐过渡到浴巾（<em>根据服饰创建的索引</em>）。这么一整理是不是比胡乱摆放的仓库好多了？</p></blockquote><p>是不是有点能理解了呢？</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;现在项目愈加复杂的需求中越来越离不开数据库了。而实际项目中，查询往往占绝大多数。所以查询的优化是整个项目的关键。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="SQL" scheme="http://www.sakebow.cn/categories/SQL/"/>
    
    
      <category term="MySQL" scheme="http://www.sakebow.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>突如其来的反思</title>
    <link href="http://www.sakebow.cn/2020/07/19/diary/%E7%AA%81%E5%A6%82%E5%85%B6%E6%9D%A5%E7%9A%84%E5%8F%8D%E6%80%9D/"/>
    <id>http://www.sakebow.cn/2020/07/19/diary/%E7%AA%81%E5%A6%82%E5%85%B6%E6%9D%A5%E7%9A%84%E5%8F%8D%E6%80%9D/</id>
    <published>2020-07-19T13:58:00.000Z</published>
    <updated>2020-07-25T07:35:15.228Z</updated>
    
    <content type="html"><![CDATA[<script src="/crypto-js.js"></script><script src="/mcommon.js"></script><h3 id="encrypt-message">如果你坚持要看，请联系我。</h3><link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.min.css"> <link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap-theme.min.css"> <script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script> <script src="//cdn.bootcss.com/bootstrap/3.3.5/js/bootstrap.min.js"></script> <div id="security"> <div> <div class="input-group"> <input type="text" class="form-control" aria-label="Enter the password." id="pass"/> <div class="input-group-btn"> <button type="button" class="btn btn-default" onclick="decryptAES()">Decrypt</button> </div> </div> </div> </div> <div id="encrypt-blog" style="display:none"> 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 </div>]]></content>
    
    <summary type="html">
    
      只不过是一点点遐想，抛出几个问题然后自己慢慢思索结果而已。没什么值得看的，而且不想公开日记。
    
    </summary>
    
    
      <category term="日记" scheme="http://www.sakebow.cn/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="随笔" scheme="http://www.sakebow.cn/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>docker创建服务器</title>
    <link href="http://www.sakebow.cn/2020/07/11/%E8%BF%90%E7%BB%B4/docker/docker%E5%88%9B%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://www.sakebow.cn/2020/07/11/%E8%BF%90%E7%BB%B4/docker/docker%E5%88%9B%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2020-07-11T12:58:00.000Z</published>
    <updated>2020-11-15T13:05:04.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p><strong>本文主要参考了<a href="https://blog.csdn.net/qq_21429153/article/details/80867813" target="_blank" rel="noopener">lzssing的“<code>Docker</code>搭建<code>CentOS</code>系统，并配置<code>ssh</code>环境”</a>，并补充了一些相关细节。本篇将按照我的尝试全过程依次排雷，这样也能够让各位看到更清晰的问题解决方案，但是照着做时需要避开明确标注了“不正确”的地方。</strong></p><a id="more"></a><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>无论是什么系统，只需要下载安装<code>Docker</code>就好了。参照我之前写的<a href="/2020/07/11/运维/docker/docker的简介与安装">docker的简介与安装</a>。如果你是<code>Ubuntu</code>系统，那么这些就够了。如果你是<code>Windows</code>系统，你可能还需要一个<a href="https://pan.baidu.com/s/1VFQVelcYuw30nd1B0jXOZA" target="_blank" rel="noopener"><code>XShell</code>（提取码：88kv）</a>用于远程连接。这里就以我使用的<code>Ubuntu</code>系统编写流程，如果你是<code>Windows</code>，你可以选择<code>Docker for Windows</code>并用<code>CMD（管理员）</code>执行同样的命令，也可以选择使用<code>Windows</code>子系统。</p><h2 id="第一次尝试"><a href="#第一次尝试" class="headerlink" title="第一次尝试"></a>第一次尝试</h2><p>首先肯定是确保自己进入了超级管理员权限，并使用docker命令下载我们需要的<code>CentOS</code>镜像。为什么是<code>CentOS</code>？因为全都是<code>Ubuntu</code>的话比较容易弄混，所以就用个其他的系统区分一下。</p><p>请求超管权限，输入密码认证之后进入超管权限。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo su</span><br></pre></td></tr></table></figure></p><p><strong>从这里之后便全是CentOS。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pull centos # 拉取镜像</span><br><span class="line">docker run -itd centos /bin/bash # 创建容器运行镜像</span><br><span class="line">docker exec -it 18 /bin/bash # 进入容器操作镜像</span><br></pre></td></tr></table></figure><p>这里需要说明的是，<code>run</code>命令中当我们使用<code>-d</code>作为参数时，容器将支持后台运行。<code>run</code>命令之后便会生成一个<strong>容器id</strong>，我的是：</p><p><code>18b400110fc8772d23016358e60b4b5ff00e3892d1ad7db4bbbc4b6d1bb13e45</code></p><p>这实在是太长了。于是我在确认了没有重复项之后缩减了长度，只写了<code>18</code>，也就是<code>exec</code>命令所示的那样。</p><p><img src="https://sakebow.gitee.io/images/运维/拉取镜像.png" alt="拉取镜像"></p><p>然后我们开始搭建<code>ssh</code>环境，因为需要使用<code>ssh</code>工具进行连接。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install passwd openssl openssh-server openssh-clients initscripts vim -y # 安装软件</span><br></pre></td></tr></table></figure><p>此处<code>-y</code>代表<strong>确认安装</strong>。这个过程实在太长而且都是一样的输出就不截图了。你担心出错？<strong>放心好了</strong>。只要你不断网，这些输出必定每个人都是一样的。</p><p><img src="https://sakebow.gitee.io/images/运维/各种包已下载完成.png" alt="下载完成"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -f /etc/ssh/ssh_host_rsa_key -N ""</span><br><span class="line">ssh-keygen -t ecdsa -f /etc/ssh/ssh_host_ecdsa_key -N ""</span><br><span class="line">ssh-keygen -t ed25519 -f /etc/ssh/ssh_host_ed25519_key -N ""</span><br></pre></td></tr></table></figure><p>运行sshd服务一共需要三种密钥，<code>rsa</code>、<code>ecdsa</code>、<code>ed25519</code>。这三种都是<strong>数字签名</strong>的算法，能够保证服务器和客户端之间有能够认证身份的<strong>唯一指定</strong>令牌。在这里就不持续展开了，总之都是<strong>世界级</strong>的加密算法。</p><p>好了，准备工作差不多就到这里了，我们不如先存个档？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exit # 从CentOS中退出来，回到超管权限下的Ubuntu</span><br><span class="line"></span><br><span class="line">docker commit -a "sakebow" -m "ssh complete" 18 centos_server/save:v1 # 保存镜像</span><br></pre></td></tr></table></figure><p><img src="https://sakebow.gitee.io/images/运维/保存修改后的镜像.png" alt="保存镜像"></p><p>既然我们已经保存了镜像，之前使用的<code>18</code>容器就不再需要了，删除了吧。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker stop 18 # 之前是保持后台运行，现在需要手动关闭容器</span><br><span class="line">docker rm 18 # 删除容器</span><br><span class="line">docker ps -a # 确认容器是否存在</span><br></pre></td></tr></table></figure><p>好了，我们再次使用新的镜像跑一下。</p><p><strong>友情提醒：从现在开始会出现错误情况，我将郑重标明</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 错误示范</span></span><br><span class="line">docker run -itd 79 /bin/bash # 创建容器并运行镜像</span><br><span class="line">docker exec -it da /bin/bash # 进入容器</span><br></pre></td></tr></table></figure><p><img src="https://sakebow.gitee.io/images/运维/进入新镜像.png" alt="进入新镜像"></p><p>这里的<code>79</code>是<strong>新镜像的id</strong>，而<code>da</code>是<strong>新容器的id</strong>。各位在这一步需要更换为<strong>自己的对应id</strong>。现在，我们已经进入了<code>CentOS</code>系统中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start sshd.service # 启动服务</span><br></pre></td></tr></table></figure><p>然后，噩梦开始了。这是第一个错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@daa9499a8f9f /]# systemctl start sshd.service</span><br><span class="line">System has not been booted with systemd as init system (PID 1). Can't operate.</span><br><span class="line">Failed to connect to bus: Host is down</span><br></pre></td></tr></table></figure><p>就很奇怪。后来在<a href="https://blog.csdn.net/baidu_38558076/article/details/103890319" target="_blank" rel="noopener">baidu_38558076的“System has not been booted with systemd as init system”一文</a>中找到了解决方案：<code>/bin/bash</code>修改为<code>/sbin/init</code>，这样才会注册主线程<code>PID 1</code>。</p><h2 id="第二次尝试"><a href="#第二次尝试" class="headerlink" title="第二次尝试"></a>第二次尝试</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">exit # 退出失败的容器</span><br><span class="line"><span class="meta">#</span><span class="bash"> 以下修改稿1 - 这说明他依然有问题</span></span><br><span class="line">docker ps -a # 确认出错容器</span><br><span class="line">docker stop da # 停掉后台的容器</span><br><span class="line">docker rm da # 删除容器</span><br><span class="line">docker run --privileged=true 94 /sbin/init # 使用不一样的方式创建镜像</span><br><span class="line">docker exec -it 94 /bin/bash # 运行</span><br></pre></td></tr></table></figure><p>截图之前没注意，参数还有顺序要求，闹了很多错误。我也就不回避这些，给大家排个雷。</p><p><img src="https://sakebow.gitee.io/images/运维/修改1.png" alt="排雷式截图：进入新容器"></p><p><code>run</code>命令一定是要<code>--privileged=true</code>在<strong>镜像id</strong>之前。</p><p>再来试试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start sshd.service # 启动服务</span><br><span class="line">ps -e | grep sshd # 查看sshd服务运行情况</span><br></pre></td></tr></table></figure><p>这次没有报错。你有些后怕？放心好了，<code>Linux</code>的哲学就是：“<strong>没有报错就是没有错误！</strong>”相信自己，他不说你有错误你就是没错误。</p><p><img src="https://sakebow.gitee.io/images/运维/成功开启服务.png" alt="成功开启服务"></p><p>我们试着用<code>ssh</code>工具连接一下。另外开一个窗口，输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@192.168.1.111 # 这个192.168.1.111是我的IP地址</span><br></pre></td></tr></table></figure><p><strong>好像行不通</strong>。以下是错误信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sakebow@sakebow-Lenovo-V310-14IKB:~$ ssh root@192.168.1.111</span><br><span class="line">ssh: connect to host 192.168.1.111 port 22: Connection refused</span><br></pre></td></tr></table></figure><p>为什么？因为<code>Docker</code>是运行在本机的，开的端口就是本机的端口，也就是默认监听<code>22</code>端口。这个端口又是其他机器连接本机的关键，<strong>不允许被占用</strong>，所以直接被拒绝了。</p><p>那怎么搞嘛！<strong>换端口</strong>。</p><h2 id="第三次尝试"><a href="#第三次尝试" class="headerlink" title="第三次尝试"></a>第三次尝试</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 这次是正确的</span></span><br><span class="line"></span><br><span class="line">exit # 同样退出错误的容器</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 同样重开重进</span></span><br><span class="line">docker ps -a</span><br><span class="line">docker stop 94 e5 10</span><br><span class="line">docker rm 94 e5 10</span><br><span class="line">docker run -itd --privileged=true -p 1000:22 79 /sbin/init</span><br><span class="line">docker exec -it be /bin/bash</span><br><span class="line"></span><br><span class="line">systemctl start sshd # 同样在CentOS里面开启服务</span><br></pre></td></tr></table></figure><p>没有错误提示。连接试试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@192.168.1.111 -p 1000</span><br></pre></td></tr></table></figure><p>出现了新的对话！</p><p><img src="https://sakebow.gitee.io/images/运维/连接成功.png" alt="连接成功"></p><p>确定继续连接吗？确定的话<code>CentOS</code>（服务器）中的指纹就会保存在<code>Ubuntu</code>（客户机）中，方便下次连接。输入<code>yes</code>录入指纹，也就是以后允许这台机器输入密码认证，这样其他任何机器输入的密码即使是正确的也不会核对；如果选择<code>no</code>将会终止连接，虽然指纹依然在服务器<code>CentOS</code>上，但是客户机<code>Ubuntu</code>没有指纹，将不会核对密码。</p><p>密码正确后，进入服务器。</p><p>到这里全部完成。</p><h2 id="总结正确的全过程"><a href="#总结正确的全过程" class="headerlink" title="总结正确的全过程"></a>总结正确的全过程</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Ubuntu</span></span><br><span class="line">sudo su</span><br><span class="line">docker pull centos # 此处获得mirror_id_1</span><br><span class="line">docker run -itd $&#123;mirror_id_1&#125; /bin/bash # 此处填入你的mirror_id_1，执行后生成container_id_1</span><br><span class="line">docker exec -it $&#123;container_id_1&#125; /bin/bash # 填入你获得的container_id_1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> CentOS</span></span><br><span class="line">yum install passwd openssl openssh-server openssh-clients initscripts vim -y</span><br><span class="line">ssh-keygen -t rsa -f /etc/ssh/ssh_host_rsa_key -N ""</span><br><span class="line">ssh-keygen -t ecdsa -f /etc/ssh/ssh_host_ecdsa_key -N ""</span><br><span class="line">ssh-keygen -t ed25519 -f /etc/ssh/ssh_host_ed25519_key -N ""</span><br><span class="line">systemctl start sshd.service # sshd.service可以简写为sshd</span><br><span class="line">exit</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Ubuntu</span></span><br><span class="line">docker commit -a "$&#123;custom_author&#125;" -m "$&#123;custom_comments&#125;" $&#123;container_id_1&#125; $&#123;custom_mirror_name&#125; # 输入自定义的作者信息、备注信息 和 container_id_1，并获得mirror_id_2</span><br><span class="line">docker stop $&#123;container_id_1&#125; # 输入你的container_id_1</span><br><span class="line">docker rm $&#123;container_id_1&#125; # 输入你的container_id_1</span><br><span class="line">docker ps -a</span><br><span class="line">docker run -itd --privileged=true -p $&#123;custom_port&#125;:22 $&#123;mirror_id_2&#125; /sbin/init # 此处填入你的自定义端口号custom_port，mirror_id_2</span><br><span class="line">ssh root@$&#123;IP_HOST&#125; -p $&#123;port&#125; # 此处填入你的IP_HOST和custom_port</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;本文主要参考了&lt;a href=&quot;https://blog.csdn.net/qq_21429153/article/details/80867813&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;lzssing的“&lt;code&gt;Docker&lt;/code&gt;搭建&lt;code&gt;CentOS&lt;/code&gt;系统，并配置&lt;code&gt;ssh&lt;/code&gt;环境”&lt;/a&gt;，并补充了一些相关细节。本篇将按照我的尝试全过程依次排雷，这样也能够让各位看到更清晰的问题解决方案，但是照着做时需要避开明确标注了“不正确”的地方。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="运维" scheme="http://www.sakebow.cn/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="docker" scheme="http://www.sakebow.cn/tags/docker/"/>
    
  </entry>
  
</feed>
